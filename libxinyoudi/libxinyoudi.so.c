/* This file was generated by the Hex-Rays decompiler version 9.0.0.240925.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

void sub_A4B0();
__int64 __fastcall xinyoudi::FileRef::getSize(xinyoudi::FileRef *this); // idb
__int64 _Unwind_GetDataRelBase();
__int64 _Unwind_Find_FDE();
__int64 __cxa_get_globals_fast();
void __noreturn __cxa_throw(void *, struct type_info *lptinfo, void (*)(void *));
// void *realloc(void *ptr, size_t size);
__int64 operator new[]();
__int64 __fastcall xinyoudi::LuaFileUtils::isFileExist(xinyoudi::LuaFileUtils *this, const char *s); // idb
// int pthread_key_create(pthread_key_t *key, void (*destr_function)(void *));
// int pthread_once(pthread_once_t *once_control, void (*init_routine)(void));
// int __cxa_finalize(void *);
void __cxa_end_catch(void);
// int isalpha(int);
__int64 __deregister_frame_info();
__int64 _Unwind_SetGR();
__int64 __fastcall xinyoudi::ApkUtils::getInstance(xinyoudi::ApkUtils *this); // idb
__int64 __fastcall xinyoudi::ApkUtils::destroyInstance(xinyoudi::ApkUtils *this); // idb
// void *calloc(size_t nmemb, size_t size);
__int64 __fastcall xinyoudi::FileRef::FileRef(xinyoudi::FileRef *this, bool a2, unsigned int a3); // idb
__int64 std::basic_string<unsigned char>::__grow_by_and_replace();
// void syslog(int pri, const char *fmt, ...);
__int64 __fastcall xinyoudi::ApkUtils::getFileSize(xinyoudi::ApkUtils *this, const char *a2, bool a3); // idb
__int64 __fastcall operator new(unsigned __int64 a1); // idb
// int posix_memalign(void **memptr, size_t alignment, size_t size);
// clock_t clock(void);
__int64 std::__hash_table<std::__hash_value_type<std::string,std::basic_string<unsigned char>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::basic_string<unsigned char>>,std::hash<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::basic_string<unsigned char>>,std::equal_to<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::basic_string<unsigned char>>>>::__rehash();
__int64 _Unwind_GetLanguageSpecificData();
__int64 operator delete[]();
// void AAsset_close(AAsset *asset);
__int64 _Unwind_DeleteException();
// void __noreturn abort(void);
void __noreturn __cxa_call_unexpected(void *);
__int64 std::__hash_table<std::__hash_value_type<char const*,xinyoudi::FileRef *>,std::__unordered_map_hasher<char const*,std::__hash_value_type<char const*,xinyoudi::FileRef *>,hash_func,true>,std::__unordered_map_equal<char const*,std::__hash_value_type<char const*,xinyoudi::FileRef *>,cmp,true>,std::allocator<std::__hash_value_type<char const*,xinyoudi::FileRef *>>>::__rehash();
// int snprintf(char *s, size_t maxlen, const char *format, ...);
// int dl_iterate_phdr(int (*callback)(struct dl_phdr_info *, size_t, void *), void *data);
// __int64 android_set_abort_message();
__int64 __fastcall xinyoudi::ApkUtils::getFileContent(xinyoudi::ApkUtils *this, const char *a2, unsigned __int8 *a3, bool a4); // idb
// int isupper(int);
__int64 operator new();
__int64 std::basic_string<unsigned char>::assign();
__int64 __deregister_frame_info_bases();
__int64 __fastcall xinyoudi::ApkUtils::addFileRef(xinyoudi::ApkUtils *this, const char *s, xinyoudi::FileRef *a3); // idb
__int64 __fastcall xinyoudi::FileRef::isExist(xinyoudi::FileRef *this); // idb
// int memcmp(const void *s1, const void *s2, size_t n);
void __fastcall std::exception::~exception(std::exception *this); // idb
void __fastcall std::type_info::~type_info(std::type_info *this); // idb
__int64 std::get_new_handler(void); // idb
// int fputc(int c, FILE *stream);
// void __noreturn __stack_chk_fail();
__int64 std::unordered_map<std::string,std::basic_string<unsigned char>>::operator[]();
__int64 __fastcall xinyoudi::LuaFileUtils::init(xinyoudi::LuaFileUtils *this); // idb
__int64 __register_frame_info();
__int64 __fastcall std::__hash_table<std::__hash_value_type<char const*,xinyoudi::FileRef *>,std::__unordered_map_hasher<char const*,std::__hash_value_type<char const*,xinyoudi::FileRef *>,hash_func,true>,std::__unordered_map_equal<char const*,std::__hash_value_type<char const*,xinyoudi::FileRef *>,cmp,true>,std::allocator<std::__hash_value_type<char const*,xinyoudi::FileRef *>>>::rehash(int a1, std::__ndk1 *this); // idb
__int64 __fastcall xinyoudi::LuaFileUtils::start(xinyoudi::LuaFileUtils *this); // idb
// int pthread_setspecific(pthread_key_t key, const void *pointer);
// void openlog(const char *ident, int option, int facility);
__int64 __cxa_get_globals();
// int __android_log_print(int prio, const char *tag, const char *fmt, ...);
__int64 __register_frame_info_table();
__int64 operator delete();
char *__cxa_demangle(const char *lpmangled, char *lpout, size_t *lpoutlen, int *lpstatus);
__int64 _Unwind_RaiseException();
// int strcmp(const char *s1, const char *s2);
__int64 _Unwind_SetIP();
__int64 __fastcall std::runtime_error::runtime_error(std::runtime_error *this, const char *s); // idb
void __fastcall operator delete[](void *a1); // idb
void *__cxa_allocate_exception(size_t thrown_size);
__int64 __fastcall xinyoudi::LuaFileUtils::getFileContent(xinyoudi::LuaFileUtils *this, const char *s, unsigned __int8 *a3); // idb
__int64 __register_frame_info_bases();
__int64 __fastcall xinyoudi::LuaFileUtils::getFileSize(xinyoudi::LuaFileUtils *this, const char *s); // idb
__int64 _Unwind_GetRegionStart();
// int pthread_mutex_lock(pthread_mutex_t *mutex);
// void closelog(void);
// void *pthread_getspecific(pthread_key_t key);
// AAsset *AAssetManager_open(AAssetManager *mgr, const char *filename, int mode);
__int64 __fastcall std::__hash_table<std::__hash_value_type<std::string,std::basic_string<unsigned char>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::basic_string<unsigned char>>,std::hash<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::basic_string<unsigned char>>,std::equal_to<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::basic_string<unsigned char>>>>::rehash(int a1, std::__ndk1 *this); // idb
void __fastcall operator delete(void *a1); // idb
__int64 _Unwind_GetTextRelBase();
// void *memmove(void *dest, const void *src, size_t n);
void __noreturn std::terminate(void); // idb
__int64 __fastcall operator new[](unsigned __int64 a1); // idb
__int64 _Unwind_GetCFA();
// int isxdigit(int);
void *__cxa_begin_catch(void *);
__int64 __fastcall std::bad_alloc::bad_alloc(std::bad_alloc *this); // idb
// off_t AAsset_getLength(AAsset *asset);
__int64 std::__murmur2_or_cityhash<unsigned long,64ul>::operator()();
void __cxa_free_exception(void *);
// int AAsset_read(AAsset *asset, void *buf, size_t count);
void *__dynamic_cast(const void *lpsrc, const struct __class_type_info *lpstype, const struct __class_type_info *lpdtype, ptrdiff_t s2d);
// size_t strlen(const char *s);
// int vasprintf(char **ptr, const char *f, __gnuc_va_list arg);
void __fastcall xinyoudi::LuaFileUtils::~LuaFileUtils(xinyoudi::LuaFileUtils *this); // idb
void __fastcall std::exception::~exception(std::exception *this); // idb
__int64 __fastcall xinyoudi::ApkUtils::isFileExist(xinyoudi::ApkUtils *this, const char *a2, bool a3); // idb
__int64 std::__hash_table<std::__hash_value_type<std::string,std::basic_string<unsigned char>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::basic_string<unsigned char>>,std::hash<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::basic_string<unsigned char>>,std::equal_to<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::basic_string<unsigned char>>>>::find<std::string>();
__int64 __fastcall xinyoudi::LuaFileUtils::LuaFileUtils(xinyoudi::LuaFileUtils *this); // idb
void __noreturn __cxa_rethrow(void);
// void *malloc(size_t size);
// void *memcpy(void *dest, const void *src, size_t n);
void __noreturn _Unwind_Resume();
// void *memset(void *s, int c, size_t n);
__int64 std::get_terminate(void); // idb
__int64 __fastcall std::__next_prime(std::__ndk1 *this, unsigned __int64 a2); // idb
// AAssetManager *AAssetManager_fromJava(JNIEnv *env, jobject assetManager);
__int64 __fastcall xinyoudi::ApkUtils::setAssetManager(xinyoudi::ApkUtils *this, AAssetManager *a2); // idb
__int64 std::get_unexpected(void); // idb
__int64 __fastcall xinyoudi::ApkUtils::getFileRef(xinyoudi::ApkUtils *this, const char *s2); // idb
__int64 std::__murmur2_or_cityhash<unsigned long,64ul>::__hash_len_0_to_16();
__int64 _Unwind_GetIP();
// void free(void *p);
__int64 __register_frame_info_table_bases();
// char *strcpy(char *, const char *);
// int vfprintf(FILE *s, const char *format, __gnuc_va_list arg);
// int pthread_mutex_unlock(pthread_mutex_t *mutex);
// int __cxa_atexit(void (*lpfunc)(void *), void *obj, void *lpdso_handle);
__int64 start();
__int64 (*__fastcall sub_AC1C(__int64 (*result)(void)))(void);
__int64 __fastcall sub_AC34(void *a1);
__int64 __fastcall xinyoudi::ApkUtils::getInstance(xinyoudi::ApkUtils *this); // idb
__int64 __fastcall xinyoudi::ApkUtils::destroyInstance(xinyoudi::ApkUtils *this); // idb
__int64 __fastcall xinyoudi::ApkUtils::setAssetManager(__int64 this, AAssetManager *a2);
__int64 __fastcall xinyoudi::ApkUtils::getAssetManager(xinyoudi::ApkUtils *this); // idb
__int64 __fastcall xinyoudi::ApkUtils::getLuaFileUtils(xinyoudi::ApkUtils *this); // idb
__int64 __fastcall xinyoudi::ApkUtils::isFileExist(xinyoudi::ApkUtils *this, const char *a2);
__int64 *__fastcall xinyoudi::ApkUtils::getFileRef(xinyoudi::ApkUtils *this, const char *s2);
__int64 __fastcall xinyoudi::ApkUtils::addFileRef(xinyoudi::ApkUtils *this, const char *s, xinyoudi::FileRef *a3); // idb
__int64 __fastcall xinyoudi::ApkUtils::checkFileExist(xinyoudi::ApkUtils *this, const char *a2, bool a3);
xinyoudi::FileRef *__fastcall xinyoudi::ApkUtils::getFileSize(xinyoudi::ApkUtils *this, const char *a2, bool a3);
void __fastcall xinyoudi::ApkUtils::getFileContent(xinyoudi::ApkUtils *this, char *a2, unsigned __int8 *a3);
__int64 __fastcall xinyoudi::ApkUtils::ApkUtils(xinyoudi::ApkUtils *this); // idb
void __fastcall xinyoudi::ApkUtils::~ApkUtils(xinyoudi::ApkUtils *this); // idb
void __fastcall xinyoudi::ApkUtils::~ApkUtils(xinyoudi::ApkUtils *this); // idb
std::__ndk1 *__fastcall std::__hash_table<std::__hash_value_type<char const*,xinyoudi::FileRef *>,std::__unordered_map_hasher<char const*,std::__hash_value_type<char const*,xinyoudi::FileRef *>,hash_func,true>,std::__unordered_map_equal<char const*,std::__hash_value_type<char const*,xinyoudi::FileRef *>,cmp,true>,std::allocator<std::__hash_value_type<char const*,xinyoudi::FileRef *>>>::rehash(std::__ndk1 *result, std::__ndk1 *this);
void __fastcall std::__hash_table<std::__hash_value_type<char const*,xinyoudi::FileRef *>,std::__unordered_map_hasher<char const*,std::__hash_value_type<char const*,xinyoudi::FileRef *>,hash_func,true>,std::__unordered_map_equal<char const*,std::__hash_value_type<char const*,xinyoudi::FileRef *>,cmp,true>,std::allocator<std::__hash_value_type<char const*,xinyoudi::FileRef *>>>::__rehash(__int64 a1, unsigned __int64 a2);
__int64 __fastcall xinyoudi::FileRef::FileRef(__int64 this, char a2, int a3);
void __fastcall xinyoudi::FileRef::~FileRef(xinyoudi::FileRef *this); // idb
void __fastcall xinyoudi::FileRef::~FileRef(xinyoudi::FileRef *this); // idb
__int64 __fastcall xinyoudi::FileRef::isExist(xinyoudi::FileRef *this); // idb
__int64 __fastcall xinyoudi::FileRef::getSize(xinyoudi::FileRef *this); // idb
__int64 __fastcall Java_com_xyd_utils_ApkUtils_initialize(JNIEnv *a1, int a2, jobject assetManager);
__int64 __fastcall DllAUCreateInstance(xinyoudi::ApkUtils *a1);
__int64 __fastcall DllAUDestroyInstance(xinyoudi::ApkUtils *a1);
__int64 __fastcall DllAUIsFileExist(xinyoudi::ApkUtils *a1, char a2, bool a3);
__int64 __fastcall DllAUGetFileSize(xinyoudi::ApkUtils *a1, char a2, bool a3);
__int64 __fastcall DllAUGetFileContent(xinyoudi::ApkUtils *a1, const char *a2, char a3, bool a4);
__int64 __fastcall xinyoudi::LuaFileUtils::init(xinyoudi::LuaFileUtils *__hidden this); // idb
__int64 __fastcall std::unordered_map<std::string,std::basic_string<unsigned char>>::operator[](float *a1, unsigned __int8 *a2);
__int64 __fastcall xinyoudi::LuaFileUtils::LuaFileUtils(__int64 this);
void __fastcall xinyoudi::LuaFileUtils::~LuaFileUtils(xinyoudi::LuaFileUtils *this); // idb
void __fastcall xinyoudi::LuaFileUtils::clean(xinyoudi::LuaFileUtils *this);
void __fastcall xinyoudi::LuaFileUtils::~LuaFileUtils(xinyoudi::LuaFileUtils *this); // idb
bool __fastcall xinyoudi::LuaFileUtils::isFileExist(xinyoudi::LuaFileUtils *this, const char *s);
void *__fastcall xinyoudi::LuaFileUtils::getFileContent(xinyoudi::LuaFileUtils *this, const char *s, unsigned __int8 *a3);
unsigned __int64 __fastcall xinyoudi::LuaFileUtils::getFileSize(xinyoudi::LuaFileUtils *this, const char *s);
__int64 __fastcall xinyoudi::LuaFileUtils::start(xinyoudi::LuaFileUtils *this); // idb
std::__ndk1 *__fastcall std::__hash_table<std::__hash_value_type<std::string,std::basic_string<unsigned char>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::basic_string<unsigned char>>,std::hash<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::basic_string<unsigned char>>,std::equal_to<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::basic_string<unsigned char>>>>::rehash(std::__ndk1 *result, std::__ndk1 *this);
__int64 __fastcall std::__murmur2_or_cityhash<unsigned long,64ul>::operator()(__int64 a1, __int64 *a2, unsigned __int64 a3);
unsigned __int64 __fastcall std::__murmur2_or_cityhash<unsigned long,64ul>::__hash_len_0_to_16(_DWORD *a1, unsigned __int64 a2);
void __fastcall std::__hash_table<std::__hash_value_type<std::string,std::basic_string<unsigned char>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::basic_string<unsigned char>>,std::hash<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::basic_string<unsigned char>>,std::equal_to<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::basic_string<unsigned char>>>>::__rehash(void **a1, unsigned __int64 a2);
__int64 *__fastcall std::basic_string<unsigned char>::assign(__int64 *a1, unsigned __int64 a2, unsigned __int64 a3);
void __fastcall std::basic_string<unsigned char>::__grow_by_and_replace(__int64 a1, unsigned __int64 a2, unsigned __int64 a3, __int64 a4, unsigned __int64 a5, __int64 a6, unsigned __int64 a7, __int64 a8);
__int64 **__fastcall std::__hash_table<std::__hash_value_type<std::string,std::basic_string<unsigned char>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::basic_string<unsigned char>>,std::hash<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::basic_string<unsigned char>>,std::equal_to<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::basic_string<unsigned char>>>>::find<std::string>(_QWORD *a1, unsigned __int8 *a2);
unsigned __int64 __fastcall std::__next_prime(unsigned __int64 this);
void *__fastcall std::logic_error::logic_error(_QWORD *a1, __int64 a2);
void *__fastcall std::logic_error::logic_error(std::logic_error *this, const char *s);
_QWORD *__fastcall std::logic_error::logic_error(_QWORD *result, __int64 a2);
__int64 __fastcall std::logic_error::operator=(__int64 a1, __int64 a2);
void *__fastcall std::runtime_error::runtime_error(_QWORD *a1, __int64 a2);
void *__fastcall std::runtime_error::runtime_error(std::runtime_error *this, const char *s);
_QWORD *__fastcall std::runtime_error::runtime_error(_QWORD *result, __int64 a2);
__int64 __fastcall std::runtime_error::operator=(__int64 a1, __int64 a2);
void *_cxa_allocate_exception(size_t thrown_size);
void _cxa_free_exception(void *);
void __noreturn j____cxa_call_unexpected(void *);
void *_cxa_allocate_dependent_exception();
__int64 __fastcall _cxa_free_dependent_exception(__int64 a1);
void __noreturn _cxa_throw(void *, struct type_info *lptinfo, void (*)(void *));
void __noreturn j____cxa_call_unexpected_0(void *);
void __noreturn j____cxa_call_unexpected_1(void *);
void *_cxa_get_exception_ptr(void *);
void *_cxa_begin_catch(void *);
void _cxa_end_catch(void);
void __noreturn j____cxa_call_unexpected_2(void *);
void __noreturn j____cxa_call_unexpected_3(void *);
__int64 __fastcall _cxa_decrement_exception_refcount(__int64 result);
void __noreturn j____cxa_call_unexpected_4(void *);
void __noreturn j____cxa_call_unexpected_5(void *);
struct type_info *_cxa_current_exception_type(void);
void __noreturn _cxa_rethrow(void);
__int64 __fastcall _cxa_increment_exception_refcount(__int64 result);
unsigned __int64 **_cxa_current_primary_exception();
void __noreturn j____cxa_call_unexpected_6(void *);
__int64 __fastcall _cxa_rethrow_primary_exception(__int64 result);
void __noreturn j____cxa_call_unexpected_7(void *);
__int64 __fastcall sub_8E9E8(int a1, __int64 a2);
void __noreturn j____cxa_call_unexpected_8(void *);
void __noreturn j____cxa_call_unexpected_9(void *);
__int64 _cxa_uncaught_exception();
void __noreturn j____cxa_call_unexpected_10(void *);
__int64 _cxa_uncaught_exceptions();
void __noreturn j____cxa_call_unexpected_11(void *);
void *_cxa_get_globals();
void *_cxa_get_globals_fast();
__int64 sub_8EB68(); // weak
__int64 sub_8EB9C(); // weak
unsigned __int64 std::get_unexpected(void);
void __fastcall __noreturn sub_8EBE8(void (*a1)(void));
void __noreturn std::unexpected(void); // idb
unsigned __int64 std::get_terminate(void);
void __fastcall __noreturn sub_8EC38(void (*a1)(void));
void __fastcall __noreturn sub_8EC78(void *a1);
void __noreturn std::terminate(void); // idb
unsigned __int64 __fastcall std::set_new_handler(void (*a1)(void));
unsigned __int64 std::get_new_handler(void);
__int64 __fastcall _gxx_personality_v0(int a1, __int64 a2, __int64 a3, _DWORD *a4, __int64 a5);
__int64 __fastcall sub_8EEDC(__int64 result, char a2, char a3, _QWORD *a4);
void __fastcall __noreturn sub_8F4D0(char a1, void *a2);
void __noreturn _cxa_call_unexpected(void *);
unsigned __int64 __fastcall sub_8F870(unsigned __int16 **a1, unsigned int a2);
void *__fastcall sub_8F9C4(size_t a1);
unsigned __int16 *__fastcall sub_8FA30(__int64 a1);
void *__fastcall sub_8FB2C(size_t a1, size_t a2);
void __fastcall _cxa_free_dependent_exception_0(int *a1);
void __fastcall sub_8FCA4(void *p);
void __fastcall std::exception::~exception(std::exception *this); // idb
void __fastcall std::exception::~exception(std::exception *this); // idb
const char *__fastcall std::exception::what(std::exception *this);
void __fastcall std::bad_exception::~bad_exception(std::bad_exception *this); // idb
const char *__fastcall std::bad_exception::what(std::bad_exception *this);
_QWORD *__fastcall std::bad_alloc::bad_alloc(_QWORD *this);
void __fastcall std::bad_alloc::~bad_alloc(std::bad_alloc *this); // idb
const char *__fastcall std::bad_alloc::what(std::bad_alloc *this);
_QWORD *__fastcall std::bad_array_new_length::bad_array_new_length(_QWORD *this);
void __fastcall std::bad_array_new_length::~bad_array_new_length(std::bad_array_new_length *this); // idb
const char *__fastcall std::bad_array_new_length::what(std::bad_array_new_length *this);
_QWORD *__fastcall std::bad_array_length::bad_array_length(_QWORD *this);
void __fastcall std::bad_array_length::~bad_array_length(std::bad_array_length *this); // idb
const char *__fastcall std::bad_array_length::what(std::bad_array_length *this);
void *__fastcall operator new(size_t a1);
__int64 __fastcall operator new(unsigned __int64 a1, const std::nothrow_t *a2); // idb
__int64 __fastcall operator new[](unsigned __int64 a1); // idb
__int64 __fastcall operator new[](unsigned __int64 a1, const std::nothrow_t *a2); // idb
void __fastcall operator delete(void *p); // idb
void __fastcall operator delete(void *a1, const std::nothrow_t *a2); // idb
void __fastcall operator delete(void *a1);
void __fastcall operator delete[](void *a1); // idb
void __fastcall operator delete[](void *a1, const std::nothrow_t *a2); // idb
void __fastcall operator delete[](void *a1);
void *__fastcall operator new(size_t a1, unsigned __int64 a2);
__int64 operator new();
__int64 operator new[](void); // weak
__int64 operator new[]();
void __fastcall operator delete(void *p);
__int64 operator delete();
__int64 operator delete();
__int64 operator delete[](void); // weak
__int64 operator delete[]();
__int64 operator delete[]();
void __fastcall std::invalid_argument::~invalid_argument(std::invalid_argument *this); // idb
void __fastcall std::logic_error::~logic_error(std::logic_error *this); // idb
__int64 __fastcall std::logic_error::what(std::logic_error *this); // idb
void __fastcall std::underflow_error::~underflow_error(std::underflow_error *this); // idb
void __fastcall std::runtime_error::~runtime_error(std::runtime_error *this); // idb
__int64 __fastcall std::runtime_error::what(std::runtime_error *this); // idb
void __fastcall std::domain_error::~domain_error(std::domain_error *this); // idb
void __fastcall std::invalid_argument::~invalid_argument(std::invalid_argument *this); // idb
void __fastcall std::length_error::~length_error(std::length_error *this); // idb
void __fastcall std::out_of_range::~out_of_range(std::out_of_range *this); // idb
void __fastcall std::range_error::~range_error(std::range_error *this); // idb
void __fastcall std::overflow_error::~overflow_error(std::overflow_error *this); // idb
void __fastcall std::underflow_error::~underflow_error(std::underflow_error *this); // idb
void __noreturn sub_9035C(char *format, ...);
unsigned __int64 __fastcall std::set_unexpected(void (__fastcall __noreturn *a1)());
unsigned __int64 __fastcall std::set_terminate(__int64 (__fastcall *a1)());
void __noreturn sub_904A8();
void __noreturn sub_905D0(); // weak
char *_cxa_demangle(const char *lpmangled, char *lpout, size_t *lpoutlen, int *lpstatus);
void __fastcall sub_90B64(_BYTE *a1, unsigned __int64 a2, _QWORD *a3, _DWORD *a4);
unsigned __int8 *__fastcall sub_91038(unsigned __int8 *a1, unsigned __int8 *a2, __int64 *a3);
unsigned __int8 *__fastcall sub_925FC(unsigned __int8 *a1, unsigned __int8 *a2, __int64 a3);
unsigned __int8 *__fastcall sub_9AA00(unsigned __int8 *a1, unsigned __int8 *a2, __int64 a3, _BYTE *a4);
size_t *__fastcall sub_9CDD8(size_t *a1, size_t a2, char *src, size_t n);
size_t *__fastcall sub_9CFD0(size_t *a1, void *src, size_t n);
size_t **__fastcall sub_9D15C(size_t **result, __int64 a2, __int64 *a3);
void __fastcall sub_9D32C(void **a1);
_BYTE *__fastcall sub_9D3DC(_BYTE *a1, _BYTE *a2, __int64 a3);
unsigned __int8 *__fastcall sub_9E1F8(_BYTE *a1, unsigned __int8 *a2, void **a3);
// size_t *__usercall sub_9F8F0@<X0>(const char *a1@<X0>, unsigned __int8 *a2@<X1>, size_t *a3@<X8>);
__int64 __fastcall sub_9F9E8(_BYTE *a1, _BYTE *a2, __int64 a3);
_BYTE *__fastcall sub_A0A48(_BYTE *a1, _BYTE *a2, _QWORD *a3);
__int64 __fastcall sub_A0C94(unsigned __int8 *a1, unsigned __int8 *a2, char **a3);
void __fastcall sub_A1F74(size_t *a1, void *src, size_t n);
__int64 __fastcall sub_A20BC(unsigned __int8 *a1, unsigned __int8 *a2, __int64 a3);
long double __fastcall sub_A7174(unsigned __int64 *a1, __int64 a2);
unsigned __int8 *__fastcall sub_A743C(unsigned __int8 *a1, unsigned __int8 *a2, __int64 *a3);
unsigned __int8 *__fastcall sub_A8CFC(unsigned __int8 *result, unsigned __int8 *a2, void **a3);
__int64 __fastcall sub_A9620(unsigned __int8 *a1, unsigned __int8 *a2, unsigned __int8 *a3, _QWORD *a4);
__int64 __fastcall sub_A9B9C(unsigned __int8 *a1, unsigned __int8 *a2, int a3, _QWORD *a4);
__int64 __fastcall sub_A9F34(_BYTE *a1, _BYTE *a2, _QWORD *a3);
unsigned __int8 *__fastcall sub_AA998(unsigned __int8 *a1, unsigned __int8 *a2, unsigned __int8 *a3, unsigned __int64 *a4);
// size_t *__usercall sub_AB28C@<X0>(size_t *__return_ptr a1@<X8>, char *s@<X1>, unsigned __int8 *a3@<X0>);
__int64 __fastcall sub_AB388(unsigned __int8 *a1, unsigned __int8 *a2, _QWORD *a3);
unsigned __int8 *__fastcall sub_AB6CC(unsigned __int8 *a1, unsigned __int8 *a2, void **a3);
__int64 __fastcall sub_AC0B0(_BYTE *a1, __int64 a2, __int64 a3);
_BYTE *__fastcall sub_B1788(_BYTE *a1, _BYTE *a2, _QWORD *a3);
unsigned __int8 *__fastcall sub_B190C(unsigned __int8 *a1, unsigned __int8 *a2, void **a3);
// void __usercall sub_B1FF4(size_t *a1@<X0>, __int64 a2@<X8>);
void __fastcall sub_B23DC(size_t *a1, char a2);
__int64 __fastcall sub_B2508(size_t *a1, __int64 a2, unsigned __int64 a3, char *a4);
unsigned __int8 *__fastcall sub_B28F0(unsigned __int8 *a1, unsigned __int8 *a2, __int64 *a3);
void __fastcall sub_B2A24(__int64 a1);
unsigned __int8 *__fastcall sub_B2B20(unsigned __int8 *a1, unsigned __int8 *a2, __int64 a3);
void __fastcall sub_B64BC(void ***a1);
void __fastcall std::type_info::~type_info(std::type_info *this); // idb
__int64 sub_B65D4();
void nullsub_2();
void nullsub_3();
void __fastcall sub_B65E0(std::type_info *a1);
void __fastcall sub_B6604(std::type_info *a1);
void __fastcall sub_B6628(std::type_info *a1);
void __fastcall sub_B664C(std::type_info *a1);
void __fastcall sub_B6670(std::type_info *a1);
void __fastcall sub_B6694(std::type_info *a1);
void __fastcall sub_B66B8(std::type_info *a1);
void __fastcall sub_B66DC(std::type_info *a1);
void __fastcall sub_B6700(std::type_info *a1);
void __fastcall sub_B6724(std::type_info *a1);
bool __fastcall sub_B6748(__int64 a1, __int64 a2);
__int64 sub_B6754();
__int64 sub_B675C();
bool __fastcall sub_B6764(__int64 a1, __int64 a2);
void *__fastcall sub_B6770(void *a1, void *lpsrc, _QWORD *a3);
void __fastcall sub_B6850(__int64 a1, __int64 a2, __int64 a3, int a4);
__int64 __fastcall sub_B68AC(__int64 result, __int64 a2, __int64 a3, int a4);
__int64 __fastcall sub_B6914(__int64 result, __int64 a2, __int64 a3, int a4);
__int64 __fastcall sub_B698C(__int64 *a1, __int64 a2, _QWORD *a3, __int64 a4);
__int64 __fastcall sub_B69CC(__int64 result, __int64 a2, char *a3, __int64 a4);
_BYTE *__fastcall sub_B6B18(const char **a1, const char **lpsrc);
void (__fastcall **__fastcall sub_B6B98(__int64 a1, const char **lpsrc, _QWORD **a3))(std::type_info *__hidden this);
_QWORD *__fastcall sub_B6E94(void *a1, void *lpsrc);
_QWORD *__fastcall sub_B6FC8(__int64 a1, void *lpsrc);
_DWORD *__fastcall sub_B7044(__int64 a1, const char **lpsrc, _QWORD *a3);
void *_dynamic_cast(const void *lpsrc, const struct __class_type_info *lpstype, const struct __class_type_info *lpdtype, ptrdiff_t s2d);
void __fastcall sub_B72C0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int a5);
void __fastcall sub_B7364(__int64 a1, __int64 a2, __int64 a3, int a4);
__int64 __fastcall sub_B7384(__int64 result, __int64 a2, char *a3, unsigned int a4, char a5);
__int64 __fastcall sub_B76F0(__int64 *a1, __int64 a2, __int64 a3, _QWORD *a4, __int64 a5, char a6);
__int64 __fastcall sub_B7728(__int64 *a1, __int64 a2, _QWORD *a3, __int64 a4, char a5);
__int64 __fastcall sub_B7760(__int64 result, __int64 a2, __int64 a3, unsigned int a4, char a5);
__int64 __fastcall sub_B78E0(__int64 result, __int64 a2, __int64 a3, int a4, char a5);
__int64 __fastcall sub_B79D8(__int64 result, __int64 a2, __int64 a3, char *a4, unsigned int a5, char a6);
__int64 __fastcall sub_B7BD4(__int64 result, __int64 a2, __int64 a3, __int64 a4, unsigned int a5, char a6);
__int64 __fastcall sub_B7CF4(__int64 result, __int64 a2, __int64 a3, __int64 a4, int a5, char a6);
void __fastcall std::type_info::~type_info(std::type_info *this); // idb
void __fastcall std::type_info::~type_info(std::type_info *this); // idb
_QWORD *__fastcall std::bad_cast::bad_cast(_QWORD *this);
void __fastcall std::bad_cast::~bad_cast(std::bad_cast *this); // idb
void __fastcall std::bad_cast::~bad_cast(std::bad_cast *this); // idb
const char *__fastcall std::bad_cast::what(std::bad_cast *this);
_QWORD *__fastcall std::bad_typeid::bad_typeid(_QWORD *this);
void __fastcall std::bad_typeid::~bad_typeid(std::bad_typeid *this); // idb
void __fastcall std::bad_typeid::~bad_typeid(std::bad_typeid *this); // idb
const char *__fastcall std::bad_typeid::what(std::bad_typeid *this);
void __noreturn _cxa_pure_virtual(void);
void __noreturn _cxa_deleted_virtual(void);
char *__fastcall sub_B7EBC(char *result, _QWORD *a2);
char *__fastcall sub_B7EFC(char a1, char *a2, char *a3, unsigned __int64 *a4);
__int64 sub_B7FEC();
__int64 __fastcall sub_B8100(__int64 result, __int64 a2, _QWORD *a3);
__int64 __fastcall Unwind_GetGR(__int64 a1, int a2);
__int64 __fastcall sub_B8194(__int64 a1, __int64 a2);
__int64 __fastcall Unwind_GetCFA(__int64 a1);
_QWORD *__fastcall Unwind_SetGR(_QWORD *result, int a2, __int64 a3);
__int64 __fastcall Unwind_GetIP(__int64 a1);
__int64 __fastcall Unwind_GetIPInfo(__int64 a1, _DWORD *a2);
__int64 __fastcall Unwind_SetIP(__int64 result, __int64 a2);
__int64 __fastcall Unwind_GetLanguageSpecificData(__int64 a1);
__int64 __fastcall Unwind_GetRegionStart(__int64 a1);
__int64 Unwind_FindEnclosingFunction();
__int64 __fastcall Unwind_GetDataRelBase(__int64 a1);
__int64 __fastcall Unwind_GetTextRelBase(__int64 a1);
__int64 __fastcall sub_B836C(unsigned __int8 a1);
char *__fastcall sub_B83E4(char *result, unsigned __int64 a2, __int64 a3, char *dest);
__int64 __fastcall sub_B88DC(_QWORD *a1, char *s);
__int64 __fastcall sub_B8D00(char *a1, unsigned __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_B92B4(__int64 *src, __int64 a2);
__int64 __fastcall sub_B94C0(_QWORD *a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_B959C(__int64 *a1, __int64 a2);
__int64 __fastcall sub_B95E8(_QWORD *a1, __int64 *a2);
__int64 __fastcall sub_B96A8(_QWORD *a1, __int64 *a2);
__int64 __fastcall _frame_state_for(__int64 a1, __int64 a2);
void nullsub_1();
_QWORD *__fastcall Unwind_RaiseException(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9);
_QWORD *__fastcall Unwind_ForcedUnwind(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9);
void __fastcall __noreturn Unwind_Resume(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9);
void __fastcall __noreturn Unwind_Resume_or_Rethrow(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9);
__int64 __fastcall Unwind_DeleteException(__int64 result);
__int64 __fastcall Unwind_Backtrace(unsigned int (__fastcall *a1)(__int64 *, __int64), __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9);
char *__fastcall sub_B9DE0(char *result, _QWORD *a2);
char *__fastcall sub_B9E08(char *result, _QWORD *a2);
__int64 __fastcall sub_B9E48(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_B9E64(__int64 result, __int64 (__fastcall *a2)(__int64, _QWORD, _QWORD), __int64 a3, int a4, int a5);
__int64 __fastcall sub_B9F24(__int64 result, __int64 (__fastcall *a2)(__int64, _QWORD, _QWORD), __int64 a3);
__int64 __fastcall sub_B9FD8(unsigned __int8 a1);
__int64 __fastcall sub_BA038(unsigned __int8 a1, __int64 a2);
__int64 __fastcall sub_BA098(unsigned __int8 a1, __int64 a2);
char *__fastcall sub_BA0F8(char a1, char *a2, char *a3, unsigned __int64 *a4);
__int64 __fastcall sub_BA1E8(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_BA278(__int64 a1);
unsigned int *__fastcall sub_BA374(__int64 a1, unsigned int *a2, __int64 a3);
__int64 __fastcall sub_BA4D4(__int64 a1);
__int64 __fastcall sub_BA4E4(__int64 *a1, unsigned __int64 a2, __int64 a3);
__int64 __fastcall sub_BA900(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_BA99C(__int64 a1, char *a2);
__int64 __fastcall sub_BAAFC(__int64 a1, __int64 *a2, unsigned int *a3);
unsigned int *__fastcall sub_BAC30(__int64 a1, unsigned __int64 a2);
__int64 *__fastcall _register_frame_info_bases(__int64 *result, _QWORD *a2, __int64 a3, __int64 a4);
__int64 _register_frame_info();
_DWORD *__fastcall _register_frame(_DWORD *result);
__int64 *__fastcall _register_frame_info_table_bases(__int64 a1, _QWORD *a2, __int64 a3, __int64 a4);
__int64 _register_frame_info_table();
__int64 _register_frame_table();
__int64 __fastcall _deregister_frame_info_bases(_DWORD *a1);
__int64 _deregister_frame_info(void); // weak
void __fastcall _deregister_frame(_DWORD *a1);
unsigned int *__fastcall Unwind_Find_FDE(unsigned __int64 a1, _QWORD *a2);
// int pthread_create(pthread_t *newthread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);
// void *realloc(void *ptr, size_t size);
// int pthread_key_create(pthread_key_t *key, void (*destr_function)(void *));
// int pthread_once(pthread_once_t *once_control, void (*init_routine)(void));
// int _cxa_finalize(void *);
// int isalpha(int);
// void *calloc(size_t nmemb, size_t size);
// void syslog(int pri, const char *fmt, ...);
// int posix_memalign(void **memptr, size_t alignment, size_t size);
// clock_t clock(void);
// void AAsset_close(AAsset *asset);
// void __noreturn abort(void);
// int snprintf(char *s, size_t maxlen, const char *format, ...);
// int dl_iterate_phdr(int (*callback)(struct dl_phdr_info *, size_t, void *), void *data);
// __int64 android_set_abort_message(void); weak
// int isupper(int);
// int memcmp(const void *s1, const void *s2, size_t n);
// int fputc(int c, FILE *stream);
// void __noreturn _stack_chk_fail(void); weak
// int pthread_setspecific(pthread_key_t key, const void *pointer);
// void openlog(const char *ident, int option, int facility);
// int _android_log_print(int prio, const char *tag, const char *fmt, ...);
// int strcmp(const char *s1, const char *s2);
// int pthread_mutex_lock(pthread_mutex_t *mutex);
// void closelog(void);
// void *pthread_getspecific(pthread_key_t key);
// AAsset *AAssetManager_open(AAssetManager *mgr, const char *filename, int mode);
// void *memmove(void *dest, const void *src, size_t n);
// int isxdigit(int);
// off_t AAsset_getLength(AAsset *asset);
// int AAsset_read(AAsset *asset, void *buf, size_t count);
// size_t strlen(const char *s);
// int vasprintf(char **ptr, const char *f, __gnuc_va_list arg);
// void *malloc(size_t size);
// void *memcpy(void *dest, const void *src, size_t n);
// void *memset(void *s, int c, size_t n);
// AAssetManager *AAssetManager_fromJava(JNIEnv *env, jobject assetManager);
// void free(void *p);
// char *strcpy(char *, const char *);
// int vfprintf(FILE *s, const char *format, __gnuc_va_list arg);
// int pthread_mutex_unlock(pthread_mutex_t *mutex);
// int _cxa_atexit(void (*lpfunc)(void *), void *obj, void *lpdso_handle);

//-------------------------------------------------------------------------
// Data declarations

int dword_0 = 1179403647; // weak
char byte_9[7] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
Elf64_Sym stru_27F8 = { 9964u, 17u, 0u, 11u, 110961552uLL, 2uLL }; // weak
_UNKNOWN loc_8E4C0; // weak
_UNKNOWN loc_B7E94; // weak
int dword_69D05F0[48] =
{
  0,
  2,
  3,
  5,
  7,
  11,
  13,
  17,
  19,
  23,
  29,
  31,
  37,
  41,
  43,
  47,
  53,
  59,
  61,
  67,
  71,
  73,
  79,
  83,
  89,
  97,
  101,
  103,
  107,
  109,
  113,
  127,
  131,
  137,
  139,
  149,
  151,
  157,
  163,
  167,
  173,
  179,
  181,
  191,
  193,
  197,
  199,
  211
}; // weak
unsigned int dword_69D06B0[48] =
{
  1u,
  11u,
  13u,
  17u,
  19u,
  23u,
  29u,
  31u,
  37u,
  41u,
  43u,
  47u,
  53u,
  59u,
  61u,
  67u,
  71u,
  73u,
  79u,
  83u,
  89u,
  97u,
  101u,
  103u,
  107u,
  109u,
  113u,
  121u,
  127u,
  131u,
  137u,
  139u,
  143u,
  149u,
  151u,
  157u,
  163u,
  167u,
  169u,
  173u,
  179u,
  181u,
  187u,
  191u,
  193u,
  197u,
  199u,
  209u
}; // weak
_QWORD qword_69D0940[11] = { 1LL, 2LL, 3LL, 3LL, 3LL, 3LL, 3LL, 3LL, 1LL, 2LL, 3LL }; // weak
char asc_69D1AEC[3] = ", "; // weak
char aLambda[10] = "'lambda'("; // weak
_UNKNOWN unk_69D22C0; // weak
_UNKNOWN unk_69D22D0; // weak
char aStdBadTypeid[16] = "std::bad_typeid"; // weak
void (__fastcall *off_69E88B0[2])(xinyoudi::ApkUtils *__hidden this) = { &xinyoudi::ApkUtils::~ApkUtils, &xinyoudi::ApkUtils::~ApkUtils }; // weak
void (__fastcall *off_69E88D0[2])(xinyoudi::FileRef *__hidden this) = { &xinyoudi::FileRef::~FileRef, &xinyoudi::FileRef::~FileRef }; // weak
void (__fastcall *off_69E88F0[2])(xinyoudi::LuaFileUtils *__hidden this) =
{
  &xinyoudi::LuaFileUtils::~LuaFileUtils,
  &xinyoudi::LuaFileUtils::~LuaFileUtils
}; // weak
void (__fastcall *off_69E8910[2])(std::exception *__hidden this) = { &std::exception::~exception, &std::bad_alloc::~bad_alloc }; // weak
void (__fastcall *off_69E8938[2])(std::exception *__hidden this) =
{
  &std::exception::~exception,
  &std::bad_array_new_length::~bad_array_new_length
}; // weak
void (__fastcall *off_69E8960[2])(std::exception *__hidden this) = { &std::exception::~exception, &std::bad_array_length::~bad_array_length }; // weak
__int64 *`typeinfo for'std::exception = &off_69E9688; // weak
__int64 *`typeinfo for'std::bad_alloc = &off_69E96D8; // weak
void (__fastcall *off_69E8A70[2])(std::invalid_argument *__hidden this) = { &std::invalid_argument::~invalid_argument, &std::logic_error::~logic_error }; // weak
void (__fastcall *off_69E8A98[2])(std::underflow_error *__hidden this) = { &std::underflow_error::~underflow_error, &std::runtime_error::~runtime_error }; // weak
void (__fastcall *off_69E8C48[2])(std::underflow_error *__hidden this) =
{
  &std::underflow_error::~underflow_error,
  &std::overflow_error::~overflow_error
}; // weak
__int64 *`typeinfo for'std::overflow_error = &off_69E96D8; // weak
__int64 *`typeinfo for'__cxxabiv1::__shim_type_info = &off_69E96D8; // weak
__int64 *`typeinfo for'__cxxabiv1::__class_type_info = &off_69E96D8; // weak
__int64 *`typeinfo for'__cxxabiv1::__pbase_type_info = &off_69E96D8; // weak
__int64 *`typeinfo for'__cxxabiv1::__pointer_type_info = &off_69E96D8; // weak
__int64 *`typeinfo for'__cxxabiv1::__function_type_info = &off_69E96D8; // weak
__int64 *`typeinfo for'__cxxabiv1::__pointer_to_member_type_info = &off_69E96D8; // weak
void (__fastcall *`typeinfo for'void)(std::type_info *__hidden this) = &off_69E8DC0; // weak
void (__fastcall *`typeinfo for'decltype(nullptr))(std::type_info *__hidden this) = &off_69E8DC0; // weak
void (__fastcall *off_69E9860[2])(std::bad_cast *__hidden this) = { &std::bad_cast::~bad_cast, &std::bad_cast::~bad_cast }; // weak
void (__fastcall *off_69E9888[2])(std::bad_typeid *__hidden this) = { &std::bad_typeid::~bad_typeid, &std::bad_typeid::~bad_typeid }; // weak
_UNKNOWN unk_69EA000; // weak
__int64 (__fastcall *_cxa_terminate_handler)() = &sub_904A8; // weak
void (__fastcall __noreturn *_cxa_unexpected_handler)() = &sub_905D0; // weak
char *off_69EA020 = "uncaught"; // weak
__int64 qword_69EA028 = -1LL; // weak
__int64 xinyoudi::ApkUtils::_apkUtils; // weak
__int64 xinyoudi::ApkUtils::_assetManager; // weak
int dword_69EA040; // weak
pthread_once_t dword_69EA044; // weak
unsigned __int64 _cxa_new_handler; // weak
pthread_mutex_t stru_69EA050; // weak
__int64 qword_69EA078; // weak
int dword_69EA080[]; // weak
char byte_69EA280[]; // weak
char byte_69EA29F; // weak
char byte_69EA2C0; // weak
_BYTE algn_69EA2E1[7]; // weak
__int64 qword_69EA2E8; // weak
__int64 qword_69EA2F0; // weak
_UNKNOWN unk_69EA2F8; // weak
_UNKNOWN unk_69EA328; // weak
__int64 qword_69EA470; // weak
__int64 qword_69EA478; // weak
_UNKNOWN unk_69EA480; // weak
pthread_mutex_t stru_69EA488; // weak
__int64 qword_69EA4B0; // weak
__int64 qword_69EA4B8; // weak
// extern _UNKNOWN _sF; weak


//----- (000000000000A4B0) ----------------------------------------------------
void sub_A4B0()
{
  JUMPOUT(0LL);
}
// A4C0: control flows out of bounds to 0

//----- (000000000000A4D0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall xinyoudi::FileRef::getSize(xinyoudi::FileRef *this)
{
  return _ZNK8xinyoudi7FileRef7getSizeEv(this);
}

//----- (000000000000A4E0) ----------------------------------------------------
// attributes: thunk
__int64 _Unwind_GetDataRelBase()
{
  return Unwind_GetDataRelBase();
}
// B835C: using guessed type __int64 Unwind_GetDataRelBase(void);

//----- (000000000000A4F0) ----------------------------------------------------
// attributes: thunk
__int64 _Unwind_Find_FDE()
{
  return Unwind_Find_FDE();
}
// BB47C: using guessed type __int64 Unwind_Find_FDE(void);

//----- (000000000000A500) ----------------------------------------------------
// attributes: thunk
__int64 __cxa_get_globals_fast()
{
  return _cxa_get_globals_fast();
}
// 8EB2C: using guessed type __int64 _cxa_get_globals_fast(void);

//----- (000000000000A510) ----------------------------------------------------
// attributes: thunk
void __noreturn __cxa_throw(void *a1, struct type_info *lptinfo, void (*a3)(void *))
{
  _cxa_throw(a1, lptinfo, a3);
}

//----- (000000000000A530) ----------------------------------------------------
// attributes: thunk
__int64 operator new[]()
{
  return _ZnamSt11align_val_t();
}
// 8FF10: using guessed type __int64 operator new[](void);

//----- (000000000000A540) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall xinyoudi::LuaFileUtils::isFileExist(xinyoudi::LuaFileUtils *this, const char *s)
{
  return _ZN8xinyoudi12LuaFileUtils11isFileExistEPKc(this, s);
}

//----- (000000000000A580) ----------------------------------------------------
// attributes: thunk
void __cxa_end_catch(void)
{
  _cxa_end_catch();
}

//----- (000000000000A5A0) ----------------------------------------------------
// attributes: thunk
__int64 __deregister_frame_info()
{
  return _deregister_frame_info();
}
// BB454: using guessed type __int64 _deregister_frame_info(void);

//----- (000000000000A5B0) ----------------------------------------------------
// attributes: thunk
__int64 _Unwind_SetGR()
{
  return Unwind_SetGR();
}
// B82A8: using guessed type __int64 Unwind_SetGR(void);

//----- (000000000000A5C0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall xinyoudi::ApkUtils::getInstance(xinyoudi::ApkUtils *this)
{
  return _ZN8xinyoudi8ApkUtils11getInstanceEv(this);
}

//----- (000000000000A5D0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall xinyoudi::ApkUtils::destroyInstance(xinyoudi::ApkUtils *this)
{
  return _ZN8xinyoudi8ApkUtils15destroyInstanceEv(this);
}

//----- (000000000000A5F0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall xinyoudi::FileRef::FileRef(xinyoudi::FileRef *this, bool a2, unsigned int a3)
{
  return _ZN8xinyoudi7FileRefC2Ebj(this, a2, a3);
}

//----- (000000000000A600) ----------------------------------------------------
// attributes: thunk
__int64 std::basic_string<unsigned char>::__grow_by_and_replace()
{
  return _ZNSt6__ndk112basic_stringIhNS_11char_traitsIhEENS_9allocatorIhEEE21__grow_by_and_replaceEmmmmmmPKh();
}
// 8D4BC: using guessed type __int64 std::basic_string<unsigned char>::__grow_by_and_replace(void);

//----- (000000000000A620) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall xinyoudi::ApkUtils::getFileSize(xinyoudi::ApkUtils *this, const char *a2, bool a3)
{
  return _ZN8xinyoudi8ApkUtils11getFileSizeEPKcb(this, a2, a3);
}

//----- (000000000000A630) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall operator new(unsigned __int64 a1)
{
  return _Znwm(a1);
}

//----- (000000000000A660) ----------------------------------------------------
// attributes: thunk
__int64 std::__hash_table<std::__hash_value_type<std::string,std::basic_string<unsigned char>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::basic_string<unsigned char>>,std::hash<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::basic_string<unsigned char>>,std::equal_to<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::basic_string<unsigned char>>>>::__rehash()
{
  return _ZNSt6__ndk112__hash_tableINS_17__hash_value_typeINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEENS2_IhNS3_IhEENS5_IhEEEEEENS_22__unordered_map_hasherIS7_SB_NS_4hashIS7_EELb1EEENS_21__unordered_map_equalIS7_SB_NS_8equal_toIS7_EELb1EEENS5_ISB_EEE8__rehashEm();
}
// 8D080: using guessed type __int64 std::__hash_table<std::__hash_value_type<std::string,std::basic_string<unsigned char>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::basic_string<unsigned char>>,std::hash<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::basic_string<unsigned char>>,std::equal_to<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::basic_string<unsigned char>>>>::__rehash(void);

//----- (000000000000A670) ----------------------------------------------------
// attributes: thunk
__int64 _Unwind_GetLanguageSpecificData()
{
  return Unwind_GetLanguageSpecificData();
}
// B8324: using guessed type __int64 Unwind_GetLanguageSpecificData(void);

//----- (000000000000A680) ----------------------------------------------------
// attributes: thunk
__int64 operator delete[]()
{
  return _ZdaPvSt11align_val_t();
}
// 8FF58: using guessed type __int64 operator delete[](void);

//----- (000000000000A6A0) ----------------------------------------------------
// attributes: thunk
__int64 _Unwind_DeleteException()
{
  return Unwind_DeleteException();
}
// B9CEC: using guessed type __int64 Unwind_DeleteException(void);

//----- (000000000000A6C0) ----------------------------------------------------
// attributes: thunk
void __noreturn __cxa_call_unexpected(void *a1)
{
  _cxa_call_unexpected(a1);
}

//----- (000000000000A6D0) ----------------------------------------------------
// attributes: thunk
__int64 std::__hash_table<std::__hash_value_type<char const*,xinyoudi::FileRef *>,std::__unordered_map_hasher<char const*,std::__hash_value_type<char const*,xinyoudi::FileRef *>,hash_func,true>,std::__unordered_map_equal<char const*,std::__hash_value_type<char const*,xinyoudi::FileRef *>,cmp,true>,std::allocator<std::__hash_value_type<char const*,xinyoudi::FileRef *>>>::__rehash()
{
  return _ZNSt6__ndk112__hash_tableINS_17__hash_value_typeIPKcPN8xinyoudi7FileRefEEENS_22__unordered_map_hasherIS3_S7_9hash_funcLb1EEENS_21__unordered_map_equalIS3_S7_3cmpLb1EEENS_9allocatorIS7_EEE8__rehashEm();
}
// B874: using guessed type __int64 std::__hash_table<std::__hash_value_type<char const*,xinyoudi::FileRef *>,std::__unordered_map_hasher<char const*,std::__hash_value_type<char const*,xinyoudi::FileRef *>,hash_func,true>,std::__unordered_map_equal<char const*,std::__hash_value_type<char const*,xinyoudi::FileRef *>,cmp,true>,std::allocator<std::__hash_value_type<char const*,xinyoudi::FileRef *>>>::__rehash(void);

//----- (000000000000A710) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall xinyoudi::ApkUtils::getFileContent(
        xinyoudi::ApkUtils *this,
        const char *a2,
        unsigned __int8 *a3,
        bool a4)
{
  return _ZN8xinyoudi8ApkUtils14getFileContentEPKcPhb(this, a2, a3, a4);
}

//----- (000000000000A730) ----------------------------------------------------
// attributes: thunk
__int64 operator new()
{
  return _ZnwmSt11align_val_t();
}
// 8FE38: using guessed type __int64 operator new(void);

//----- (000000000000A740) ----------------------------------------------------
// attributes: thunk
__int64 std::basic_string<unsigned char>::assign()
{
  return _ZNSt6__ndk112basic_stringIhNS_11char_traitsIhEENS_9allocatorIhEEE6assignEPKhm();
}
// 8D2E8: using guessed type __int64 std::basic_string<unsigned char>::assign(void);

//----- (000000000000A750) ----------------------------------------------------
// attributes: thunk
__int64 __deregister_frame_info_bases()
{
  return _deregister_frame_info_bases();
}
// BB354: using guessed type __int64 _deregister_frame_info_bases(void);

//----- (000000000000A760) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall xinyoudi::ApkUtils::addFileRef(xinyoudi::ApkUtils *this, const char *s, xinyoudi::FileRef *a3)
{
  return _ZN8xinyoudi8ApkUtils10addFileRefEPKcPNS_7FileRefE(this, s, a3);
}

//----- (000000000000A770) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall xinyoudi::FileRef::isExist(xinyoudi::FileRef *this)
{
  return _ZNK8xinyoudi7FileRef7isExistEv(this);
}

//----- (000000000000A790) ----------------------------------------------------
// attributes: thunk
void __fastcall std::exception::~exception(std::exception *this)
{
  _ZNSt9exceptionD2Ev(this);
}

//----- (000000000000A7A0) ----------------------------------------------------
// attributes: thunk
void __fastcall std::type_info::~type_info(std::type_info *this)
{
  _ZNSt9type_infoD2Ev(this);
}

//----- (000000000000A7B0) ----------------------------------------------------
// attributes: thunk
__int64 std::get_new_handler(void)
{
  return _ZSt15get_new_handlerv();
}

//----- (000000000000A7E0) ----------------------------------------------------
// attributes: thunk
__int64 std::unordered_map<std::string,std::basic_string<unsigned char>>::operator[]()
{
  return _ZNSt6__ndk113unordered_mapINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEENS1_IhNS2_IhEENS4_IhEEEENS_4hashIS6_EENS_8equal_toIS6_EENS4_INS_4pairIKS6_S9_EEEEEixEOS6_();
}
// 8C2F0: using guessed type __int64 std::unordered_map<std::string,std::basic_string<unsigned char>>::operator[](void);

//----- (000000000000A7F0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall xinyoudi::LuaFileUtils::init(xinyoudi::LuaFileUtils *this)
{
  return _ZN8xinyoudi12LuaFileUtils4initEv(this);
}

//----- (000000000000A800) ----------------------------------------------------
// attributes: thunk
__int64 __register_frame_info()
{
  return _register_frame_info();
}
// BB23C: using guessed type __int64 _register_frame_info(void);

//----- (000000000000A810) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall std::__hash_table<std::__hash_value_type<char const*,xinyoudi::FileRef *>,std::__unordered_map_hasher<char const*,std::__hash_value_type<char const*,xinyoudi::FileRef *>,hash_func,true>,std::__unordered_map_equal<char const*,std::__hash_value_type<char const*,xinyoudi::FileRef *>,cmp,true>,std::allocator<std::__hash_value_type<char const*,xinyoudi::FileRef *>>>::rehash(
        int a1,
        std::__ndk1 *this)
{
  return _ZNSt6__ndk112__hash_tableINS_17__hash_value_typeIPKcPN8xinyoudi7FileRefEEENS_22__unordered_map_hasherIS3_S7_9hash_funcLb1EEENS_21__unordered_map_equalIS3_S7_3cmpLb1EEENS_9allocatorIS7_EEE6rehashEm(
           a1,
           this);
}

//----- (000000000000A820) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall xinyoudi::LuaFileUtils::start(xinyoudi::LuaFileUtils *this)
{
  return _ZN8xinyoudi12LuaFileUtils5startEv(this);
}

//----- (000000000000A850) ----------------------------------------------------
// attributes: thunk
__int64 __cxa_get_globals()
{
  return _cxa_get_globals();
}
// 8EA9C: using guessed type __int64 _cxa_get_globals(void);

//----- (000000000000A870) ----------------------------------------------------
// attributes: thunk
__int64 __register_frame_info_table()
{
  return _register_frame_info_table();
}
// BB31C: using guessed type __int64 _register_frame_info_table(void);

//----- (000000000000A880) ----------------------------------------------------
// attributes: thunk
__int64 operator delete()
{
  return _ZdlPvSt11align_val_t();
}
// 8FF40: using guessed type __int64 operator delete(void);

//----- (000000000000A890) ----------------------------------------------------
// attributes: thunk
char *__cxa_demangle(const char *lpmangled, char *lpout, size_t *lpoutlen, int *lpstatus)
{
  return _cxa_demangle(lpmangled, lpout, lpoutlen, lpstatus);
}

//----- (000000000000A8A0) ----------------------------------------------------
// attributes: thunk
__int64 _Unwind_RaiseException()
{
  return Unwind_RaiseException();
}
// B988C: using guessed type __int64 Unwind_RaiseException(void);

//----- (000000000000A8C0) ----------------------------------------------------
// attributes: thunk
__int64 _Unwind_SetIP()
{
  return Unwind_SetIP();
}
// B831C: using guessed type __int64 Unwind_SetIP(void);

//----- (000000000000A8D0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall std::runtime_error::runtime_error(std::runtime_error *this, const char *s)
{
  return _ZNSt13runtime_errorC2EPKc(this, s);
}

//----- (000000000000A8E0) ----------------------------------------------------
// attributes: thunk
void __fastcall operator delete[](void *a1)
{
  _ZdaPv(a1);
}

//----- (000000000000A8F0) ----------------------------------------------------
// attributes: thunk
void *__cxa_allocate_exception(size_t thrown_size)
{
  return _cxa_allocate_exception(thrown_size);
}

//----- (000000000000A900) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall xinyoudi::LuaFileUtils::getFileContent(
        xinyoudi::LuaFileUtils *this,
        const char *s,
        unsigned __int8 *a3)
{
  return _ZN8xinyoudi12LuaFileUtils14getFileContentEPKcPh(this, s, a3);
}

//----- (000000000000A910) ----------------------------------------------------
// attributes: thunk
__int64 __register_frame_info_bases()
{
  return _register_frame_info_bases();
}
// BB1A0: using guessed type __int64 _register_frame_info_bases(void);

//----- (000000000000A920) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall xinyoudi::LuaFileUtils::getFileSize(xinyoudi::LuaFileUtils *this, const char *s)
{
  return _ZN8xinyoudi12LuaFileUtils11getFileSizeEPKc(this, s);
}

//----- (000000000000A930) ----------------------------------------------------
// attributes: thunk
__int64 _Unwind_GetRegionStart()
{
  return Unwind_GetRegionStart();
}
// B832C: using guessed type __int64 Unwind_GetRegionStart(void);

//----- (000000000000A980) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall std::__hash_table<std::__hash_value_type<std::string,std::basic_string<unsigned char>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::basic_string<unsigned char>>,std::hash<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::basic_string<unsigned char>>,std::equal_to<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::basic_string<unsigned char>>>>::rehash(
        int a1,
        std::__ndk1 *this)
{
  return _ZNSt6__ndk112__hash_tableINS_17__hash_value_typeINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEENS2_IhNS3_IhEENS5_IhEEEEEENS_22__unordered_map_hasherIS7_SB_NS_4hashIS7_EELb1EEENS_21__unordered_map_equalIS7_SB_NS_8equal_toIS7_EELb1EEENS5_ISB_EEE6rehashEm(
           a1,
           this);
}

//----- (000000000000A990) ----------------------------------------------------
// attributes: thunk
void __fastcall operator delete(void *a1)
{
  _ZdlPv(a1);
}

//----- (000000000000A9A0) ----------------------------------------------------
// attributes: thunk
__int64 _Unwind_GetTextRelBase()
{
  return Unwind_GetTextRelBase();
}
// B8364: using guessed type __int64 Unwind_GetTextRelBase(void);

//----- (000000000000A9C0) ----------------------------------------------------
// attributes: thunk
void __noreturn std::terminate(void)
{
  _ZSt9terminatev();
}

//----- (000000000000A9D0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall operator new[](unsigned __int64 a1)
{
  return _Znam(a1);
}

//----- (000000000000A9E0) ----------------------------------------------------
// attributes: thunk
__int64 _Unwind_GetCFA()
{
  return Unwind_GetCFA();
}
// B82A0: using guessed type __int64 Unwind_GetCFA(void);

//----- (000000000000AA00) ----------------------------------------------------
// attributes: thunk
void *__cxa_begin_catch(void *a1)
{
  return _cxa_begin_catch(a1);
}

//----- (000000000000AA10) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall std::bad_alloc::bad_alloc(std::bad_alloc *this)
{
  return _ZNSt9bad_allocC2Ev(this);
}

//----- (000000000000AA30) ----------------------------------------------------
// attributes: thunk
__int64 std::__murmur2_or_cityhash<unsigned long,64ul>::operator()()
{
  return _ZNSt6__ndk121__murmur2_or_cityhashImLm64EEclEPKvm();
}
// 8CC50: using guessed type __int64 std::__murmur2_or_cityhash<unsigned long,64ul>::operator()(void);

//----- (000000000000AA40) ----------------------------------------------------
// attributes: thunk
void __cxa_free_exception(void *a1)
{
  _cxa_free_exception(a1);
}

//----- (000000000000AA60) ----------------------------------------------------
// attributes: thunk
void *__dynamic_cast(
        const void *lpsrc,
        const struct __class_type_info *lpstype,
        const struct __class_type_info *lpdtype,
        ptrdiff_t s2d)
{
  return _dynamic_cast(lpsrc, lpstype, lpdtype, s2d);
}

//----- (000000000000AA90) ----------------------------------------------------
// attributes: thunk
void __fastcall xinyoudi::LuaFileUtils::~LuaFileUtils(xinyoudi::LuaFileUtils *this)
{
  _ZN8xinyoudi12LuaFileUtilsD2Ev(this);
}

//----- (000000000000AAA0) ----------------------------------------------------
// attributes: thunk
void __fastcall std::exception::~exception(std::exception *this)
{
  _ZNSt9exceptionD2Ev(this);
}

//----- (000000000000AAB0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall xinyoudi::ApkUtils::isFileExist(xinyoudi::ApkUtils *this, const char *a2, bool a3)
{
  return _ZN8xinyoudi8ApkUtils11isFileExistEPKcb(this, a2, a3);
}

//----- (000000000000AAC0) ----------------------------------------------------
// attributes: thunk
__int64 std::__hash_table<std::__hash_value_type<std::string,std::basic_string<unsigned char>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::basic_string<unsigned char>>,std::hash<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::basic_string<unsigned char>>,std::equal_to<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::basic_string<unsigned char>>>>::find<std::string>()
{
  return _ZNSt6__ndk112__hash_tableINS_17__hash_value_typeINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEENS2_IhNS3_IhEENS5_IhEEEEEENS_22__unordered_map_hasherIS7_SB_NS_4hashIS7_EELb1EEENS_21__unordered_map_equalIS7_SB_NS_8equal_toIS7_EELb1EEENS5_ISB_EEE4findIS7_EENS_15__hash_iteratorIPNS_11__hash_nodeISB_PvEEEERKT_();
}
// 8D758: using guessed type __int64 std::__hash_table<std::__hash_value_type<std::string,std::basic_string<unsigned char>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::basic_string<unsigned char>>,std::hash<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::basic_string<unsigned char>>,std::equal_to<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::basic_string<unsigned char>>>>::find<std::string>(void);

//----- (000000000000AAD0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall xinyoudi::LuaFileUtils::LuaFileUtils(xinyoudi::LuaFileUtils *this)
{
  return _ZN8xinyoudi12LuaFileUtilsC2Ev(this);
}

//----- (000000000000AAE0) ----------------------------------------------------
// attributes: thunk
void __noreturn __cxa_rethrow(void)
{
  _cxa_rethrow();
}

//----- (000000000000AB10) ----------------------------------------------------
// attributes: thunk
void __noreturn _Unwind_Resume()
{
  Unwind_Resume();
}
// B9AF8: using guessed type void __noreturn Unwind_Resume(void);

//----- (000000000000AB30) ----------------------------------------------------
// attributes: thunk
__int64 std::get_terminate(void)
{
  return _ZSt13get_terminatev();
}

//----- (000000000000AB40) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall std::__next_prime(std::__ndk1 *this, unsigned __int64 a2)
{
  return _ZNSt6__ndk112__next_primeEm(this, a2);
}

//----- (000000000000AB60) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall xinyoudi::ApkUtils::setAssetManager(xinyoudi::ApkUtils *this, AAssetManager *a2)
{
  return _ZN8xinyoudi8ApkUtils15setAssetManagerEP13AAssetManager(this, a2);
}

//----- (000000000000AB70) ----------------------------------------------------
// attributes: thunk
__int64 std::get_unexpected(void)
{
  return _ZSt14get_unexpectedv();
}

//----- (000000000000AB80) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall xinyoudi::ApkUtils::getFileRef(xinyoudi::ApkUtils *this, const char *s2)
{
  return _ZNK8xinyoudi8ApkUtils10getFileRefEPKc(this, s2);
}

//----- (000000000000AB90) ----------------------------------------------------
// attributes: thunk
__int64 std::__murmur2_or_cityhash<unsigned long,64ul>::__hash_len_0_to_16()
{
  return _ZNSt6__ndk121__murmur2_or_cityhashImLm64EE18__hash_len_0_to_16EPKcm();
}
// 8CF84: using guessed type __int64 std::__murmur2_or_cityhash<unsigned long,64ul>::__hash_len_0_to_16(void);

//----- (000000000000ABA0) ----------------------------------------------------
// attributes: thunk
__int64 _Unwind_GetIP()
{
  return Unwind_GetIP();
}
// B8300: using guessed type __int64 Unwind_GetIP(void);

//----- (000000000000ABC0) ----------------------------------------------------
// attributes: thunk
__int64 __register_frame_info_table_bases()
{
  return _register_frame_info_table_bases();
}
// BB288: using guessed type __int64 _register_frame_info_table_bases(void);

//----- (000000000000AC10) ----------------------------------------------------
__int64 start()
{
  return __cxa_finalize(&unk_69EA000);
}

//----- (000000000000AC1C) ----------------------------------------------------
__int64 (*__fastcall sub_AC1C(__int64 (*result)(void)))(void)
{
  if ( result )
    return (__int64 (*)(void))result();
  return result;
}

//----- (000000000000AC34) ----------------------------------------------------
__int64 __fastcall sub_AC34(void *a1)
{
  return __cxa_atexit((void (*)(void *))sub_AC1C, a1, &unk_69EA000);
}

//----- (000000000000AC4C) ----------------------------------------------------
__int64 __fastcall xinyoudi::ApkUtils::getInstance(xinyoudi::ApkUtils *this)
{
  __int64 v1; // x19
  xinyoudi::LuaFileUtils *v2; // x20

  v1 = xinyoudi::ApkUtils::_apkUtils;
  if ( !xinyoudi::ApkUtils::_apkUtils )
  {
    v1 = operator new(0x38uLL);
    *(_OWORD *)(v1 + 24) = 0u;
    *(_OWORD *)(v1 + 8) = 0u;
    *(_QWORD *)v1 = off_69E88B0;
    *(_DWORD *)(v1 + 40) = 1065353216;
    v2 = (xinyoudi::LuaFileUtils *)operator new(0x30uLL);
    xinyoudi::LuaFileUtils::LuaFileUtils(v2);
    *(_QWORD *)(v1 + 48) = v2;
    xinyoudi::LuaFileUtils::start(v2);
    xinyoudi::ApkUtils::_apkUtils = v1;
  }
  return v1;
}
// 69E88B0: using guessed type void (__fastcall *[2])(xinyoudi::ApkUtils *__hidden this);
// 69EA030: using guessed type __int64 xinyoudi::ApkUtils::_apkUtils;

//----- (000000000000ACD0) ----------------------------------------------------
__int64 __fastcall xinyoudi::ApkUtils::destroyInstance(xinyoudi::ApkUtils *this)
{
  if ( xinyoudi::ApkUtils::_apkUtils )
  {
    (*(void (__fastcall **)(__int64))(*(_QWORD *)xinyoudi::ApkUtils::_apkUtils + 8LL))(xinyoudi::ApkUtils::_apkUtils);
    xinyoudi::ApkUtils::_apkUtils = 0LL;
  }
  return __android_log_print(4, "ApkUtils-Unity", "DestroyInstance!");
}
// 69EA030: using guessed type __int64 xinyoudi::ApkUtils::_apkUtils;

//----- (000000000000AD1C) ----------------------------------------------------
__int64 __fastcall xinyoudi::ApkUtils::setAssetManager(__int64 this, AAssetManager *a2)
{
  if ( !this )
    return __android_log_print(6, "ApkUtils-Unity", "AssetManager is nullptr in setAssetManager!");
  xinyoudi::ApkUtils::_assetManager = this;
  return this;
}
// 69EA038: using guessed type __int64 xinyoudi::ApkUtils::_assetManager;

//----- (000000000000AD48) ----------------------------------------------------
__int64 __fastcall xinyoudi::ApkUtils::getAssetManager(xinyoudi::ApkUtils *this)
{
  return xinyoudi::ApkUtils::_assetManager;
}
// 69EA038: using guessed type __int64 xinyoudi::ApkUtils::_assetManager;

//----- (000000000000AD58) ----------------------------------------------------
__int64 __fastcall xinyoudi::ApkUtils::getLuaFileUtils(xinyoudi::ApkUtils *this)
{
  return *((_QWORD *)this + 6);
}

//----- (000000000000AD60) ----------------------------------------------------
__int64 __fastcall xinyoudi::ApkUtils::isFileExist(xinyoudi::ApkUtils *this, const char *a2)
{
  __int64 v3; // x20
  xinyoudi::LuaFileUtils *v4; // x21
  __int64 v6; // x20
  xinyoudi::LuaFileUtils *v7; // x21
  xinyoudi::FileRef *FileRef; // x0
  AAsset *v9; // x20
  AAsset *v10; // x0
  unsigned int Length; // w22
  xinyoudi::FileRef *v12; // x21
  __int64 v13; // x22
  xinyoudi::LuaFileUtils *v14; // x23

  if ( ((unsigned __int8)a2 & 1) != 0 )
  {
    v3 = xinyoudi::ApkUtils::_apkUtils;
    if ( !xinyoudi::ApkUtils::_apkUtils )
    {
      v3 = operator new(0x38uLL);
      *(_OWORD *)(v3 + 24) = 0u;
      *(_OWORD *)(v3 + 8) = 0u;
      *(_QWORD *)v3 = off_69E88B0;
      *(_DWORD *)(v3 + 40) = 1065353216;
      v4 = (xinyoudi::LuaFileUtils *)operator new(0x30uLL);
      xinyoudi::LuaFileUtils::LuaFileUtils(v4);
      *(_QWORD *)(v3 + 48) = v4;
      xinyoudi::LuaFileUtils::start(v4);
      xinyoudi::ApkUtils::_apkUtils = v3;
    }
    return xinyoudi::LuaFileUtils::isFileExist(*(xinyoudi::LuaFileUtils **)(v3 + 48), (const char *)this);
  }
  else if ( xinyoudi::ApkUtils::_assetManager )
  {
    v6 = xinyoudi::ApkUtils::_apkUtils;
    if ( !xinyoudi::ApkUtils::_apkUtils )
    {
      v6 = operator new(0x38uLL);
      *(_OWORD *)(v6 + 24) = 0u;
      *(_OWORD *)(v6 + 8) = 0u;
      *(_QWORD *)v6 = off_69E88B0;
      *(_DWORD *)(v6 + 40) = 1065353216;
      v7 = (xinyoudi::LuaFileUtils *)operator new(0x30uLL);
      xinyoudi::LuaFileUtils::LuaFileUtils(v7);
      *(_QWORD *)(v6 + 48) = v7;
      xinyoudi::LuaFileUtils::start(v7);
      xinyoudi::ApkUtils::_apkUtils = v6;
    }
    FileRef = (xinyoudi::FileRef *)xinyoudi::ApkUtils::getFileRef((xinyoudi::ApkUtils *)v6, (const char *)this);
    if ( FileRef )
    {
      LODWORD(v9) = xinyoudi::FileRef::isExist(FileRef) & 1;
    }
    else
    {
      v10 = AAssetManager_open((AAssetManager *)xinyoudi::ApkUtils::_assetManager, (const char *)this, 0);
      v9 = v10;
      if ( v10 )
      {
        Length = AAsset_getLength(v10);
        AAsset_close(v9);
        LODWORD(v9) = 1;
      }
      else
      {
        Length = 0;
      }
      v12 = (xinyoudi::FileRef *)operator new(0x10uLL);
      xinyoudi::FileRef::FileRef(v12, (bool)v9, Length);
      v13 = xinyoudi::ApkUtils::_apkUtils;
      if ( !xinyoudi::ApkUtils::_apkUtils )
      {
        v13 = operator new(0x38uLL);
        *(_OWORD *)(v13 + 24) = 0u;
        *(_OWORD *)(v13 + 8) = 0u;
        *(_QWORD *)v13 = off_69E88B0;
        *(_DWORD *)(v13 + 40) = 1065353216;
        v14 = (xinyoudi::LuaFileUtils *)operator new(0x30uLL);
        xinyoudi::LuaFileUtils::LuaFileUtils(v14);
        *(_QWORD *)(v13 + 48) = v14;
        xinyoudi::LuaFileUtils::start(v14);
        xinyoudi::ApkUtils::_apkUtils = v13;
      }
      xinyoudi::ApkUtils::addFileRef((xinyoudi::ApkUtils *)v13, (const char *)this, v12);
    }
    return (_DWORD)v9 != 0;
  }
  else
  {
    __android_log_print(6, "ApkUtils-Unity", "AssetManager is nullptr in isFileExist!");
    return 0LL;
  }
}
// 69E88B0: using guessed type void (__fastcall *[2])(xinyoudi::ApkUtils *__hidden this);
// 69EA030: using guessed type __int64 xinyoudi::ApkUtils::_apkUtils;
// 69EA038: using guessed type __int64 xinyoudi::ApkUtils::_assetManager;

//----- (000000000000AF78) ----------------------------------------------------
__int64 *__fastcall xinyoudi::ApkUtils::getFileRef(xinyoudi::ApkUtils *this, const char *s2)
{
  unsigned __int8 v3; // w9
  int v4; // w8
  const char *v5; // x10
  int v6; // t1
  unsigned __int64 v7; // x20
  unsigned __int64 v8; // x21
  unsigned __int64 v9; // x22
  __int64 v10; // x23
  unsigned __int64 v11; // x24
  __int64 ***v12; // x8
  __int64 **v13; // x25
  unsigned __int64 v14; // x8

  v3 = *s2;
  if ( *s2 )
  {
    v4 = 0;
    v5 = s2 + 1;
    do
    {
      v4 = 131 * v4 + v3;
      v6 = *(unsigned __int8 *)v5++;
      v3 = v6;
    }
    while ( v6 );
    v7 = v4 & 0x7FFFFFFF;
    v8 = *((_QWORD *)this + 2);
    if ( !v8 )
      return 0LL;
    goto LABEL_7;
  }
  v7 = 0LL;
  v8 = *((_QWORD *)this + 2);
  if ( v8 )
  {
LABEL_7:
    v9 = v8 - 1;
    v10 = (v8 - 1) & v8;
    if ( v10 )
    {
      v11 = v7;
      if ( v7 >= v8 )
        v11 = v7 % v8;
    }
    else
    {
      v11 = v9 & v7;
    }
    v12 = *(__int64 ****)(*((_QWORD *)this + 1) + 8 * v11);
    if ( !v12 )
      return 0LL;
    v13 = *v12;
    if ( !*v12 )
      return 0LL;
    do
    {
      v14 = (unsigned __int64)v13[1];
      if ( v7 == v14 )
      {
        if ( !strcmp((const char *)v13[2], s2) )
          return v13[3];
      }
      else
      {
        if ( v10 )
        {
          if ( v14 >= v8 )
          {
            if ( v14 % v8 != v11 )
              return 0LL;
            goto LABEL_19;
          }
        }
        else
        {
          v14 &= v9;
        }
        if ( v14 != v11 )
          return 0LL;
      }
LABEL_19:
      v13 = (__int64 **)*v13;
    }
    while ( v13 );
  }
  return 0LL;
}

//----- (000000000000B088) ----------------------------------------------------
__int64 __fastcall xinyoudi::ApkUtils::addFileRef(xinyoudi::ApkUtils *this, const char *s, xinyoudi::FileRef *a3)
{
  unsigned __int64 v3; // x26
  size_t v7; // x0
  char *v8; // x22
  unsigned __int8 v9; // w9
  int v10; // w8
  unsigned __int8 *v11; // x10
  int v12; // t1
  unsigned __int64 v13; // x25
  unsigned __int64 v14; // x24
  __int64 *v15; // x20
  unsigned __int64 v16; // x23
  __int64 v17; // x27
  __int64 **v18; // x28
  unsigned __int64 v19; // x8
  __int64 result; // x0
  __int64 v21; // x23
  float v22; // s0
  float v23; // s1
  _BOOL8 v24; // x9
  unsigned __int64 v25; // x8
  unsigned __int64 v26; // x9
  std::__ndk1 *v27; // x1
  __int64 v28; // x9
  __int64 *v29; // x8
  unsigned __int64 v30; // x8

  v7 = strlen(s);
  v8 = (char *)malloc(v7 + 1);
  strcpy(v8, s);
  v9 = *v8;
  if ( *v8 )
  {
    v10 = 0;
    v11 = (unsigned __int8 *)(v8 + 1);
    do
    {
      v10 = 131 * v10 + v9;
      v12 = *v11++;
      v9 = v12;
    }
    while ( v12 );
    v13 = v10 & 0x7FFFFFFF;
  }
  else
  {
    v13 = 0LL;
  }
  v14 = *((_QWORD *)this + 2);
  v15 = (__int64 *)((char *)this + 8);
  if ( v14 )
  {
    v16 = v14 - 1;
    v17 = (v14 - 1) & v14;
    if ( v17 )
    {
      v3 = v13;
      if ( v13 >= v14 )
        v3 = v13 % v14;
    }
    else
    {
      v3 = v16 & v13;
    }
    v18 = *(__int64 ***)(*v15 + 8 * v3);
    if ( v18 )
    {
      while ( 1 )
      {
        v18 = (__int64 **)*v18;
        if ( !v18 )
          break;
        v19 = (unsigned __int64)v18[1];
        if ( v19 != v13 )
        {
          if ( !v17 )
          {
            v19 &= v16;
LABEL_20:
            if ( v19 != v3 )
              break;
            goto LABEL_21;
          }
          if ( v19 < v14 )
            goto LABEL_20;
          if ( v19 % v14 != v3 )
            break;
        }
LABEL_21:
        result = strcmp((const char *)v18[2], v8);
        if ( !(_DWORD)result )
          return result;
      }
    }
  }
  result = operator new(0x20uLL);
  v21 = result;
  *(_QWORD *)(result + 16) = v8;
  *(_QWORD *)(result + 24) = a3;
  *(_QWORD *)result = 0LL;
  *(_QWORD *)(result + 8) = v13;
  v22 = *((float *)this + 10);
  v23 = (float)(unsigned __int64)(*((_QWORD *)this + 4) + 1LL);
  if ( !v14 || (float)(v22 * (float)v14) < v23 )
  {
    v24 = v14 < 3 || ((v14 - 1) & v14) != 0;
    v25 = v24 | (2 * v14);
    v26 = vcvtps_u32_f32(v23 / v22);
    if ( v25 >= v26 )
      v27 = (std::__ndk1 *)v25;
    else
      v27 = (std::__ndk1 *)v26;
    result = std::__hash_table<std::__hash_value_type<char const*,xinyoudi::FileRef *>,std::__unordered_map_hasher<char const*,std::__hash_value_type<char const*,xinyoudi::FileRef *>,hash_func,true>,std::__unordered_map_equal<char const*,std::__hash_value_type<char const*,xinyoudi::FileRef *>,cmp,true>,std::allocator<std::__hash_value_type<char const*,xinyoudi::FileRef *>>>::rehash(
               (int)this + 8,
               v27);
    v14 = *((_QWORD *)this + 2);
    if ( ((v14 - 1) & v14) != 0 )
    {
      if ( v13 >= v14 )
        v3 = v13 % v14;
      else
        v3 = v13;
    }
    else
    {
      v3 = (v14 - 1) & v13;
    }
  }
  v28 = *v15;
  v29 = *(__int64 **)(*v15 + 8 * v3);
  if ( v29 )
  {
    *(_QWORD *)v21 = *v29;
LABEL_44:
    *v29 = v21;
    goto LABEL_45;
  }
  *(_QWORD *)v21 = *((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v21;
  *(_QWORD *)(v28 + 8 * v3) = (char *)this + 24;
  if ( *(_QWORD *)v21 )
  {
    v30 = *(_QWORD *)(*(_QWORD *)v21 + 8LL);
    if ( ((v14 - 1) & v14) != 0 )
    {
      if ( v30 >= v14 )
        v30 %= v14;
    }
    else
    {
      v30 &= v14 - 1;
    }
    v29 = (__int64 *)(*v15 + 8 * v30);
    goto LABEL_44;
  }
LABEL_45:
  ++*((_QWORD *)this + 4);
  return result;
}
// B23C: variable 'v3' is possibly undefined

//----- (000000000000B2C8) ----------------------------------------------------
__int64 __fastcall xinyoudi::ApkUtils::checkFileExist(xinyoudi::ApkUtils *this, const char *a2, bool a3)
{
  __int64 v4; // x20
  xinyoudi::LuaFileUtils *v5; // x21

  if ( !xinyoudi::ApkUtils::_apkUtils )
  {
    v4 = operator new(0x38uLL);
    *(_OWORD *)(v4 + 24) = 0u;
    *(_OWORD *)(v4 + 8) = 0u;
    *(_QWORD *)v4 = off_69E88B0;
    *(_DWORD *)(v4 + 40) = 1065353216;
    v5 = (xinyoudi::LuaFileUtils *)operator new(0x30uLL);
    xinyoudi::LuaFileUtils::LuaFileUtils(v5);
    *(_QWORD *)(v4 + 48) = v5;
    xinyoudi::LuaFileUtils::start(v5);
    xinyoudi::ApkUtils::_apkUtils = v4;
  }
  return xinyoudi::ApkUtils::isFileExist(this, 0LL, a3);
}
// B350: variable 'a3' is possibly undefined
// 69E88B0: using guessed type void (__fastcall *[2])(xinyoudi::ApkUtils *__hidden this);
// 69EA030: using guessed type __int64 xinyoudi::ApkUtils::_apkUtils;

//----- (000000000000B354) ----------------------------------------------------
xinyoudi::FileRef *__fastcall xinyoudi::ApkUtils::getFileSize(xinyoudi::ApkUtils *this, const char *a2, bool a3)
{
  __int64 v4; // x20
  xinyoudi::LuaFileUtils *v5; // x21
  xinyoudi::FileRef *result; // x0
  __int64 v7; // x20
  xinyoudi::LuaFileUtils *v8; // x21
  __int64 v9; // x20
  xinyoudi::LuaFileUtils *v10; // x21

  v4 = xinyoudi::ApkUtils::_apkUtils;
  if ( ((unsigned __int8)a2 & 1) != 0 )
  {
    if ( !xinyoudi::ApkUtils::_apkUtils )
    {
      v4 = operator new(0x38uLL);
      *(_OWORD *)(v4 + 24) = 0u;
      *(_OWORD *)(v4 + 8) = 0u;
      *(_QWORD *)v4 = off_69E88B0;
      *(_DWORD *)(v4 + 40) = 1065353216;
      v5 = (xinyoudi::LuaFileUtils *)operator new(0x30uLL);
      xinyoudi::LuaFileUtils::LuaFileUtils(v5);
      *(_QWORD *)(v4 + 48) = v5;
      xinyoudi::LuaFileUtils::start(v5);
      xinyoudi::ApkUtils::_apkUtils = v4;
    }
    return (xinyoudi::FileRef *)xinyoudi::LuaFileUtils::getFileSize(
                                  *(xinyoudi::LuaFileUtils **)(v4 + 48),
                                  (const char *)this);
  }
  else
  {
    if ( !xinyoudi::ApkUtils::_apkUtils )
    {
      v7 = operator new(0x38uLL);
      *(_OWORD *)(v7 + 24) = 0u;
      *(_OWORD *)(v7 + 8) = 0u;
      *(_QWORD *)v7 = off_69E88B0;
      *(_DWORD *)(v7 + 40) = 1065353216;
      v8 = (xinyoudi::LuaFileUtils *)operator new(0x30uLL);
      xinyoudi::LuaFileUtils::LuaFileUtils(v8);
      *(_QWORD *)(v7 + 48) = v8;
      xinyoudi::LuaFileUtils::start(v8);
      xinyoudi::ApkUtils::_apkUtils = v7;
    }
    xinyoudi::ApkUtils::isFileExist(this, 0LL, a3);
    v9 = xinyoudi::ApkUtils::_apkUtils;
    if ( !xinyoudi::ApkUtils::_apkUtils )
    {
      v9 = operator new(0x38uLL);
      *(_OWORD *)(v9 + 24) = 0u;
      *(_OWORD *)(v9 + 8) = 0u;
      *(_QWORD *)v9 = off_69E88B0;
      *(_DWORD *)(v9 + 40) = 1065353216;
      v10 = (xinyoudi::LuaFileUtils *)operator new(0x30uLL);
      xinyoudi::LuaFileUtils::LuaFileUtils(v10);
      *(_QWORD *)(v9 + 48) = v10;
      xinyoudi::LuaFileUtils::start(v10);
      xinyoudi::ApkUtils::_apkUtils = v9;
    }
    result = (xinyoudi::FileRef *)xinyoudi::ApkUtils::getFileRef((xinyoudi::ApkUtils *)v9, (const char *)this);
    if ( result )
      return (xinyoudi::FileRef *)xinyoudi::FileRef::getSize(result);
  }
  return result;
}
// B440: variable 'a3' is possibly undefined
// 69E88B0: using guessed type void (__fastcall *[2])(xinyoudi::ApkUtils *__hidden this);
// 69EA030: using guessed type __int64 xinyoudi::ApkUtils::_apkUtils;

//----- (000000000000B4CC) ----------------------------------------------------
void __fastcall xinyoudi::ApkUtils::getFileContent(xinyoudi::ApkUtils *this, char *a2, unsigned __int8 *a3)
{
  __int64 v5; // x21
  xinyoudi::LuaFileUtils *v6; // x22
  unsigned int FileSize; // w21
  AAsset *v8; // x0
  AAsset *v9; // x22
  int v10; // w20

  if ( ((unsigned __int8)a3 & 1) != 0 )
  {
    v5 = xinyoudi::ApkUtils::_apkUtils;
    if ( !xinyoudi::ApkUtils::_apkUtils )
    {
      v5 = operator new(0x38uLL);
      *(_OWORD *)(v5 + 24) = 0u;
      *(_OWORD *)(v5 + 8) = 0u;
      *(_QWORD *)v5 = off_69E88B0;
      *(_DWORD *)(v5 + 40) = 1065353216;
      v6 = (xinyoudi::LuaFileUtils *)operator new(0x30uLL);
      xinyoudi::LuaFileUtils::LuaFileUtils(v6);
      *(_QWORD *)(v5 + 48) = v6;
      xinyoudi::LuaFileUtils::start(v6);
      xinyoudi::ApkUtils::_apkUtils = v5;
    }
    xinyoudi::LuaFileUtils::getFileContent(
      *(xinyoudi::LuaFileUtils **)(v5 + 48),
      (const char *)this,
      (unsigned __int8 *)a2);
  }
  else if ( xinyoudi::ApkUtils::_assetManager )
  {
    FileSize = xinyoudi::ApkUtils::getFileSize(this, 0LL, (bool)a3);
    v8 = AAssetManager_open((AAssetManager *)xinyoudi::ApkUtils::_assetManager, (const char *)this, 0);
    v9 = v8;
    if ( v8 )
    {
      v10 = AAsset_read(v8, a2, FileSize);
      if ( v10 != FileSize )
      {
        if ( a2 )
          operator delete[](a2);
        __android_log_print(6, "ApkUtils-Unity", "ReadSize: %d is equal to size: %d!", v10, FileSize);
      }
      AAsset_close(v9);
    }
    else
    {
      __android_log_print(6, "ApkUtils-Unity", "Asset %s is nullptr in getFileContent!");
    }
  }
  else
  {
    __android_log_print(6, "ApkUtils-Unity", "AssetManager is nullptr in getFileContent!");
  }
}
// 69E88B0: using guessed type void (__fastcall *[2])(xinyoudi::ApkUtils *__hidden this);
// 69EA030: using guessed type __int64 xinyoudi::ApkUtils::_apkUtils;
// 69EA038: using guessed type __int64 xinyoudi::ApkUtils::_assetManager;

//----- (000000000000B65C) ----------------------------------------------------
__int64 __fastcall xinyoudi::ApkUtils::ApkUtils(xinyoudi::ApkUtils *this)
{
  xinyoudi::LuaFileUtils *v2; // x20

  *((_QWORD *)this + 3) = 0LL;
  *((_QWORD *)this + 4) = 0LL;
  *((_QWORD *)this + 1) = 0LL;
  *((_QWORD *)this + 2) = 0LL;
  *(_QWORD *)this = off_69E88B0;
  *((_DWORD *)this + 10) = 1065353216;
  v2 = (xinyoudi::LuaFileUtils *)operator new(0x30uLL);
  xinyoudi::LuaFileUtils::LuaFileUtils(v2);
  *((_QWORD *)this + 6) = v2;
  return xinyoudi::LuaFileUtils::start(v2);
}
// 69E88B0: using guessed type void (__fastcall *[2])(xinyoudi::ApkUtils *__hidden this);

//----- (000000000000B6B0) ----------------------------------------------------
void __fastcall xinyoudi::ApkUtils::~ApkUtils(xinyoudi::ApkUtils *this)
{
  __int64 v2; // x0
  _QWORD *v3; // x0
  _QWORD *v4; // x20
  void *v5; // x0

  v2 = *((_QWORD *)this + 6);
  *(_QWORD *)this = off_69E88B0;
  if ( v2 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v2 + 8LL))(v2);
  v3 = (_QWORD *)*((_QWORD *)this + 3);
  if ( v3 )
  {
    do
    {
      v4 = (_QWORD *)*v3;
      operator delete(v3);
      v3 = v4;
    }
    while ( v4 );
  }
  v5 = (void *)*((_QWORD *)this + 1);
  *((_QWORD *)this + 1) = 0LL;
  if ( v5 )
    operator delete(v5);
}
// 69E88B0: using guessed type void (__fastcall *[2])(xinyoudi::ApkUtils *__hidden this);

//----- (000000000000B720) ----------------------------------------------------
void __fastcall xinyoudi::ApkUtils::~ApkUtils(xinyoudi::ApkUtils *this)
{
  __int64 v2; // x0
  _QWORD *v3; // x0
  _QWORD *v4; // x20
  void *v5; // x0

  v2 = *((_QWORD *)this + 6);
  *(_QWORD *)this = off_69E88B0;
  if ( v2 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v2 + 8LL))(v2);
  v3 = (_QWORD *)*((_QWORD *)this + 3);
  if ( v3 )
  {
    do
    {
      v4 = (_QWORD *)*v3;
      operator delete(v3);
      v3 = v4;
    }
    while ( v4 );
  }
  v5 = (void *)*((_QWORD *)this + 1);
  *((_QWORD *)this + 1) = 0LL;
  if ( v5 )
    operator delete(v5);
  operator delete(this);
}
// 69E88B0: using guessed type void (__fastcall *[2])(xinyoudi::ApkUtils *__hidden this);

//----- (000000000000B78C) ----------------------------------------------------
std::__ndk1 *__fastcall std::__hash_table<std::__hash_value_type<char const*,xinyoudi::FileRef *>,std::__unordered_map_hasher<char const*,std::__hash_value_type<char const*,xinyoudi::FileRef *>,hash_func,true>,std::__unordered_map_equal<char const*,std::__hash_value_type<char const*,xinyoudi::FileRef *>,cmp,true>,std::allocator<std::__hash_value_type<char const*,xinyoudi::FileRef *>>>::rehash(
        std::__ndk1 *result,
        std::__ndk1 *this)
{
  std::__ndk1 *v2; // x20
  std::__ndk1 *v3; // x19
  unsigned __int64 v4; // x21
  _BOOL4 v5; // w8
  std::__ndk1 *v6; // x1

  v2 = this;
  v3 = result;
  if ( this == (std::__ndk1 *)((char *)&dword_0 + 1) )
  {
    v2 = (std::__ndk1 *)(&dword_0 + 2);
  }
  else if ( (((unsigned __int64)this - 1) & (unsigned __int64)this) != 0 )
  {
    result = (std::__ndk1 *)std::__next_prime(this, (unsigned __int64)this);
    v2 = result;
  }
  v4 = *((_QWORD *)v3 + 1);
  if ( (unsigned __int64)v2 > v4 )
    return (std::__ndk1 *)std::__hash_table<std::__hash_value_type<char const*,xinyoudi::FileRef *>,std::__unordered_map_hasher<char const*,std::__hash_value_type<char const*,xinyoudi::FileRef *>,hash_func,true>,std::__unordered_map_equal<char const*,std::__hash_value_type<char const*,xinyoudi::FileRef *>,cmp,true>,std::allocator<std::__hash_value_type<char const*,xinyoudi::FileRef *>>>::__rehash();
  if ( (unsigned __int64)v2 < v4 )
  {
    v5 = v4 >= 3 && ((v4 - 1) & v4) == 0;
    result = (std::__ndk1 *)vcvtps_u32_f32((float)*((unsigned __int64 *)v3 + 3) / *((float *)v3 + 8));
    if ( v5 )
    {
      if ( (unsigned __int64)result >= 2 )
        result = (std::__ndk1 *)(1LL << (64 - (unsigned __int8)__clz((unsigned __int64)result - 1)));
    }
    else
    {
      result = (std::__ndk1 *)std::__next_prime(result, (unsigned __int64)this);
    }
    v6 = v2 >= result ? v2 : result;
    if ( (unsigned __int64)v6 < v4 )
      return (std::__ndk1 *)std::__hash_table<std::__hash_value_type<char const*,xinyoudi::FileRef *>,std::__unordered_map_hasher<char const*,std::__hash_value_type<char const*,xinyoudi::FileRef *>,hash_func,true>,std::__unordered_map_equal<char const*,std::__hash_value_type<char const*,xinyoudi::FileRef *>,cmp,true>,std::allocator<std::__hash_value_type<char const*,xinyoudi::FileRef *>>>::__rehash();
  }
  return result;
}
// B848: variable 'this' is possibly undefined
// 0: using guessed type int dword_0;

//----- (000000000000B874) ----------------------------------------------------
void __fastcall std::__hash_table<std::__hash_value_type<char const*,xinyoudi::FileRef *>,std::__unordered_map_hasher<char const*,std::__hash_value_type<char const*,xinyoudi::FileRef *>,hash_func,true>,std::__unordered_map_equal<char const*,std::__hash_value_type<char const*,xinyoudi::FileRef *>,cmp,true>,std::allocator<std::__hash_value_type<char const*,xinyoudi::FileRef *>>>::__rehash(
        __int64 a1,
        unsigned __int64 a2)
{
  __int64 v4; // x0
  void *v5; // x8
  __int64 v6; // x8
  __int64 **v7; // x21
  unsigned __int64 v8; // x24
  __int64 v9; // x23
  void *v10; // x0
  __int64 *v11; // x8
  unsigned __int64 v12; // x25
  __int64 **v13; // x26
  __int64 **v14; // x27
  __int64 **v15; // x28
  __int64 **v16; // x22

  if ( a2 )
  {
    if ( a2 >> 61 )
      abort();
    v4 = operator new(8 * a2);
    v5 = *(void **)a1;
    *(_QWORD *)a1 = v4;
    if ( v5 )
      operator delete(v5);
    v6 = 0LL;
    *(_QWORD *)(a1 + 8) = a2;
    do
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v6++) = 0LL;
    while ( a2 != v6 );
    v7 = *(__int64 ***)(a1 + 16);
    if ( !v7 )
      return;
    v8 = (unsigned __int64)v7[1];
    v9 = (a2 - 1) & a2;
    if ( v9 )
    {
      if ( v8 >= a2 )
        v8 %= a2;
    }
    else
    {
      v8 &= a2 - 1;
    }
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v8) = a1 + 16;
    v11 = *v7;
    if ( !*v7 )
      return;
LABEL_18:
    v12 = v8;
    v13 = v7;
LABEL_19:
    v14 = v7;
    v7 = (__int64 **)v11;
    while ( 1 )
    {
      v8 = (unsigned __int64)v7[1];
      if ( v9 )
      {
        if ( v8 >= a2 )
        {
          v8 %= a2;
          if ( v8 == v12 )
            goto LABEL_31;
          goto LABEL_26;
        }
      }
      else
      {
        v8 &= a2 - 1;
      }
      if ( v8 == v12 )
      {
LABEL_31:
        v11 = *v7;
        v13 = v7;
        if ( !*v7 )
          return;
        goto LABEL_19;
      }
LABEL_26:
      v15 = v7;
      if ( !*(_QWORD *)(*(_QWORD *)a1 + 8 * v8) )
      {
        *(_QWORD *)(*(_QWORD *)a1 + 8 * v8) = v14;
        v11 = *v7;
        if ( !*v7 )
          return;
        goto LABEL_18;
      }
      do
      {
        v16 = v15;
        v15 = (__int64 **)*v15;
      }
      while ( v15 && !strcmp((const char *)v7[2], (const char *)v15[2]) );
      *v14 = (__int64 *)v15;
      *v16 = **(__int64 ***)(*(_QWORD *)a1 + 8 * v8);
      **(_QWORD **)(*(_QWORD *)a1 + 8 * v8) = v7;
      v7 = (__int64 **)*v13;
      if ( !*v13 )
        return;
    }
  }
  v10 = *(void **)a1;
  *(_QWORD *)a1 = 0LL;
  if ( v10 )
    operator delete(v10);
  *(_QWORD *)(a1 + 8) = 0LL;
}

//----- (000000000000BA20) ----------------------------------------------------
__int64 __fastcall xinyoudi::FileRef::FileRef(__int64 this, char a2, int a3)
{
  *(_BYTE *)(this + 8) = a2 & 1;
  *(_DWORD *)(this + 12) = a3;
  *(_QWORD *)this = off_69E88D0;
  return this;
}
// 69E88D0: using guessed type void (__fastcall *[2])(xinyoudi::FileRef *__hidden this);

//----- (000000000000BA48) ----------------------------------------------------
__int64 __fastcall xinyoudi::FileRef::isExist(xinyoudi::FileRef *this)
{
  return *((unsigned __int8 *)this + 8);
}

//----- (000000000000BA50) ----------------------------------------------------
__int64 __fastcall xinyoudi::FileRef::getSize(xinyoudi::FileRef *this)
{
  return *((unsigned int *)this + 3);
}

//----- (000000000000BA58) ----------------------------------------------------
__int64 __fastcall Java_com_xyd_utils_ApkUtils_initialize(JNIEnv *a1, int a2, jobject assetManager)
{
  AAssetManager *v3; // x1
  AAssetManager *v4; // x19

  v4 = AAssetManager_fromJava(a1, assetManager);
  if ( !v4 )
    __android_log_print(6, "ApkUtils-Unity", "AssetManager is nullptr in initialize!");
  return xinyoudi::ApkUtils::setAssetManager(v4, v3);
}
// BA98: variable 'v3' is possibly undefined

//----- (000000000000BAA4) ----------------------------------------------------
__int64 __fastcall DllAUIsFileExist(xinyoudi::ApkUtils *a1, char a2, bool a3)
{
  return xinyoudi::ApkUtils::isFileExist(a1, (const char *)(a2 & 1), a3);
}

//----- (000000000000BAAC) ----------------------------------------------------
__int64 __fastcall DllAUGetFileSize(xinyoudi::ApkUtils *a1, char a2, bool a3)
{
  return xinyoudi::ApkUtils::getFileSize(a1, (const char *)(a2 & 1), a3);
}

//----- (000000000000BAB4) ----------------------------------------------------
__int64 __fastcall DllAUGetFileContent(xinyoudi::ApkUtils *a1, const char *a2, char a3, bool a4)
{
  return xinyoudi::ApkUtils::getFileContent(a1, a2, (unsigned __int8 *)(a3 & 1), a4);
}

//----- (000000000000BABC) ----------------------------------------------------
#error "BABC: too big function (funcsize=0)"

//----- (000000000008C2F0) ----------------------------------------------------
__int64 __fastcall std::unordered_map<std::string,std::basic_string<unsigned char>>::operator[](
        float *a1,
        unsigned __int8 *a2)
{
  unsigned __int64 v2; // x27
  unsigned __int64 v5; // x0
  unsigned __int64 v6; // x26
  unsigned __int64 v7; // x21
  unsigned __int64 v8; // x28
  __int64 v9; // x25
  __int64 *v10; // x8
  __int64 v11; // x20
  unsigned __int64 v12; // x8
  size_t v13; // x23
  unsigned __int8 *v14; // x24
  unsigned __int64 v15; // x8
  unsigned __int64 v16; // x10
  unsigned __int64 v17; // x11
  const void *v18; // x0
  __int64 v19; // x9
  float v20; // s0
  float v21; // s1
  _BOOL8 v22; // x9
  unsigned __int64 v23; // x8
  unsigned __int64 v24; // x9
  std::__ndk1 *v25; // x1
  __int64 v26; // x9
  __int64 *v27; // x8
  unsigned __int64 v28; // x8

  _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v5 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()();
  v6 = *((_QWORD *)a1 + 1);
  v7 = v5;
  if ( v6 )
  {
    v8 = v6 - 1;
    v9 = (v6 - 1) & v6;
    if ( v9 )
    {
      v2 = v5;
      if ( v5 >= v6 )
        v2 = v5 % v6;
    }
    else
    {
      v2 = v8 & v5;
    }
    v10 = *(__int64 **)(*(_QWORD *)a1 + 8 * v2);
    if ( v10 )
    {
      v11 = *v10;
      if ( *v10 )
      {
        v12 = *a2;
        if ( (v12 & 1) != 0 )
          v13 = *((_QWORD *)a2 + 1);
        else
          v13 = v12 >> 1;
        if ( (v12 & 1) != 0 )
          v14 = (unsigned __int8 *)*((_QWORD *)a2 + 2);
        else
          v14 = a2 + 1;
        do
        {
          v15 = *(_QWORD *)(v11 + 8);
          if ( v15 == v7 )
            goto LABEL_22;
          if ( v9 )
          {
            if ( v15 >= v6 )
            {
              if ( v15 % v6 != v2 )
                break;
              goto LABEL_22;
            }
          }
          else
          {
            v15 &= v8;
          }
          if ( v15 != v2 )
            break;
LABEL_22:
          v16 = *(unsigned __int8 *)(v11 + 16);
          v17 = *(_QWORD *)(v11 + 24);
          if ( (v16 & 1) == 0 )
            v17 = v16 >> 1;
          if ( v17 == v13 )
          {
            if ( (v16 & 1) != 0 )
              v18 = *(const void **)(v11 + 32);
            else
              v18 = (const void *)(v11 + 17);
            if ( (v16 & 1) != 0 )
            {
              if ( !v13 || !memcmp(v18, v14, v13) )
                return v11 + 40;
            }
            else
            {
              if ( !v13 )
                return v11 + 40;
              v19 = 0LL;
              while ( *(unsigned __int8 *)(v11 + v19 + 17) == v14[v19] )
              {
                if ( v16 >> 1 == ++v19 )
                  return v11 + 40;
              }
            }
          }
          v11 = *(_QWORD *)v11;
        }
        while ( v11 );
      }
    }
  }
  v11 = operator new(0x40uLL);
  *(_QWORD *)(v11 + 32) = *((_QWORD *)a2 + 2);
  *(_QWORD *)(v11 + 40) = 0LL;
  *(_OWORD *)(v11 + 16) = *(_OWORD *)a2;
  *((_QWORD *)a2 + 1) = 0LL;
  *((_QWORD *)a2 + 2) = 0LL;
  *(_QWORD *)a2 = 0LL;
  *(_QWORD *)(v11 + 48) = 0LL;
  *(_QWORD *)(v11 + 56) = 0LL;
  *(_QWORD *)v11 = 0LL;
  *(_QWORD *)(v11 + 8) = v7;
  v20 = a1[8];
  v21 = (float)(unsigned __int64)(*((_QWORD *)a1 + 3) + 1LL);
  if ( !v6 || (float)(v20 * (float)v6) < v21 )
  {
    v22 = v6 < 3 || ((v6 - 1) & v6) != 0;
    v23 = v22 | (2 * v6);
    v24 = vcvtps_u32_f32(v21 / v20);
    if ( v23 >= v24 )
      v25 = (std::__ndk1 *)v23;
    else
      v25 = (std::__ndk1 *)v24;
    std::__hash_table<std::__hash_value_type<std::string,std::basic_string<unsigned char>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::basic_string<unsigned char>>,std::hash<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::basic_string<unsigned char>>,std::equal_to<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::basic_string<unsigned char>>>>::rehash(
      (int)a1,
      v25);
    v6 = *((_QWORD *)a1 + 1);
    if ( ((v6 - 1) & v6) != 0 )
    {
      if ( v7 >= v6 )
        v2 = v7 % v6;
      else
        v2 = v7;
    }
    else
    {
      v2 = (v6 - 1) & v7;
    }
  }
  v26 = *(_QWORD *)a1;
  v27 = *(__int64 **)(*(_QWORD *)a1 + 8 * v2);
  if ( v27 )
  {
    *(_QWORD *)v11 = *v27;
LABEL_59:
    *v27 = v11;
    goto LABEL_60;
  }
  *(_QWORD *)v11 = *((_QWORD *)a1 + 2);
  *((_QWORD *)a1 + 2) = v11;
  *(_QWORD *)(v26 + 8 * v2) = a1 + 4;
  if ( *(_QWORD *)v11 )
  {
    v28 = *(_QWORD *)(*(_QWORD *)v11 + 8LL);
    if ( ((v6 - 1) & v6) != 0 )
    {
      if ( v28 >= v6 )
        v28 %= v6;
    }
    else
    {
      v28 &= v6 - 1;
    }
    v27 = (__int64 *)(*(_QWORD *)a1 + 8 * v28);
    goto LABEL_59;
  }
LABEL_60:
  ++*((_QWORD *)a1 + 3);
  return v11 + 40;
}
// 8C52C: variable 'v2' is possibly undefined

//----- (000000000008C5D4) ----------------------------------------------------
__int64 __fastcall xinyoudi::LuaFileUtils::LuaFileUtils(__int64 this)
{
  *(_QWORD *)(this + 24) = 0LL;
  *(_QWORD *)(this + 32) = 0LL;
  *(_QWORD *)(this + 8) = 0LL;
  *(_QWORD *)(this + 16) = 0LL;
  *(_QWORD *)this = off_69E88F0;
  *(_DWORD *)(this + 40) = 1065353216;
  return this;
}
// 69E88F0: using guessed type void (__fastcall *[2])(xinyoudi::LuaFileUtils *__hidden this);

//----- (000000000008C5F8) ----------------------------------------------------
void __fastcall xinyoudi::LuaFileUtils::~LuaFileUtils(xinyoudi::LuaFileUtils *this)
{
  __int64 v2; // x8
  void **v3; // x20
  void **v4; // x21
  __int64 v5; // x8
  __int64 i; // x9
  void **v7; // x20
  void **v8; // x21
  void *v9; // x0

  v2 = *((_QWORD *)this + 4);
  *(_QWORD *)this = off_69E88F0;
  if ( v2 )
  {
    v3 = (void **)*((_QWORD *)this + 3);
    if ( v3 )
    {
      do
      {
        v4 = (void **)*v3;
        if ( ((_BYTE)v3[5] & 1) != 0 )
          operator delete(v3[7]);
        if ( ((_BYTE)v3[2] & 1) != 0 )
          operator delete(v3[4]);
        operator delete(v3);
        v3 = v4;
      }
      while ( v4 );
    }
    v5 = *((_QWORD *)this + 2);
    *((_QWORD *)this + 3) = 0LL;
    if ( v5 )
    {
      for ( i = 0LL; i != v5; ++i )
        *(_QWORD *)(*((_QWORD *)this + 1) + 8 * i) = 0LL;
    }
    *((_QWORD *)this + 4) = 0LL;
  }
  v7 = (void **)*((_QWORD *)this + 3);
  if ( v7 )
  {
    do
    {
      v8 = (void **)*v7;
      if ( ((_BYTE)v7[5] & 1) != 0 )
        operator delete(v7[7]);
      if ( ((_BYTE)v7[2] & 1) != 0 )
        operator delete(v7[4]);
      operator delete(v7);
      v7 = v8;
    }
    while ( v8 );
  }
  v9 = (void *)*((_QWORD *)this + 1);
  *((_QWORD *)this + 1) = 0LL;
  if ( v9 )
    operator delete(v9);
}
// 69E88F0: using guessed type void (__fastcall *[2])(xinyoudi::LuaFileUtils *__hidden this);

//----- (000000000008C6F0) ----------------------------------------------------
void __fastcall xinyoudi::LuaFileUtils::clean(xinyoudi::LuaFileUtils *this)
{
  void **v2; // x20
  void **v3; // x21
  __int64 v4; // x8
  __int64 i; // x9

  if ( *((_QWORD *)this + 4) )
  {
    v2 = (void **)*((_QWORD *)this + 3);
    if ( v2 )
    {
      do
      {
        v3 = (void **)*v2;
        if ( ((_BYTE)v2[5] & 1) != 0 )
          operator delete(v2[7]);
        if ( ((_BYTE)v2[2] & 1) != 0 )
          operator delete(v2[4]);
        operator delete(v2);
        v2 = v3;
      }
      while ( v3 );
    }
    v4 = *((_QWORD *)this + 2);
    *((_QWORD *)this + 3) = 0LL;
    if ( v4 )
    {
      for ( i = 0LL; i != v4; ++i )
        *(_QWORD *)(*((_QWORD *)this + 1) + 8 * i) = 0LL;
    }
    *((_QWORD *)this + 4) = 0LL;
  }
}

//----- (000000000008C780) ----------------------------------------------------
void __fastcall xinyoudi::LuaFileUtils::~LuaFileUtils(xinyoudi::LuaFileUtils *this)
{
  xinyoudi::LuaFileUtils::~LuaFileUtils(this);
  operator delete(this);
}

//----- (000000000008C7A4) ----------------------------------------------------
bool __fastcall xinyoudi::LuaFileUtils::isFileExist(xinyoudi::LuaFileUtils *this, const char *s)
{
  size_t v3; // x0
  size_t v4; // x21
  char *v5; // x22
  unsigned __int64 v6; // x23
  __int64 v7; // x19
  __int64 v9; // [xsp+0h] [xbp-50h] BYREF
  size_t v10; // [xsp+8h] [xbp-48h]
  void *v11; // [xsp+10h] [xbp-40h]
  __int64 v12; // [xsp+18h] [xbp-38h]

  v12 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v10 = 0LL;
  v11 = 0LL;
  v9 = 0LL;
  v3 = strlen(s);
  v4 = v3;
  if ( v3 >= 0xFFFFFFFFFFFFFFF0LL )
    abort();
  if ( v3 >= 0x17 )
  {
    v6 = (v3 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v5 = (char *)operator new(v6);
    v10 = v4;
    v11 = v5;
    v9 = v6 | 1;
    goto LABEL_6;
  }
  v5 = (char *)&v9 + 1;
  LOBYTE(v9) = 2 * v3;
  if ( v3 )
LABEL_6:
    memcpy(v5, s, v4);
  v5[v4] = 0;
  v7 = std::__hash_table<std::__hash_value_type<std::string,std::basic_string<unsigned char>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::basic_string<unsigned char>>,std::hash<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::basic_string<unsigned char>>,std::equal_to<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::basic_string<unsigned char>>>>::find<std::string>();
  if ( (v9 & 1) != 0 )
    operator delete(v11);
  return v7 != 0;
}

//----- (000000000008C898) ----------------------------------------------------
void *__fastcall xinyoudi::LuaFileUtils::getFileContent(
        xinyoudi::LuaFileUtils *this,
        const char *s,
        unsigned __int8 *a3)
{
  size_t v5; // x0
  size_t v6; // x22
  char *v7; // x23
  unsigned __int64 v8; // x24
  __int64 v9; // x21
  unsigned __int64 v10; // x8
  const void *v11; // x1
  size_t v12; // x2
  __int64 v14; // [xsp+0h] [xbp-60h] BYREF
  size_t v15; // [xsp+8h] [xbp-58h]
  void *v16; // [xsp+10h] [xbp-50h]
  __int64 v17; // [xsp+18h] [xbp-48h]

  v17 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v15 = 0LL;
  v16 = 0LL;
  v14 = 0LL;
  v5 = strlen(s);
  v6 = v5;
  if ( v5 >= 0xFFFFFFFFFFFFFFF0LL )
    abort();
  if ( v5 >= 0x17 )
  {
    v8 = (v5 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v7 = (char *)operator new(v8);
    v15 = v6;
    v16 = v7;
    v14 = v8 | 1;
    goto LABEL_6;
  }
  v7 = (char *)&v14 + 1;
  LOBYTE(v14) = 2 * v5;
  if ( v5 )
LABEL_6:
    memcpy(v7, s, v6);
  v7[v6] = 0;
  v9 = std::__hash_table<std::__hash_value_type<std::string,std::basic_string<unsigned char>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::basic_string<unsigned char>>,std::hash<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::basic_string<unsigned char>>,std::equal_to<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::basic_string<unsigned char>>>>::find<std::string>();
  if ( (v14 & 1) != 0 )
    operator delete(v16);
  if ( !v9 )
    return (void *)__android_log_print(6, "ApkUtils-Unity", "LuaFileUtils::getFileContent: %s is null", s);
  v10 = *(unsigned __int8 *)(v9 + 40);
  if ( (v10 & 1) != 0 )
  {
    v12 = *(_QWORD *)(v9 + 48);
    v11 = *(const void **)(v9 + 56);
  }
  else
  {
    v11 = (const void *)(v9 + 41);
    v12 = v10 >> 1;
  }
  return memcpy(a3, v11, v12);
}

//----- (000000000008C9D8) ----------------------------------------------------
unsigned __int64 __fastcall xinyoudi::LuaFileUtils::getFileSize(xinyoudi::LuaFileUtils *this, const char *s)
{
  size_t v3; // x0
  size_t v4; // x21
  char *v5; // x22
  unsigned __int64 v6; // x23
  __int64 v7; // x20
  unsigned __int64 v8; // x8
  __int64 v10; // [xsp+0h] [xbp-50h] BYREF
  size_t v11; // [xsp+8h] [xbp-48h]
  void *v12; // [xsp+10h] [xbp-40h]
  __int64 v13; // [xsp+18h] [xbp-38h]

  v13 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v11 = 0LL;
  v12 = 0LL;
  v10 = 0LL;
  v3 = strlen(s);
  v4 = v3;
  if ( v3 >= 0xFFFFFFFFFFFFFFF0LL )
    abort();
  if ( v3 >= 0x17 )
  {
    v6 = (v3 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v5 = (char *)operator new(v6);
    v11 = v4;
    v12 = v5;
    v10 = v6 | 1;
    goto LABEL_6;
  }
  v5 = (char *)&v10 + 1;
  LOBYTE(v10) = 2 * v3;
  if ( v3 )
LABEL_6:
    memcpy(v5, s, v4);
  v5[v4] = 0;
  v7 = std::__hash_table<std::__hash_value_type<std::string,std::basic_string<unsigned char>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::basic_string<unsigned char>>,std::hash<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::basic_string<unsigned char>>,std::equal_to<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::basic_string<unsigned char>>>>::find<std::string>();
  if ( (v10 & 1) != 0 )
    operator delete(v12);
  if ( v7 )
  {
    v8 = *(unsigned __int8 *)(v7 + 40);
    if ( (v8 & 1) != 0 )
      return *(_QWORD *)(v7 + 48);
    else
      return v8 >> 1;
  }
  else
  {
    __android_log_print(6, "ApkUtils-Unity", "LuaFileUtils::getFileSize: %s is zero.", s);
    return 0LL;
  }
}

//----- (000000000008CB00) ----------------------------------------------------
__int64 __fastcall xinyoudi::LuaFileUtils::start(xinyoudi::LuaFileUtils *this)
{
  clock_t v2; // x20
  int v3; // w3

  v2 = clock();
  xinyoudi::LuaFileUtils::init(this);
  v3 = (int)((double)(clock() - v2) * 1000.0 / 1000000.0);
  return __android_log_print(
           6,
           "ApkUtils-Unity",
           "====================== LuaFileUtils::init cost: %d ms ======================",
           v3);
}

//----- (000000000008CB68) ----------------------------------------------------
std::__ndk1 *__fastcall std::__hash_table<std::__hash_value_type<std::string,std::basic_string<unsigned char>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::basic_string<unsigned char>>,std::hash<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::basic_string<unsigned char>>,std::equal_to<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::basic_string<unsigned char>>>>::rehash(
        std::__ndk1 *result,
        std::__ndk1 *this)
{
  std::__ndk1 *v2; // x20
  std::__ndk1 *v3; // x19
  unsigned __int64 v4; // x21
  _BOOL4 v5; // w8
  std::__ndk1 *v6; // x1

  v2 = this;
  v3 = result;
  if ( this == (std::__ndk1 *)((char *)&dword_0 + 1) )
  {
    v2 = (std::__ndk1 *)(&dword_0 + 2);
  }
  else if ( (((unsigned __int64)this - 1) & (unsigned __int64)this) != 0 )
  {
    result = (std::__ndk1 *)std::__next_prime(this, (unsigned __int64)this);
    v2 = result;
  }
  v4 = *((_QWORD *)v3 + 1);
  if ( (unsigned __int64)v2 > v4 )
    return (std::__ndk1 *)std::__hash_table<std::__hash_value_type<std::string,std::basic_string<unsigned char>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::basic_string<unsigned char>>,std::hash<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::basic_string<unsigned char>>,std::equal_to<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::basic_string<unsigned char>>>>::__rehash();
  if ( (unsigned __int64)v2 < v4 )
  {
    v5 = v4 >= 3 && ((v4 - 1) & v4) == 0;
    result = (std::__ndk1 *)vcvtps_u32_f32((float)*((unsigned __int64 *)v3 + 3) / *((float *)v3 + 8));
    if ( v5 )
    {
      if ( (unsigned __int64)result >= 2 )
        result = (std::__ndk1 *)(1LL << (64 - (unsigned __int8)__clz((unsigned __int64)result - 1)));
    }
    else
    {
      result = (std::__ndk1 *)std::__next_prime(result, (unsigned __int64)this);
    }
    v6 = v2 >= result ? v2 : result;
    if ( (unsigned __int64)v6 < v4 )
      return (std::__ndk1 *)std::__hash_table<std::__hash_value_type<std::string,std::basic_string<unsigned char>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::basic_string<unsigned char>>,std::hash<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::basic_string<unsigned char>>,std::equal_to<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::basic_string<unsigned char>>>>::__rehash();
  }
  return result;
}
// 8CC24: variable 'this' is possibly undefined
// 0: using guessed type int dword_0;

//----- (000000000008CC50) ----------------------------------------------------
__int64 __fastcall std::__murmur2_or_cityhash<unsigned long,64ul>::operator()(
        __int64 a1,
        __int64 *a2,
        unsigned __int64 a3)
{
  __int64 v4; // x15
  __int64 v5; // x8
  __int64 v6; // x9
  __int64 v7; // x13
  __int64 v8; // x16
  __int64 v9; // x17
  __int64 v10; // x8
  __int64 v11; // x14
  __int64 v12; // x18
  __int64 v13; // x12
  __int64 v14; // x13
  __int64 v15; // x9
  __int64 v16; // x15
  __int64 v17; // x17
  __int64 v18; // x8
  __int64 v19; // x15
  __int64 v20; // x9
  unsigned __int64 v21; // x9
  __int64 v22; // x13
  __int64 v23; // x14
  unsigned __int64 v24; // x9
  unsigned __int64 v25; // x12
  __int64 v26; // x13
  unsigned __int64 v27; // x9
  unsigned __int64 v28; // x10
  unsigned __int64 v29; // x9
  __int64 v30; // x11
  __int64 v31; // x13
  __int64 v32; // x16
  __int64 v33; // x14
  __int64 v34; // x18
  unsigned __int64 v35; // x12
  unsigned __int64 v36; // x15
  __int64 v37; // x0
  unsigned __int64 v38; // x10
  __int64 v39; // x16
  __int64 v40; // x17
  unsigned __int64 v41; // x2
  __int64 v42; // x14
  __int64 v43; // x18
  __int64 v44; // x11
  __int64 v45; // x14
  _QWORD *v46; // x1
  __int64 v47; // x17
  __int64 v48; // t1
  unsigned __int64 v49; // x0
  unsigned __int64 v50; // x12
  unsigned __int64 v51; // x4
  __int64 v52; // x14
  unsigned __int64 v53; // x16
  unsigned __int64 v54; // x18
  unsigned __int64 v55; // x15
  unsigned __int64 i; // x13
  unsigned __int64 v57; // x0
  __int64 v58; // x3
  __int64 v59; // x15
  unsigned __int64 v60; // x17
  __int64 v61; // t2
  __int64 v62; // x5
  __int64 v63; // x18
  unsigned __int64 v64; // x2
  __int64 v65; // t2
  __int64 v66; // x4
  __int64 v67; // x0
  __int64 v68; // x3
  __int64 v69; // x14
  __int64 v70; // x6
  __int64 v71; // x0
  __int64 v72; // x11
  unsigned __int64 v73; // x17
  __int64 v74; // x12
  unsigned __int64 v75; // x9
  unsigned __int64 v76; // x10
  unsigned __int64 v77; // x9

  if ( a3 > 0x20 )
  {
    if ( a3 <= 0x40 )
    {
      v4 = *(__int64 *)((char *)a2 + a3 - 16);
      v5 = a2[2];
      v6 = a2[3];
      v7 = *a2 - 0x3C5A37A36834CED9LL * (v4 + a3);
      v8 = *(__int64 *)((char *)a2 + a3 - 32) + v5;
      v9 = *(__int64 *)((char *)a2 + a3 - 8) + v6;
      v10 = v7 + a2[1] + v5;
      v11 = __ROR8__(v7 + a2[1], 7) + __ROR8__(v7, 37);
      v12 = v9 + v8;
      v13 = *(__int64 *)((char *)a2 + a3 - 24) + v8;
      v14 = __ROR8__(v7 + v6, 52);
      v15 = v10 + v6;
      v16 = v13 + v4;
      v17 = v16 + v9;
      v18 = v11 + v14 + __ROR8__(v10, 31);
      v19 = __ROR8__(v16, 31);
      v20 = v15 + __ROR8__(v8, 37) + __ROR8__(v13, 7) + __ROR8__(v12, 52);
      v21 = (0xC3A5C85C97CB3127LL * (v17 + v18) - 0x651E95C4D06FBFB1LL * (v20 + v19)) ^ ((0xC3A5C85C97CB3127LL
                                                                                        * (v17 + v18)
                                                                                        - 0x651E95C4D06FBFB1LL
                                                                                        * (v20 + v19)) >> 47);
      return 0x9AE16A3B2F90404FLL * ((v18 - 0x3C5A37A36834CED9LL * v21) ^ ((v18 - 0x3C5A37A36834CED9LL * v21) >> 47));
    }
    v30 = *(__int64 *)((char *)a2 + a3 - 48);
    v31 = *(__int64 *)((char *)a2 + a3 - 40);
    v32 = *(__int64 *)((char *)a2 + a3 - 56);
    v34 = *(__int64 *)((char *)a2 + a3 - 24);
    v33 = *(__int64 *)((char *)a2 + a3 - 16);
    v35 = a3 - 1;
    v36 = *(__int64 *)((char *)a2 + a3 - 64) + a3;
    v37 = *(__int64 *)((char *)a2 + a3 - 8);
    v38 = v32 + v33;
    v39 = v36 + v32 + v30;
    v40 = v38 - 0x4B6D499041670D8DLL + *(__int64 *)((char *)a2 + a3 - 32);
    v41 = (0x9DDFEA08EB382D69LL * (v34 ^ (v30 + a3))) ^ v34 ^ ((0x9DDFEA08EB382D69LL * (v34 ^ (v30 + a3))) >> 47);
    v42 = v40 + v34 + v33;
    v43 = v40 + v31 + v37;
    v44 = v42 + v37;
    v45 = __ROR8__(v42, 44) + v40;
    v48 = *a2;
    v46 = a2 + 4;
    v47 = v48;
    v49 = v35 & 0xFFFFFFFFFFFFFFC0LL;
    v50 = v45 + __ROR8__(v43, 21);
    v51 = __ROR8__(v39, 44) + v36;
    v52 = v39 + v31;
    v53 = v48 - 0x4B6D499041670D8DLL * v31;
    v54 = 0x9DDFEA08EB382D69LL * ((0x9DDFEA08EB382D69LL * v41) ^ ((0x9DDFEA08EB382D69LL * v41) >> 47));
    v55 = v51
        + __ROR8__(
            v31 + v36 - 0x622015F714C7D297LL * ((0x9DDFEA08EB382D69LL * v41) ^ ((0x9DDFEA08EB382D69LL * v41) >> 47)),
            21);
    for ( i = 64 - v49; ; i += 64LL )
    {
      v57 = v38 + v55;
      v58 = v46[1];
      v59 = v47 - 0x4B6D499041670D8DLL * v55;
      v60 = v53 + v52 + v38;
      v61 = __ROR8__(v54 + v44, 33);
      v63 = v46[2];
      v62 = v46[3];
      v53 = 0xB492B66FBE98F273LL * v61;
      v64 = 0xB492B66FBE98F273LL * v61 + v50 + *v46;
      v65 = __ROR8__(v57 + v63, 42);
      v66 = *(v46 - 1);
      v67 = v64 + v58;
      v38 = v58 + v52 - 0x4B6D499041670D8DLL * v65;
      v69 = *(v46 - 3);
      v68 = *(v46 - 2);
      v70 = v59 + v44 + v66;
      v71 = v67 + v63;
      v72 = v59 + v69 + v68;
      v73 = 0xB492B66FBE98F273LL * __ROR8__(v60 + v69, 37);
      v52 = v72 + v66;
      v54 = v73 ^ v50;
      v74 = __ROR8__(v72, 44) + v59;
      v44 = v71 + v62;
      v55 = v74 + __ROR8__(v70 + v54, 21);
      v50 = __ROR8__(v71, 44) + v64 + __ROR8__(v38 + v68 + v64 + v62, 21);
      if ( !i )
        break;
      v47 = v46[4];
      v46 += 8;
    }
    v75 = v54 - 0x4B6D499041670D8DLL * (v38 ^ (v38 >> 47));
    v76 = v53
        - 0x622015F714C7D297LL
        * ((0x9DDFEA08EB382D69LL
          * ((0x9DDFEA08EB382D69LL * (v50 ^ v55)) ^ v50 ^ ((0x9DDFEA08EB382D69LL * (v50 ^ v55)) >> 47))) ^ ((0x9DDFEA08EB382D69LL * ((0x9DDFEA08EB382D69LL * (v50 ^ v55)) ^ v50 ^ ((0x9DDFEA08EB382D69LL * (v50 ^ v55)) >> 47))) >> 47));
    v77 = 0x9DDFEA08EB382D69LL
        * (v76 ^ (v75
                - 0x622015F714C7D297LL
                * ((0x9DDFEA08EB382D69LL
                  * ((0x9DDFEA08EB382D69LL * (v44 ^ v52)) ^ v44 ^ ((0x9DDFEA08EB382D69LL * (v44 ^ v52)) >> 47))) ^ ((0x9DDFEA08EB382D69LL * ((0x9DDFEA08EB382D69LL * (v44 ^ v52)) ^ v44 ^ ((0x9DDFEA08EB382D69LL * (v44 ^ v52)) >> 47))) >> 47))));
    v29 = v77 ^ v76 ^ (v77 >> 47);
  }
  else
  {
    if ( a3 <= 0x10 )
      return std::__murmur2_or_cityhash<unsigned long,64ul>::__hash_len_0_to_16();
    v22 = a2[1];
    v23 = *(__int64 *)((char *)a2 + a3 - 8);
    v24 = 0xB492B66FBE98F273LL * *a2;
    v25 = v22 ^ 0xC949D7C7509E6557LL;
    v26 = __ROR8__(v24 - v22, 43);
    v27 = v24 + a3 - 0x9AE16A3B2F90404FLL * v23 + __ROR8__(v25, 20);
    v28 = 0x9DDFEA08EB382D69LL
        * ((v26
          - 0x3C5A37A36834CED9LL * *(__int64 *)((char *)a2 + a3 - 16)
          + ((0xBE41013C00000000LL * v23) | ((0x9AE16A3B2F90404FLL * v23) >> 30))) ^ v27);
    v29 = v28 ^ v27 ^ (v28 >> 47);
  }
  return 0x9DDFEA08EB382D69LL * ((0x9DDFEA08EB382D69LL * v29) ^ ((0x9DDFEA08EB382D69LL * v29) >> 47));
}

//----- (000000000008CF84) ----------------------------------------------------
unsigned __int64 __fastcall std::__murmur2_or_cityhash<unsigned long,64ul>::__hash_len_0_to_16(
        _DWORD *a1,
        unsigned __int64 a2)
{
  __int64 v3; // x8
  __int64 v4; // x11
  unsigned __int64 result; // x0
  __int64 v6; // x8
  unsigned __int64 v7; // x10
  unsigned __int64 v8; // x8

  if ( a2 < 9 )
  {
    if ( a2 < 4 )
    {
      result = 0x9AE16A3B2F90404FLL;
      if ( a2 )
      {
        v8 = (0xC949D7C7509E6557LL * ((unsigned int)a2 + 4 * *((unsigned __int8 *)a1 + a2 - 1))) ^ (0x9AE16A3B2F90404FLL
                                                                                                  * (*(unsigned __int8 *)a1 | ((unsigned __int64)*((unsigned __int8 *)a1 + (a2 >> 1)) << 8)));
        return 0x9AE16A3B2F90404FLL * (v8 ^ (v8 >> 47));
      }
    }
    else
    {
      v6 = *(unsigned int *)((char *)a1 + a2 - 4);
      v7 = 0x9DDFEA08EB382D69LL * (((unsigned int)(8 * *a1) + a2) ^ v6);
      return 0x9DDFEA08EB382D69LL
           * ((0x9DDFEA08EB382D69LL * (v7 ^ v6 ^ (v7 >> 47))) ^ ((0x9DDFEA08EB382D69LL * (v7 ^ v6 ^ (v7 >> 47))) >> 47));
    }
  }
  else
  {
    v3 = *(_QWORD *)((char *)a1 + a2 - 8);
    v4 = __ROR8__(v3 + a2, a2);
    return (0x9DDFEA08EB382D69LL
          * ((0x9DDFEA08EB382D69LL
            * ((0x9DDFEA08EB382D69LL * (v4 ^ *(_QWORD *)a1)) ^ v4 ^ ((0x9DDFEA08EB382D69LL * (v4 ^ *(_QWORD *)a1)) >> 47))) ^ ((0x9DDFEA08EB382D69LL * ((0x9DDFEA08EB382D69LL * (v4 ^ *(_QWORD *)a1)) ^ v4 ^ ((0x9DDFEA08EB382D69LL * (v4 ^ *(_QWORD *)a1)) >> 47))) >> 47))) ^ v3;
  }
  return result;
}

//----- (000000000008D080) ----------------------------------------------------
void __fastcall std::__hash_table<std::__hash_value_type<std::string,std::basic_string<unsigned char>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::basic_string<unsigned char>>,std::hash<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::basic_string<unsigned char>>,std::equal_to<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::basic_string<unsigned char>>>>::__rehash(
        void **a1,
        unsigned __int64 a2)
{
  void **v3; // x19
  __int64 v4; // x0
  void *v5; // x8
  char *v6; // x8
  void **v7; // x25
  unsigned __int64 v8; // x26
  unsigned __int64 v9; // x12
  void *v10; // x0
  void **v11; // x8
  void **v12; // x8
  void **v13; // x24
  unsigned __int64 v14; // x23
  void **v15; // x28
  size_t v16; // x21
  __int64 v17; // x13
  _QWORD *v18; // x8
  char v19; // w9
  unsigned int v20; // t1
  unsigned __int64 v21; // x10
  unsigned __int64 v22; // x11
  const void *v23; // x0
  unsigned __int8 *v24; // x1
  __int64 v25; // x8
  unsigned __int8 *v26; // x9
  unsigned __int64 v27; // x20
  __int64 v28; // x19
  int v29; // w0
  void **v30; // [xsp+8h] [xbp-78h]
  void **v31; // [xsp+10h] [xbp-70h]
  __int64 v32; // [xsp+18h] [xbp-68h]
  void **v33; // [xsp+20h] [xbp-60h]
  unsigned __int64 v34; // [xsp+28h] [xbp-58h]

  v3 = a1;
  if ( a2 )
  {
    if ( a2 >> 61 )
      abort();
    v4 = operator new(8 * a2);
    v5 = *v3;
    *v3 = (void *)v4;
    if ( v5 )
      operator delete(v5);
    v6 = 0LL;
    v3[1] = (void *)a2;
    do
      *((_QWORD *)*v3 + (_QWORD)v6++) = 0LL;
    while ( (char *)a2 != v6 );
    v7 = (void **)v3[2];
    if ( v7 )
    {
      v8 = (unsigned __int64)v7[1];
      v9 = a2 - 1;
      v32 = (a2 - 1) & a2;
      if ( v32 )
      {
        if ( v8 >= a2 )
          v8 %= a2;
      }
      else
      {
        v8 &= v9;
      }
      *((_QWORD *)*v3 + v8) = v3 + 2;
      v11 = (void **)*v7;
      if ( *v7 )
      {
        v30 = v3;
        while ( 2 )
        {
          v34 = v8;
          v31 = v7;
LABEL_18:
          v33 = v7;
          v7 = v11;
          while ( 1 )
          {
            v8 = (unsigned __int64)v7[1];
            if ( v32 )
            {
              if ( v8 >= a2 )
                v8 %= a2;
            }
            else
            {
              v8 &= v9;
            }
            if ( v8 == v34 )
            {
              v11 = (void **)*v7;
              v31 = v7;
              if ( *v7 )
                goto LABEL_18;
              return;
            }
            if ( !*((_QWORD *)*v3 + v8) )
              break;
            v12 = (void **)*v7;
            v13 = v7;
            if ( *v7 )
            {
              v14 = *((unsigned __int8 *)v7 + 16);
              v15 = v7;
              if ( (v14 & 1) != 0 )
                v16 = (size_t)v7[3];
              else
                v16 = v14 >> 1;
              v17 = -(__int64)(v14 >> 1);
              do
              {
                v13 = v15;
                v15 = v12;
                v20 = *((unsigned __int8 *)v12 + 16);
                v18 = v12 + 2;
                v19 = v20;
                v21 = v18[1];
                v22 = (unsigned __int64)v20 >> 1;
                if ( (v20 & 1) == 0 )
                  v21 = v22;
                if ( v16 != v21 )
                  break;
                if ( (v14 & 1) != 0 )
                  v23 = v7[4];
                else
                  v23 = (char *)v7 + 17;
                if ( (v19 & 1) != 0 )
                  v24 = (unsigned __int8 *)v15[4];
                else
                  v24 = (unsigned __int8 *)v18 + 1;
                if ( (v14 & 1) != 0 )
                {
                  if ( v16 )
                  {
                    v27 = v9;
                    v28 = v17;
                    v29 = memcmp(v23, v24, v16);
                    v17 = v28;
                    v3 = v30;
                    v9 = v27;
                    if ( v29 )
                      break;
                  }
                }
                else
                {
                  v25 = v17;
                  v26 = (unsigned __int8 *)v7 + 17;
                  if ( v16 )
                  {
                    while ( *v26 == *v24 )
                    {
                      ++v26;
                      ++v25;
                      ++v24;
                      if ( !v25 )
                        goto LABEL_46;
                    }
                    break;
                  }
                }
LABEL_46:
                v12 = (void **)*v15;
                v13 = v15;
              }
              while ( *v15 );
            }
            *v33 = *v13;
            *v13 = (void *)**((_QWORD **)*v3 + v8);
            **((_QWORD **)*v3 + v8) = v7;
            v7 = (void **)*v31;
            if ( !*v31 )
              return;
          }
          *((_QWORD *)*v3 + v8) = v33;
          v11 = (void **)*v7;
          if ( *v7 )
            continue;
          break;
        }
      }
    }
  }
  else
  {
    v10 = *a1;
    *v3 = 0LL;
    if ( v10 )
      operator delete(v10);
    v3[1] = 0LL;
  }
}

//----- (000000000008D2E8) ----------------------------------------------------
__int64 *__fastcall std::basic_string<unsigned char>::assign(__int64 *a1, unsigned __int64 a2, unsigned __int64 a3)
{
  __int64 v4; // x10
  unsigned __int64 v5; // x10
  unsigned __int64 v6; // x11
  unsigned __int64 v7; // x12
  unsigned __int64 v8; // x13
  unsigned __int64 v9; // x14
  unsigned __int64 v10; // x15
  __int128 *v11; // x9
  _OWORD *v12; // x15
  __int128 v13; // q0
  __int128 v14; // q1
  unsigned __int64 v15; // x14
  _BYTE *v16; // x11
  unsigned __int64 v17; // x12
  char *v18; // x13
  char v19; // t1
  _BYTE *v20; // x9
  char *v21; // x11
  char v22; // t1
  __int128 *v24; // x9
  _OWORD *v25; // x15
  unsigned __int64 v26; // x16
  __int128 v27; // q0
  __int128 v28; // q1

  LOBYTE(v4) = *(_BYTE *)a1;
  if ( (*(_BYTE *)a1 & 1) == 0 )
  {
    if ( a3 <= 0x16 )
      goto LABEL_3;
LABEL_16:
    std::basic_string<unsigned char>::__grow_by_and_replace();
    return a1;
  }
  v4 = *a1;
  if ( (*a1 & 0xFFFFFFFFFFFFFFFELL) - 1 < a3 )
    goto LABEL_16;
LABEL_3:
  if ( (v4 & 1) != 0 )
  {
    v5 = a1[2];
    if ( v5 >= a2 )
      goto LABEL_5;
  }
  else
  {
    v5 = (unsigned __int64)a1 + 1;
    if ( (unsigned __int64)a1 + 1 >= a2 )
    {
LABEL_5:
      if ( a3 && v5 > a2 )
      {
        v6 = a2 + a3;
        v7 = v5 + a3;
        if ( a3 < 0x20 || (v8 = a3 & 0x1F, v9 = a3 - v8, a3 == v8) )
        {
          v10 = a3;
        }
        else if ( v5 >= v6 || (v10 = a3, v7 <= a2) )
        {
          v7 = v5 + v8;
          v6 = a2 + v8;
          v11 = (__int128 *)(a2 + a3 - 16);
          v12 = (_OWORD *)(v5 + a3 - 16);
          do
          {
            v14 = *(v11 - 1);
            v13 = *v11;
            v9 -= 32LL;
            v11 -= 2;
            *(v12 - 1) = v14;
            *v12 = v13;
            v12 -= 2;
          }
          while ( v9 );
          v10 = a3 & 0x1F;
          if ( (a3 & 0x1F) == 0 )
            goto LABEL_29;
        }
        v20 = (_BYTE *)(v7 - 1);
        v21 = (char *)(v6 - 1);
        do
        {
          v22 = *v21--;
          --v10;
          *v20-- = v22;
        }
        while ( v10 );
      }
      goto LABEL_29;
    }
  }
  if ( a3 )
  {
    if ( a3 >= 0x20
      && (v15 = a3 & 0xFFFFFFFFFFFFFFE0LL, (a3 & 0xFFFFFFFFFFFFFFE0LL) != 0)
      && (v5 >= a2 + a3 || v5 + a3 <= a2) )
    {
      v16 = (_BYTE *)(v5 + v15);
      v17 = a3 - v15;
      v18 = (char *)(a2 + v15);
      v24 = (__int128 *)(a2 + 16);
      v25 = (_OWORD *)(v5 + 16);
      v26 = a3 & 0xFFFFFFFFFFFFFFE0LL;
      do
      {
        v27 = *(v24 - 1);
        v28 = *v24;
        v24 += 2;
        v26 -= 32LL;
        *(v25 - 1) = v27;
        *v25 = v28;
        v25 += 2;
      }
      while ( v26 );
      if ( v15 == a3 )
        goto LABEL_29;
    }
    else
    {
      v16 = (_BYTE *)v5;
      v17 = a3;
      v18 = (char *)a2;
    }
    do
    {
      v19 = *v18++;
      --v17;
      *v16++ = v19;
    }
    while ( v17 );
  }
LABEL_29:
  *(_BYTE *)(v5 + a3) = 0;
  if ( (*(_BYTE *)a1 & 1) != 0 )
    a1[1] = a3;
  else
    *(_BYTE *)a1 = 2 * a3;
  return a1;
}

//----- (000000000008D4BC) ----------------------------------------------------
void __fastcall std::basic_string<unsigned char>::__grow_by_and_replace(
        __int64 a1,
        unsigned __int64 a2,
        unsigned __int64 a3,
        __int64 a4,
        unsigned __int64 a5,
        __int64 a6,
        unsigned __int64 a7,
        __int64 a8)
{
  char *v15; // x22
  unsigned __int64 v16; // x8
  __int64 v17; // x23
  unsigned __int64 v18; // x0
  unsigned __int64 v19; // x24
  _BYTE *v20; // x8
  unsigned __int64 v21; // x9
  char *v22; // x10
  unsigned __int64 v23; // x11
  __int128 *v24; // x12
  _OWORD *v25; // x13
  unsigned __int64 v26; // x14
  __int128 v27; // q0
  __int128 v28; // q1
  char v29; // t1
  _BYTE *v30; // x8
  unsigned __int64 v31; // x11
  unsigned __int64 v32; // x9
  char *v33; // x10
  __int128 *v34; // x12
  _OWORD *v35; // x13
  unsigned __int64 v36; // x14
  __int128 v37; // q0
  __int128 v38; // q1
  char v39; // t1
  __int64 v40; // x28
  unsigned __int64 v41; // x8
  char *v42; // x9
  char *v43; // x10
  unsigned __int64 v44; // x11
  char *v45; // x13
  _OWORD *v46; // x14
  unsigned __int64 v47; // x15
  __int128 v48; // q0
  __int128 v49; // q1
  char v50; // t1

  if ( -18LL - a2 < a3 )
    abort();
  if ( (*(_BYTE *)a1 & 1) != 0 )
    v15 = *(char **)(a1 + 16);
  else
    v15 = (char *)(a1 + 1);
  if ( a2 > 0x7FFFFFFFFFFFFFE6LL )
  {
    v17 = -17LL;
  }
  else
  {
    v16 = a3 + a2;
    if ( a3 + a2 < 2 * a2 )
      v16 = 2 * a2;
    if ( v16 >= 0x17 )
      v17 = (v16 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    else
      v17 = 23LL;
  }
  v18 = operator new(v17);
  v19 = v18;
  if ( a5 )
  {
    v20 = (_BYTE *)v18;
    v21 = a5;
    v22 = v15;
    if ( a5 < 0x20 )
      goto LABEL_45;
    v23 = a5 & 0xFFFFFFFFFFFFFFE0LL;
    v20 = (_BYTE *)v18;
    v21 = a5;
    v22 = v15;
    if ( (a5 & 0xFFFFFFFFFFFFFFE0LL) == 0 )
      goto LABEL_45;
    if ( v18 < (unsigned __int64)&v15[a5] )
    {
      v20 = (_BYTE *)v18;
      v21 = a5;
      v22 = v15;
      if ( (unsigned __int64)v15 < v18 + a5 )
        goto LABEL_45;
    }
    v20 = (_BYTE *)(v18 + v23);
    v21 = a5 - v23;
    v22 = &v15[v23];
    v24 = (__int128 *)(v15 + 16);
    v25 = (_OWORD *)(v18 + 16);
    v26 = a5 & 0xFFFFFFFFFFFFFFE0LL;
    do
    {
      v27 = *(v24 - 1);
      v28 = *v24;
      v24 += 2;
      v26 -= 32LL;
      *(v25 - 1) = v27;
      *v25 = v28;
      v25 += 2;
    }
    while ( v26 );
    if ( v23 != a5 )
    {
LABEL_45:
      do
      {
        v29 = *v22++;
        --v21;
        *v20++ = v29;
      }
      while ( v21 );
    }
  }
  if ( a7 )
  {
    v30 = (_BYTE *)(v18 + a5);
    if ( a7 >= 0x20 && (v31 = a7 & 0xFFFFFFFFFFFFFFE0LL, (a7 & 0xFFFFFFFFFFFFFFE0LL) != 0) )
    {
      v30 += v31;
      v32 = a7 - v31;
      v33 = (char *)(a8 + v31);
      v34 = (__int128 *)(a8 + 16);
      v35 = (_OWORD *)(v18 + a5 + 16);
      v36 = a7 & 0xFFFFFFFFFFFFFFE0LL;
      do
      {
        v37 = *(v34 - 1);
        v38 = *v34;
        v34 += 2;
        v36 -= 32LL;
        *(v35 - 1) = v37;
        *v35 = v38;
        v35 += 2;
      }
      while ( v36 );
      if ( v31 == a7 )
        goto LABEL_30;
    }
    else
    {
      v32 = a7;
      v33 = (char *)a8;
    }
    do
    {
      v39 = *v33++;
      --v32;
      *v30++ = v39;
    }
    while ( v32 );
  }
LABEL_30:
  v40 = a4 - a6;
  v41 = a4 - a6 - a5;
  if ( v41 )
  {
    v42 = (char *)(v18 + a5 + a7);
    v43 = &v15[a5 + a6];
    if ( v41 < 0x20 )
      goto LABEL_46;
    v44 = v41 & 0xFFFFFFFFFFFFFFE0LL;
    if ( (v41 & 0xFFFFFFFFFFFFFFE0LL) == 0 || v42 < &v15[a4] && (unsigned __int64)v43 < v18 + a7 + a4 - a6 )
      goto LABEL_46;
    v42 += v44;
    v43 += v44;
    v45 = &v15[a6 + 16 + a5];
    v46 = (_OWORD *)(v18 + a7 + a5 + 16);
    v47 = v41 & 0xFFFFFFFFFFFFFFE0LL;
    do
    {
      v48 = *((_OWORD *)v45 - 1);
      v49 = *(_OWORD *)v45;
      v47 -= 32LL;
      v45 += 32;
      *(v46 - 1) = v48;
      *v46 = v49;
      v46 += 2;
    }
    while ( v47 );
    v41 -= v44;
    if ( v41 )
    {
LABEL_46:
      do
      {
        v50 = *v43++;
        --v41;
        *v42++ = v50;
      }
      while ( v41 );
    }
  }
  if ( a2 != 22 )
    operator delete(v15);
  *(_QWORD *)a1 = v17 | 1;
  *(_QWORD *)(a1 + 8) = v40 + a7;
  *(_QWORD *)(a1 + 16) = v19;
  *(_BYTE *)(v19 + v40 + a7) = 0;
}

//----- (000000000008D758) ----------------------------------------------------
__int64 **__fastcall std::__hash_table<std::__hash_value_type<std::string,std::basic_string<unsigned char>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::basic_string<unsigned char>>,std::hash<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::basic_string<unsigned char>>,std::equal_to<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::basic_string<unsigned char>>>>::find<std::string>(
        _QWORD *a1,
        unsigned __int8 *a2)
{
  unsigned __int64 v4; // x0
  unsigned __int64 v5; // x24
  unsigned __int64 v6; // x19
  unsigned __int64 v7; // x25
  __int64 v8; // x26
  unsigned __int64 v9; // x27
  __int64 ***v10; // x8
  __int64 **v11; // x20
  unsigned __int64 v12; // x8
  unsigned __int8 *v13; // x11
  unsigned __int8 *v14; // x9
  size_t v15; // x21
  unsigned __int8 *v16; // x22
  unsigned __int64 v17; // x8
  unsigned __int64 v18; // x10
  unsigned __int64 v19; // x11
  __int64 *v20; // x0
  unsigned __int8 *v21; // x8
  __int64 v22; // x9
  unsigned __int8 *i; // x10

  _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v4 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()();
  v5 = a1[1];
  v6 = v4;
  if ( !v5 )
    return 0LL;
  v7 = v5 - 1;
  v8 = (v5 - 1) & v5;
  if ( v8 )
  {
    v9 = v4;
    if ( v4 >= v5 )
      v9 = v4 % v5;
  }
  else
  {
    v9 = v7 & v4;
  }
  v10 = *(__int64 ****)(*a1 + 8 * v9);
  if ( !v10 )
    return 0LL;
  v11 = *v10;
  if ( *v10 )
  {
    v12 = *a2;
    v13 = (unsigned __int8 *)*((_QWORD *)a2 + 2);
    v14 = a2 + 1;
    if ( (v12 & 1) != 0 )
      v15 = *((_QWORD *)a2 + 1);
    else
      v15 = v12 >> 1;
    if ( (v12 & 1) != 0 )
      v16 = v13;
    else
      v16 = v14;
    do
    {
      v17 = (unsigned __int64)v11[1];
      if ( v17 == v6 )
      {
        v18 = *((unsigned __int8 *)v11 + 16);
        v19 = (unsigned __int64)v11[3];
        if ( (v18 & 1) == 0 )
          v19 = v18 >> 1;
        if ( v19 == v15 )
        {
          if ( (v18 & 1) != 0 )
            v20 = v11[4];
          else
            v20 = (__int64 *)((char *)v11 + 17);
          if ( (v18 & 1) != 0 )
          {
            if ( !v15 || !memcmp(v20, v16, v15) )
              return v11;
          }
          else
          {
            if ( !v15 )
              return v11;
            v21 = (unsigned __int8 *)v11 + 17;
            v22 = -(__int64)(v18 >> 1);
            for ( i = v16; *v21 == *i; ++i )
            {
              ++v21;
              if ( !++v22 )
                return v11;
            }
          }
        }
      }
      else
      {
        if ( !v8 )
        {
          v17 &= v7;
LABEL_32:
          if ( v17 != v9 )
            return 0LL;
          goto LABEL_33;
        }
        if ( v17 < v5 )
          goto LABEL_32;
        if ( v17 % v5 != v9 )
          return 0LL;
      }
LABEL_33:
      v11 = (__int64 **)*v11;
    }
    while ( v11 );
  }
  return v11;
}

//----- (000000000008D90C) ----------------------------------------------------
unsigned __int64 __fastcall std::__next_prime(unsigned __int64 this)
{
  int *v1; // x8
  __int64 v2; // x9
  unsigned __int64 v3; // x9
  __int64 v4; // x14
  __int64 v5; // x12
  unsigned int *v6; // x11
  __int64 v7; // x10
  int *v8; // x11
  __int64 v9; // x13
  unsigned int *v10; // x15
  __int64 v11; // x12
  unsigned __int64 v12; // x14
  unsigned __int64 i; // x15
  unsigned __int64 v14; // x16
  unsigned __int64 v15; // x15
  int v16; // w16
  int v17; // w17
  unsigned __int64 v18; // x16
  unsigned __int64 v19; // x16
  unsigned __int64 v20; // x16
  unsigned __int64 v21; // x16
  unsigned __int64 v22; // x16
  unsigned __int64 v23; // x16
  unsigned __int64 v24; // x16
  unsigned __int64 v25; // x16
  unsigned __int64 v26; // x16
  unsigned __int64 v27; // x16
  unsigned __int64 v28; // x16
  unsigned __int64 v29; // x16
  unsigned __int64 v30; // x16
  unsigned __int64 v31; // x16
  unsigned __int64 v32; // x16
  unsigned __int64 v33; // x16
  unsigned __int64 v34; // x16
  unsigned __int64 v35; // x16
  unsigned __int64 v36; // x16
  unsigned __int64 v37; // x16
  unsigned __int64 v38; // x16
  unsigned __int64 v39; // x16
  unsigned __int64 v40; // x16
  unsigned __int64 v41; // x16
  unsigned __int64 v42; // x16
  unsigned __int64 v43; // x16
  unsigned __int64 v44; // x16
  unsigned __int64 v45; // x16
  unsigned __int64 v46; // x16
  unsigned __int64 v47; // x16
  unsigned __int64 v48; // x16
  unsigned __int64 v49; // x16
  unsigned __int64 v50; // x16
  unsigned __int64 v51; // x16
  unsigned __int64 v52; // x16
  unsigned __int64 v53; // x16
  unsigned __int64 v54; // x16
  unsigned __int64 v55; // x16
  unsigned __int64 v56; // x16
  unsigned __int64 v57; // x16
  unsigned __int64 v58; // x16
  unsigned __int64 v59; // x16
  unsigned __int64 v60; // x16
  unsigned __int64 v61; // x16
  unsigned __int64 v62; // x16
  unsigned __int64 v63; // x16
  unsigned __int64 v64; // x17
  unsigned __int64 v65; // x16
  unsigned __int64 v66; // x16
  bool v67; // zf
  std::runtime_error *exception; // x19

  if ( this > 0xD3 )
  {
    if ( this >= 0xFFFFFFFFFFFFFFC6LL )
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "__next_prime overflow");
      *(_QWORD *)exception = off_69E8C48;
      __cxa_throw(
        exception,
        (struct type_info *)&`typeinfo for'std::overflow_error,
        (void (*)(void *))std::underflow_error::~underflow_error);
    }
    v3 = this / 0xD2;
    v4 = 210 * (this / 0xD2);
    v5 = 48LL;
    v6 = dword_69D06B0;
    while ( 1 )
    {
      v9 = v5;
      if ( !v5 )
        break;
      v5 /= 2LL;
      v10 = &v6[v5];
      if ( this % 0xD2 > *v10 )
      {
        v6 = v10 + 1;
        v5 = v9 - 1 - v5;
      }
    }
    v11 = v6 - dword_69D06B0;
LABEL_17:
    v12 = v4 + dword_69D06B0[v11];
    for ( i = 5LL; i < 0x2F; ++i )
    {
      v14 = (unsigned int)dword_69D05F0[i];
      if ( v12 / v14 < v14 )
        return v12;
      if ( v12 == v12 / v14 * v14 )
      {
LABEL_13:
        if ( v11 == 47 )
        {
          ++v3;
          v11 = 0LL;
        }
        else
        {
          ++v11;
        }
        v4 = 210 * v3;
        goto LABEL_17;
      }
    }
    v15 = 211LL;
    while ( 1 )
    {
      if ( v12 / v15 < v15 )
      {
        v16 = 1;
        this = v12;
        v17 = 1;
        goto LABEL_127;
      }
      if ( v12 == v12 / v15 * v15 )
      {
        v16 = 9;
        v17 = 9;
        goto LABEL_127;
      }
      v18 = v12 / (v15 + 10);
      if ( v18 < v15 + 10 )
        goto LABEL_27;
      if ( v12 == v18 * (v15 + 10) )
        break;
      v19 = v12 / (v15 + 12);
      if ( v19 < v15 + 12 )
        goto LABEL_27;
      if ( v12 == v19 * (v15 + 12) )
        break;
      v20 = v12 / (v15 + 16);
      if ( v20 < v15 + 16 )
        goto LABEL_27;
      if ( v12 == v20 * (v15 + 16) )
        break;
      v21 = v12 / (v15 + 18);
      if ( v21 < v15 + 18 )
        goto LABEL_27;
      if ( v12 == v21 * (v15 + 18) )
        break;
      v22 = v12 / (v15 + 22);
      if ( v22 < v15 + 22 )
        goto LABEL_27;
      if ( v12 == v22 * (v15 + 22) )
        break;
      v23 = v12 / (v15 + 28);
      if ( v23 < v15 + 28 )
        goto LABEL_27;
      if ( v12 == v23 * (v15 + 28) )
        break;
      v24 = v12 / (v15 + 30);
      if ( v24 < v15 + 30 )
        goto LABEL_27;
      if ( v12 == v24 * (v15 + 30) )
        break;
      v25 = v12 / (v15 + 36);
      if ( v25 < v15 + 36 )
        goto LABEL_27;
      if ( v12 == v25 * (v15 + 36) )
        break;
      v26 = v12 / (v15 + 40);
      if ( v26 < v15 + 40 )
        goto LABEL_27;
      if ( v12 == v26 * (v15 + 40) )
        break;
      v27 = v12 / (v15 + 42);
      if ( v27 < v15 + 42 )
        goto LABEL_27;
      if ( v12 == v27 * (v15 + 42) )
        break;
      v28 = v12 / (v15 + 46);
      if ( v28 < v15 + 46 )
        goto LABEL_27;
      if ( v12 == v28 * (v15 + 46) )
        break;
      v29 = v12 / (v15 + 52);
      if ( v29 < v15 + 52 )
        goto LABEL_27;
      if ( v12 == v29 * (v15 + 52) )
        break;
      v30 = v12 / (v15 + 58);
      if ( v30 < v15 + 58 )
        goto LABEL_27;
      if ( v12 == v30 * (v15 + 58) )
        break;
      v31 = v12 / (v15 + 60);
      if ( v31 < v15 + 60 )
        goto LABEL_27;
      if ( v12 == v31 * (v15 + 60) )
        break;
      v32 = v12 / (v15 + 66);
      if ( v32 < v15 + 66 )
        goto LABEL_27;
      if ( v12 == v32 * (v15 + 66) )
        break;
      v33 = v12 / (v15 + 70);
      if ( v33 < v15 + 70 )
        goto LABEL_27;
      if ( v12 == v33 * (v15 + 70) )
        break;
      v34 = v12 / (v15 + 72);
      if ( v34 < v15 + 72 )
        goto LABEL_27;
      if ( v12 == v34 * (v15 + 72) )
        break;
      v35 = v12 / (v15 + 78);
      if ( v35 < v15 + 78 )
        goto LABEL_27;
      if ( v12 == v35 * (v15 + 78) )
        break;
      v36 = v12 / (v15 + 82);
      if ( v36 < v15 + 82 )
        goto LABEL_27;
      if ( v12 == v36 * (v15 + 82) )
        break;
      v37 = v12 / (v15 + 88);
      if ( v37 < v15 + 88 )
        goto LABEL_27;
      if ( v12 == v37 * (v15 + 88) )
        break;
      v38 = v12 / (v15 + 96);
      if ( v38 < v15 + 96 )
        goto LABEL_27;
      if ( v12 == v38 * (v15 + 96) )
        break;
      v39 = v12 / (v15 + 100);
      if ( v39 < v15 + 100 )
        goto LABEL_27;
      if ( v12 == v39 * (v15 + 100) )
        break;
      v40 = v12 / (v15 + 102);
      if ( v40 < v15 + 102 )
        goto LABEL_27;
      if ( v12 == v40 * (v15 + 102) )
        break;
      v41 = v12 / (v15 + 106);
      if ( v41 < v15 + 106 )
        goto LABEL_27;
      if ( v12 == v41 * (v15 + 106) )
        break;
      v42 = v12 / (v15 + 108);
      if ( v42 < v15 + 108 )
        goto LABEL_27;
      if ( v12 == v42 * (v15 + 108) )
        break;
      v43 = v12 / (v15 + 112);
      if ( v43 < v15 + 112 )
        goto LABEL_27;
      if ( v12 == v43 * (v15 + 112) )
        break;
      v44 = v12 / (v15 + 120);
      if ( v44 < v15 + 120 )
        goto LABEL_27;
      if ( v12 == v44 * (v15 + 120) )
        break;
      v45 = v12 / (v15 + 126);
      if ( v45 < v15 + 126 )
        goto LABEL_27;
      if ( v12 == v45 * (v15 + 126) )
        break;
      v46 = v12 / (v15 + 130);
      if ( v46 < v15 + 130 )
        goto LABEL_27;
      if ( v12 == v46 * (v15 + 130) )
        break;
      v47 = v12 / (v15 + 136);
      if ( v47 < v15 + 136 )
        goto LABEL_27;
      if ( v12 == v47 * (v15 + 136) )
        break;
      v48 = v12 / (v15 + 138);
      if ( v48 < v15 + 138 )
        goto LABEL_27;
      if ( v12 == v48 * (v15 + 138) )
        break;
      v49 = v12 / (v15 + 142);
      if ( v49 < v15 + 142 )
        goto LABEL_27;
      if ( v12 == v49 * (v15 + 142) )
        break;
      v50 = v12 / (v15 + 148);
      if ( v50 < v15 + 148 )
        goto LABEL_27;
      if ( v12 == v50 * (v15 + 148) )
        break;
      v51 = v12 / (v15 + 150);
      if ( v51 < v15 + 150 )
        goto LABEL_27;
      if ( v12 == v51 * (v15 + 150) )
        break;
      v52 = v12 / (v15 + 156);
      if ( v52 < v15 + 156 )
        goto LABEL_27;
      if ( v12 == v52 * (v15 + 156) )
        break;
      v53 = v12 / (v15 + 162);
      if ( v53 < v15 + 162 )
        goto LABEL_27;
      if ( v12 == v53 * (v15 + 162) )
        break;
      v54 = v12 / (v15 + 166);
      if ( v54 < v15 + 166 )
        goto LABEL_27;
      if ( v12 == v54 * (v15 + 166) )
        break;
      v55 = v12 / (v15 + 168);
      if ( v55 < v15 + 168 )
        goto LABEL_27;
      if ( v12 == v55 * (v15 + 168) )
        break;
      v56 = v12 / (v15 + 172);
      if ( v56 < v15 + 172 )
        goto LABEL_27;
      if ( v12 == v56 * (v15 + 172) )
        break;
      v57 = v12 / (v15 + 178);
      if ( v57 < v15 + 178 )
        goto LABEL_27;
      if ( v12 == v57 * (v15 + 178) )
        break;
      v58 = v12 / (v15 + 180);
      if ( v58 < v15 + 180 )
        goto LABEL_27;
      if ( v12 == v58 * (v15 + 180) )
        break;
      v59 = v12 / (v15 + 186);
      if ( v59 < v15 + 186 )
        goto LABEL_27;
      if ( v12 == v59 * (v15 + 186) )
        break;
      v60 = v12 / (v15 + 190);
      if ( v60 < v15 + 190 )
        goto LABEL_27;
      if ( v12 == v60 * (v15 + 190) )
        break;
      v61 = v12 / (v15 + 192);
      if ( v61 < v15 + 192 )
        goto LABEL_27;
      if ( v12 == v61 * (v15 + 192) )
        break;
      v62 = v12 / (v15 + 196);
      if ( v62 < v15 + 196 )
        goto LABEL_27;
      if ( v12 == v62 * (v15 + 196) )
        break;
      v63 = v12 / (v15 + 198);
      if ( v63 < v15 + 198 )
      {
LABEL_27:
        v16 = 1;
        this = v12;
        v17 = 1;
        goto LABEL_127;
      }
      if ( v12 == v63 * (v15 + 198) )
        break;
      v64 = v15 + 208;
      v65 = v12 / (v15 + 208);
      if ( v65 < v15 + 208 )
        goto LABEL_27;
      v66 = v65 * v64;
      v15 += 210LL;
      v67 = v12 == v66;
      if ( v12 == v66 )
        v16 = 9;
      else
        v16 = 0;
      if ( v67 )
        v15 = v64;
      v17 = v16;
      if ( (v16 & 0xF) != 0 )
        goto LABEL_127;
    }
    v16 = 9;
    v17 = 9;
LABEL_127:
    if ( v17 == 9 || !v16 )
      goto LABEL_13;
  }
  else
  {
    v1 = dword_69D05F0;
    v2 = 48LL;
    while ( 1 )
    {
      v7 = v2;
      if ( !v2 )
        break;
      v2 /= 2LL;
      v8 = &v1[v2];
      if ( (unsigned int)*v8 < this )
      {
        v1 = v8 + 1;
        v2 = v7 - 1 - v2;
      }
    }
    return (unsigned int)*v1;
  }
  return this;
}
// 8DFDC: masking with 0xF was optimized away because w16.4 <= 0x9
// 69D05F0: using guessed type int dword_69D05F0[48];
// 69D06B0: using guessed type unsigned int dword_69D06B0[48];
// 69E8C48: using guessed type void (__fastcall *[2])(std::underflow_error *__hidden this);
// 69E8C60: using guessed type __int64 *`typeinfo for'std::overflow_error;

//----- (000000000008E058) ----------------------------------------------------
void *__fastcall std::logic_error::logic_error(_QWORD *a1, __int64 a2)
{
  const char *v3; // x20
  size_t v4; // x21
  __int64 v5; // x0
  __int64 v6; // x22
  void *result; // x0

  *a1 = off_69E8A70;
  if ( (*(_BYTE *)a2 & 1) != 0 )
    v3 = *(const char **)(a2 + 16);
  else
    v3 = (const char *)(a2 + 1);
  v4 = strlen(v3);
  v5 = operator new(v4 + 25);
  v6 = v5 + 24;
  *(_QWORD *)v5 = v4;
  *(_QWORD *)(v5 + 8) = v4;
  *(_DWORD *)(v5 + 16) = 0;
  result = memcpy((void *)(v5 + 24), v3, v4 + 1);
  a1[1] = v6;
  return result;
}
// 69E8A70: using guessed type void (__fastcall *[2])(std::invalid_argument *__hidden this);

//----- (000000000008E0E4) ----------------------------------------------------
void *__fastcall std::logic_error::logic_error(std::logic_error *this, const char *s)
{
  size_t v4; // x21
  __int64 v5; // x0
  __int64 v6; // x22
  void *result; // x0

  *(_QWORD *)this = off_69E8A70;
  v4 = strlen(s);
  v5 = operator new(v4 + 25);
  v6 = v5 + 24;
  *(_QWORD *)v5 = v4;
  *(_QWORD *)(v5 + 8) = v4;
  *(_DWORD *)(v5 + 16) = 0;
  result = memcpy((void *)(v5 + 24), s, v4 + 1);
  *((_QWORD *)this + 1) = v6;
  return result;
}
// 69E8A70: using guessed type void (__fastcall *[2])(std::invalid_argument *__hidden this);

//----- (000000000008E164) ----------------------------------------------------
_QWORD *__fastcall std::logic_error::logic_error(_QWORD *result, __int64 a2)
{
  __int64 v2; // x8
  unsigned int *v3; // x8
  unsigned int v4; // w9

  *result = off_69E8A70;
  v2 = *(_QWORD *)(a2 + 8);
  result[1] = v2;
  v3 = (unsigned int *)(v2 - 8);
  do
    v4 = __ldaxr(v3);
  while ( __stlxr(v4 + 1, v3) );
  return result;
}
// 69E8A70: using guessed type void (__fastcall *[2])(std::invalid_argument *__hidden this);

//----- (000000000008E194) ----------------------------------------------------
__int64 __fastcall std::logic_error::operator=(__int64 a1, __int64 a2)
{
  __int64 v3; // x9
  __int64 v4; // x8
  unsigned int *v5; // x9
  unsigned int v6; // w10
  unsigned int *v7; // x9
  unsigned int v8; // w10
  unsigned int v9; // w10

  v3 = *(_QWORD *)(a2 + 8);
  v4 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 8) = v3;
  v5 = (unsigned int *)(v3 - 8);
  do
    v6 = __ldaxr(v5);
  while ( __stlxr(v6 + 1, v5) );
  v7 = (unsigned int *)(v4 - 8);
  do
  {
    v8 = __ldaxr(v7);
    v9 = v8 - 1;
  }
  while ( __stlxr(v9, v7) );
  if ( (v9 & 0x80000000) != 0 )
    operator delete((void *)(v4 - 24));
  return a1;
}

//----- (000000000008E1F4) ----------------------------------------------------
void *__fastcall std::runtime_error::runtime_error(_QWORD *a1, __int64 a2)
{
  const char *v3; // x20
  size_t v4; // x21
  __int64 v5; // x0
  __int64 v6; // x22
  void *result; // x0

  *a1 = off_69E8A98;
  if ( (*(_BYTE *)a2 & 1) != 0 )
    v3 = *(const char **)(a2 + 16);
  else
    v3 = (const char *)(a2 + 1);
  v4 = strlen(v3);
  v5 = operator new(v4 + 25);
  v6 = v5 + 24;
  *(_QWORD *)v5 = v4;
  *(_QWORD *)(v5 + 8) = v4;
  *(_DWORD *)(v5 + 16) = 0;
  result = memcpy((void *)(v5 + 24), v3, v4 + 1);
  a1[1] = v6;
  return result;
}
// 69E8A98: using guessed type void (__fastcall *[2])(std::underflow_error *__hidden this);

//----- (000000000008E280) ----------------------------------------------------
void *__fastcall std::runtime_error::runtime_error(std::runtime_error *this, const char *s)
{
  size_t v4; // x21
  __int64 v5; // x0
  __int64 v6; // x22
  void *result; // x0

  *(_QWORD *)this = off_69E8A98;
  v4 = strlen(s);
  v5 = operator new(v4 + 25);
  v6 = v5 + 24;
  *(_QWORD *)v5 = v4;
  *(_QWORD *)(v5 + 8) = v4;
  *(_DWORD *)(v5 + 16) = 0;
  result = memcpy((void *)(v5 + 24), s, v4 + 1);
  *((_QWORD *)this + 1) = v6;
  return result;
}
// 69E8A98: using guessed type void (__fastcall *[2])(std::underflow_error *__hidden this);

//----- (000000000008E300) ----------------------------------------------------
_QWORD *__fastcall std::runtime_error::runtime_error(_QWORD *result, __int64 a2)
{
  __int64 v2; // x8
  unsigned int *v3; // x8
  unsigned int v4; // w9

  *result = off_69E8A98;
  v2 = *(_QWORD *)(a2 + 8);
  result[1] = v2;
  v3 = (unsigned int *)(v2 - 8);
  do
    v4 = __ldaxr(v3);
  while ( __stlxr(v4 + 1, v3) );
  return result;
}
// 69E8A98: using guessed type void (__fastcall *[2])(std::underflow_error *__hidden this);

//----- (000000000008E330) ----------------------------------------------------
__int64 __fastcall std::runtime_error::operator=(__int64 a1, __int64 a2)
{
  __int64 v3; // x9
  __int64 v4; // x8
  unsigned int *v5; // x9
  unsigned int v6; // w10
  unsigned int *v7; // x9
  unsigned int v8; // w10
  unsigned int v9; // w10

  v3 = *(_QWORD *)(a2 + 8);
  v4 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 8) = v3;
  v5 = (unsigned int *)(v3 - 8);
  do
    v6 = __ldaxr(v5);
  while ( __stlxr(v6 + 1, v5) );
  v7 = (unsigned int *)(v4 - 8);
  do
  {
    v8 = __ldaxr(v7);
    v9 = v8 - 1;
  }
  while ( __stlxr(v9, v7) );
  if ( (v9 & 0x80000000) != 0 )
    operator delete((void *)(v4 - 24));
  return a1;
}

//----- (000000000008E390) ----------------------------------------------------
void *_cxa_allocate_exception(size_t thrown_size)
{
  size_t v1; // x19
  char *v2; // x0
  char *v3; // x20

  v1 = (thrown_size + 143) & 0xFFFFFFFFFFFFFFF0LL;
  v2 = (char *)sub_8F9C4(v1);
  v3 = v2;
  if ( !v2 )
    std::terminate();
  memset(v2, 0, v1);
  return v3 + 128;
}
// 8F9C4: using guessed type __int64 __fastcall sub_8F9C4(_QWORD);

//----- (000000000008E3DC) ----------------------------------------------------
void _cxa_free_exception(void *a1)
{
  _cxa_free_dependent_exception_0((char *)a1 - 128);
}
// 8FB88: using guessed type __int64 __fastcall _cxa_free_dependent_exception_0(_QWORD);

//----- (000000000008E3F8) ----------------------------------------------------
void *_cxa_allocate_dependent_exception()
{
  void *v0; // x0
  void *v1; // x19

  v0 = (void *)sub_8F9C4(128LL);
  v1 = v0;
  if ( !v0 )
    std::terminate();
  memset(v0, 0, 0x80uLL);
  return v1;
}
// 8F9C4: using guessed type __int64 __fastcall sub_8F9C4(_QWORD);

//----- (000000000008E43C) ----------------------------------------------------
void __noreturn _cxa_throw(void *a1, struct type_info *lptinfo, void (*a3)(void *))
{
  __int64 globals; // x22
  __int64 terminate; // x0

  globals = __cxa_get_globals();
  *((_QWORD *)a1 - 13) = std::get_unexpected();
  terminate = std::get_terminate();
  *((_QWORD *)a1 - 4) = 0x434C4E47432B2B00LL;
  a1 = (char *)a1 - 32;
  *((_QWORD *)a1 - 8) = terminate;
  *((_QWORD *)a1 - 12) = 1LL;
  *((_QWORD *)a1 - 11) = lptinfo;
  *((_QWORD *)a1 - 10) = a3;
  ++*(_DWORD *)(globals + 8);
  *((_QWORD *)a1 + 1) = &loc_8E4C0;
  _Unwind_RaiseException();
  __cxa_begin_catch(a1);
  sub_8EC38(*((_QWORD *)a1 - 8));
}
// 8EC38: using guessed type void __fastcall __noreturn sub_8EC38(_QWORD);

//----- (000000000008E520) ----------------------------------------------------
void *_cxa_get_exception_ptr(void *a1)
{
  return (void *)*((_QWORD *)a1 - 2);
}

//----- (000000000008E528) ----------------------------------------------------
void *_cxa_begin_catch(void *a1)
{
  unsigned __int64 v2; // x20
  __int64 globals; // x0
  char *v4; // x8
  int v5; // w9

  v2 = *(_QWORD *)a1;
  globals = __cxa_get_globals();
  v4 = (char *)a1 - 96;
  if ( v2 >> 8 == 0x434C4E47432B2BLL )
  {
    v5 = *((_DWORD *)a1 - 12);
    if ( v5 < 0 )
      v5 = -v5;
    *((_DWORD *)a1 - 12) = v5 + 1;
    if ( *(char **)globals != v4 )
    {
      *((_QWORD *)a1 - 7) = *(_QWORD *)globals;
      *(_QWORD *)globals = v4;
    }
    --*(_DWORD *)(globals + 8);
    return (void *)*((_QWORD *)a1 - 2);
  }
  else
  {
    if ( *(_QWORD *)globals )
      std::terminate();
    *(_QWORD *)globals = v4;
    return (char *)a1 + 32;
  }
}

//----- (000000000008E5C0) ----------------------------------------------------
void _cxa_end_catch(void)
{
  __int64 *globals_fast; // x20
  __int64 v1; // x19
  unsigned __int64 v2; // x8
  int v3; // w9
  int v4; // w9
  __int64 v5; // x20
  unsigned __int64 v6; // x8
  unsigned __int64 v7; // x8
  void (__fastcall *v8)(__int64); // x8

  globals_fast = (__int64 *)__cxa_get_globals_fast();
  v1 = *globals_fast;
  if ( *globals_fast )
  {
    v2 = *(_QWORD *)(v1 + 96);
    if ( v2 >> 8 == 0x434C4E47432B2BLL )
    {
      v3 = *(_DWORD *)(v1 + 48);
      if ( v3 < 0 )
      {
        *(_DWORD *)(v1 + 48) = v3 + 1;
        if ( v3 == -1 )
          *globals_fast = *(_QWORD *)(v1 + 40);
      }
      else
      {
        v4 = v3 - 1;
        *(_DWORD *)(v1 + 48) = v4;
        if ( !v4 )
        {
          *globals_fast = *(_QWORD *)(v1 + 40);
          if ( (unsigned __int8)v2 == 1LL )
          {
            v5 = *(_QWORD *)v1 - 128LL;
            _cxa_free_dependent_exception_0(v1);
            v1 = v5;
          }
          do
          {
            v6 = __ldaxr((unsigned __int64 *)v1);
            v7 = v6 - 1;
          }
          while ( __stlxr(v7, (unsigned __int64 *)v1) );
          if ( !v7 )
          {
            v8 = *(void (__fastcall **)(__int64))(v1 + 16);
            if ( v8 )
              v8(v1 + 128);
            _cxa_free_dependent_exception_0(v1);
          }
        }
      }
    }
    else
    {
      _Unwind_DeleteException();
      *globals_fast = 0LL;
    }
  }
}
// 8FB88: using guessed type __int64 __fastcall _cxa_free_dependent_exception_0(_QWORD);

//----- (000000000008E6A0) ----------------------------------------------------
__int64 __fastcall _cxa_decrement_exception_refcount(__int64 result)
{
  unsigned __int64 *v1; // x19
  unsigned __int64 v2; // x8
  unsigned __int64 v3; // x8
  void (*v4)(void); // x8

  if ( result )
  {
    v1 = (unsigned __int64 *)(result - 128);
    do
    {
      v2 = __ldaxr(v1);
      v3 = v2 - 1;
    }
    while ( __stlxr(v3, v1) );
    if ( !v3 )
    {
      v4 = *(void (**)(void))(result - 112);
      if ( v4 )
        v4();
      return _cxa_free_dependent_exception_0(v1);
    }
  }
  return result;
}
// 8FB88: using guessed type __int64 __fastcall _cxa_free_dependent_exception_0(_QWORD);

//----- (000000000008E6F0) ----------------------------------------------------
struct type_info *_cxa_current_exception_type(void)
{
  struct type_info *result; // x0
  __int64 v1; // x8

  result = (struct type_info *)__cxa_get_globals_fast();
  if ( result )
  {
    v1 = *(_QWORD *)result;
    if ( *(_QWORD *)result )
    {
      if ( *(_QWORD *)(v1 + 96) >> 8 == 0x434C4E47432B2BLL )
        return *(struct type_info **)(v1 + 8);
      else
        return 0LL;
    }
    else
    {
      return 0LL;
    }
  }
  return result;
}

//----- (000000000008E74C) ----------------------------------------------------
void __noreturn _cxa_rethrow(void)
{
  __int64 globals; // x0
  __int64 v1; // x20
  unsigned __int64 v2; // x22
  __int64 v3; // x23
  __int64 v4; // x0
  int v5; // w9

  globals = __cxa_get_globals();
  v1 = *(_QWORD *)globals;
  if ( *(_QWORD *)globals )
  {
    v2 = *(_QWORD *)(v1 + 96) & 0xFFFFFFFFFFFFFF00LL;
    if ( v2 == 0x434C4E47432B2B00LL )
    {
      *(_DWORD *)(v1 + 48) = -*(_DWORD *)(v1 + 48);
      ++*(_DWORD *)(globals + 8);
    }
    else
    {
      *(_QWORD *)globals = 0LL;
    }
    _Unwind_RaiseException();
    v3 = *(_QWORD *)(v1 + 96);
    v4 = __cxa_get_globals();
    if ( (v3 & 0xFFFFFFFFFFFFFF00LL) == 0x434C4E47432B2B00LL )
    {
      v5 = *(_DWORD *)(v1 + 48);
      if ( v5 < 0 )
        v5 = -v5;
      *(_DWORD *)(v1 + 48) = v5 + 1;
      if ( *(_QWORD *)v4 != v1 )
      {
        *(_QWORD *)(v1 + 40) = *(_QWORD *)v4;
        *(_QWORD *)v4 = v1;
      }
      --*(_DWORD *)(v4 + 8);
      if ( v2 == 0x434C4E47432B2B00LL )
LABEL_11:
        sub_8EC38(*(_QWORD *)(v1 + 32));
    }
    else if ( !*(_QWORD *)v4 )
    {
      *(_QWORD *)v4 = v1;
      if ( v2 == 0x434C4E47432B2B00LL )
        goto LABEL_11;
    }
  }
  std::terminate();
}
// 8EC38: using guessed type void __fastcall __noreturn sub_8EC38(_QWORD);

//----- (000000000008E830) ----------------------------------------------------
__int64 __fastcall _cxa_increment_exception_refcount(__int64 result)
{
  unsigned __int64 *v1; // x8
  unsigned __int64 v2; // x9

  if ( result )
  {
    v1 = (unsigned __int64 *)(result - 128);
    do
      v2 = __ldaxr(v1);
    while ( __stlxr(v2 + 1, v1) );
  }
  return result;
}

//----- (000000000008E84C) ----------------------------------------------------
unsigned __int64 **_cxa_current_primary_exception()
{
  unsigned __int64 **result; // x0
  unsigned __int64 *v1; // x8
  unsigned __int64 v2; // x9

  result = (unsigned __int64 **)__cxa_get_globals_fast();
  if ( result )
  {
    v1 = *result;
    if ( *result )
    {
      if ( v1[12] >> 8 == 0x434C4E47432B2BLL )
      {
        if ( (unsigned __int8)v1[12] == 1LL )
          v1 = (unsigned __int64 *)(*v1 - 128);
        result = (unsigned __int64 **)(v1 + 16);
        do
          v2 = __ldaxr(v1);
        while ( __stlxr(v2 + 1, v1) );
      }
      else
      {
        return 0LL;
      }
    }
    else
    {
      return 0LL;
    }
  }
  return result;
}

//----- (000000000008E8D0) ----------------------------------------------------
__int64 __fastcall _cxa_rethrow_primary_exception(__int64 result)
{
  __int64 v1; // x20
  __int64 v2; // x0
  __int64 v3; // x19
  unsigned __int64 *v4; // x21
  unsigned __int64 v5; // x8
  __int64 terminate; // x0
  __int64 globals; // x0
  __int64 v8; // x20
  int v9; // w8

  v1 = result;
  if ( !result )
    return result;
  v2 = sub_8F9C4(128LL);
  v3 = v2;
  if ( !v2 )
LABEL_14:
    std::terminate();
  v4 = (unsigned __int64 *)(v1 - 128);
  memset((void *)(v2 + 8), 0, 0x78uLL);
  *(_QWORD *)v3 = v1;
  do
    v5 = __ldaxr(v4);
  while ( __stlxr(v5 + 1, v4) );
  *(_QWORD *)(v3 + 8) = *(_QWORD *)(v1 - 120);
  *(_QWORD *)(v3 + 24) = std::get_unexpected();
  terminate = std::get_terminate();
  *(_QWORD *)(v3 + 96) = 0x434C4E47432B2B01LL;
  *(_QWORD *)(v3 + 32) = terminate;
  globals = __cxa_get_globals();
  ++*(_DWORD *)(globals + 8);
  *(_QWORD *)(v3 + 104) = sub_8E9E8;
  _Unwind_RaiseException();
  v8 = *(_QWORD *)(v3 + 96);
  result = __cxa_get_globals();
  if ( (v8 & 0xFFFFFFFFFFFFFF00LL) != 0x434C4E47432B2B00LL )
  {
    if ( !*(_QWORD *)result )
    {
      *(_QWORD *)result = v3;
      return result;
    }
    goto LABEL_14;
  }
  v9 = *(_DWORD *)(v3 + 48);
  if ( v9 < 0 )
    v9 = -v9;
  *(_DWORD *)(v3 + 48) = v9 + 1;
  if ( *(_QWORD *)result != v3 )
  {
    *(_QWORD *)(v3 + 40) = *(_QWORD *)result;
    *(_QWORD *)result = v3;
  }
  --*(_DWORD *)(result + 8);
  return result;
}
// 8E9E8: using guessed type __int64 __fastcall sub_8E9E8();
// 8F9C4: using guessed type __int64 __fastcall sub_8F9C4(_QWORD);

//----- (000000000008E9E8) ----------------------------------------------------
__int64 __fastcall sub_8E9E8(int a1, __int64 a2)
{
  __int64 v2; // x19
  __int64 v3; // x0
  unsigned __int64 *v4; // x20
  unsigned __int64 v5; // x8
  unsigned __int64 v6; // x8
  void (*v7)(void); // x8

  if ( a1 != 1 )
    sub_8EC38(*(_QWORD *)(a2 - 64));
  v2 = a2 - 96;
  v3 = *(_QWORD *)(a2 - 96);
  if ( v3 )
  {
    v4 = (unsigned __int64 *)(v3 - 128);
    do
    {
      v5 = __ldaxr(v4);
      v6 = v5 - 1;
    }
    while ( __stlxr(v6, v4) );
    if ( !v6 )
    {
      v7 = *(void (**)(void))(v3 - 112);
      if ( v7 )
        v7();
      _cxa_free_dependent_exception_0(v4);
    }
  }
  return _cxa_free_dependent_exception_0(v2);
}
// 8EC38: using guessed type void __fastcall __noreturn sub_8EC38(_QWORD);
// 8FB88: using guessed type __int64 __fastcall _cxa_free_dependent_exception_0(_QWORD);

//----- (000000000008EA54) ----------------------------------------------------
__int64 _cxa_uncaught_exception()
{
  __int64 result; // x0

  result = __cxa_get_globals_fast();
  if ( result )
    return *(_DWORD *)(result + 8) != 0;
  return result;
}

//----- (000000000008EA7C) ----------------------------------------------------
__int64 _cxa_uncaught_exceptions()
{
  __int64 result; // x0

  result = __cxa_get_globals_fast();
  if ( result )
    return *(unsigned int *)(result + 8);
  return result;
}

//----- (000000000008EA9C) ----------------------------------------------------
void *_cxa_get_globals()
{
  void *v0; // x19

  if ( pthread_once(&dword_69EA044, (void (*)(void))sub_8EB68) )
    sub_9035C("execute once failure in __cxa_get_globals_fast()");
  v0 = pthread_getspecific(dword_69EA040);
  if ( !v0 )
  {
    v0 = (void *)sub_8FB2C(1LL, 16LL);
    if ( !v0 )
      sub_9035C("cannot allocate __cxa_eh_globals");
    if ( pthread_setspecific(dword_69EA040, v0) )
      sub_9035C("std::__libcpp_tls_set failure in __cxa_get_globals()");
  }
  return v0;
}
// 8EB68: using guessed type __int64 __fastcall sub_8EB68();
// 8FB2C: using guessed type __int64 __fastcall sub_8FB2C(_QWORD, _QWORD);
// 69EA040: using guessed type int dword_69EA040;
// 69EA044: using guessed type pthread_once_t dword_69EA044;

//----- (000000000008EB2C) ----------------------------------------------------
void *_cxa_get_globals_fast()
{
  if ( pthread_once(&dword_69EA044, (void (*)(void))sub_8EB68) )
    sub_9035C("execute once failure in __cxa_get_globals_fast()");
  return pthread_getspecific(dword_69EA040);
}
// 8EB68: using guessed type __int64 __fastcall sub_8EB68();
// 69EA040: using guessed type int dword_69EA040;
// 69EA044: using guessed type pthread_once_t dword_69EA044;

//----- (000000000008EB68) ----------------------------------------------------
__int64 sub_8EB68()
{
  __int64 result; // x0

  result = pthread_key_create((pthread_key_t *)&dword_69EA040, (void (*)(void *))sub_8EB9C);
  if ( (_DWORD)result )
    sub_9035C("cannot create thread specific key for __cxa_get_globals()");
  return result;
}
// 8EB68: using guessed type __int64 sub_8EB68();
// 8EB9C: using guessed type __int64 __fastcall sub_8EB9C();
// 69EA040: using guessed type int dword_69EA040;

//----- (000000000008EB9C) ----------------------------------------------------
__int64 sub_8EB9C()
{
  __int64 result; // x0

  sub_8FCA4();
  result = pthread_setspecific(dword_69EA040, 0LL);
  if ( (_DWORD)result )
    sub_9035C("cannot zero out thread value for __cxa_get_globals()");
  return result;
}
// 8EB9C: using guessed type __int64 sub_8EB9C();
// 8FCA4: using guessed type __int64 sub_8FCA4(void);
// 69EA040: using guessed type int dword_69EA040;

//----- (000000000008EBD0) ----------------------------------------------------
unsigned __int64 std::get_unexpected(void)
{
  unsigned __int64 result; // x0

  do
    result = __ldaxr((unsigned __int64 *)&_cxa_unexpected_handler);
  while ( __stlxr(result, (unsigned __int64 *)&_cxa_unexpected_handler) );
  return result;
}
// 69EA018: using guessed type void (__fastcall __noreturn *_cxa_unexpected_handler)();

//----- (000000000008EBE8) ----------------------------------------------------
void __fastcall __noreturn sub_8EBE8(void (*a1)(void))
{
  a1();
  sub_9035C("unexpected_handler unexpectedly returned");
}

//----- (000000000008EC00) ----------------------------------------------------
void __noreturn std::unexpected(void)
{
  void (*v0)(void); // x0

  do
    v0 = (void (*)(void))__ldaxr((unsigned __int64 *)&_cxa_unexpected_handler);
  while ( __stlxr((unsigned __int64)v0, (unsigned __int64 *)&_cxa_unexpected_handler) );
  sub_8EBE8(v0);
}
// 69EA018: using guessed type void (__fastcall __noreturn *_cxa_unexpected_handler)();

//----- (000000000008EC20) ----------------------------------------------------
unsigned __int64 std::get_terminate(void)
{
  unsigned __int64 result; // x0

  do
    result = __ldaxr((unsigned __int64 *)&_cxa_terminate_handler);
  while ( __stlxr(result, (unsigned __int64 *)&_cxa_terminate_handler) );
  return result;
}
// 69EA010: using guessed type __int64 (__fastcall *_cxa_terminate_handler)();

//----- (000000000008EC38) ----------------------------------------------------
void __fastcall __noreturn sub_8EC38(void (*a1)(void))
{
  a1();
  sub_9035C("terminate_handler unexpectedly returned");
}
// 8EC78: using guessed type void __fastcall __noreturn sub_8EC78(_QWORD);

//----- (000000000008EC78) ----------------------------------------------------
void __fastcall __noreturn sub_8EC78(void *a1)
{
  __cxa_begin_catch(a1);
  std::terminate();
}

//----- (000000000008EC84) ----------------------------------------------------
void __noreturn std::terminate(void)
{
  __int64 *globals_fast; // x0
  __int64 v1; // x8
  void (*terminate)(void); // x0

  globals_fast = (__int64 *)__cxa_get_globals_fast();
  if ( globals_fast )
  {
    v1 = *globals_fast;
    if ( *globals_fast )
    {
      if ( *(_QWORD *)(v1 + 96) >> 8 == 0x434C4E47432B2BLL )
        sub_8EC38(*(void (**)(void))(v1 + 32));
    }
  }
  terminate = (void (*)(void))std::get_terminate();
  sub_8EC38(terminate);
}

//----- (000000000008ECCC) ----------------------------------------------------
unsigned __int64 __fastcall std::set_new_handler(void (*a1)(void))
{
  unsigned __int64 v1; // x8

  do
    v1 = __ldaxr(&_cxa_new_handler);
  while ( __stlxr((unsigned __int64)a1, &_cxa_new_handler) );
  return v1;
}
// 69EA048: using guessed type unsigned __int64 _cxa_new_handler;

//----- (000000000008ECE8) ----------------------------------------------------
unsigned __int64 std::get_new_handler(void)
{
  unsigned __int64 result; // x0

  do
    result = __ldaxr(&_cxa_new_handler);
  while ( __stlxr(result, &_cxa_new_handler) );
  return result;
}
// 69EA048: using guessed type unsigned __int64 _cxa_new_handler;

//----- (000000000008ED00) ----------------------------------------------------
__int64 __fastcall _gxx_personality_v0(int a1, __int64 a2, __int64 a3, _DWORD *a4, __int64 a5)
{
  bool v6; // zf
  __int64 result; // x0
  unsigned __int64 v8; // x21
  __int64 v9; // x0
  __int64 v10; // x1
  __int64 v11; // x2
  __int64 v12; // x3
  __int64 v13; // x4
  __int64 v14; // [xsp+8h] [xbp-68h] BYREF
  __int128 v15; // [xsp+10h] [xbp-60h]
  __int128 v16; // [xsp+20h] [xbp-50h]
  unsigned int v17; // [xsp+30h] [xbp-40h]
  __int64 v18; // [xsp+38h] [xbp-38h]

  v6 = a1 == 1;
  result = 3LL;
  v18 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( v6 && a4 && a5 )
  {
    v8 = a3 & 0xFFFFFFFFFFFFFF00LL;
    if ( (a2 & 1) != 0 )
    {
      sub_8EEDC(&v14, a2, v8 == 0x434C4E47432B2B00LL, a4, a5);
      result = v17;
      if ( v17 == 6 && v8 == 0x434C4E47432B2B00LL )
      {
        result = 6LL;
        *(a4 - 11) = v14;
        *(_OWORD *)(a4 - 10) = v15;
        *(_OWORD *)(a4 - 6) = v16;
      }
    }
    else
    {
      if ( (a2 & 2) == 0 )
        return 3LL;
      if ( (a2 & 4) != 0 )
      {
        if ( v8 == 0x434C4E47432B2B00LL )
        {
          v14 = (int)*(a4 - 11);
          v15 = *(_OWORD *)(a4 - 10);
          v16 = *(_OWORD *)(a4 - 6);
        }
        else
        {
          sub_8EEDC(&v14, a2, 0LL, a4, a5);
          if ( v17 != 6 )
          {
            v9 = sub_8F4D0(0, a4);
            return sub_8EEDC(v9, v10, v11, v12, v13);
          }
        }
      }
      else
      {
        sub_8EEDC(&v14, a2, v8 == 0x434C4E47432B2B00LL, a4, a5);
        result = v17;
        if ( v17 != 6 )
          return result;
      }
      _Unwind_SetGR();
      _Unwind_SetGR();
      _Unwind_SetIP();
      return 7LL;
    }
  }
  return result;
}
// 8EED9: variable 'v10' is possibly undefined
// 8EED9: variable 'v11' is possibly undefined
// 8EED9: variable 'v12' is possibly undefined
// 8EED9: variable 'v13' is possibly undefined
// 8EEDC: using guessed type __int64 __fastcall sub_8EEDC(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000008EEDC) ----------------------------------------------------
__int64 __fastcall sub_8EEDC(__int64 result, char a2, char a3, _QWORD *a4)
{
  __int64 v5; // x19
  unsigned __int8 *v6; // x24
  __int64 v7; // x26
  __int64 RegionStart; // x25
  __int64 v9; // x0
  unsigned __int8 *v10; // x9
  unsigned __int8 *v11; // x22
  unsigned __int8 *v12; // x8
  __int64 v13; // x10
  __int64 v14; // x9
  char v15; // t1
  unsigned __int8 *v16; // x28
  char *v17; // x21
  unsigned int v18; // w24
  __int64 v19; // x10
  __int64 v20; // x9
  unsigned __int64 v21; // x27
  char v22; // t1
  signed __int64 v23; // x23
  char *v24; // x20
  char *v25; // x9
  unsigned __int64 v26; // x25
  __int64 v27; // x26
  __int64 v28; // x10
  __int64 v29; // x8
  char v30; // t1
  __int64 v31; // x25
  __int64 v32; // x27
  unsigned __int64 v33; // x9
  __int64 v34; // x8
  char *v35; // x20
  char v36; // w10
  char v37; // t1
  bool v38; // w11
  __int64 v39; // x9
  __int64 v40; // x26
  _QWORD *v41; // x8
  __int64 v42; // x1
  char v43; // w8
  void *v44; // x1
  __int64 v45; // x24
  __int64 v46; // x9
  __int64 v47; // x8
  char v48; // t1
  __int64 v49; // x0
  __int64 v50; // x10
  unsigned __int64 v51; // x9
  __int64 v52; // x8
  char v53; // w11
  unsigned int v54; // w10
  _BOOL4 v55; // w11
  __int64 v56; // x9
  __int64 v57; // x8
  int v58; // w8
  __int64 v59; // x8
  int v60; // w0
  void *v61; // x1
  unsigned __int8 *v62; // [xsp+0h] [xbp-B0h]
  _QWORD *v63; // [xsp+18h] [xbp-98h]
  char v65; // [xsp+34h] [xbp-7Ch]
  unsigned int v67; // [xsp+3Ch] [xbp-74h]
  char *v68; // [xsp+40h] [xbp-70h] BYREF
  unsigned __int8 *v69; // [xsp+48h] [xbp-68h] BYREF
  _QWORD v70[2]; // [xsp+50h] [xbp-60h] BYREF

  v5 = result;
  v70[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  *(_QWORD *)(result + 32) = 0LL;
  *(_OWORD *)result = 0u;
  *(_OWORD *)(result + 16) = 0u;
  *(_DWORD *)(result + 40) = 3;
  if ( (a2 & 1) == 0 )
  {
    if ( (a2 & 2) != 0 )
    {
      if ( (~a2 & 0xC) == 0 )
      {
        *(_DWORD *)(result + 40) = 2;
        return result;
      }
      goto LABEL_8;
    }
LABEL_5:
    *(_DWORD *)(result + 40) = 3;
    return result;
  }
  if ( (a2 & 0xE) != 0 )
    goto LABEL_5;
LABEL_8:
  result = _Unwind_GetLanguageSpecificData();
  v6 = (unsigned __int8 *)result;
  v69 = (unsigned __int8 *)result;
  if ( !result )
  {
    *(_DWORD *)(v5 + 40) = 8;
    return result;
  }
  *(_QWORD *)(v5 + 16) = result;
  v7 = _Unwind_GetIP() - 1;
  v69 = v6 + 1;
  RegionStart = _Unwind_GetRegionStart();
  v9 = sub_8F870(&v69, *v6);
  v10 = v69;
  if ( v9 )
    v11 = (unsigned __int8 *)v9;
  else
    v11 = (unsigned __int8 *)RegionStart;
  v12 = ++v69;
  v65 = a3;
  v67 = *v10;
  if ( v67 == 255 )
  {
    v16 = 0LL;
  }
  else
  {
    v13 = 0LL;
    v14 = 0LL;
    do
    {
      v15 = *v12++;
      v14 |= (unsigned __int64)(v15 & 0x7F) << v13;
      v13 += 7LL;
    }
    while ( v15 < 0 );
    v16 = &v12[v14];
    v69 = v12;
  }
  v17 = (char *)(v12 + 1);
  v69 = v12 + 1;
  v18 = *v12;
  v19 = 0LL;
  v20 = 0LL;
  v21 = v7 - RegionStart;
  do
  {
    v22 = *v17++;
    v20 |= (unsigned __int64)(v22 & 0x7F) << v19;
    v19 += 7LL;
  }
  while ( v22 < 0 );
  v23 = (unsigned int)v20;
  v24 = &v17[(unsigned int)v20];
  v25 = v17;
  v68 = v17;
  v69 = (unsigned __int8 *)v17;
  do
  {
    if ( v25 >= v24 )
      break;
    v26 = sub_8F870(&v68, v18);
    v27 = sub_8F870(&v68, v18);
    result = sub_8F870(&v68, v18);
    v25 = v68;
    v28 = 0LL;
    v29 = 0LL;
    do
    {
      v30 = *v25++;
      v29 |= (unsigned __int64)(v30 & 0x7F) << v28;
      v28 += 7LL;
    }
    while ( v30 < 0 );
    v68 = v25;
    if ( v26 <= v21 && v21 < v27 + v26 )
      goto LABEL_28;
  }
  while ( v21 >= v26 );
LABEL_27:
  result = sub_8F4D0(v65 & 1, a4);
LABEL_28:
  if ( !result )
    goto LABEL_82;
  if ( !v29 )
  {
    if ( (a2 & 6) == 2 )
    {
      *(_QWORD *)v5 = 0LL;
      *(_QWORD *)(v5 + 24) = &v11[result];
LABEL_86:
      v58 = 6;
      goto LABEL_87;
    }
LABEL_82:
    v58 = 8;
LABEL_87:
    *(_DWORD *)(v5 + 40) = v58;
    return result;
  }
  v62 = &v11[result];
  v63 = a4 + 4;
  v31 = (v67 + 6) & 0xFLL;
  v32 = (__int64)&v17[v23 - 1 + v29];
  v17 = (char *)((0x747u >> v31) & 1);
  while ( 1 )
  {
    v33 = 0LL;
    v34 = 0LL;
    v35 = (char *)v32;
    do
    {
      v37 = *v35++;
      v36 = v37;
      v34 |= (unsigned __int64)(v37 & 0x7F) << v33;
      v33 += 7LL;
    }
    while ( v37 < 0 );
    v38 = v33 < 0x40;
    v39 = -1LL << v33;
    if ( (*(_DWORD *)&v38 & ((unsigned __int8)(v36 & 0x40) >> 6)) == 0 )
      v39 = 0LL;
    v40 = v34 | v39;
    if ( (v34 | v39) >= 1 )
    {
      v70[0] = v16;
      if ( !v16 || ((v67 + 6) & 0xF) > 0xA || !(_DWORD)v17 )
        goto LABEL_27;
      v70[0] = &v16[-(v40 << qword_69D0940[v31])];
      result = sub_8F870(v70, v67);
      if ( result )
      {
        if ( (v65 & 1) != 0 )
        {
          v41 = a4 + 4;
          if ( *a4 == 0x434C4E47432B2B01LL )
            v41 = (_QWORD *)*(a4 - 12);
          v70[0] = v41;
          if ( !v41 || (v42 = *(a4 - 11)) == 0 )
          {
            sub_8F4D0(1, a4);
LABEL_94:
            sub_8F4D0(0, a4);
LABEL_95:
            v60 = sub_8F4D0(1, v44);
            return sub_8F4D0(v60, v61);
          }
          result = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD *))(*(_QWORD *)result + 32LL))(result, v42, v70);
          if ( (result & 1) != 0 )
          {
            v43 = a2;
            if ( (a2 & 1) != 0 )
            {
              *(_QWORD *)v5 = v40;
              *(_QWORD *)(v5 + 8) = v32;
              *(_QWORD *)(v5 + 24) = v62;
              v59 = v70[0];
              *(_DWORD *)(v5 + 40) = 6;
              *(_QWORD *)(v5 + 32) = v59;
              return result;
            }
LABEL_73:
            if ( (v43 & 8) == 0 )
LABEL_92:
              sub_8F4D0(1, a4);
            goto LABEL_74;
          }
        }
      }
      else
      {
        if ( (a2 & 5) != 0 )
          goto LABEL_83;
        if ( (a2 & 8) == 0 )
          goto LABEL_27;
      }
      goto LABEL_74;
    }
    if ( (v40 & 0x8000000000000000LL) == 0 )
      break;
    if ( (v65 & 1) != 0 )
    {
      v44 = a4;
      v23 = (signed __int64)(a4 + 4);
      if ( *a4 == 0x434C4E47432B2B01LL )
        v23 = *(a4 - 12);
      if ( !v23 )
        goto LABEL_95;
      v45 = *(a4 - 11);
      if ( !v45 )
        goto LABEL_95;
      if ( !v16 )
        goto LABEL_94;
      v11 = &v16[~v40];
      while ( 1 )
      {
        v46 = 0LL;
        v47 = 0LL;
        do
        {
          v48 = *v11++;
          v47 |= (unsigned __int64)(v48 & 0x7F) << v46;
          v46 += 7LL;
        }
        while ( v48 < 0 );
        if ( !v47 )
          break;
        v70[0] = v16;
        if ( ((v67 + 6) & 0xF) > 0xA || !(_DWORD)v17 )
          goto LABEL_92;
        v70[0] = &v16[-(v47 << qword_69D0940[v31])];
        v49 = sub_8F870(v70, v67);
        v70[0] = v23;
        result = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD *))(*(_QWORD *)v49 + 32LL))(v49, v45, v70);
        if ( (result & 1) != 0 )
          goto LABEL_74;
      }
      v43 = a2;
      if ( (a2 & 1) != 0 )
      {
        *(_QWORD *)v5 = v40;
        *(_QWORD *)(v5 + 8) = v32;
        *(_QWORD *)(v5 + 24) = v62;
        *(_QWORD *)(v5 + 32) = v23;
        goto LABEL_86;
      }
      goto LABEL_73;
    }
    if ( (a2 & 5) != 0 )
    {
LABEL_83:
      *(_QWORD *)v5 = v40;
      *(_QWORD *)(v5 + 8) = v32;
      *(_QWORD *)(v5 + 24) = v62;
      if ( *a4 == 0x434C4E47432B2B01LL )
        v63 = (_QWORD *)*(a4 - 12);
      *(_QWORD *)(v5 + 32) = v63;
      goto LABEL_86;
    }
    if ( (a2 & 8) == 0 )
      goto LABEL_94;
LABEL_74:
    v50 = 0LL;
    v51 = 0LL;
    v52 = 0LL;
    do
    {
      v53 = v35[v50++];
      v52 |= (unsigned __int64)(v53 & 0x7F) << v51;
      v51 += 7LL;
    }
    while ( v53 < 0 );
    v54 = v53 & 0x40;
    v55 = v51 < 0x40;
    v56 = -1LL << v51;
    if ( (v55 & (v54 >> 6)) == 0 )
      v56 = 0LL;
    v57 = v52 | v56;
    if ( !v57 )
      goto LABEL_82;
    v32 = (__int64)&v35[v57];
  }
  if ( (a2 & 6) != 2 )
    goto LABEL_74;
  *(_QWORD *)v5 = v40;
  *(_QWORD *)(v5 + 8) = v32;
  *(_QWORD *)(v5 + 24) = v62;
  if ( *a4 == 0x434C4E47432B2B01LL )
    v63 = (_QWORD *)*(a4 - 12);
  *(_QWORD *)(v5 + 32) = v63;
  *(_DWORD *)(v5 + 40) = 6;
  return result;
}
// 8F0E4: variable 'v29' is possibly undefined
// 8F4CC: variable 'v44' is possibly undefined
// 8F4CD: variable 'v61' is possibly undefined
// 8F870: using guessed type __int64 __fastcall sub_8F870(_QWORD, _QWORD);
// 69D0940: using guessed type _QWORD qword_69D0940[11];

//----- (000000000008F4D0) ----------------------------------------------------
void __fastcall __noreturn sub_8F4D0(char a1, void *a2)
{
  __cxa_begin_catch(a2);
  if ( (a1 & 1) != 0 )
    sub_8EC38(*((void (**)(void))a2 - 8));
  std::terminate();
}

//----- (000000000008F4FC) ----------------------------------------------------
void __noreturn _cxa_call_unexpected(void *a1)
{
  void (*unexpected)(void); // x0
  __int64 v3; // [xsp+38h] [xbp-78h]

  if ( !a1 )
    sub_8F4D0(0, 0LL);
  __cxa_begin_catch(a1);
  if ( (*(_QWORD *)a1 & 0xFFFFFFFFFFFFFF00LL) == 0x434C4E47432B2B00LL )
  {
    unexpected = (void (*)(void))*((_QWORD *)a1 - 9);
    v3 = *((_QWORD *)a1 - 4);
  }
  else
  {
    std::get_terminate();
    unexpected = (void (*)(void))std::get_unexpected();
  }
  sub_8EBE8(unexpected);
}
// 8F870: using guessed type __int64 __fastcall sub_8F870(_QWORD, _QWORD);

//----- (000000000008F870) ----------------------------------------------------
unsigned __int64 __fastcall sub_8F870(unsigned __int16 **a1, unsigned int a2)
{
  unsigned __int16 *v2; // x10
  unsigned __int64 v3; // x8
  unsigned __int16 *v4; // x9
  int v5; // w11
  __int64 v6; // x11
  char v7; // t1
  unsigned __int64 v9; // x11
  __int64 v10; // x8
  char v11; // w12
  char v12; // t1
  bool v13; // w14
  __int64 v14; // x11

  if ( (_BYTE)a2 == 0xFF )
    return 0LL;
  v2 = *a1;
  switch ( a2 & 0xF )
  {
    case 0u:
    case 4u:
    case 0xCu:
      v4 = v2 + 4;
      v3 = *(_QWORD *)v2;
      v5 = (a2 >> 4) & 7;
      if ( !v5 )
        goto LABEL_12;
      goto LABEL_9;
    case 1u:
      v6 = 0LL;
      v3 = 0LL;
      v4 = *a1;
      do
      {
        v7 = *(_BYTE *)v4;
        v4 = (unsigned __int16 *)((char *)v4 + 1);
        v3 |= (unsigned __int64)(v7 & 0x7F) << v6;
        v6 += 7LL;
      }
      while ( v7 < 0 );
      v5 = (a2 >> 4) & 7;
      if ( v5 )
        goto LABEL_9;
      goto LABEL_12;
    case 2u:
      v4 = v2 + 1;
      v3 = *v2;
      v5 = (a2 >> 4) & 7;
      if ( !v5 )
        goto LABEL_12;
      goto LABEL_9;
    case 3u:
      v4 = v2 + 2;
      v3 = *(unsigned int *)v2;
      v5 = (a2 >> 4) & 7;
      if ( !v5 )
        goto LABEL_12;
      goto LABEL_9;
    case 9u:
      v9 = 0LL;
      v10 = 0LL;
      v4 = *a1;
      do
      {
        v12 = *(_BYTE *)v4;
        v4 = (unsigned __int16 *)((char *)v4 + 1);
        v11 = v12;
        v10 |= (unsigned __int64)(v12 & 0x7F) << v9;
        v9 += 7LL;
      }
      while ( v12 < 0 );
      v13 = v9 < 0x40;
      v14 = -1LL << v9;
      if ( (*(_DWORD *)&v13 & ((unsigned __int8)(v11 & 0x40) >> 6)) == 0 )
        v14 = 0LL;
      v3 = v10 | v14;
      v5 = (a2 >> 4) & 7;
      if ( !v5 )
        goto LABEL_12;
      goto LABEL_9;
    case 0xAu:
      v4 = v2 + 1;
      v3 = (__int16)*v2;
      v5 = (a2 >> 4) & 7;
      if ( !v5 )
        goto LABEL_12;
      goto LABEL_9;
    case 0xBu:
      v4 = v2 + 2;
      v3 = *(int *)v2;
      v5 = (a2 >> 4) & 7;
      if ( !v5 )
        goto LABEL_12;
LABEL_9:
      if ( v5 != 1 )
        goto LABEL_31;
      if ( v3 )
      {
        v3 += (unsigned __int64)v2;
LABEL_12:
        if ( (char)a2 < 0 && v3 )
          v3 = *(_QWORD *)v3;
      }
      *a1 = v4;
      break;
    default:
LABEL_31:
      abort();
  }
  return v3;
}

//----- (000000000008F9C4) ----------------------------------------------------
void *__fastcall sub_8F9C4(size_t a1)
{
  unsigned __int64 StatusReg; // x20
  size_t v2; // x19
  void *v4[2]; // [xsp+0h] [xbp-20h] BYREF

  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  if ( a1 )
    v2 = a1;
  else
    v2 = 1LL;
  v4[1] = *(void **)(StatusReg + 40);
  if ( posix_memalign(v4, 0x10uLL, v2) )
    return (void *)sub_8FA30(v2);
  else
    return v4[0];
}
// 8FA30: using guessed type __int64 __fastcall sub_8FA30(_QWORD);

//----- (000000000008FA30) ----------------------------------------------------
unsigned __int16 *__fastcall sub_8FA30(__int64 a1)
{
  int *v2; // x10
  unsigned __int16 *v3; // x19
  int *v4; // x13
  unsigned __int64 v5; // x12
  int *v6; // x11
  unsigned __int64 v7; // x10
  unsigned __int16 *v8; // x8
  __int64 v9; // x10

  pthread_mutex_lock(&stru_69EA050);
  v2 = (int *)qword_69EA078;
  if ( !qword_69EA078 )
  {
    v2 = dword_69EA080;
    qword_69EA078 = (__int64)dword_69EA080;
    dword_69EA080[0] = 8388736;
  }
  v3 = 0LL;
  if ( v2 && v2 != (int *)&byte_69EA280 )
  {
    v4 = 0LL;
    v5 = ((unsigned __int64)(a1 + 3) >> 2) + 1;
    while ( 1 )
    {
      v6 = v2;
      v7 = *((unsigned __int16 *)v2 + 1);
      if ( v5 < v7 )
      {
        *((_WORD *)v6 + 1) = v7 - v5;
        v8 = (unsigned __int16 *)&v6[(unsigned __int16)(v7 - v5)];
        *v8 = 0;
        v8[1] = v5;
        v3 = v8 + 2;
        goto LABEL_16;
      }
      if ( v5 == v7 )
        break;
      v3 = 0LL;
      v2 = &dword_69EA080[*(unsigned __int16 *)v6];
      if ( v2 )
      {
        v4 = v6;
        if ( &dword_69EA080[*(unsigned __int16 *)v6] != (int *)&byte_69EA280 )
          continue;
      }
      goto LABEL_16;
    }
    v9 = *(unsigned __int16 *)v6;
    if ( v4 )
      *(_WORD *)v4 = v9;
    else
      qword_69EA078 = (__int64)&dword_69EA080[v9];
    *(_WORD *)v6 = 0;
    v3 = (unsigned __int16 *)(v6 + 1);
  }
LABEL_16:
  pthread_mutex_unlock(&stru_69EA050);
  return v3;
}
// 69EA050: using guessed type pthread_mutex_t stru_69EA050;
// 69EA078: using guessed type __int64 qword_69EA078;
// 69EA080: using guessed type int dword_69EA080[];
// 69EA280: using guessed type char byte_69EA280;

//----- (000000000008FB2C) ----------------------------------------------------
void *__fastcall sub_8FB2C(size_t a1, size_t a2)
{
  void *v4; // x19
  size_t v5; // x20
  unsigned __int16 *v6; // x0

  v4 = calloc(a1, a2);
  if ( !v4 )
  {
    v5 = a2 * a1;
    v6 = sub_8FA30(v5);
    v4 = v6;
    if ( v6 )
      memset(v6, 0, v5);
  }
  return v4;
}

//----- (000000000008FB88) ----------------------------------------------------
void __fastcall _cxa_free_dependent_exception_0(int *a1)
{
  char *v2; // x20
  int *v3; // x12
  int *v4; // x11
  __int64 v5; // x13
  __int64 v6; // x14
  char *v7; // x13

  if ( a1 < dword_69EA080 || a1 >= (int *)&byte_69EA280 )
  {
    free(a1);
  }
  else
  {
    v2 = (char *)(a1 - 1);
    pthread_mutex_lock(&stru_69EA050);
    if ( !qword_69EA078 || (char *)qword_69EA078 == &byte_69EA280 )
    {
LABEL_12:
      *(_WORD *)v2 = ((unsigned int)qword_69EA078 - (unsigned int)dword_69EA080) >> 2;
      qword_69EA078 = (__int64)(a1 - 1);
    }
    else
    {
      v3 = 0LL;
      v4 = (int *)qword_69EA078;
      while ( 1 )
      {
        v5 = *((unsigned __int16 *)v4 + 1);
        if ( &v4[v5] == (int *)v2 )
        {
          *((_WORD *)v4 + 1) = *((_WORD *)a1 - 1) + v5;
          goto LABEL_17;
        }
        v6 = *((unsigned __int16 *)a1 - 1);
        if ( &v2[4 * v6] == (char *)v4 )
          break;
        v7 = (char *)&dword_69EA080[*(unsigned __int16 *)v4];
        if ( v7 )
        {
          v3 = v4;
          v4 = &dword_69EA080[*(unsigned __int16 *)v4];
          if ( v7 != &byte_69EA280 )
            continue;
        }
        goto LABEL_12;
      }
      *((_WORD *)a1 - 1) = v6 + v5;
      if ( v3 )
      {
        *(_WORD *)v3 = (unsigned __int64)(v2 - (char *)dword_69EA080) >> 2;
      }
      else
      {
        qword_69EA078 = (__int64)(a1 - 1);
        *(_WORD *)v2 = *(_WORD *)v4;
      }
    }
LABEL_17:
    pthread_mutex_unlock(&stru_69EA050);
  }
}
// 69EA050: using guessed type pthread_mutex_t stru_69EA050;
// 69EA078: using guessed type __int64 qword_69EA078;
// 69EA080: using guessed type int dword_69EA080[];
// 69EA280: using guessed type char byte_69EA280;

//----- (000000000008FCA4) ----------------------------------------------------
void __fastcall sub_8FCA4(void *p)
{
  if ( p >= dword_69EA080 && p < &byte_69EA280 )
    JUMPOUT(0x8FBACLL);
  free(p);
}
// 8FCC0: control flows out of bounds to 8FBAC
// 69EA080: using guessed type int dword_69EA080[];
// 69EA280: using guessed type char byte_69EA280;

//----- (000000000008FCD0) ----------------------------------------------------
const char *__fastcall std::exception::what(std::exception *this)
{
  return "std::exception";
}

//----- (000000000008FCE0) ----------------------------------------------------
const char *__fastcall std::bad_exception::what(std::bad_exception *this)
{
  return "std::bad_exception";
}

//----- (000000000008FCEC) ----------------------------------------------------
_QWORD *__fastcall std::bad_alloc::bad_alloc(_QWORD *this)
{
  *this = off_69E8910;
  return this;
}
// 69E8910: using guessed type void (__fastcall *[2])(std::exception *__hidden this);

//----- (000000000008FD04) ----------------------------------------------------
const char *__fastcall std::bad_alloc::what(std::bad_alloc *this)
{
  return "std::bad_alloc";
}

//----- (000000000008FD10) ----------------------------------------------------
_QWORD *__fastcall std::bad_array_new_length::bad_array_new_length(_QWORD *this)
{
  *this = off_69E8938;
  return this;
}
// 69E8938: using guessed type void (__fastcall *[2])(std::exception *__hidden this);

//----- (000000000008FD28) ----------------------------------------------------
const char *__fastcall std::bad_array_new_length::what(std::bad_array_new_length *this)
{
  return "bad_array_new_length";
}

//----- (000000000008FD34) ----------------------------------------------------
_QWORD *__fastcall std::bad_array_length::bad_array_length(_QWORD *this)
{
  *this = off_69E8960;
  return this;
}
// 69E8960: using guessed type void (__fastcall *[2])(std::exception *__hidden this);

//----- (000000000008FD4C) ----------------------------------------------------
const char *__fastcall std::bad_array_length::what(std::bad_array_length *this)
{
  return "bad_array_length";
}

//----- (000000000008FD58) ----------------------------------------------------
void *__fastcall operator new(size_t a1)
{
  size_t v1; // x19
  void *result; // x0
  void (*new_handler)(void); // x0
  std::bad_alloc *exception; // x19

  if ( a1 )
    v1 = a1;
  else
    v1 = 1LL;
  while ( 1 )
  {
    result = malloc(v1);
    if ( result )
      break;
    new_handler = (void (*)(void))std::get_new_handler();
    if ( !new_handler )
    {
      exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
      std::bad_alloc::bad_alloc(exception);
      __cxa_throw(
        exception,
        (struct type_info *)&`typeinfo for'std::bad_alloc,
        (void (*)(void *))std::exception::~exception);
    }
    new_handler();
  }
  return result;
}
// 69E8A00: using guessed type __int64 *`typeinfo for'std::bad_alloc;

//----- (000000000008FDBC) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
__int64 __fastcall operator new(unsigned __int64 a1, const std::nothrow_t *a2)
{
  return operator new(a1);
}
// 8FDE0: positive sp value 10 has been found

//----- (000000000008FDEC) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
__int64 __fastcall operator new[](unsigned __int64 a1, const std::nothrow_t *a2)
{
  return operator new[](a1);
}
// 8FE10: positive sp value 10 has been found

//----- (000000000008FE18) ----------------------------------------------------
void __fastcall operator delete(void *p)
{
  if ( p )
    free(p);
}

//----- (000000000008FE38) ----------------------------------------------------
void *__fastcall operator new(size_t a1, unsigned __int64 a2)
{
  unsigned __int64 StatusReg; // x21
  size_t v3; // x19
  size_t v4; // x20
  void (*new_handler)(void); // x0
  std::bad_alloc *exception; // x19
  void *v8[2]; // [xsp+0h] [xbp-30h] BYREF

  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  if ( a1 )
    v3 = a1;
  else
    v3 = 1LL;
  if ( a2 <= 8 )
    v4 = 8LL;
  else
    v4 = a2;
  v8[1] = *(void **)(StatusReg + 40);
  while ( posix_memalign(v8, v4, v3) )
  {
    new_handler = (void (*)(void))std::get_new_handler();
    if ( !new_handler )
    {
      exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
      std::bad_alloc::bad_alloc(exception);
      __cxa_throw(
        exception,
        (struct type_info *)&`typeinfo for'std::bad_alloc,
        (void (*)(void *))std::exception::~exception);
    }
    new_handler();
  }
  return v8[0];
}
// 69E8A00: using guessed type __int64 *`typeinfo for'std::bad_alloc;

//----- (000000000008FEE4) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
__int64 operator new()
{
  return operator new();
}
// 8FF08: positive sp value 10 has been found

//----- (000000000008FF14) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
__int64 operator new[]()
{
  return operator new[]();
}
// 8FF38: positive sp value 10 has been found

//----- (000000000008FF40) ----------------------------------------------------
void __fastcall operator delete(void *p)
{
  if ( p )
    free(p);
}

//----- (000000000008FF50) ----------------------------------------------------
__int64 operator delete()
{
  return operator delete();
}

//----- (000000000008FF60) ----------------------------------------------------
__int64 operator delete[]()
{
  return operator delete[]();
}

//----- (000000000008FF68) ----------------------------------------------------
void __fastcall std::invalid_argument::~invalid_argument(std::invalid_argument *this)
{
  __int64 v2; // x8
  unsigned int *v3; // x9
  unsigned int v4; // w10
  unsigned int v5; // w10

  v2 = *((_QWORD *)this + 1);
  *(_QWORD *)this = off_69E8A70;
  v3 = (unsigned int *)(v2 - 8);
  do
  {
    v4 = __ldaxr(v3);
    v5 = v4 - 1;
  }
  while ( __stlxr(v5, v3) );
  if ( (v5 & 0x80000000) != 0 )
    operator delete((void *)(v2 - 24));
  std::exception::~exception(this);
}
// 69E8A70: using guessed type void (__fastcall *[2])(std::invalid_argument *__hidden this);

//----- (000000000008FFBC) ----------------------------------------------------
void __fastcall std::logic_error::~logic_error(std::logic_error *this)
{
  __int64 v2; // x8
  unsigned int *v3; // x9
  unsigned int v4; // w10
  unsigned int v5; // w10

  v2 = *((_QWORD *)this + 1);
  *(_QWORD *)this = off_69E8A70;
  v3 = (unsigned int *)(v2 - 8);
  do
  {
    v4 = __ldaxr(v3);
    v5 = v4 - 1;
  }
  while ( __stlxr(v5, v3) );
  if ( (v5 & 0x80000000) != 0 )
    operator delete((void *)(v2 - 24));
  std::exception::~exception(this);
  operator delete(this);
}
// 69E8A70: using guessed type void (__fastcall *[2])(std::invalid_argument *__hidden this);

//----- (0000000000090018) ----------------------------------------------------
__int64 __fastcall std::logic_error::what(std::logic_error *this)
{
  return *((_QWORD *)this + 1);
}

//----- (0000000000090020) ----------------------------------------------------
void __fastcall std::underflow_error::~underflow_error(std::underflow_error *this)
{
  __int64 v2; // x8
  unsigned int *v3; // x9
  unsigned int v4; // w10
  unsigned int v5; // w10

  v2 = *((_QWORD *)this + 1);
  *(_QWORD *)this = off_69E8A98;
  v3 = (unsigned int *)(v2 - 8);
  do
  {
    v4 = __ldaxr(v3);
    v5 = v4 - 1;
  }
  while ( __stlxr(v5, v3) );
  if ( (v5 & 0x80000000) != 0 )
    operator delete((void *)(v2 - 24));
  std::exception::~exception(this);
}
// 69E8A98: using guessed type void (__fastcall *[2])(std::underflow_error *__hidden this);

//----- (0000000000090074) ----------------------------------------------------
void __fastcall std::runtime_error::~runtime_error(std::runtime_error *this)
{
  __int64 v2; // x8
  unsigned int *v3; // x9
  unsigned int v4; // w10
  unsigned int v5; // w10

  v2 = *((_QWORD *)this + 1);
  *(_QWORD *)this = off_69E8A98;
  v3 = (unsigned int *)(v2 - 8);
  do
  {
    v4 = __ldaxr(v3);
    v5 = v4 - 1;
  }
  while ( __stlxr(v5, v3) );
  if ( (v5 & 0x80000000) != 0 )
    operator delete((void *)(v2 - 24));
  std::exception::~exception(this);
  operator delete(this);
}
// 69E8A98: using guessed type void (__fastcall *[2])(std::underflow_error *__hidden this);

//----- (00000000000900D0) ----------------------------------------------------
__int64 __fastcall std::runtime_error::what(std::runtime_error *this)
{
  return *((_QWORD *)this + 1);
}

//----- (00000000000900D8) ----------------------------------------------------
void __fastcall std::domain_error::~domain_error(std::domain_error *this)
{
  __int64 v2; // x8
  unsigned int *v3; // x9
  unsigned int v4; // w10
  unsigned int v5; // w10

  v2 = *((_QWORD *)this + 1);
  *(_QWORD *)this = off_69E8A70;
  v3 = (unsigned int *)(v2 - 8);
  do
  {
    v4 = __ldaxr(v3);
    v5 = v4 - 1;
  }
  while ( __stlxr(v5, v3) );
  if ( (v5 & 0x80000000) != 0 )
    operator delete((void *)(v2 - 24));
  std::exception::~exception(this);
  operator delete(this);
}
// 69E8A70: using guessed type void (__fastcall *[2])(std::invalid_argument *__hidden this);

//----- (0000000000090134) ----------------------------------------------------
void __fastcall std::invalid_argument::~invalid_argument(std::invalid_argument *this)
{
  __int64 v2; // x8
  unsigned int *v3; // x9
  unsigned int v4; // w10
  unsigned int v5; // w10

  v2 = *((_QWORD *)this + 1);
  *(_QWORD *)this = off_69E8A70;
  v3 = (unsigned int *)(v2 - 8);
  do
  {
    v4 = __ldaxr(v3);
    v5 = v4 - 1;
  }
  while ( __stlxr(v5, v3) );
  if ( (v5 & 0x80000000) != 0 )
    operator delete((void *)(v2 - 24));
  std::exception::~exception(this);
  operator delete(this);
}
// 69E8A70: using guessed type void (__fastcall *[2])(std::invalid_argument *__hidden this);

//----- (0000000000090190) ----------------------------------------------------
void __fastcall std::length_error::~length_error(std::length_error *this)
{
  __int64 v2; // x8
  unsigned int *v3; // x9
  unsigned int v4; // w10
  unsigned int v5; // w10

  v2 = *((_QWORD *)this + 1);
  *(_QWORD *)this = off_69E8A70;
  v3 = (unsigned int *)(v2 - 8);
  do
  {
    v4 = __ldaxr(v3);
    v5 = v4 - 1;
  }
  while ( __stlxr(v5, v3) );
  if ( (v5 & 0x80000000) != 0 )
    operator delete((void *)(v2 - 24));
  std::exception::~exception(this);
  operator delete(this);
}
// 69E8A70: using guessed type void (__fastcall *[2])(std::invalid_argument *__hidden this);

//----- (00000000000901EC) ----------------------------------------------------
void __fastcall std::out_of_range::~out_of_range(std::out_of_range *this)
{
  __int64 v2; // x8
  unsigned int *v3; // x9
  unsigned int v4; // w10
  unsigned int v5; // w10

  v2 = *((_QWORD *)this + 1);
  *(_QWORD *)this = off_69E8A70;
  v3 = (unsigned int *)(v2 - 8);
  do
  {
    v4 = __ldaxr(v3);
    v5 = v4 - 1;
  }
  while ( __stlxr(v5, v3) );
  if ( (v5 & 0x80000000) != 0 )
    operator delete((void *)(v2 - 24));
  std::exception::~exception(this);
  operator delete(this);
}
// 69E8A70: using guessed type void (__fastcall *[2])(std::invalid_argument *__hidden this);

//----- (0000000000090248) ----------------------------------------------------
void __fastcall std::range_error::~range_error(std::range_error *this)
{
  __int64 v2; // x8
  unsigned int *v3; // x9
  unsigned int v4; // w10
  unsigned int v5; // w10

  v2 = *((_QWORD *)this + 1);
  *(_QWORD *)this = off_69E8A98;
  v3 = (unsigned int *)(v2 - 8);
  do
  {
    v4 = __ldaxr(v3);
    v5 = v4 - 1;
  }
  while ( __stlxr(v5, v3) );
  if ( (v5 & 0x80000000) != 0 )
    operator delete((void *)(v2 - 24));
  std::exception::~exception(this);
  operator delete(this);
}
// 69E8A98: using guessed type void (__fastcall *[2])(std::underflow_error *__hidden this);

//----- (00000000000902A4) ----------------------------------------------------
void __fastcall std::overflow_error::~overflow_error(std::overflow_error *this)
{
  __int64 v2; // x8
  unsigned int *v3; // x9
  unsigned int v4; // w10
  unsigned int v5; // w10

  v2 = *((_QWORD *)this + 1);
  *(_QWORD *)this = off_69E8A98;
  v3 = (unsigned int *)(v2 - 8);
  do
  {
    v4 = __ldaxr(v3);
    v5 = v4 - 1;
  }
  while ( __stlxr(v5, v3) );
  if ( (v5 & 0x80000000) != 0 )
    operator delete((void *)(v2 - 24));
  std::exception::~exception(this);
  operator delete(this);
}
// 69E8A98: using guessed type void (__fastcall *[2])(std::underflow_error *__hidden this);

//----- (0000000000090300) ----------------------------------------------------
void __fastcall std::underflow_error::~underflow_error(std::underflow_error *this)
{
  __int64 v2; // x8
  unsigned int *v3; // x9
  unsigned int v4; // w10
  unsigned int v5; // w10

  v2 = *((_QWORD *)this + 1);
  *(_QWORD *)this = off_69E8A98;
  v3 = (unsigned int *)(v2 - 8);
  do
  {
    v4 = __ldaxr(v3);
    v5 = v4 - 1;
  }
  while ( __stlxr(v5, v3) );
  if ( (v5 & 0x80000000) != 0 )
    operator delete((void *)(v2 - 24));
  std::exception::~exception(this);
  operator delete(this);
}
// 69E8A98: using guessed type void (__fastcall *[2])(std::underflow_error *__hidden this);

//----- (000000000009035C) ----------------------------------------------------
void __noreturn sub_9035C(char *format, ...)
{
  gcc_va_list va2; // [xsp+C0h] [xbp-E0h] BYREF
  gcc_va_list va; // [xsp+E8h] [xbp-B8h] BYREF
  char *ptr; // [xsp+108h] [xbp-98h] BYREF
  gcc_va_list arg; // [xsp+110h] [xbp-90h] BYREF
  gcc_va_list va1; // [xsp+130h] [xbp-70h] BYREF

  va_start(va, format);
  va_start(va1, format);
  va_copy(arg, va1);
  vfprintf((FILE *)((char *)&_sF + 304), format, arg);
  fputc(10, (FILE *)((char *)&_sF + 304));
  va_copy(va2, va);
  vasprintf(&ptr, format, va2);
  android_set_abort_message();
  openlog("libc++abi", 0, 0);
  syslog(2, "%s", ptr);
  closelog();
  abort();
}

//----- (0000000000090458) ----------------------------------------------------
unsigned __int64 __fastcall std::set_unexpected(void (__fastcall __noreturn *a1)())
{
  void (__fastcall __noreturn *v1)(); // x8
  unsigned __int64 result; // x0

  v1 = sub_905D0;
  if ( a1 )
    v1 = a1;
  do
    result = __ldaxr((unsigned __int64 *)&_cxa_unexpected_handler);
  while ( __stlxr((unsigned __int64)v1, (unsigned __int64 *)&_cxa_unexpected_handler) );
  return result;
}
// 905D0: using guessed type void __fastcall __noreturn sub_905D0();
// 69EA018: using guessed type void (__fastcall __noreturn *_cxa_unexpected_handler)();

//----- (0000000000090480) ----------------------------------------------------
unsigned __int64 __fastcall std::set_terminate(__int64 (__fastcall *a1)())
{
  __int64 (__fastcall *v1)(); // x8
  unsigned __int64 result; // x0

  v1 = sub_904A8;
  if ( a1 )
    v1 = a1;
  do
    result = __ldaxr((unsigned __int64 *)&_cxa_terminate_handler);
  while ( __stlxr((unsigned __int64)v1, (unsigned __int64 *)&_cxa_terminate_handler) );
  return result;
}
// 904A8: using guessed type __int64 __fastcall sub_904A8();
// 69EA010: using guessed type __int64 (__fastcall *_cxa_terminate_handler)();

//----- (00000000000904A8) ----------------------------------------------------
void __noreturn sub_904A8()
{
  _QWORD **globals_fast; // x0
  _QWORD *v1; // x8
  unsigned __int64 v2; // x9
  _QWORD *v3; // x9
  const char **v4; // x20
  char *v5; // x19
  const char *v6; // x20
  const char *v7; // x0
  size_t v8; // [xsp+0h] [xbp-430h] BYREF
  char out[1024]; // [xsp+Ch] [xbp-424h] BYREF
  int status; // [xsp+40Ch] [xbp-24h] BYREF
  _QWORD *v11; // [xsp+418h] [xbp-18h]

  globals_fast = (_QWORD **)__cxa_get_globals_fast();
  if ( !globals_fast || (v1 = *globals_fast) == 0LL )
    sub_9035C("terminating");
  v2 = v1[12];
  if ( v2 >> 8 == 0x434C4E47432B2BLL )
  {
    if ( v2 == 0x434C4E47432B2B01LL )
      v3 = (_QWORD *)*v1;
    else
      v3 = v1 + 16;
    v11 = v3;
    v4 = (const char **)v1[1];
    v8 = 1024LL;
    v5 = __cxa_demangle(v4[1], out, &v8, &status);
    if ( status )
      v5 = (char *)v4[1];
    if ( (sub_B6770((int)&`typeinfo for'std::exception, v4) & 1) != 0 )
    {
      v6 = off_69EA020;
      v7 = (const char *)(*(__int64 (__fastcall **)(_QWORD *))(*v11 + 16LL))(v11);
      sub_9035C("terminating with %s exception of type %s: %s", v6, v5, v7);
    }
    sub_9035C("terminating with %s exception of type %s", off_69EA020, v5);
  }
  sub_9035C("terminating with %s foreign exception", off_69EA020);
}
// 69E89A0: using guessed type __int64 *`typeinfo for'std::exception;
// 69EA020: using guessed type char *off_69EA020;

//----- (00000000000905D0) ----------------------------------------------------
void __noreturn sub_905D0()
{
  off_69EA020 = "unexpected";
  std::terminate();
}
// 905D0: using guessed type void __noreturn sub_905D0();
// 69EA020: using guessed type char *off_69EA020;

//----- (00000000000905EC) ----------------------------------------------------
char *_cxa_demangle(const char *lpmangled, char *lpout, size_t *lpoutlen, int *lpstatus)
{
  char *v6; // x19
  size_t v8; // x26
  size_t v9; // x0
  const char *v10; // x23
  int v11; // w8
  char *v12; // x21
  char *v13; // x20
  _QWORD *v14; // x0
  _QWORD *v15; // x20
  _QWORD *v16; // x24
  _QWORD *v17; // x27
  _QWORD *v18; // x28
  char *v19; // x24
  char *v20; // x27
  _QWORD *v21; // x21
  _QWORD *v22; // x0
  _QWORD *v23; // x22
  unsigned __int64 v25; // x8
  unsigned __int64 v26; // x8
  unsigned __int64 v27; // x10
  unsigned __int64 v28; // x9
  size_t v29; // x22
  size_t v30; // x23
  unsigned __int64 v31; // x9
  bool v32; // zf
  size_t v33; // x9
  char *v34; // x1
  size_t v35; // x2
  char *v36; // x1
  void *v37; // [xsp+8h] [xbp-1108h] BYREF
  _QWORD *v38; // [xsp+10h] [xbp-1100h]
  __int64 v39; // [xsp+18h] [xbp-10F8h]
  _QWORD *v40; // [xsp+20h] [xbp-10F0h]
  void *p; // [xsp+28h] [xbp-10E8h]
  char *v42; // [xsp+30h] [xbp-10E0h]
  __int64 v43; // [xsp+38h] [xbp-10D8h]
  _QWORD *v44; // [xsp+40h] [xbp-10D0h]
  _QWORD *v45; // [xsp+48h] [xbp-10C8h] BYREF
  _QWORD *v46; // [xsp+50h] [xbp-10C0h]
  _QWORD *v47; // [xsp+58h] [xbp-10B8h]
  _BYTE v48[21]; // [xsp+60h] [xbp-10B0h] BYREF
  __int16 v49; // [xsp+75h] [xbp-109Bh]
  char v50; // [xsp+77h] [xbp-1099h]
  _QWORD v51[5]; // [xsp+78h] [xbp-1098h] BYREF
  _QWORD v52[4]; // [xsp+A0h] [xbp-1070h] BYREF
  _QWORD v53[512]; // [xsp+C0h] [xbp-1050h] BYREF

  v6 = lpout;
  v53[511] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( !lpmangled || lpout && !lpoutlen )
  {
    v6 = 0LL;
    if ( lpstatus )
      *lpstatus = -3;
    return v6;
  }
  if ( lpout )
    v8 = *lpoutlen;
  else
    v8 = 0LL;
  v51[4] = v48;
  memset(v52, 0, 24);
  v40 = v52;
  p = 0LL;
  v44 = v52;
  *(_QWORD *)v48 = v52;
  memset(&v48[8], 0, 13);
  v49 = 1;
  v50 = 1;
  v52[3] = v52;
  v38 = 0LL;
  v39 = 0LL;
  v37 = 0LL;
  v42 = 0LL;
  v43 = 0LL;
  v53[508] = v53;
  v45 = v52;
  v46 = v53;
  v47 = v53;
  memset(v51, 0, 32);
  sub_B2A24(v51);
  LODWORD(v51[0]) = 0;
  v9 = strlen(lpmangled);
  v10 = &lpmangled[v9];
  sub_90B64(lpmangled, &lpmangled[v9], &v37, v51);
  v11 = v51[0];
  if ( LODWORD(v51[0]) )
  {
LABEL_11:
    v6 = 0LL;
    if ( !lpstatus )
      goto LABEL_13;
    goto LABEL_12;
  }
  if ( HIBYTE(v49) && v45 != v46 && *v45 != v45[1] )
  {
    v16 = v37;
    v17 = v38;
    v49 = 0;
    if ( v38 != v37 )
    {
      do
      {
        if ( (*(_BYTE *)(v17 - 3) & 1) != 0 )
          free((void *)*(v17 - 1));
        v18 = v17 - 6;
        if ( (*(_BYTE *)(v17 - 6) & 1) != 0 )
          free((void *)*(v17 - 4));
        v17 -= 6;
      }
      while ( v16 != v18 );
    }
    v38 = v16;
    v20 = (char *)p;
    v19 = v42;
    if ( v42 != p )
    {
      do
      {
        v19 -= 32;
        sub_9D32C(v19);
      }
      while ( v20 != v19 );
    }
    v42 = v20;
    sub_90B64(lpmangled, v10, &v37, v51);
    if ( HIBYTE(v49) )
    {
      v11 = -2;
      v6 = 0LL;
      LODWORD(v51[0]) = -2;
      if ( !lpstatus )
        goto LABEL_13;
LABEL_12:
      *lpstatus = v11;
      goto LABEL_13;
    }
    v11 = v51[0];
    if ( LODWORD(v51[0]) )
      goto LABEL_11;
  }
  v25 = *((unsigned __int8 *)v38 - 48);
  if ( (v25 & 1) != 0 )
  {
    v26 = *(v38 - 5);
    v27 = *((unsigned __int8 *)v38 - 24);
    if ( (v27 & 1) != 0 )
      goto LABEL_54;
  }
  else
  {
    v26 = v25 >> 1;
    v27 = *((unsigned __int8 *)v38 - 24);
    if ( (v27 & 1) != 0 )
    {
LABEL_54:
      v28 = *(v38 - 2);
      goto LABEL_57;
    }
  }
  v28 = v27 >> 1;
LABEL_57:
  v29 = v28 + v26;
  v30 = v28 + v26 + 1;
  if ( v30 <= v8 )
  {
    if ( v6 )
      goto LABEL_62;
    v11 = 0;
    if ( lpstatus )
      goto LABEL_12;
  }
  else
  {
    v6 = (char *)realloc(v6, v28 + v26 + 1);
    if ( v6 )
    {
      if ( lpoutlen )
        *lpoutlen = v30;
LABEL_62:
      v31 = *((unsigned __int8 *)v38 - 24);
      v32 = (v31 & 1) == 0;
      v33 = v31 >> 1;
      if ( v32 )
        v34 = (char *)v38 - 23;
      else
        v34 = (char *)*(v38 - 1);
      if ( v32 )
        v35 = v33;
      else
        v35 = *(v38 - 2);
      sub_9CFD0((_DWORD)v38 - 48, v34, v35);
      if ( (*(_BYTE *)(v38 - 6) & 1) != 0 )
        v36 = (char *)*(v38 - 4);
      else
        v36 = (char *)v38 - 47;
      memcpy(v6, v36, v29);
      v11 = 0;
      v6[v29] = 0;
      if ( lpstatus )
        goto LABEL_12;
      goto LABEL_13;
    }
    v11 = -1;
    LODWORD(v51[0]) = -1;
    if ( lpstatus )
      goto LABEL_12;
  }
LABEL_13:
  sub_B64BC(&v45);
  v12 = (char *)p;
  if ( !p )
    goto LABEL_37;
  v13 = v42;
  v14 = p;
  if ( v42 != p )
  {
    do
    {
      v13 -= 32;
      sub_9D32C(v13);
    }
    while ( v12 != v13 );
    v14 = p;
  }
  v42 = v12;
  if ( v44 + 512 < v14 || v44 > v14 )
  {
    free(v14);
LABEL_37:
    v15 = v37;
    if ( !v37 )
      return v6;
    goto LABEL_38;
  }
  if ( v44[512] != v43 )
    goto LABEL_37;
  v44[512] = v14;
  v15 = v37;
  if ( !v37 )
    return v6;
LABEL_38:
  v21 = v38;
  v22 = v15;
  if ( v38 != v15 )
  {
    do
    {
      if ( (*(_BYTE *)(v21 - 3) & 1) != 0 )
        free((void *)*(v21 - 1));
      v23 = v21 - 6;
      if ( (*(_BYTE *)(v21 - 6) & 1) != 0 )
        free((void *)*(v21 - 4));
      v21 -= 6;
    }
    while ( v15 != v23 );
    v22 = v37;
  }
  v38 = v15;
  if ( v40 + 512 < v22 || v40 > v22 )
  {
    free(v22);
  }
  else if ( v40[512] == v39 )
  {
    v40[512] = v22;
  }
  return v6;
}
// 90B64: using guessed type __int64 __fastcall sub_90B64(_QWORD, _QWORD, _QWORD, _QWORD);
// 9D32C: using guessed type __int64 __fastcall sub_9D32C(_QWORD);
// B2A24: using guessed type __int64 __fastcall sub_B2A24(_QWORD);
// B64BC: using guessed type __int64 __fastcall sub_B64BC(_QWORD);

//----- (0000000000090B64) ----------------------------------------------------
void __fastcall sub_90B64(_BYTE *a1, unsigned __int64 a2, _QWORD *a3, _DWORD *a4)
{
  int v7; // w8
  _BYTE *v8; // x23
  _BYTE *v9; // x0
  unsigned __int64 v10; // x22
  unsigned __int64 v11; // x25
  _BYTE *v12; // x0
  _BYTE *v13; // x0
  _BYTE *v14; // x22
  _BYTE *v15; // x8
  _BYTE *v16; // x22
  char *v17; // x8
  unsigned __int64 v18; // x9
  unsigned __int64 v19; // x10
  _BYTE *v20; // x11
  _OWORD *v21; // x12
  __int128 *v22; // x13
  unsigned __int64 v23; // x14
  __int128 v24; // q0
  __int128 v25; // q1
  _BYTE *v26; // x9
  char v27; // t1
  void *v28; // x8
  __int128 v29; // q0
  __int128 v30; // q0
  char *v31; // x8
  char v32; // w22
  void *v33; // x21
  char *v34; // x1
  size_t v35; // x2
  __int64 v36; // x8
  __int128 v37; // [xsp+8h] [xbp-98h] BYREF
  void *v38; // [xsp+18h] [xbp-88h]
  __int128 v39; // [xsp+20h] [xbp-80h] BYREF
  void *p; // [xsp+30h] [xbp-70h]
  __int128 v41; // [xsp+40h] [xbp-60h] BYREF
  char *v42; // [xsp+50h] [xbp-50h]
  __int64 v43; // [xsp+58h] [xbp-48h]

  v43 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( (unsigned __int64)a1 >= a2 )
    goto LABEL_15;
  if ( *a1 != 95 )
  {
    v13 = (_BYTE *)sub_925FC();
    goto LABEL_14;
  }
  if ( (__int64)(a2 - (_QWORD)a1) < 4 )
    goto LABEL_15;
  v7 = (unsigned __int8)a1[1];
  if ( v7 == 95 )
  {
    if ( a1[2] != 95 )
      goto LABEL_15;
    if ( a1[3] != 90 )
      goto LABEL_15;
    v14 = a1 + 4;
    v13 = (_BYTE *)sub_91038(a1 + 4, a2, a3);
    if ( v13 == v14 || v13 == (_BYTE *)a2 )
      goto LABEL_15;
    if ( (__int64)(a2 - (_QWORD)v13) >= 13
      && *v13 == 95
      && v13[1] == 98
      && v13[2] == 108
      && v13[3] == 111
      && v13[4] == 99
      && v13[5] == 107
      && v13[6] == 95
      && v13[7] == 105
      && v13[8] == 110
      && v13[9] == 118
      && v13[10] == 111
      && v13[11] == 107
      && v13[12] == 101 )
    {
      v15 = v13 + 13;
      v16 = (_BYTE *)a2;
      if ( v13 + 13 != (_BYTE *)a2 )
      {
        if ( *v15 == 95 )
        {
          if ( v13 + 14 == (_BYTE *)a2 || (unsigned int)(unsigned __int8)v13[14] - 48 > 9 )
            goto LABEL_14;
          v15 = v13 + 15;
        }
        v16 = (_BYTE *)a2;
        if ( v15 != (_BYTE *)a2 )
        {
          while ( (unsigned int)(unsigned __int8)*v15 - 48 <= 9 )
          {
            if ( (_BYTE *)a2 == ++v15 )
            {
              v16 = (_BYTE *)a2;
              goto LABEL_76;
            }
          }
          v16 = v15;
        }
      }
LABEL_76:
      v36 = a3[1];
      if ( *a3 != v36 )
      {
        sub_9CDD8(v36 - 48, 0, "invocation function for block in ", 0x21uLL);
        if ( v16 == (_BYTE *)a2 )
          goto LABEL_45;
LABEL_15:
        *a4 = -2;
        return;
      }
    }
LABEL_14:
    if ( v13 == (_BYTE *)a2 )
      goto LABEL_45;
    goto LABEL_15;
  }
  if ( v7 != 90 )
    goto LABEL_15;
  v8 = a1 + 2;
  v9 = (_BYTE *)sub_91038(a1 + 2, a2, a3);
  v10 = (unsigned __int64)v9;
  if ( v9 == v8 || v9 == (_BYTE *)a2 || *v9 != 46 || *a3 == a3[1] )
  {
    if ( v9 == (_BYTE *)a2 )
      goto LABEL_45;
    goto LABEL_15;
  }
  v11 = a2 - (_QWORD)v9;
  v38 = 0LL;
  v37 = 0uLL;
  if ( a2 - (unsigned __int64)v9 >= 0xFFFFFFFFFFFFFFF0LL )
    abort();
  if ( v11 > 0x16 )
  {
    v12 = malloc((v11 + 16) & 0xFFFFFFFFFFFFFFF0LL);
    *((_QWORD *)&v37 + 1) = a2 - v10;
    v38 = v12;
    *(_QWORD *)&v37 = (v11 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
  }
  else
  {
    LOBYTE(v37) = 2 * v11;
    v12 = (char *)&v37 + 1;
  }
  v17 = (char *)(v10 + 1);
  *v12 = 46;
  if ( v10 + 1 != a2 )
  {
    v18 = a2 + ~v10;
    if ( v18 >= 0x20 && (v19 = v18 & 0xFFFFFFFFFFFFFFE0LL, (v18 & 0xFFFFFFFFFFFFFFE0LL) != 0) )
    {
      if ( (unsigned __int64)(v12 + 1) >= a2 || (v20 = v12, v17 >= &v12[v11]) )
      {
        v17 += v19;
        v20 = &v12[v19];
        v21 = v12 + 17;
        v22 = (__int128 *)(v10 + 17);
        v23 = v18 & 0xFFFFFFFFFFFFFFE0LL;
        do
        {
          v24 = *(v22 - 1);
          v25 = *v22;
          v23 -= 32LL;
          v22 += 2;
          *(v21 - 1) = v24;
          *v21 = v25;
          v21 += 2;
        }
        while ( v23 );
        if ( v19 == v18 )
          goto LABEL_61;
      }
    }
    else
    {
      v20 = v12;
    }
    v26 = v20 + 1;
    do
    {
      v27 = *v17++;
      *v26++ = v27;
    }
    while ( (char *)a2 != v17 );
  }
LABEL_61:
  v12[v11] = 0;
  sub_9CDD8((int)&v37, 0, " (", 2uLL);
  v28 = v38;
  v29 = v37;
  v38 = 0LL;
  v37 = 0uLL;
  p = v28;
  v39 = v29;
  sub_9CFD0((int)&v39, ")", 1uLL);
  v30 = v39;
  v31 = (char *)p;
  p = 0LL;
  v39 = 0uLL;
  v41 = v30;
  v42 = v31;
  v32 = v30;
  v33 = v31;
  if ( (v30 & 1) != 0 )
    v34 = v31;
  else
    v34 = (char *)&v41 + 1;
  if ( (v30 & 1) != 0 )
    v35 = *((_QWORD *)&v30 + 1);
  else
    v35 = (unsigned __int64)(unsigned __int8)v30 >> 1;
  sub_9CFD0(*((_DWORD *)a3 + 2) - 48, v34, v35);
  if ( (v32 & 1) == 0 )
  {
    if ( (v39 & 1) == 0 )
      goto LABEL_69;
LABEL_72:
    free(p);
    if ( (v37 & 1) != 0 )
      goto LABEL_73;
    goto LABEL_45;
  }
  free(v33);
  if ( (v39 & 1) != 0 )
    goto LABEL_72;
LABEL_69:
  if ( (v37 & 1) != 0 )
  {
LABEL_73:
    free(v38);
    if ( *a4 )
      return;
    goto LABEL_46;
  }
LABEL_45:
  if ( *a4 )
    return;
LABEL_46:
  if ( *a3 == a3[1] )
    goto LABEL_15;
}
// 91038: using guessed type __int64 __fastcall sub_91038(_QWORD, _QWORD, _QWORD);
// 925FC: using guessed type __int64 sub_925FC(void);

//----- (0000000000091038) ----------------------------------------------------
unsigned __int8 *__fastcall sub_91038(unsigned __int8 *a1, unsigned __int8 *a2, __int64 *a3)
{
  unsigned __int8 *v4; // x20
  int v6; // w28
  char v7; // w27
  int v8; // w8
  int v9; // w8
  unsigned __int8 *v10; // x24
  unsigned __int8 *v11; // x22
  unsigned __int8 *v12; // x0
  unsigned __int8 *v13; // x8
  int v14; // w9
  unsigned __int8 *v15; // x8
  _BYTE *v16; // x23
  __int64 v17; // x22
  __int64 v18; // x8
  unsigned __int64 v19; // x9
  size_t v20; // x10
  void *v21; // x11
  int v22; // w0
  void *v23; // x8
  bool v24; // zf
  size_t v25; // x9
  void *v26; // x1
  size_t v27; // x2
  __int64 v28; // x0
  __int64 v29; // x23
  _BYTE *v30; // x21
  _BYTE *v31; // x8
  void *v32; // x8
  __int128 v33; // q0
  void *v34; // x8
  __int128 v35; // q0
  __int64 v36; // x8
  unsigned __int64 v37; // x9
  size_t v38; // x10
  void *v39; // x11
  int v40; // w0
  void *v41; // x8
  bool v42; // zf
  size_t v43; // x9
  void *v44; // x1
  size_t v45; // x2
  __int64 v46; // x0
  char v47; // w28
  char *v48; // x1
  size_t v49; // x2
  __int64 v50; // x9
  __int64 v51; // x8
  void *v52; // x10
  __int64 v53; // x23
  __int64 *v54; // x27
  const void **v55; // x26
  unsigned __int8 *v56; // x0
  unsigned __int8 *v57; // x22
  int v58; // w8
  int v59; // w8
  unsigned __int8 *v60; // x23
  __int64 v61; // x8
  int v62; // w10
  int v63; // w23
  char v64; // w26
  __int64 v65; // x8
  unsigned __int64 v66; // x9
  unsigned __int8 *v67; // x23
  __int64 v68; // x8
  __int64 v69; // x24
  __int64 v70; // x8
  __int64 v71; // x23
  unsigned __int8 *v72; // x8
  unsigned __int8 *v73; // x9
  int v74; // w10
  unsigned __int8 *v75; // x9
  int v76; // w8
  unsigned __int8 *v77; // x9
  int v78; // t1
  unsigned __int8 *v79; // x23
  __int64 v80; // x8
  int v81; // w0
  unsigned __int8 *v82; // x23
  __int64 v83; // x8
  unsigned __int8 *v84; // x23
  __int64 v85; // x8
  unsigned __int8 *v86; // x23
  __int64 v87; // x8
  unsigned __int8 *v88; // x23
  __int64 v89; // x8
  unsigned __int8 *v90; // x9
  int v91; // w8
  unsigned __int8 *v92; // x8
  unsigned __int8 *v93; // x10
  int v94; // w11
  unsigned __int8 *v95; // x10
  unsigned __int8 *v96; // x10
  int v97; // t1
  unsigned __int8 *v98; // x8
  int v99; // w9
  unsigned __int8 *v100; // x9
  unsigned __int8 *v101; // x10
  int v102; // w11
  unsigned __int8 *v103; // x10
  unsigned __int8 *v104; // x10
  int v105; // t1
  unsigned __int8 *v106; // x23
  __int64 v107; // x8
  unsigned __int8 *v108; // x23
  __int64 v109; // x8
  unsigned __int8 *v110; // x23
  __int64 v111; // x8
  unsigned __int8 *v112; // x9
  int v113; // w10
  unsigned __int8 *v114; // x9
  int v115; // w10
  int v116; // w10
  unsigned __int8 *v117; // x9
  int v118; // t1
  unsigned __int8 *v119; // x8
  unsigned __int8 *v120; // x10
  int v121; // w11
  unsigned __int8 *v122; // x10
  int v123; // w11
  int v124; // w11
  unsigned __int8 *v125; // x10
  int v126; // t1
  unsigned __int8 *v127; // x8
  int v128; // t1
  void *v129; // x10
  __int64 v130; // x26
  unsigned __int64 v131; // x8
  __int64 v132; // x23
  _BYTE *v133; // x26
  _BYTE *v134; // x8
  char *v135; // x2
  size_t v136; // x3
  int v137; // w23
  __int64 v138; // x8
  unsigned __int8 *v139; // x24
  char *v140; // x1
  size_t v141; // x2
  int v142; // w23
  int v143; // t1
  int v144; // t1
  unsigned __int8 *v145; // x9
  int v146; // t1
  int v147; // w9
  unsigned __int8 *v148; // x10
  int v149; // t1
  unsigned __int8 v151; // w9
  unsigned __int64 v152; // x26
  unsigned __int64 v153; // x28
  _BYTE *v154; // x0
  int v155; // w24
  __int64 v156; // x26
  __int64 v157; // x28
  __int64 v158; // x0
  __int64 v159; // x9
  unsigned __int64 v160; // x23
  unsigned __int64 v161; // x27
  unsigned __int64 v162; // x9
  unsigned __int8 v163; // w8
  char *v164; // x24
  unsigned __int64 v165; // x8
  __int64 v166; // x0
  unsigned __int64 v167; // x8
  bool v168; // zf
  size_t v169; // x8
  void *v170; // x1
  size_t v171; // x2
  __int64 v172; // x0
  char v173; // w26
  void *v174; // x24
  char *v175; // x1
  size_t v176; // x2
  __int64 v177; // x24
  unsigned __int64 v178; // x8
  size_t v179; // x9
  unsigned __int64 v180; // x10
  __int64 v181; // x10
  bool v182; // zf
  size_t v183; // x8
  size_t v184; // x2
  char *v185; // x1
  _BYTE *v186; // x28
  int v187; // w21
  __int64 v188; // x24
  unsigned __int64 v189; // x21
  unsigned __int8 *v190; // x9
  unsigned __int8 *v191; // x10
  int v192; // w11
  unsigned __int8 *v193; // x10
  int v194; // w11
  int v195; // w11
  unsigned __int8 *v196; // x10
  int v197; // t1
  _BYTE *v198; // x21
  _BYTE *v199; // x0
  _BYTE *v200; // x0
  bool v201; // cc
  _BYTE *v202; // x21
  int v203; // t1
  unsigned __int8 *v204; // x10
  int v205; // t1
  void *v206; // x0
  char v207; // [xsp+18h] [xbp-128h]
  unsigned __int64 v208; // [xsp+18h] [xbp-128h]
  int v209; // [xsp+24h] [xbp-11Ch]
  int v210; // [xsp+24h] [xbp-11Ch]
  int v211; // [xsp+24h] [xbp-11Ch]
  int v212; // [xsp+28h] [xbp-118h]
  int v213; // [xsp+28h] [xbp-118h]
  int v214; // [xsp+28h] [xbp-118h]
  char v215; // [xsp+2Ch] [xbp-114h]
  char v216; // [xsp+2Ch] [xbp-114h]
  unsigned __int64 v217; // [xsp+30h] [xbp-110h]
  char v218; // [xsp+38h] [xbp-108h]
  unsigned __int64 v219; // [xsp+38h] [xbp-108h]
  void *v220; // [xsp+40h] [xbp-100h]
  size_t v221; // [xsp+40h] [xbp-100h]
  char *v222; // [xsp+40h] [xbp-100h]
  const void *v223; // [xsp+48h] [xbp-F8h]
  char v224; // [xsp+48h] [xbp-F8h]
  char p; // [xsp+50h] [xbp-F0h]
  void *pc; // [xsp+50h] [xbp-F0h]
  void *pa; // [xsp+50h] [xbp-F0h]
  __int64 pb; // [xsp+50h] [xbp-F0h]
  char v229; // [xsp+5Ch] [xbp-E4h]
  __int128 v230; // [xsp+60h] [xbp-E0h] BYREF
  char *v231; // [xsp+70h] [xbp-D0h]
  __int128 v232; // [xsp+80h] [xbp-C0h] BYREF
  void *v233; // [xsp+90h] [xbp-B0h]
  __int128 v234; // [xsp+A0h] [xbp-A0h] BYREF
  void *v235; // [xsp+B0h] [xbp-90h]
  __int128 v236; // [xsp+C0h] [xbp-80h] BYREF
  _BYTE *v237; // [xsp+D0h] [xbp-70h]
  _QWORD v238[3]; // [xsp+D8h] [xbp-68h] BYREF

  v4 = a1;
  v238[2] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a1 != a2 )
  {
    v6 = *((_DWORD *)a3 + 26);
    v7 = *((_BYTE *)a3 + 109);
    *((_DWORD *)a3 + 26) = v6 + 1;
    if ( (unsigned int)(v6 + 1) >= 2 )
      *((_BYTE *)a3 + 109) = 1;
    v229 = *((_BYTE *)a3 + 108);
    *((_BYTE *)a3 + 108) = 0;
    v8 = *a1;
    if ( v8 == 84 || v8 == 71 )
    {
      if ( a2 - a1 < 3 )
        goto LABEL_262;
      if ( v8 == 71 )
      {
        v59 = a1[1];
        if ( v59 == 82 )
        {
          v67 = a1 + 2;
          v17 = sub_9AA00(a1 + 2, a2, a3, 0LL);
          if ( (unsigned __int8 *)v17 == v67 )
            goto LABEL_262;
          v68 = a3[1];
          if ( *a3 == v68 )
            goto LABEL_262;
          sub_9CDD8(v68 - 48, 0, "reference temporary for ", 0x18uLL);
        }
        else
        {
          if ( v59 != 86 )
            goto LABEL_262;
          v60 = a1 + 2;
          v17 = sub_9AA00(a1 + 2, a2, a3, 0LL);
          if ( (unsigned __int8 *)v17 == v60 )
            goto LABEL_262;
          v61 = a3[1];
          if ( *a3 == v61 )
            goto LABEL_262;
          sub_9CDD8(v61 - 48, 0, "guard variable for ", 0x13uLL);
        }
LABEL_256:
        v4 = (unsigned __int8 *)v17;
LABEL_262:
        *((_BYTE *)a3 + 109) = v7;
        *((_DWORD *)a3 + 26) = v6;
        *((_BYTE *)a3 + 108) = v229;
        return v4;
      }
      v10 = a1 + 1;
      v9 = a1[1];
      switch ( a1[1] )
      {
        case 'C':
          v11 = a1 + 2;
          v12 = (unsigned __int8 *)sub_925FC(a1 + 2, a2, a3);
          if ( v12 == v11 || v12 == a2 )
            goto LABEL_262;
          v13 = v12 + 1;
          if ( *v12 != 110 )
            v13 = v12;
          if ( v13 == a2 )
            goto LABEL_262;
          v14 = *v13;
          if ( v14 != 48 )
          {
            if ( (unsigned int)(v14 - 49) <= 8 )
            {
              v127 = v13 + 1;
              while ( a2 != v127 )
              {
                v128 = *v127++;
                if ( (unsigned int)(v128 - 48) >= 0xA )
                {
                  v15 = v127 - 1;
                  if ( v15 != v12 )
                    goto LABEL_16;
                  goto LABEL_262;
                }
              }
            }
            goto LABEL_262;
          }
          v15 = v13 + 1;
          if ( v15 == v12 )
            goto LABEL_262;
LABEL_16:
          if ( v15 == a2 )
            goto LABEL_262;
          if ( *v15 != 95 )
            goto LABEL_262;
          v16 = v15 + 1;
          v17 = sub_925FC(v15 + 1, a2, a3);
          if ( (_BYTE *)v17 == v16 )
            goto LABEL_262;
          v18 = a3[1];
          if ( 0xAAAAAAAAAAAAAAABLL * ((v18 - *a3) >> 4) < 2 )
            goto LABEL_262;
          v19 = *(unsigned __int8 *)(v18 - 24);
          v20 = *(_QWORD *)(v18 - 16);
          v21 = *(void **)(v18 - 8);
          v22 = v18 - 48;
          v23 = (void *)(v18 - 23);
          v24 = (v19 & 1) == 0;
          v25 = v19 >> 1;
          if ( v24 )
            v26 = v23;
          else
            v26 = v21;
          if ( v24 )
            v27 = v25;
          else
            v27 = v20;
          v28 = sub_9CFD0(v22, v26, v27);
          v212 = v6;
          v215 = v7;
          v237 = *(_BYTE **)(v28 + 16);
          v236 = *(_OWORD *)v28;
          *(_QWORD *)(v28 + 8) = 0LL;
          *(_QWORD *)(v28 + 16) = 0LL;
          *(_QWORD *)v28 = 0LL;
          v29 = a3[1];
          v30 = (_BYTE *)(v29 - 48);
          if ( (*(_BYTE *)(v29 - 24) & 1) != 0 )
            free(*(void **)(v29 - 8));
          if ( (*v30 & 1) != 0 )
            free(*(void **)(v29 - 32));
          v31 = (_BYTE *)*a3;
          a3[1] = (__int64)v30;
          if ( v31 == v30 )
          {
            v187 = 1;
            v17 = (__int64)v4;
            if ( (v236 & 1) == 0 )
            {
LABEL_390:
              v6 = v212;
              v7 = v215;
              if ( !v187 )
                goto LABEL_256;
              goto LABEL_262;
            }
LABEL_389:
            free(v237);
            goto LABEL_390;
          }
          sub_9CDD8((int)&v236, 0, "construction vtable for ", 0x18uLL);
          v32 = v237;
          v33 = v236;
          v237 = 0LL;
          v236 = 0uLL;
          v233 = v32;
          v232 = v33;
          sub_9CFD0((int)&v232, "-in-", 4uLL);
          v34 = v233;
          v35 = v232;
          v233 = 0LL;
          v232 = 0uLL;
          v235 = v34;
          v234 = v35;
          v36 = a3[1];
          v37 = *(unsigned __int8 *)(v36 - 24);
          v38 = *(_QWORD *)(v36 - 16);
          v39 = *(void **)(v36 - 8);
          v40 = v36 - 48;
          v41 = (void *)(v36 - 23);
          v42 = (v37 & 1) == 0;
          v43 = v37 >> 1;
          if ( v42 )
            v44 = v41;
          else
            v44 = v39;
          if ( v42 )
            v45 = v43;
          else
            v45 = v38;
          v46 = sub_9CFD0(v40, v44, v45);
          v231 = *(char **)(v46 + 16);
          v230 = *(_OWORD *)v46;
          *(_QWORD *)(v46 + 8) = 0LL;
          *(_QWORD *)(v46 + 16) = 0LL;
          *(_QWORD *)v46 = 0LL;
          v47 = v230;
          if ( (v230 & 1) != 0 )
            v48 = v231;
          else
            v48 = (char *)&v230 + 1;
          v220 = v231;
          if ( (v230 & 1) != 0 )
            v49 = *((_QWORD *)&v230 + 1);
          else
            v49 = (unsigned __int64)(unsigned __int8)v230 >> 1;
          sub_9CFD0((int)&v234, v48, v49);
          v50 = *(_QWORD *)((char *)&v234 + 1);
          p = v234;
          v51 = *((_QWORD *)&v234 + 1);
          v52 = v235;
          v234 = 0uLL;
          v235 = 0LL;
          v223 = v52;
          *(_QWORD *)((char *)v238 + 7) = v51;
          v238[0] = v50;
          v53 = a3[1];
          v54 = (__int64 *)(v53 - 48);
          if ( (*(_BYTE *)(v53 - 48) & 1) == 0 )
          {
            *(_WORD *)(v53 - 48) = 0;
            v55 = (const void **)(v53 - 32);
            goto LABEL_384;
          }
          **(_BYTE **)(v53 - 32) = 0;
          LOBYTE(v188) = *(_BYTE *)(v53 - 48);
          v55 = (const void **)(v53 - 32);
          *(_QWORD *)(v53 - 40) = 0LL;
          if ( (v188 & 1) != 0 )
          {
            v188 = *v54;
            v219 = (*v54 & 0xFFFFFFFFFFFFFFFELL) - 1;
            if ( (*v54 & 1) != 0 )
            {
              v217 = 0LL;
              v211 = 0;
              v189 = 22LL;
              goto LABEL_360;
            }
          }
          else
          {
            v219 = 22LL;
          }
          v217 = (unsigned __int64)((unsigned __int8)v188 & 0xFE) >> 1;
          if ( (unsigned __int8)v188 >= 0x2Eu )
          {
            v189 = ((unsigned __int8)(v217 + 16) & 0xF0) - 1LL;
            v211 = 1;
          }
          else
          {
            v211 = 1;
            v189 = 22LL;
          }
LABEL_360:
          if ( v189 != v219 )
          {
            if ( v189 == 22 )
            {
              v198 = *v55;
              v199 = (_BYTE *)(v53 - 47);
              if ( v211 )
                memcpy(v199, *v55, ((unsigned __int64)((unsigned __int8)v188 & 0xFE) >> 1) + 1);
              else
                *v199 = *v198;
              free(v198);
              *(_BYTE *)v54 = 2 * v217;
            }
            else
            {
              v208 = v189 + 1;
              v200 = malloc(v189 + 1);
              v201 = v189 > v219;
              v202 = v200;
              if ( v201 || v200 )
              {
                if ( (v211 & 1) != 0 )
                {
                  memcpy(v200, (const void *)(v53 - 47), ((unsigned __int64)((unsigned __int8)v188 & 0xFE) >> 1) + 1);
                }
                else
                {
                  v206 = (void *)*v55;
                  *v202 = *(_BYTE *)*v55;
                  free(v206);
                }
                *(_QWORD *)(v53 - 48) = v208 | 1;
                *(_QWORD *)(v53 - 40) = v217;
                *(_QWORD *)(v53 - 32) = v202;
              }
            }
          }
LABEL_384:
          *(_BYTE *)(v53 - 48) = p;
          *(_QWORD *)(v53 - 47) = v238[0];
          *(_QWORD *)(v53 - 40) = *(_QWORD *)((char *)v238 + 7);
          *v55 = v223;
          memset(v238, 0, 15);
          if ( (v47 & 1) != 0 )
          {
            free(v220);
            if ( (v234 & 1) == 0 )
            {
LABEL_386:
              if ( (v232 & 1) == 0 )
                goto LABEL_388;
              goto LABEL_387;
            }
          }
          else if ( (v234 & 1) == 0 )
          {
            goto LABEL_386;
          }
          free(v235);
          if ( (v232 & 1) == 0 )
          {
LABEL_388:
            v187 = 0;
            if ( (v236 & 1) == 0 )
              goto LABEL_390;
            goto LABEL_389;
          }
LABEL_387:
          free(v233);
          goto LABEL_388;
        case 'H':
          v84 = a1 + 2;
          v17 = sub_9AA00(a1 + 2, a2, a3, 0LL);
          if ( (unsigned __int8 *)v17 != v84 )
          {
            v85 = a3[1];
            if ( *a3 != v85 )
            {
              sub_9CDD8(v85 - 48, 0, "thread-local initialization routine for ", 0x28uLL);
              goto LABEL_256;
            }
          }
          goto LABEL_262;
        case 'I':
          v86 = a1 + 2;
          v17 = sub_925FC(a1 + 2, a2, a3);
          if ( (unsigned __int8 *)v17 != v86 )
          {
            v87 = a3[1];
            if ( *a3 != v87 )
            {
              sub_9CDD8(v87 - 48, 0, "typeinfo for ", 0xDuLL);
              goto LABEL_256;
            }
          }
          goto LABEL_262;
        case 'S':
          v108 = a1 + 2;
          v17 = sub_925FC(a1 + 2, a2, a3);
          if ( (unsigned __int8 *)v17 != v108 )
          {
            v109 = a3[1];
            if ( *a3 != v109 )
            {
              sub_9CDD8(v109 - 48, 0, "typeinfo name for ", 0x12uLL);
              goto LABEL_256;
            }
          }
          goto LABEL_262;
        case 'T':
          v110 = a1 + 2;
          v17 = sub_925FC(a1 + 2, a2, a3);
          if ( (unsigned __int8 *)v17 != v110 )
          {
            v111 = a3[1];
            if ( *a3 != v111 )
            {
              sub_9CDD8(v111 - 48, 0, "VTT for ", 8uLL);
              goto LABEL_256;
            }
          }
          goto LABEL_262;
        case 'V':
          v82 = a1 + 2;
          v17 = sub_925FC(a1 + 2, a2, a3);
          if ( (unsigned __int8 *)v17 != v82 )
          {
            v83 = a3[1];
            if ( *a3 != v83 )
            {
              sub_9CDD8(v83 - 48, 0, "vtable for ", 0xBuLL);
              goto LABEL_256;
            }
          }
          goto LABEL_262;
        case 'W':
          v88 = a1 + 2;
          v17 = sub_9AA00(a1 + 2, a2, a3, 0LL);
          if ( (unsigned __int8 *)v17 != v88 )
          {
            v89 = a3[1];
            if ( *a3 != v89 )
            {
              sub_9CDD8(v89 - 48, 0, "thread-local wrapper routine for ", 0x21uLL);
              goto LABEL_256;
            }
          }
          goto LABEL_262;
        case 'c':
          v90 = a1 + 2;
          if ( a1 + 2 == a2 )
            goto LABEL_262;
          v91 = *v90;
          if ( v91 == 118 )
          {
            v119 = a1 + 3;
            if ( a1 + 3 == a2 )
              goto LABEL_262;
            v120 = a1[3] == 110 ? a1 + 4 : a1 + 3;
            if ( v120 == a2 )
              goto LABEL_262;
            v121 = *v120;
            if ( v121 != 48 )
            {
              if ( (unsigned int)(v121 - 49) <= 8 )
              {
                v148 = v120 + 1;
                while ( a2 != v148 )
                {
                  v149 = *v148++;
                  if ( (unsigned int)(v149 - 48) >= 0xA )
                  {
                    v122 = v148 - 1;
                    if ( v122 != v119 )
                      goto LABEL_169;
                    goto LABEL_262;
                  }
                }
              }
              goto LABEL_262;
            }
            v122 = v120 + 1;
            if ( v122 == v119 )
              goto LABEL_262;
LABEL_169:
            if ( v122 == a2 )
              goto LABEL_262;
            if ( *v122 != 95 )
              goto LABEL_262;
            v92 = v122 + 1;
            if ( v122 + 1 == a2 )
              goto LABEL_262;
            v123 = v122[1];
            v93 = v122 + 2;
            if ( v123 != 110 )
              v93 = v92;
            if ( v93 == a2 )
              goto LABEL_262;
            v124 = *v93;
            if ( v124 != 48 )
            {
              if ( (unsigned int)(v124 - 49) <= 8 )
              {
                v125 = v93 + 1;
                while ( a2 != v125 )
                {
                  v126 = *v125++;
                  if ( (unsigned int)(v126 - 48) >= 0xA )
                  {
LABEL_245:
                    v95 = v125 - 1;
                    if ( v95 != v92 )
                      goto LABEL_113;
                    goto LABEL_262;
                  }
                }
              }
              goto LABEL_262;
            }
          }
          else
          {
            if ( v91 != 104 )
              goto LABEL_262;
            v92 = a1 + 3;
            if ( a1 + 3 == a2 )
              goto LABEL_262;
            v93 = a1[3] == 110 ? a1 + 4 : a1 + 3;
            if ( v93 == a2 )
              goto LABEL_262;
            v94 = *v93;
            if ( v94 != 48 )
            {
              if ( (unsigned int)(v94 - 49) <= 8 )
              {
                v125 = v93 + 1;
                while ( a2 != v125 )
                {
                  v144 = *v125++;
                  if ( (unsigned int)(v144 - 48) >= 0xA )
                    goto LABEL_245;
                }
              }
              goto LABEL_262;
            }
          }
          v95 = v93 + 1;
          if ( v95 != v92 )
          {
LABEL_113:
            if ( v95 != a2 )
            {
              v97 = *v95;
              v96 = v95 + 1;
              v98 = v97 == 95 ? v96 : a1 + 2;
              if ( v98 != v90 && v98 != a2 )
              {
                v99 = *v98;
                if ( v99 == 118 )
                {
                  v190 = v98 + 1;
                  if ( v98 + 1 != a2 )
                  {
                    v191 = v98[1] == 110 ? v98 + 2 : v98 + 1;
                    if ( v191 != a2 )
                    {
                      v192 = *v191;
                      if ( v192 != 48 )
                      {
                        if ( (unsigned int)(v192 - 49) <= 8 )
                        {
                          v204 = v191 + 1;
                          while ( a2 != v204 )
                          {
                            v205 = *v204++;
                            if ( (unsigned int)(v205 - 48) >= 0xA )
                            {
                              v193 = v204 - 1;
                              if ( v193 != v190 )
                                goto LABEL_341;
                              goto LABEL_262;
                            }
                          }
                        }
                        goto LABEL_262;
                      }
                      v193 = v191 + 1;
                      if ( v193 != v190 )
                      {
LABEL_341:
                        if ( v193 != a2 && *v193 == 95 )
                        {
                          v100 = v193 + 1;
                          if ( v193 + 1 != a2 )
                          {
                            v194 = v193[1];
                            v101 = v193 + 2;
                            if ( v194 != 110 )
                              v101 = v100;
                            if ( v101 != a2 )
                            {
                              v195 = *v101;
                              if ( v195 != 48 )
                              {
                                if ( (unsigned int)(v195 - 49) <= 8 )
                                {
                                  v196 = v101 + 1;
                                  while ( a2 != v196 )
                                  {
                                    v197 = *v196++;
                                    if ( (unsigned int)(v197 - 48) >= 0xA )
                                    {
LABEL_372:
                                      v103 = v196 - 1;
                                      if ( v103 != v100 )
                                        goto LABEL_128;
                                      goto LABEL_262;
                                    }
                                  }
                                }
                                goto LABEL_262;
                              }
                              goto LABEL_127;
                            }
                          }
                        }
                      }
                    }
                  }
                }
                else if ( v99 == 104 )
                {
                  v100 = v98 + 1;
                  if ( v98 + 1 != a2 )
                  {
                    v101 = v98[1] == 110 ? v98 + 2 : v98 + 1;
                    if ( v101 != a2 )
                    {
                      v102 = *v101;
                      if ( v102 != 48 )
                      {
                        if ( (unsigned int)(v102 - 49) <= 8 )
                        {
                          v196 = v101 + 1;
                          while ( a2 != v196 )
                          {
                            v203 = *v196++;
                            if ( (unsigned int)(v203 - 48) >= 0xA )
                              goto LABEL_372;
                          }
                        }
                        goto LABEL_262;
                      }
LABEL_127:
                      v103 = v101 + 1;
                      if ( v103 != v100 )
                      {
LABEL_128:
                        if ( v103 != a2 )
                        {
                          v105 = *v103;
                          v104 = v103 + 1;
                          v106 = v105 == 95 ? v104 : v98;
                          if ( v106 != v98 )
                          {
                            v17 = sub_91038(v106, a2, a3);
                            if ( (unsigned __int8 *)v17 != v106 )
                            {
                              v107 = a3[1];
                              if ( *a3 != v107 )
                              {
                                sub_9CDD8(v107 - 48, 0, "covariant return thunk to ", 0x1AuLL);
                                goto LABEL_256;
                              }
                            }
                          }
                        }
                      }
                      goto LABEL_262;
                    }
                  }
                }
              }
            }
          }
          goto LABEL_262;
        default:
          if ( v10 == a2 )
            goto LABEL_252;
          if ( v9 == 118 )
          {
            if ( a1 + 2 != a2 )
            {
              v112 = a1[2] == 110 ? a1 + 3 : a1 + 2;
              if ( v112 != a2 )
              {
                v113 = *v112;
                if ( v113 == 48 )
                {
                  v114 = v112 + 1;
LABEL_149:
                  v76 = 3;
                  if ( v114 == a1 + 2 )
                    goto LABEL_354;
                  v17 = (__int64)a1;
                  if ( v114 == a2 )
                    goto LABEL_253;
                  if ( *v114 == 95 )
                  {
                    v72 = v114 + 1;
                    if ( v114 + 1 != a2 )
                    {
                      v115 = v114[1];
                      v73 = v114 + 2;
                      if ( v115 != 110 )
                        v73 = v72;
                      if ( v73 != a2 )
                      {
                        v116 = *v73;
                        if ( v116 == 48 )
                          goto LABEL_80;
                        if ( (unsigned int)(v116 - 49) <= 8 )
                        {
                          v117 = v73 + 1;
                          while ( a2 != v117 )
                          {
                            v118 = *v117++;
                            if ( (unsigned int)(v118 - 48) >= 0xA )
                            {
LABEL_240:
                              v75 = v117 - 1;
                              goto LABEL_81;
                            }
                          }
                        }
                      }
                    }
                  }
                }
                else if ( (unsigned int)(v113 - 49) <= 8 )
                {
                  v145 = v112 + 1;
                  while ( a2 != v145 )
                  {
                    v146 = *v145++;
                    if ( (unsigned int)(v146 - 48) >= 0xA )
                    {
                      v114 = v145 - 1;
                      goto LABEL_149;
                    }
                  }
                }
              }
            }
          }
          else if ( v9 == 104 )
          {
            v72 = a1 + 2;
            if ( a1 + 2 != a2 )
            {
              v73 = a1[2] == 110 ? a1 + 3 : a1 + 2;
              if ( v73 != a2 )
              {
                v74 = *v73;
                if ( v74 == 48 )
                {
LABEL_80:
                  v75 = v73 + 1;
LABEL_81:
                  v24 = v75 == v72;
                  v76 = 3;
                  if ( v24 )
                    goto LABEL_354;
                  v17 = (__int64)a1;
                  if ( v75 != a2 )
                  {
                    v78 = *v75;
                    v77 = v75 + 1;
                    if ( v78 == 95 )
                      v79 = v77;
                    else
                      v79 = a1 + 1;
                    if ( v79 != v10 )
                    {
                      v17 = sub_91038(v79, a2, a3);
                      if ( (unsigned __int8 *)v17 == v79 )
                      {
                        v76 = 0;
                      }
                      else
                      {
                        v80 = a3[1];
                        if ( *a3 != v80 )
                        {
                          v81 = v80 - 48;
                          if ( *v10 == 118 )
                            sub_9CDD8(v81, 0, "virtual thunk to ", 0x11uLL);
                          else
                            sub_9CDD8(v81, 0, "non-virtual thunk to ", 0x15uLL);
                          goto LABEL_256;
                        }
                        v76 = 1;
                      }
LABEL_354:
                      v17 = (__int64)v4;
                      v147 = v76 & 3;
                      if ( (v76 & 3) == 0 )
                        goto LABEL_256;
LABEL_254:
                      if ( v147 == 3 || !v76 )
                        goto LABEL_256;
                      goto LABEL_262;
                    }
                    goto LABEL_252;
                  }
LABEL_253:
                  v147 = 3;
                  goto LABEL_254;
                }
                if ( (unsigned int)(v74 - 49) <= 8 )
                {
                  v117 = v73 + 1;
                  while ( a2 != v117 )
                  {
                    v143 = *v117++;
                    if ( (unsigned int)(v143 - 48) >= 0xA )
                      goto LABEL_240;
                  }
                }
              }
            }
          }
LABEL_252:
          v76 = 3;
          v17 = (__int64)a1;
          goto LABEL_253;
      }
    }
    LOBYTE(v230) = 0;
    v56 = (unsigned __int8 *)sub_9AA00(a1, a2, a3, &v230);
    v57 = v56;
    if ( v56 == v4 )
      goto LABEL_262;
    if ( v56 == a2 )
    {
      v4 = a2;
      goto LABEL_262;
    }
    v58 = *v56;
    if ( v58 == 46 || v58 == 69 )
    {
      v4 = v56;
      goto LABEL_262;
    }
    v62 = *((_DWORD *)a3 + 24);
    v63 = *((_DWORD *)a3 + 25);
    v64 = *((_BYTE *)a3 + 109);
    *((_BYTE *)a3 + 109) = 0;
    v237 = 0LL;
    v236 = 0uLL;
    v65 = a3[1];
    if ( *a3 == v65 )
      goto LABEL_321;
    v66 = *(unsigned __int8 *)(v65 - 48);
    if ( (v66 & 1) != 0 )
    {
      if ( !*(_QWORD *)(v65 - 40) )
        goto LABEL_321;
    }
    else if ( !(v66 >> 1) )
    {
      goto LABEL_321;
    }
    v224 = v64;
    v218 = v62;
    if ( *((_BYTE *)a3 + 108) || !(_BYTE)v230 )
    {
LABEL_212:
      sub_B23DC(v65 - 48, 40LL);
      if ( v57 == a2 || *v57 != 118 )
      {
        v210 = v63;
        v213 = v6;
        v216 = v7;
        v207 = 1;
LABEL_270:
        v157 = *a3;
        v156 = a3[1];
        v139 = v57;
        while ( 1 )
        {
          v158 = sub_925FC(v139, a2, a3);
          v57 = (unsigned __int8 *)v158;
          v159 = *a3;
          v138 = a3[1];
          if ( (unsigned __int8 *)v158 == v139 )
            break;
          v160 = 0xAAAAAAAAAAAAAAABLL * ((v156 - v157) >> 4);
          v161 = 0xAAAAAAAAAAAAAAABLL * ((v138 - v159) >> 4);
          v157 = *a3;
          v156 = a3[1];
          v139 = (unsigned __int8 *)v158;
          if ( v161 > v160 )
          {
            v162 = 0LL;
            v163 = 0;
            v164 = (char *)(v160 + 1);
            v235 = 0LL;
            v234 = 0uLL;
            for ( pb = 48 * v160; ; pb += 48LL )
            {
              if ( (v163 & 1) != 0 )
                v165 = v162;
              else
                v165 = (unsigned __int64)(v163 & 0xFE) >> 1;
              if ( v165 )
                sub_9CFD0((int)&v234, &asc_69D1AEC, 2uLL);
              v166 = *a3 + pb;
              v167 = *(unsigned __int8 *)(v166 + 24);
              v168 = (v167 & 1) == 0;
              v169 = v167 >> 1;
              if ( v168 )
                v170 = (void *)(v166 + 25);
              else
                v170 = *(void **)(v166 + 40);
              if ( v168 )
                v171 = v169;
              else
                v171 = *(_QWORD *)(v166 + 32);
              v172 = sub_9CFD0(v166, v170, v171);
              v222 = v164;
              v233 = *(void **)(v172 + 16);
              v232 = *(_OWORD *)v172;
              *(_QWORD *)(v172 + 8) = 0LL;
              *(_QWORD *)(v172 + 16) = 0LL;
              *(_QWORD *)v172 = 0LL;
              v173 = v232;
              v174 = v233;
              if ( (v232 & 1) != 0 )
                v175 = (char *)v233;
              else
                v175 = (char *)&v232 + 1;
              if ( (v232 & 1) != 0 )
                v176 = *((_QWORD *)&v232 + 1);
              else
                v176 = (unsigned __int64)(unsigned __int8)v232 >> 1;
              sub_9CFD0((int)&v234, v175, v176);
              if ( (v173 & 1) != 0 )
                free(v174);
              if ( (unsigned __int64)v222 >= v161 )
                break;
              v163 = v234;
              v162 = *((_QWORD *)&v234 + 1);
              v164 = v222 + 1;
            }
            v177 = a3[1];
            do
            {
              if ( v177 == *a3 )
                goto LABEL_316;
              if ( (*(_BYTE *)(v177 - 24) & 1) != 0 )
                free(*(void **)(v177 - 8));
              if ( (*(_BYTE *)(v177 - 48) & 1) != 0 )
                free(*(void **)(v177 - 32));
              ++v160;
              v177 -= 48LL;
              a3[1] = v177;
            }
            while ( v160 < v161 );
            v178 = (unsigned __int8)v234;
            v179 = *((_QWORD *)&v234 + 1);
            v180 = (unsigned __int64)(unsigned __int8)v234 >> 1;
            if ( (v234 & 1) != 0 )
              v180 = *((_QWORD *)&v234 + 1);
            if ( !v180 )
            {
              v155 = 0;
              if ( (v234 & 1) == 0 )
                goto LABEL_318;
LABEL_317:
              free(v235);
              goto LABEL_318;
            }
            v181 = a3[1];
            if ( *a3 == v181 )
            {
LABEL_316:
              v155 = 1;
              if ( (v234 & 1) == 0 )
                goto LABEL_318;
              goto LABEL_317;
            }
            if ( (v207 & 1) == 0 )
            {
              sub_9CFD0(v181 - 48, &asc_69D1AEC, 2uLL);
              v181 = a3[1];
              v178 = (unsigned __int8)v234;
              v179 = *((_QWORD *)&v234 + 1);
            }
            v182 = (v178 & 1) == 0;
            v183 = v178 >> 1;
            if ( v182 )
              v184 = v183;
            else
              v184 = v179;
            if ( v182 )
              v185 = (char *)&v234 + 1;
            else
              v185 = (char *)v235;
            sub_9CFD0(v181 - 48, v185, v184);
            v155 = 0;
            v207 = 0;
            if ( (v234 & 1) != 0 )
              goto LABEL_317;
LABEL_318:
            v142 = 1;
            if ( v155 )
            {
              v6 = v213;
              v7 = v216;
              v64 = v224;
              goto LABEL_322;
            }
            goto LABEL_270;
          }
        }
        v6 = v213;
        v7 = v216;
        v64 = v224;
        v63 = v210;
        if ( v159 != v138 )
        {
LABEL_215:
          sub_B23DC(v138 - 48, 41LL);
          if ( (v218 & 1) != 0 )
            sub_9CFD0(a3[1] - 48, " const", 6uLL);
          if ( (v218 & 2) != 0 )
            sub_9CFD0(a3[1] - 48, " volatile", 9uLL);
          if ( (v218 & 4) != 0 )
            sub_9CFD0(a3[1] - 48, " restrict", 9uLL);
          if ( v63 == 2 )
          {
            sub_9CFD0(a3[1] - 48, " &&", 3uLL);
          }
          else if ( v63 == 1 )
          {
            sub_9CFD0(a3[1] - 48, " &", 2uLL);
          }
          if ( (v236 & 1) != 0 )
            v140 = v237;
          else
            v140 = (char *)&v236 + 1;
          if ( (v236 & 1) != 0 )
            v141 = *((_QWORD *)&v236 + 1);
          else
            v141 = (unsigned __int64)(unsigned __int8)v236 >> 1;
          sub_9CFD0(*((_DWORD *)a3 + 2) - 48, v140, v141);
          v142 = 0;
          if ( (v236 & 1) == 0 )
            goto LABEL_324;
          goto LABEL_323;
        }
      }
      else
      {
        v138 = a3[1];
        v139 = v57 + 1;
        if ( *a3 != v138 )
          goto LABEL_215;
      }
LABEL_321:
      v142 = 1;
LABEL_322:
      v139 = v4;
      if ( (v236 & 1) == 0 )
        goto LABEL_324;
LABEL_323:
      free(v237);
LABEL_324:
      *((_BYTE *)a3 + 109) = v64;
      if ( !v142 )
        v4 = v139;
      goto LABEL_262;
    }
    v69 = sub_925FC(v56, a2, a3);
    if ( (unsigned __int8 *)v69 == v57 )
      goto LABEL_321;
    v70 = a3[1];
    if ( 0xAAAAAAAAAAAAAAABLL * ((v70 - *a3) >> 4) < 2 )
      goto LABEL_321;
    v209 = v63;
    v235 = *(void **)(v70 - 32);
    v234 = *(_OWORD *)(v70 - 48);
    *(_QWORD *)(v70 - 40) = 0LL;
    *(_QWORD *)(v70 - 32) = 0LL;
    *(_QWORD *)(v70 - 48) = 0LL;
    v71 = a3[1] - 24;
    if ( (v236 & 1) == 0 )
    {
      LOWORD(v236) = 0;
      goto LABEL_192;
    }
    v129 = v237;
    *v237 = 0;
    *((_QWORD *)&v236 + 1) = 0LL;
    if ( (v236 & 1) != 0 )
    {
      BYTE1(v236) = 0;
      free(v129);
      LOBYTE(v130) = 0;
    }
    else
    {
      v130 = (unsigned __int8)v236 >> 1;
      if ( (unsigned __int8)v236 >= 0x2Eu )
      {
        v151 = v130 + 16;
        pa = (void *)((unsigned __int8)v236 >> 1);
        v152 = (v236 & 0xFFFFFFFFFFFFFFFELL) - 1;
        v214 = v6;
        v153 = (v151 & 0xF0) - 1LL;
        if ( v153 != v152 && ((v221 = v151 & 0xF0, v154 = malloc(v221), v153 > v152) || v154) )
        {
          v186 = v154;
          memcpy(v154, (char *)&v236 + 1, (size_t)pa + 1);
          v237 = v186;
          v6 = v214;
          *(_QWORD *)&v236 = v221 | 1;
          *((_QWORD *)&v236 + 1) = pa;
        }
        else
        {
          v6 = v214;
        }
LABEL_192:
        v237 = *(_BYTE **)(v71 + 16);
        v236 = *(_OWORD *)v71;
        *(_QWORD *)(v71 + 8) = 0LL;
        *(_QWORD *)(v71 + 16) = 0LL;
        *(_QWORD *)v71 = 0LL;
        if ( (v236 & 1) != 0 )
          v131 = *((_QWORD *)&v236 + 1);
        else
          v131 = (unsigned __int64)(unsigned __int8)v236 >> 1;
        if ( !v131 )
          sub_B23DC(&v234, 32LL);
        v132 = a3[1];
        v133 = (_BYTE *)(v132 - 48);
        if ( (*(_BYTE *)(v132 - 24) & 1) != 0 )
          free(*(void **)(v132 - 8));
        if ( (*v133 & 1) != 0 )
          free(*(void **)(v132 - 32));
        v134 = (_BYTE *)*a3;
        a3[1] = (__int64)v133;
        if ( v134 == v133 )
        {
          v64 = v224;
          v137 = 1;
          if ( (v234 & 1) == 0 )
            goto LABEL_210;
        }
        else
        {
          if ( (v234 & 1) != 0 )
            v135 = (char *)v235;
          else
            v135 = (char *)&v234 + 1;
          if ( (v234 & 1) != 0 )
            v136 = *((_QWORD *)&v234 + 1);
          else
            v136 = (unsigned __int64)(unsigned __int8)v234 >> 1;
          v64 = v224;
          sub_9CDD8(v132 - 96, 0, v135, v136);
          v137 = 0;
          v57 = (unsigned __int8 *)v69;
          if ( (v234 & 1) == 0 )
            goto LABEL_210;
        }
        free(v235);
LABEL_210:
        if ( v137 )
          goto LABEL_321;
        v65 = a3[1];
        v63 = v209;
        goto LABEL_212;
      }
      pc = v129;
      memcpy((char *)&v236 + 1, v129, v130 + 1);
      free(pc);
    }
    LOBYTE(v236) = 2 * v130;
    goto LABEL_192;
  }
  return v4;
}
// 910D0: conditional instruction was optimized away because w8.4==54
// 925FC: using guessed type __int64 __fastcall sub_925FC(_QWORD, _QWORD, _QWORD);
// 9AA00: using guessed type __int64 __fastcall sub_9AA00(_QWORD, _QWORD, _QWORD, _QWORD);
// B23DC: using guessed type __int64 __fastcall sub_B23DC(_QWORD, _QWORD);

//----- (00000000000925FC) ----------------------------------------------------
unsigned __int8 *__fastcall sub_925FC(unsigned __int8 *a1, unsigned __int8 *a2, __int64 a3)
{
  unsigned __int8 *v3; // x24
  unsigned __int8 *v4; // x20
  unsigned __int8 *v5; // x21
  int v6; // w27
  char v7; // w23
  unsigned __int8 *v8; // x8
  int v9; // t1
  unsigned __int8 *v10; // x22
  int v11; // w26
  void **v12; // x19
  __int64 v13; // x21
  __int64 v14; // x28
  void **v15; // x23
  __int64 v16; // x24
  unsigned __int64 v17; // x20
  __int64 *v18; // x28
  unsigned __int64 v19; // x8
  __int64 v20; // x22
  unsigned __int8 *v21; // x22
  int v22; // w8
  _QWORD *v23; // x25
  __int64 v24; // x21
  __int64 v25; // x8
  unsigned __int64 v26; // x9
  const void *v27; // x10
  const void *v28; // x8
  unsigned __int64 v29; // x11
  bool v30; // zf
  unsigned __int64 v31; // x9
  const void *v32; // x23
  size_t v33; // x22
  __int64 v34; // x10
  __int64 v35; // x20
  __int64 v36; // x8
  unsigned __int64 v37; // x8
  __int64 v38; // x25
  char *v39; // x0
  __int64 v40; // x9
  char *v41; // x8
  void **v42; // x11
  void **v43; // x20
  char *v44; // x9
  _QWORD *v45; // x10
  __int128 v46; // t1
  void **v47; // x22
  __int64 v48; // x25
  unsigned __int64 v49; // x8
  unsigned __int64 v50; // x22
  char v51; // w23
  char *v52; // x24
  size_t *v53; // x27
  char *v54; // x11
  __int64 v55; // x8
  size_t v56; // x25
  const void *v57; // x1
  void *v58; // x19
  const void *v59; // x19
  void *v60; // x0
  char *v61; // x8
  char *v62; // x25
  char *v63; // x25
  __int64 v64; // x8
  __int64 v65; // x8
  char v66; // t1
  __int64 v67; // x8
  size_t v68; // x26
  const void *v69; // x21
  void *v70; // x25
  void *v71; // x0
  char *v72; // x8
  void **v73; // x9
  void **v74; // x19
  _QWORD *v75; // x8
  size_t v76; // x10
  void **v77; // x24
  __int64 v78; // x21
  void **v79; // x23
  unsigned __int64 v80; // x8
  __int64 v81; // x9
  __int64 v82; // x0
  size_t *v83; // x0
  unsigned __int64 v84; // x10
  unsigned int v85; // t1
  unsigned __int64 v86; // x8
  char *v87; // x11
  __int64 v88; // x11
  size_t v89; // x24
  char *v90; // x12
  char *v91; // x9
  unsigned __int64 v92; // x10
  __int64 v93; // x9
  __int64 v94; // x20
  __int64 v95; // x21
  size_t *v96; // x9
  size_t *v97; // x19
  __int64 v98; // x25
  __int64 v99; // x10
  unsigned __int64 v100; // x23
  unsigned __int64 v101; // x9
  __int64 v102; // x19
  unsigned __int64 v103; // x9
  __int64 v104; // x8
  size_t v105; // x0
  __int64 v106; // x8
  size_t v107; // x24
  const void *v108; // x25
  void *v109; // x26
  _BYTE *v110; // x24
  __int64 v111; // x8
  __int64 v112; // x8
  char v113; // t1
  __int64 v114; // x8
  size_t v115; // x25
  const void *v116; // x26
  void *v117; // x24
  void **v118; // x19
  __int64 v119; // x21
  __int64 v120; // x26
  _QWORD *v121; // x8
  unsigned __int64 v122; // x9
  void **v123; // x22
  __int64 v124; // x24
  __int64 v125; // x20
  unsigned __int8 *v126; // x22
  __int64 v127; // x8
  unsigned __int64 v128; // x8
  unsigned __int64 v129; // x9
  void **v130; // x19
  __int64 v131; // x0
  __int64 v132; // x22
  __int64 v133; // x23
  __int64 v134; // x28
  __int64 v135; // x8
  void *v136; // x9
  __int64 v137; // x19
  _BYTE *v138; // x21
  char *v139; // x8
  unsigned __int64 v140; // x8
  _BYTE *v141; // x8
  __int128 v142; // q0
  char *v143; // x1
  size_t v144; // x2
  __int128 v145; // q0
  void *v146; // x8
  char v147; // w26
  void *v148; // x21
  char *v149; // x1
  size_t v150; // x2
  unsigned __int16 *v151; // x8
  __int128 v152; // q0
  void *v153; // x11
  char v154; // w10
  __int64 v155; // x25
  void **v156; // x24
  const void **v157; // x23
  unsigned __int8 *v158; // x0
  unsigned __int8 *v159; // x23
  _QWORD *v160; // x24
  __int64 v161; // x19
  unsigned __int64 v162; // x8
  bool v163; // zf
  size_t v164; // x8
  void *v165; // x1
  size_t v166; // x2
  __int64 v167; // x19
  _BYTE *v168; // x20
  unsigned __int64 v169; // x8
  bool v170; // zf
  unsigned __int64 v171; // x8
  const void *v172; // x22
  size_t v173; // x20
  __int64 v174; // x8
  __int64 v175; // x1
  unsigned __int64 v176; // x8
  unsigned __int64 v177; // x9
  void **v178; // x19
  void **v179; // x19
  __int64 v180; // x21
  __int64 v181; // x0
  _QWORD *v182; // x8
  unsigned __int64 v183; // x9
  void **v184; // x23
  __int64 v185; // x24
  __int64 v186; // x20
  __int64 *v187; // x28
  void **v188; // x19
  __int64 v189; // x21
  __int64 v190; // x0
  _QWORD *v191; // x8
  unsigned __int64 v192; // x9
  void **v193; // x22
  __int64 v194; // x24
  __int64 v195; // x20
  __int64 *v196; // x27
  unsigned __int8 *v197; // x22
  unsigned __int8 *v198; // x0
  unsigned __int8 *v199; // x28
  __int64 *v200; // x26
  unsigned __int8 *v201; // x24
  unsigned int v202; // w8
  unsigned __int8 *v203; // x23
  unsigned __int8 *v204; // x19
  void **v205; // x22
  __int64 v206; // x25
  __int64 v207; // x0
  int v208; // w21
  unsigned __int64 v209; // x22
  unsigned __int64 v210; // x25
  __int64 v211; // x26
  unsigned __int64 v212; // x21
  void *v213; // x8
  __int64 v214; // x0
  unsigned __int64 v215; // x8
  bool v216; // zf
  size_t v217; // x8
  void *v218; // x1
  size_t v219; // x2
  size_t *v220; // x0
  char v221; // w19
  void *v222; // x24
  char *v223; // x1
  size_t v224; // x2
  unsigned __int64 v225; // x22
  __int64 v226; // x21
  _QWORD *v227; // x23
  __int64 v228; // x8
  __int64 v229; // x1
  unsigned __int64 v230; // x8
  unsigned __int64 v231; // x9
  __int64 v232; // x8
  unsigned __int64 v233; // x8
  unsigned __int64 v234; // x9
  void **v235; // x19
  __int64 v236; // x21
  __int64 v237; // x0
  _QWORD *v238; // x8
  unsigned __int64 v239; // x9
  void **v240; // x23
  __int64 v241; // x24
  __int64 v242; // x20
  __int64 *v243; // x28
  unsigned __int8 *v244; // x0
  __int64 v245; // x19
  unsigned __int64 v246; // x8
  bool v247; // zf
  size_t v248; // x8
  void *v249; // x1
  size_t v250; // x2
  __int64 v251; // x19
  _BYTE *v252; // x21
  char *v253; // x1
  size_t v254; // x2
  __int64 v255; // x1
  unsigned __int64 v256; // x8
  unsigned __int64 v257; // x9
  void **v258; // x19
  __int64 v259; // x10
  __int64 v260; // x23
  __int64 v261; // x9
  unsigned __int64 v262; // x9
  __int64 v263; // x25
  char *v264; // x0
  __int64 v265; // x19
  int v266; // w8
  unsigned __int8 *v267; // x26
  __int64 v268; // x8
  unsigned __int64 v269; // x9
  const void *v270; // x10
  const void *v271; // x8
  unsigned __int64 v272; // x11
  bool v273; // zf
  unsigned __int64 v274; // x9
  const void *v275; // x24
  size_t v276; // x23
  __int64 v277; // x10
  __int64 v278; // x22
  __int64 v279; // x9
  unsigned __int64 v280; // x9
  __int64 v281; // x25
  char *v282; // x0
  __int64 v283; // x10
  __int64 v284; // x23
  __int64 v285; // x9
  unsigned __int64 v286; // x9
  __int64 v287; // x25
  char *v288; // x0
  __int64 v289; // x10
  __int64 v290; // x22
  __int64 v291; // x9
  unsigned __int64 v292; // x9
  __int64 v293; // x25
  char *v294; // x0
  __int64 v295; // x10
  __int64 v296; // x20
  __int64 v297; // x9
  unsigned __int64 v298; // x9
  __int64 v299; // x19
  char *v300; // x0
  __int64 v301; // x10
  __int64 v302; // x20
  __int64 v303; // x9
  unsigned __int64 v304; // x9
  __int64 v305; // x19
  char *v306; // x0
  unsigned __int8 *v307; // x0
  _BYTE *v308; // x22
  __int64 v309; // x8
  void *v310; // x9
  __int64 v311; // x19
  _BYTE *v312; // x23
  char *v313; // x8
  __int64 v314; // x25
  _WORD *v315; // x24
  __int64 v316; // x9
  __int64 v317; // x9
  __int64 v318; // x9
  __int64 v319; // x9
  __int128 v320; // q0
  char *v321; // x1
  size_t v322; // x2
  __int128 v323; // q0
  void *v324; // x8
  char v325; // w26
  void *v326; // x24
  char *v327; // x1
  size_t v328; // x2
  unsigned __int16 *v329; // x8
  __int128 v330; // q0
  void *v331; // x27
  char v332; // w10
  __int64 v333; // x28
  __int64 *v334; // x21
  const void **v335; // x25
  char *v336; // x8
  _QWORD *v337; // x10
  void **v338; // x11
  void **v339; // x20
  char *v340; // x9
  __int128 v341; // t1
  _QWORD *v342; // x11
  void **v343; // x23
  char *v344; // x8
  void **v345; // x11
  void **v346; // x20
  char *v347; // x9
  _QWORD *v348; // x10
  __int128 v349; // t1
  void **v350; // x22
  char *v351; // x8
  void **v352; // x11
  void **v353; // x20
  char *v354; // x9
  _QWORD *v355; // x10
  __int128 v356; // t1
  void **v357; // x23
  char *v358; // x8
  void **v359; // x11
  void **v360; // x20
  char *v361; // x9
  _QWORD *v362; // x10
  __int128 v363; // t1
  void **v364; // x22
  unsigned __int8 *v365; // x28
  int v366; // w8
  unsigned __int8 *v367; // x24
  int v368; // w9
  size_t v369; // x25
  char *v370; // x23
  void **v371; // x19
  __int64 v372; // x23
  __int64 *v373; // x26
  _QWORD *v374; // x8
  unsigned __int64 v375; // x9
  void **v376; // x22
  __int64 v377; // x24
  __int64 v378; // x20
  __int64 v379; // x19
  _BYTE *v380; // x21
  __int64 v381; // x8
  unsigned __int64 v382; // x8
  unsigned __int64 v383; // x9
  __int64 v384; // x25
  unsigned __int64 v385; // x8
  __int64 v386; // x25
  unsigned __int64 v387; // x8
  __int64 v388; // x25
  unsigned __int64 v389; // x8
  __int64 v390; // x25
  unsigned __int64 v391; // x8
  __int64 v392; // x10
  unsigned __int8 *v393; // x24
  unsigned __int64 v394; // x26
  unsigned __int64 i; // x22
  char *v396; // x20
  size_t *v397; // x25
  char *v398; // x11
  void **v399; // x8
  size_t v400; // x23
  const void *v401; // x1
  void *v402; // x21
  const void *v403; // x21
  void *v404; // x0
  char *v405; // x8
  char *v406; // x23
  char *v407; // x23
  void **v408; // x8
  void **v409; // x8
  char v410; // t1
  void **v411; // x8
  size_t v412; // x24
  const void *v413; // x19
  void *v414; // x23
  void *v415; // x0
  char *v416; // x8
  void **v417; // x9
  void **v418; // x19
  _QWORD *v419; // x8
  size_t v420; // x10
  void **v421; // x20
  __int64 v422; // x21
  void **v423; // x23
  unsigned __int64 v424; // x8
  __int64 v425; // x27
  void **v426; // x19
  size_t *v427; // x9
  size_t *v428; // x21
  __int64 v429; // x23
  __int64 v430; // x10
  unsigned __int64 v431; // x28
  unsigned __int64 v432; // x26
  unsigned __int64 v433; // x9
  __int64 v434; // x21
  unsigned __int64 v435; // x9
  __int64 v436; // x8
  size_t v437; // x0
  void **v438; // x8
  size_t v439; // x20
  const void *v440; // x23
  void *v441; // x24
  _BYTE *v442; // x20
  void **v443; // x8
  void **v444; // x8
  char v445; // t1
  void **v446; // x8
  size_t v447; // x23
  const void *v448; // x24
  void *v449; // x20
  __int64 v450; // x19
  unsigned __int64 v451; // x8
  bool v452; // zf
  size_t v453; // x8
  void *v454; // x1
  size_t v455; // x2
  __int64 v456; // x19
  _BYTE *v457; // x21
  char *v458; // x1
  size_t v459; // x2
  __int64 v460; // x1
  unsigned __int64 v461; // x8
  unsigned __int64 v462; // x9
  unsigned __int64 v463; // x19
  unsigned __int64 v464; // x24
  char *v465; // x25
  size_t *v466; // x28
  char *v467; // x11
  __int64 v468; // x8
  size_t v469; // x26
  const void *v470; // x27
  void *v471; // x22
  char *v472; // x8
  char *v473; // x26
  char *v474; // x26
  __int64 v475; // x8
  __int64 v476; // x8
  char v477; // t1
  __int64 v478; // x8
  size_t v479; // x27
  const void *v480; // x21
  void *v481; // x26
  void *v482; // x0
  char *v483; // x8
  void **v484; // x9
  void **v485; // x20
  _QWORD *v486; // x8
  size_t v487; // x10
  void **v488; // x25
  __int64 v489; // x21
  void **v490; // x22
  unsigned __int64 v491; // x8
  __int64 v492; // x8
  __int64 v493; // x8
  unsigned __int64 v494; // x9
  unsigned __int64 v495; // x10
  const void *v496; // x11
  const void *v497; // x8
  unsigned __int64 v498; // x9
  const void *v499; // x26
  size_t v500; // x25
  char *v501; // x9
  _BOOL4 v502; // w20
  unsigned __int16 *v503; // x9
  __int64 v504; // x8
  __int64 v505; // x9
  __int64 v506; // x9
  unsigned __int64 v507; // x10
  unsigned int v508; // t1
  __int64 v509; // x20
  size_t *v510; // x0
  size_t v511; // x2
  char *v512; // x1
  _BYTE *v513; // x9
  __int64 v514; // x23
  __int64 v515; // x21
  size_t *v516; // x9
  size_t *v517; // x20
  __int64 v518; // x22
  __int64 v519; // x10
  unsigned __int64 v520; // x20
  unsigned __int64 v521; // x9
  __int64 v522; // x24
  unsigned __int64 v523; // x9
  __int64 v524; // x8
  size_t v525; // x0
  __int64 v526; // x8
  size_t v527; // x25
  const void *v528; // x26
  void *v529; // x27
  _BYTE *v530; // x25
  __int64 v531; // x8
  __int64 v532; // x8
  char v533; // t1
  __int64 v534; // x8
  size_t v535; // x26
  const void *v536; // x27
  void *v537; // x25
  unsigned __int64 v538; // x26
  char *v539; // x27
  size_t *v540; // x21
  char *v541; // x23
  __int64 v542; // x8
  size_t v543; // x24
  const void *v544; // x20
  void *v545; // x25
  char *v546; // x8
  char *v547; // x25
  char *v548; // x25
  __int64 v549; // x8
  __int64 v550; // x8
  char v551; // t1
  __int64 v552; // x8
  size_t v553; // x24
  const void *v554; // x20
  void *v555; // x25
  void *v556; // x0
  char *v557; // x8
  void **v558; // x9
  void **v559; // x19
  _QWORD *v560; // x8
  size_t v561; // x10
  void **v562; // x25
  __int64 v563; // x20
  void **v564; // x21
  unsigned __int64 v565; // x8
  size_t v566; // x27
  __int64 v567; // x8
  __int64 v568; // x8
  unsigned __int64 v569; // x9
  unsigned __int64 v570; // x10
  const void *v571; // x11
  const void *v572; // x8
  unsigned __int64 v573; // x9
  const void *v574; // x20
  size_t v575; // x21
  char *v576; // x9
  _BOOL4 v577; // w19
  unsigned __int16 *v578; // x9
  __int64 v579; // x8
  __int64 v580; // x9
  __int64 v581; // x9
  unsigned __int64 v582; // x10
  unsigned int v583; // t1
  __int64 v584; // x19
  size_t *v585; // x0
  size_t v586; // x2
  char *v587; // x1
  _BYTE *v588; // x9
  __int64 v589; // x8
  unsigned __int8 *v590; // x8
  unsigned __int64 v591; // x9
  bool v592; // zf
  unsigned __int64 v593; // x9
  const void *v594; // x21
  size_t v595; // x20
  size_t *v596; // x28
  char *v597; // x8
  char *v598; // x0
  _BOOL4 v599; // w20
  __int64 v600; // x19
  __int64 *v601; // x9
  size_t v602; // x8
  unsigned __int64 v603; // x20
  unsigned __int64 v604; // x22
  size_t v605; // x24
  unsigned __int64 v606; // x23
  char *v607; // x25
  char *v608; // x25
  size_t v609; // x8
  char *v610; // x21
  size_t v611; // x23
  __int64 v612; // x9
  unsigned __int64 v613; // x8
  size_t v614; // x20
  _WORD *v615; // x0
  _WORD *v616; // x21
  __int64 v617; // x8
  char *v618; // x8
  char *v619; // x1
  size_t v620; // x8
  __int64 v621; // x28
  __int64 v622; // x19
  size_t *v623; // x9
  size_t *v624; // x22
  __int64 v625; // x20
  __int64 v626; // x10
  unsigned __int64 v627; // x22
  unsigned __int64 v628; // x9
  __int64 v629; // x23
  unsigned __int64 v630; // x9
  __int64 v631; // x8
  size_t v632; // x0
  __int64 v633; // x8
  size_t v634; // x24
  const void *v635; // x20
  void *v636; // x21
  _BYTE *v637; // x24
  __int64 v638; // x8
  __int64 v639; // x8
  char v640; // t1
  __int64 v641; // x8
  size_t v642; // x25
  const void *v643; // x20
  void *v644; // x24
  __int64 v645; // x9
  __int64 v646; // x9
  unsigned __int64 v647; // x19
  unsigned __int64 v648; // x24
  char *v649; // x25
  size_t *v650; // x28
  char *v651; // x11
  __int64 v652; // x8
  size_t v653; // x26
  const void *v654; // x27
  void *v655; // x22
  char *v656; // x8
  char *v657; // x26
  char *v658; // x26
  __int64 v659; // x8
  __int64 v660; // x8
  char v661; // t1
  __int64 v662; // x8
  size_t v663; // x27
  const void *v664; // x21
  void *v665; // x26
  void *v666; // x0
  char *v667; // x8
  void **v668; // x9
  void **v669; // x20
  _QWORD *v670; // x8
  size_t v671; // x10
  void **v672; // x25
  __int64 v673; // x21
  void **v674; // x22
  unsigned __int64 v675; // x8
  __int64 v676; // x8
  __int64 v677; // x8
  unsigned __int64 v678; // x9
  unsigned __int64 v679; // x10
  const void *v680; // x11
  const void *v681; // x8
  unsigned __int64 v682; // x9
  const void *v683; // x26
  size_t v684; // x25
  char *v685; // x9
  _BOOL4 v686; // w20
  unsigned __int16 *v687; // x9
  __int64 v688; // x8
  __int64 v689; // x9
  __int64 v690; // x9
  unsigned __int64 v691; // x10
  unsigned int v692; // t1
  __int64 v693; // x20
  size_t *v694; // x0
  size_t v695; // x2
  char *v696; // x1
  _BYTE *v697; // x9
  __int64 v698; // x23
  __int64 v699; // x21
  size_t *v700; // x9
  size_t *v701; // x20
  __int64 v702; // x22
  __int64 v703; // x10
  unsigned __int64 v704; // x20
  unsigned __int64 v705; // x9
  __int64 v706; // x24
  unsigned __int64 v707; // x9
  __int64 v708; // x8
  size_t v709; // x0
  __int64 v710; // x8
  size_t v711; // x25
  const void *v712; // x26
  void *v713; // x27
  _BYTE *v714; // x25
  __int64 v715; // x8
  __int64 v716; // x8
  char v717; // t1
  __int64 v718; // x8
  size_t v719; // x26
  const void *v720; // x27
  void *v721; // x25
  __int64 v722; // x10
  __int64 v723; // x22
  __int64 v724; // x9
  unsigned __int64 v725; // x9
  __int64 v726; // x19
  char *v727; // x0
  char *v728; // x8
  char *v729; // x10
  void **v730; // x11
  void **v731; // x20
  char *v732; // x9
  __int128 v733; // t1
  void **v734; // x22
  char *v735; // x8
  char *v736; // x10
  void **v737; // x11
  void **v738; // x20
  char *v739; // x9
  __int128 v740; // t1
  void **v741; // x22
  __int64 v742; // x19
  unsigned __int64 v743; // x8
  __int64 v744; // x19
  unsigned __int64 v745; // x8
  __int64 v746; // x23
  unsigned __int64 v747; // x24
  unsigned __int64 v748; // x9
  int v749; // w8
  __int64 v750; // x10
  __int64 v751; // x20
  __int64 v752; // x9
  unsigned __int64 v753; // x9
  __int64 v754; // x19
  char *v755; // x0
  char *v756; // x8
  char *v757; // x0
  _BOOL4 v758; // w20
  __int64 v759; // x8
  unsigned __int64 v760; // x9
  size_t v761; // x10
  void *v762; // x11
  size_t *v763; // x0
  void *v764; // x8
  bool v765; // zf
  size_t v766; // x9
  void *v767; // x1
  size_t v768; // x2
  size_t *v769; // x0
  char v770; // w19
  void *v771; // x20
  char *v772; // x1
  size_t v773; // x2
  void *v774; // x9
  __int64 v775; // x10
  void *v776; // x11
  char v777; // w8
  void *v778; // x8
  void *v779; // x9
  __int64 v780; // x8
  unsigned __int64 v781; // x9
  size_t v782; // x10
  void *v783; // x11
  size_t *v784; // x0
  void *v785; // x8
  bool v786; // zf
  size_t v787; // x9
  void *v788; // x1
  size_t v789; // x2
  size_t *v790; // x0
  __int64 v791; // x20
  _BYTE *v792; // x19
  unsigned __int64 v793; // x8
  unsigned __int8 *v794; // x10
  unsigned __int8 *v795; // x0
  char *v796; // x8
  __int64 v797; // x8
  unsigned __int64 v798; // x9
  size_t v799; // x10
  void *v800; // x11
  size_t *v801; // x0
  void *v802; // x8
  bool v803; // zf
  size_t v804; // x9
  void *v805; // x1
  size_t v806; // x2
  size_t *v807; // x0
  char v808; // w19
  void *v809; // x20
  char *v810; // x1
  size_t v811; // x2
  char *v812; // x8
  __int128 v813; // q0
  void *v814; // x9
  __int64 v815; // x10
  void *v816; // x11
  char v817; // w8
  void *v818; // x8
  void *v819; // x9
  void **v820; // x20
  void **v821; // x22
  char *v822; // x9
  _BOOL4 v823; // w19
  unsigned __int16 *v824; // x9
  __int64 v825; // x19
  unsigned __int64 v826; // x8
  _BYTE *v827; // x24
  unsigned __int64 v828; // x9
  char *v829; // x22
  void **v830; // x20
  void **v831; // x22
  __int64 v832; // x10
  __int64 v833; // x20
  __int64 v834; // x9
  unsigned __int64 v835; // x9
  __int64 v836; // x19
  char *v837; // x0
  __int64 v838; // x9
  __int64 v839; // x10
  __int64 v840; // x22
  __int64 v841; // x9
  unsigned __int64 v842; // x9
  __int64 v843; // x19
  char *v844; // x0
  char *v845; // x8
  char *v846; // x10
  void **v847; // x11
  void **v848; // x21
  char *v849; // x9
  __int128 v850; // t1
  void **v851; // x22
  __int64 v852; // x10
  __int64 v853; // x21
  __int64 v854; // x9
  unsigned __int64 v855; // x9
  __int64 v856; // x25
  char *v857; // x0
  __int64 v858; // x19
  unsigned __int64 v859; // x8
  unsigned __int64 v860; // x19
  __int64 v861; // x22
  __int64 v862; // x8
  unsigned __int64 v863; // x9
  size_t v864; // x10
  void *v865; // x11
  size_t *v866; // x0
  void *v867; // x8
  bool v868; // zf
  size_t v869; // x9
  void *v870; // x1
  size_t v871; // x2
  size_t *v872; // x0
  char v873; // w21
  void *v874; // x23
  __int64 v875; // x24
  _BYTE *v876; // x19
  __int64 v877; // x10
  __int64 v878; // x23
  __int64 v879; // x8
  unsigned __int64 v880; // x8
  unsigned __int64 v881; // x9
  __int64 v882; // x9
  unsigned __int64 v883; // x19
  void *v884; // x0
  void **v885; // x21
  void **v886; // x22
  __int64 v887; // x8
  __int64 v888; // x10
  __int64 v889; // x20
  __int64 v890; // x9
  unsigned __int64 v891; // x9
  __int64 v892; // x19
  char *v893; // x0
  __int64 v894; // x10
  __int64 v895; // x20
  __int64 v896; // x9
  unsigned __int64 v897; // x9
  __int64 v898; // x19
  char *v899; // x0
  char *v900; // x8
  char *v901; // x10
  void **v902; // x11
  void **v903; // x20
  char *v904; // x9
  __int128 v905; // t1
  void **v906; // x22
  __int64 v907; // x9
  __int64 v908; // x19
  unsigned __int64 v909; // x8
  char *v910; // x1
  size_t v911; // x2
  __int64 v912; // x8
  void *v913; // x9
  void *v914; // x20
  char v915; // w19
  __int64 v916; // x8
  __int64 v917; // x9
  unsigned __int64 v918; // x8
  unsigned __int64 v919; // x9
  unsigned __int8 *v920; // x24
  char *v921; // x8
  __int128 v922; // q0
  char v923; // w19
  char *v924; // x24
  char *v925; // x1
  size_t v926; // x2
  int v927; // w19
  __int64 v928; // x8
  unsigned __int64 v929; // x8
  unsigned __int64 v930; // x9
  __int64 v931; // x10
  __int64 v932; // x20
  __int64 v933; // x9
  unsigned __int64 v934; // x9
  __int64 v935; // x19
  char *v936; // x0
  __int64 v937; // x9
  char *v938; // x8
  char *v939; // x10
  void **v940; // x11
  void **v941; // x20
  char *v942; // x9
  __int128 v943; // t1
  void **v944; // x22
  __int64 v945; // x19
  unsigned __int64 v946; // x8
  void **v947; // x20
  void **v948; // x22
  __int64 v949; // x9
  char *v950; // x8
  char *v951; // x10
  void **v952; // x11
  void **v953; // x20
  char *v954; // x9
  __int128 v955; // t1
  void **v956; // x21
  __int64 v957; // x9
  void **v958; // x20
  void **v959; // x22
  __int64 v960; // x19
  unsigned __int64 v961; // x8
  int v962; // w8
  char *v963; // x8
  char *v964; // x10
  void **v965; // x11
  void **v966; // x21
  char *v967; // x9
  __int128 v968; // t1
  void **v969; // x22
  _BYTE *v970; // x24
  _BYTE *v971; // x0
  _BYTE *v972; // x0
  bool v973; // cc
  _BYTE *v974; // x24
  char *v975; // x8
  void **v976; // x11
  void **v977; // x20
  char *v978; // x9
  _QWORD *v979; // x10
  __int128 v980; // t1
  void **v981; // x21
  __int64 v982; // x19
  unsigned __int64 v983; // x8
  void **v984; // x20
  void **v985; // x21
  int v986; // w8
  unsigned __int64 v987; // x28
  __int64 v988; // x25
  unsigned __int64 v989; // x8
  __int64 v990; // x9
  void **v991; // x21
  void **v992; // x22
  __int64 v993; // x9
  unsigned __int64 v994; // x19
  char *v995; // x20
  size_t *v996; // x24
  char *v997; // x11
  __int64 v998; // x8
  size_t v999; // x21
  const void *v1000; // x1
  void *v1001; // x26
  const void *v1002; // x26
  void *v1003; // x0
  char *v1004; // x8
  char *v1005; // x21
  char *v1006; // x21
  __int64 v1007; // x8
  __int64 v1008; // x8
  char v1009; // t1
  __int64 v1010; // x8
  size_t v1011; // x22
  const void *v1012; // x27
  void *v1013; // x21
  void *v1014; // x0
  char *v1015; // x8
  void **v1016; // x9
  void **v1017; // x21
  _QWORD *v1018; // x8
  size_t v1019; // x10
  void **v1020; // x20
  __int64 v1021; // x22
  void **v1022; // x24
  unsigned __int64 v1023; // x8
  __int64 v1024; // x23
  __int64 v1025; // x27
  size_t *v1026; // x9
  size_t *v1027; // x25
  __int64 v1028; // x21
  __int64 v1029; // x10
  unsigned __int64 v1030; // x25
  unsigned __int64 v1031; // x9
  __int64 v1032; // x22
  unsigned __int64 v1033; // x9
  __int64 v1034; // x8
  size_t v1035; // x0
  __int64 v1036; // x8
  size_t v1037; // x20
  const void *v1038; // x21
  void *v1039; // x22
  _BYTE *v1040; // x20
  __int64 v1041; // x8
  __int64 v1042; // x8
  char v1043; // t1
  __int64 v1044; // x8
  size_t v1045; // x21
  const void *v1046; // x22
  void *v1047; // x20
  unsigned __int64 v1048; // x22
  unsigned __int64 v1049; // x8
  unsigned __int64 v1050; // x9
  unsigned __int64 v1051; // x9
  __int64 v1052; // x9
  char *v1053; // x0
  char *v1054; // x8
  char *v1055; // x10
  void **v1056; // x11
  void **v1057; // x20
  char *v1058; // x9
  __int128 v1059; // t1
  void **v1060; // x22
  __int64 v1061; // x19
  unsigned __int64 v1062; // x8
  char *v1063; // x8
  char *v1064; // x10
  char *v1065; // x9
  void **v1066; // x11
  void **v1067; // x20
  __int128 v1068; // t1
  void **v1069; // x21
  __int64 v1070; // x19
  unsigned __int64 v1071; // x8
  void **v1072; // x20
  void **v1073; // x22
  void **v1074; // x0
  void **v1075; // x20
  void **v1076; // x21
  _BYTE *v1077; // x19
  _BYTE *v1078; // x0
  _BYTE *v1079; // x0
  _BYTE *v1080; // x19
  __int64 v1081; // x27
  unsigned __int64 v1082; // x23
  unsigned __int64 v1083; // x26
  int v1084; // w28
  __int64 v1085; // x8
  void *v1086; // x3
  char *v1087; // x2
  char *v1088; // x9
  _BOOL4 v1089; // w23
  unsigned __int16 *v1090; // x9
  _BYTE *v1091; // x25
  __int64 v1092; // x26
  unsigned __int64 v1093; // x8
  _BYTE *v1094; // x27
  unsigned __int64 v1095; // x9
  char *v1096; // x23
  void *v1097; // x0
  __int64 v1098; // x19
  __int64 v1099; // x21
  _WORD *v1100; // x19
  __int64 v1101; // x26
  unsigned __int64 v1102; // x24
  unsigned __int64 v1103; // x25
  int v1104; // w27
  unsigned __int64 v1105; // x28
  _BYTE *v1106; // x23
  _BYTE *v1107; // x0
  _BYTE *v1108; // x0
  _BYTE *v1109; // x24
  _BYTE *v1110; // x0
  unsigned __int64 v1111; // x22
  __int64 v1112; // x10
  __int64 v1113; // x24
  unsigned __int64 v1114; // x25
  __int64 v1115; // x24
  unsigned __int64 v1116; // x26
  char *v1117; // x0
  char *v1118; // x8
  unsigned __int64 v1119; // x9
  _OWORD *v1120; // x10
  __int128 *v1121; // x11
  unsigned __int64 v1122; // x12
  __int128 v1123; // q0
  __int128 v1124; // q1
  unsigned __int8 *v1125; // x9
  char v1126; // t1
  char *v1127; // x8
  __int128 v1128; // q0
  char *v1129; // x10
  size_t v1130; // x11
  bool v1131; // zf
  unsigned __int64 v1132; // x8
  char *v1133; // x2
  size_t v1134; // x3
  void *v1135; // x0
  char *v1136; // x8
  void **v1137; // x11
  void **v1138; // x19
  char *v1139; // x10
  __int64 v1140; // x12
  void **v1141; // x20
  __int64 v1142; // x22
  void **v1143; // x23
  unsigned __int64 v1144; // x8
  __int64 v1145; // x1
  unsigned __int64 v1146; // x8
  unsigned __int64 v1147; // x9
  void **v1148; // x19
  __int64 v1149; // x10
  __int64 v1150; // x20
  __int64 v1151; // x9
  unsigned __int64 v1152; // x9
  __int64 v1153; // x19
  char *v1154; // x0
  __int64 v1155; // x9
  char *v1156; // x8
  char *v1157; // x10
  void **v1158; // x11
  void **v1159; // x20
  char *v1160; // x9
  __int128 v1161; // t1
  void **v1162; // x22
  __int64 v1163; // x19
  unsigned __int64 v1164; // x8
  void **v1165; // x20
  void **v1166; // x22
  void *v1167; // x0
  void *v1168; // x24
  char v1169; // w10
  __int64 v1170; // x25
  __int64 *v1171; // x28
  const void **v1172; // x26
  __int64 v1173; // x21
  unsigned __int64 v1174; // x23
  int v1175; // w19
  unsigned __int64 v1176; // x22
  _BYTE *v1177; // x23
  _BYTE *v1178; // x0
  _BYTE *v1179; // x0
  _BYTE *v1180; // x23
  void *v1181; // x0
  __int64 v1182; // x8
  unsigned __int64 v1183; // x8
  unsigned __int64 v1184; // x9
  void **v1185; // x19
  __int64 v1186; // x10
  __int64 v1187; // x20
  __int64 v1188; // x9
  unsigned __int64 v1189; // x9
  __int64 v1190; // x19
  char *v1191; // x0
  __int64 v1192; // x9
  char *v1193; // x8
  char *v1194; // x10
  void **v1195; // x11
  void **v1196; // x20
  char *v1197; // x9
  __int128 v1198; // t1
  void **v1199; // x22
  __int64 v1200; // x19
  unsigned __int64 v1201; // x8
  void **v1202; // x20
  void **v1203; // x21
  _BYTE *v1204; // x22
  _BYTE *v1205; // x0
  _BYTE *v1206; // x0
  _BYTE *v1207; // x23
  __int64 v1208; // x23
  char *v1209; // x22
  void *v1210; // x8
  __int128 v1211; // q0
  __int64 v1212; // x8
  void *v1213; // x9
  void *v1214; // x23
  char v1215; // w19
  unsigned __int64 v1216; // x8
  unsigned __int64 v1217; // x9
  unsigned __int64 v1218; // x21
  unsigned __int64 v1219; // x8
  unsigned __int64 v1220; // x9
  unsigned __int64 v1221; // x9
  __int64 v1222; // x9
  char *v1223; // x0
  _BYTE *v1224; // x0
  unsigned __int64 v1225; // x8
  char *v1226; // x23
  size_t v1227; // x22
  unsigned __int64 v1228; // x9
  _BOOL4 v1229; // w22
  unsigned __int16 *v1230; // x9
  unsigned __int64 v1231; // x10
  char *v1232; // x22
  __int64 v1233; // x8
  __int64 v1234; // x23
  char *v1235; // x1
  size_t v1236; // x2
  void *v1237; // x8
  __int128 v1238; // q0
  char *v1239; // x8
  __int128 v1240; // q0
  unsigned __int16 *v1241; // x8
  __int128 v1242; // q0
  char v1243; // w19
  char *v1244; // x1
  size_t v1245; // x2
  __int64 v1246; // x9
  __int64 v1247; // x8
  void *v1248; // x26
  __int64 v1249; // x27
  __int64 *v1250; // x24
  const void **v1251; // x28
  __int64 v1252; // x23
  unsigned __int64 v1253; // x22
  unsigned __int64 v1254; // x25
  _BYTE *v1255; // x22
  _BYTE *v1256; // x0
  _BYTE *v1257; // x0
  _BYTE *v1258; // x22
  void *v1259; // x0
  char *v1261; // x8
  __int128 v1262; // q0
  char *v1263; // x8
  __int128 v1264; // q0
  char v1265; // w21
  void *v1266; // x19
  char *v1267; // x1
  size_t v1268; // x2
  char *v1269; // x8
  void **v1270; // x11
  void **v1271; // x19
  char *v1272; // x10
  __int64 v1273; // x12
  void **v1274; // x23
  __int64 v1275; // x21
  void **v1276; // x24
  unsigned __int64 v1277; // x8
  __int64 v1278; // x8
  unsigned __int64 v1279; // x8
  unsigned __int64 v1280; // x9
  __int64 v1281; // x10
  __int64 v1282; // x20
  __int64 v1283; // x9
  unsigned __int64 v1284; // x9
  __int64 v1285; // x19
  char *v1286; // x0
  __int64 v1287; // x9
  char *v1288; // x8
  char *v1289; // x10
  void **v1290; // x11
  void **v1291; // x20
  char *v1292; // x9
  __int128 v1293; // t1
  void **v1294; // x21
  __int64 v1295; // x19
  unsigned __int64 v1296; // x8
  void **v1297; // x20
  void **v1298; // x21
  __int64 v1299; // [xsp+10h] [xbp-1B0h]
  __int64 v1300; // [xsp+18h] [xbp-1A8h]
  char v1301; // [xsp+18h] [xbp-1A8h]
  char v1302; // [xsp+20h] [xbp-1A0h]
  __int64 v1303; // [xsp+20h] [xbp-1A0h]
  char v1304; // [xsp+20h] [xbp-1A0h]
  unsigned __int64 v1305; // [xsp+20h] [xbp-1A0h]
  int v1306; // [xsp+30h] [xbp-190h]
  unsigned __int8 *v1307; // [xsp+30h] [xbp-190h]
  unsigned __int64 v1308; // [xsp+30h] [xbp-190h]
  void *v1309; // [xsp+30h] [xbp-190h]
  int v1310; // [xsp+30h] [xbp-190h]
  char *v1311; // [xsp+38h] [xbp-188h]
  unsigned __int64 v1312; // [xsp+38h] [xbp-188h]
  unsigned __int64 v1313; // [xsp+38h] [xbp-188h]
  unsigned __int64 v1314; // [xsp+38h] [xbp-188h]
  unsigned __int64 v1315; // [xsp+38h] [xbp-188h]
  char v1316; // [xsp+38h] [xbp-188h]
  char v1317; // [xsp+38h] [xbp-188h]
  unsigned __int64 v1318; // [xsp+38h] [xbp-188h]
  unsigned __int64 v1319; // [xsp+38h] [xbp-188h]
  int v1321; // [xsp+48h] [xbp-178h]
  _BYTE *v1322; // [xsp+48h] [xbp-178h]
  char v1323; // [xsp+48h] [xbp-178h]
  char *v1324; // [xsp+48h] [xbp-178h]
  char *v1325; // [xsp+48h] [xbp-178h]
  char *v1326; // [xsp+48h] [xbp-178h]
  void *v1327; // [xsp+48h] [xbp-178h]
  void *v1328; // [xsp+48h] [xbp-178h]
  char *v1329; // [xsp+48h] [xbp-178h]
  char v1330; // [xsp+48h] [xbp-178h]
  void *v1331; // [xsp+48h] [xbp-178h]
  unsigned __int64 dest; // [xsp+50h] [xbp-170h]
  unsigned __int8 *desta; // [xsp+50h] [xbp-170h]
  unsigned __int8 *destb; // [xsp+50h] [xbp-170h]
  __int64 *destc; // [xsp+50h] [xbp-170h]
  unsigned __int64 destd; // [xsp+50h] [xbp-170h]
  char deste; // [xsp+50h] [xbp-170h]
  void *v1338[2]; // [xsp+60h] [xbp-160h] BYREF
  void *p; // [xsp+70h] [xbp-150h]
  __int128 v1340; // [xsp+78h] [xbp-148h] BYREF
  void *v1341; // [xsp+88h] [xbp-138h]
  _QWORD v1342[2]; // [xsp+90h] [xbp-130h] BYREF
  __int128 v1343; // [xsp+A0h] [xbp-120h] BYREF
  char *v1344; // [xsp+B0h] [xbp-110h]
  _BYTE v1345[32]; // [xsp+C0h] [xbp-100h] BYREF
  __int128 v1346; // [xsp+E0h] [xbp-E0h] BYREF
  void *v1347; // [xsp+F0h] [xbp-D0h]
  __int128 v1348; // [xsp+100h] [xbp-C0h] BYREF
  char *v1349; // [xsp+110h] [xbp-B0h]
  __int128 v1350; // [xsp+120h] [xbp-A0h] BYREF
  char *v1351; // [xsp+130h] [xbp-90h]
  __int128 v1352; // [xsp+138h] [xbp-88h] BYREF
  char *v1353; // [xsp+148h] [xbp-78h]
  __int128 v1354; // [xsp+150h] [xbp-70h] BYREF
  unsigned __int16 *v1355; // [xsp+160h] [xbp-60h]

  v3 = a2;
  v4 = a1;
  v5 = (unsigned __int8 *)(a1 - a2);
  _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  if ( a1 == a2 )
    return v4;
  v6 = *a1;
  v7 = 0;
  v1300 = 0x555555555555555LL;
  if ( v6 == 75 )
  {
    v8 = a1;
    goto LABEL_8;
  }
  v8 = a1;
  if ( v6 != 86 )
  {
    if ( v6 == 114 )
    {
      v8 = a1 + 1;
      v6 = a1[1];
      v7 = 4;
      goto LABEL_6;
    }
    v14 = sub_B2B20(a1, a2, a3);
    if ( (unsigned __int8 *)v14 != v4 )
      return (unsigned __int8 *)v14;
    switch ( *v4 )
    {
      case 'A':
        v21 = v4 + 1;
        if ( v4 + 1 == v3 )
          return v4;
        v22 = *v21;
        if ( v22 == 95 )
        {
          v23 = (_QWORD *)a3;
          v24 = sub_925FC(v4 + 2, v3, a3);
          if ( (unsigned __int8 *)v24 == v4 + 2 )
            return v4;
          v25 = *(_QWORD *)(a3 + 8);
          if ( *(_QWORD *)a3 == v25 )
            return v4;
          v1338[1] = 0LL;
          p = 0LL;
          v1338[0] = 0LL;
          v26 = *(unsigned __int8 *)(v25 - 24);
          v27 = (const void *)(v25 - 23);
          v29 = *(_QWORD *)(v25 - 16);
          v28 = *(const void **)(v25 - 8);
          v30 = (v26 & 1) == 0;
          if ( (v26 & 1) != 0 )
            v31 = v29;
          else
            v31 = v26 >> 1;
          if ( v30 )
            v32 = v27;
          else
            v32 = v28;
          if ( v31 >= 2 )
            v33 = 2LL;
          else
            v33 = v31;
          LOBYTE(v1338[0]) = 2 * v33;
          if ( v33 )
            memcpy((char *)v1338 + 1, v32, v33);
          *((_BYTE *)v1338 + v33 + 1) = 0;
          v822 = (char *)v1338[1];
          v823 = 0;
          if ( ((__int64)v1338[0] & 1) == 0 )
            v822 = (char *)((unsigned __int64)LOBYTE(v1338[0]) >> 1);
          if ( v822 == (_BYTE *)&dword_0 + 2 )
          {
            v824 = (unsigned __int16 *)p;
            if ( ((__int64)v1338[0] & 1) == 0 )
              v824 = (unsigned __int16 *)((char *)v1338 + 1);
            v823 = *v824 == 23328;
            if ( ((__int64)v1338[0] & 1) != 0 )
            {
LABEL_1087:
              free(p);
              if ( !v823 )
                goto LABEL_1165;
LABEL_1091:
              v825 = *(_QWORD *)(a3 + 8);
              v827 = (_BYTE *)(v825 - 24);
              v826 = *(unsigned __int8 *)(v825 - 24);
              if ( (*(_BYTE *)(v825 - 24) & 1) != 0 )
              {
                v828 = *(_QWORD *)(v825 - 16);
                v829 = *(char **)(v825 - 8);
              }
              else
              {
                v828 = v826 >> 1;
                v829 = (char *)(v825 - 23);
              }
              v877 = v828 != 0;
              v878 = v828 - v877;
              if ( v828 != v877 )
              {
                memmove(v829, &v829[v877], v828 - v877);
                LOBYTE(v826) = *v827;
              }
              if ( (v826 & 1) != 0 )
                *(_QWORD *)(v825 - 16) = v878;
              else
                *v827 = 2 * v878;
              v829[v878] = 0;
LABEL_1165:
              sub_9CDD8((size_t *)(*(_QWORD *)(a3 + 8) - 24LL), 0LL, " []", 3uLL);
              if ( (unsigned __int8 *)v24 != v4 )
                goto LABEL_1166;
              return v4;
            }
          }
          else if ( ((__int64)v1338[0] & 1) != 0 )
          {
            goto LABEL_1087;
          }
          if ( !v823 )
            goto LABEL_1165;
          goto LABEL_1091;
        }
        if ( (unsigned int)(v22 - 49) <= 8 )
        {
          v265 = -1LL;
          do
          {
            if ( &v5[v265] == (unsigned __int8 *)-3LL )
              return v4;
            v266 = v4[v265++ + 3];
          }
          while ( (unsigned int)(v266 - 48) < 0xA );
          if ( &v5[v265] == (unsigned __int8 *)-2LL )
            return v4;
          v267 = &v4[v265];
          if ( v4[v265 + 2] != 95 )
            return v4;
          v24 = sub_925FC(&v4[v265 + 3], v3, a3);
          if ( &v4[v265 - v24] == (unsigned __int8 *)-3LL )
            return v4;
          v268 = *(_QWORD *)(a3 + 8);
          if ( *(_QWORD *)a3 == v268 )
            return v4;
          v1338[1] = 0LL;
          p = 0LL;
          v1338[0] = 0LL;
          v269 = *(unsigned __int8 *)(v268 - 24);
          v270 = (const void *)(v268 - 23);
          v272 = *(_QWORD *)(v268 - 16);
          v271 = *(const void **)(v268 - 8);
          v273 = (v269 & 1) == 0;
          if ( (v269 & 1) != 0 )
            v274 = v272;
          else
            v274 = v269 >> 1;
          if ( v273 )
            v275 = v270;
          else
            v275 = v271;
          if ( v274 >= 2 )
            v276 = 2LL;
          else
            v276 = v274;
          LOBYTE(v1338[0]) = 2 * v276;
          if ( v276 )
            memcpy((char *)v1338 + 1, v275, v276);
          *((_BYTE *)v1338 + v276 + 1) = 0;
          v1088 = (char *)v1338[1];
          v1089 = 0;
          if ( ((__int64)v1338[0] & 1) == 0 )
            v1088 = (char *)((unsigned __int64)LOBYTE(v1338[0]) >> 1);
          if ( v1088 == (_BYTE *)&dword_0 + 2 )
          {
            v1090 = (unsigned __int16 *)p;
            if ( ((__int64)v1338[0] & 1) == 0 )
              v1090 = (unsigned __int16 *)((char *)v1338 + 1);
            v1089 = *v1090 == 23328;
            if ( ((__int64)v1338[0] & 1) != 0 )
            {
LABEL_1560:
              free(p);
              v1091 = v267 + 2;
              if ( !v1089 )
                goto LABEL_1613;
LABEL_1564:
              v1092 = *(_QWORD *)(a3 + 8);
              v1094 = (_BYTE *)(v1092 - 24);
              v1093 = *(unsigned __int8 *)(v1092 - 24);
              if ( (*(_BYTE *)(v1092 - 24) & 1) != 0 )
              {
                v1095 = *(_QWORD *)(v1092 - 16);
                v1096 = *(char **)(v1092 - 8);
              }
              else
              {
                v1095 = v1093 >> 1;
                v1096 = (char *)(v1092 - 23);
              }
              v1112 = v1095 != 0;
              v1113 = v1095 - v1112;
              if ( v1095 != v1112 )
              {
                memmove(v1096, &v1096[v1112], v1095 - v1112);
                LOBYTE(v1093) = *v1094;
              }
              if ( (v1093 & 1) != 0 )
                *(_QWORD *)(v1092 - 16) = v1113;
              else
                *v1094 = 2 * v1113;
              v1096[v1113] = 0;
LABEL_1613:
              v1114 = v1091 - v21;
              v1115 = *(_QWORD *)(a3 + 8);
              v1355 = 0LL;
              v1354 = 0uLL;
              if ( v1114 >= 0xFFFFFFFFFFFFFFF0LL )
                goto LABEL_1805;
              v1116 = v265 + 1;
              if ( v1114 > 0x16 )
              {
                v1117 = (char *)malloc((v1114 + 16) & 0xFFFFFFFFFFFFFFF0LL);
                *((_QWORD *)&v1354 + 1) = v1114;
                v1355 = (unsigned __int16 *)v1117;
                *(_QWORD *)&v1354 = (v1114 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
                if ( v1116 < 0x20 )
                  goto LABEL_1616;
              }
              else
              {
                LOBYTE(v1354) = 2 * v1114;
                v1117 = (char *)&v1354 + 1;
                if ( v1116 < 0x20 )
                {
LABEL_1616:
                  v1118 = v1117;
LABEL_1622:
                  v1125 = &v4[2LL - (_QWORD)v21 + v265];
                  do
                  {
                    v1126 = *v21++;
                    --v1125;
                    *v1118++ = v1126;
                  }
                  while ( v1125 );
LABEL_1624:
                  v1117[v1114] = 0;
                  sub_9CDD8((size_t *)&v1354, 0LL, " [", 2uLL);
                  v1127 = (char *)v1355;
                  v1128 = v1354;
                  v1355 = 0LL;
                  v1354 = 0uLL;
                  v1351 = v1127;
                  v1350 = v1128;
                  sub_9CFD0((size_t *)&v1350, "]", 1uLL);
                  *(_OWORD *)v1338 = v1350;
                  p = v1351;
                  v1130 = *((_QWORD *)&v1350 + 1);
                  v1129 = v1351;
                  v1351 = 0LL;
                  v1131 = (v1350 & 1) == 0;
                  v1132 = (unsigned __int64)(unsigned __int8)v1350 >> 1;
                  v1350 = 0uLL;
                  if ( v1131 )
                    v1133 = (char *)v1338 + 1;
                  else
                    v1133 = v1129;
                  if ( v1131 )
                    v1134 = v1132;
                  else
                    v1134 = v1130;
                  sub_9CDD8((size_t *)(v1115 - 24), 0LL, v1133, v1134);
                  if ( ((__int64)v1338[0] & 1) != 0 )
                  {
                    free(p);
                    if ( (v1350 & 1) == 0 )
                    {
LABEL_1632:
                      if ( (v1354 & 1) == 0 )
                        goto LABEL_1896;
                      goto LABEL_1636;
                    }
                  }
                  else if ( (v1350 & 1) == 0 )
                  {
                    goto LABEL_1632;
                  }
                  free(v1351);
                  if ( (v1354 & 1) == 0 )
                    goto LABEL_1896;
LABEL_1636:
                  v1135 = v1355;
LABEL_1895:
                  free(v1135);
                  goto LABEL_1896;
                }
              }
              v1119 = v1116 & 0xFFFFFFFFFFFFFFE0LL;
              v1118 = v1117;
              if ( (v1116 & 0xFFFFFFFFFFFFFFE0LL) != 0 )
              {
                v21 += v1119;
                v1118 = &v1117[v1119];
                v1120 = v1117 + 16;
                v1121 = (__int128 *)(v4 + 17);
                v1122 = v1116 & 0xFFFFFFFFFFFFFFE0LL;
                do
                {
                  v1123 = *(v1121 - 1);
                  v1124 = *v1121;
                  v1122 -= 32LL;
                  v1121 += 2;
                  *(v1120 - 1) = v1123;
                  *v1120 = v1124;
                  v1120 += 2;
                }
                while ( v1122 );
                if ( v1116 == v1119 )
                  goto LABEL_1624;
              }
              goto LABEL_1622;
            }
          }
          else if ( ((__int64)v1338[0] & 1) != 0 )
          {
            goto LABEL_1560;
          }
          v1091 = v267 + 2;
          if ( !v1089 )
            goto LABEL_1613;
          goto LABEL_1564;
        }
        v307 = (unsigned __int8 *)sub_A20BC(v4 + 1, v3, a3);
        if ( v307 == v21 )
          return v4;
        if ( v307 == v3 )
          return v4;
        if ( *v307 != 95 )
          return v4;
        v308 = v307 + 1;
        v24 = sub_925FC(v307 + 1, v3, a3);
        if ( (_BYTE *)v24 == v308 )
          return v4;
        v309 = *(_QWORD *)(a3 + 8);
        if ( 0xAAAAAAAAAAAAAAABLL * ((v309 - *(_QWORD *)a3) >> 4) < 2 )
          return v4;
        p = *(void **)(v309 - 32);
        *(_OWORD *)v1338 = *(_OWORD *)(v309 - 48);
        v310 = *(void **)(v309 - 8);
        *(_QWORD *)(v309 - 40) = 0LL;
        *(_QWORD *)(v309 - 32) = 0LL;
        *(_QWORD *)(v309 - 48) = 0LL;
        v1341 = v310;
        v1340 = *(_OWORD *)(v309 - 24);
        *(_QWORD *)(v309 - 16) = 0LL;
        *(_QWORD *)(v309 - 8) = 0LL;
        *(_QWORD *)(v309 - 24) = 0LL;
        v311 = *(_QWORD *)(a3 + 8);
        v312 = (_BYTE *)(v311 - 48);
        if ( (*(_BYTE *)(v311 - 24) & 1) != 0 )
          free(*(void **)(v311 - 8));
        if ( (*v312 & 1) != 0 )
          free(*(void **)(v311 - 32));
        *(_QWORD *)(a3 + 8) = v312;
        v1351 = *(char **)(v311 - 80);
        v1350 = *(_OWORD *)(v311 - 96);
        v313 = *(char **)(v311 - 56);
        *(_QWORD *)(v311 - 88) = 0LL;
        *(_QWORD *)(v311 - 80) = 0LL;
        *(_QWORD *)(v311 - 96) = 0LL;
        v1353 = v313;
        v1352 = *(_OWORD *)(v311 - 72);
        *(_QWORD *)(v311 - 64) = 0LL;
        *(_QWORD *)(v311 - 56) = 0LL;
        *(_QWORD *)(v311 - 72) = 0LL;
        v314 = *(_QWORD *)(a3 + 8);
        v315 = (_WORD *)(v314 - 48);
        if ( (*(_BYTE *)(v314 - 48) & 1) == 0 )
        {
          *v315 = 0;
          goto LABEL_1820;
        }
        **(_BYTE **)(v314 - 32) = 0;
        LOBYTE(v1081) = *(_BYTE *)(v314 - 48);
        *(_QWORD *)(v314 - 40) = 0LL;
        if ( (v1081 & 1) != 0 )
        {
          v1081 = *(_QWORD *)v315;
          v1082 = (*(_QWORD *)v315 & 0xFFFFFFFFFFFFFFFELL) - 1;
          if ( (*(_QWORD *)v315 & 1) != 0 )
          {
            v1083 = 0LL;
            v1084 = 0;
            goto LABEL_1604;
          }
        }
        else
        {
          v1082 = 22LL;
        }
        v1083 = (unsigned __int64)((unsigned __int8)v1081 & 0xFE) >> 1;
        if ( (unsigned __int8)v1081 >= 0x2Eu )
        {
          v1111 = ((unsigned __int8)(v1083 + 16) & 0xF0) - 1LL;
          v1084 = 1;
          if ( v1111 == v1082 )
            goto LABEL_1820;
LABEL_1788:
          if ( v1111 == 22 )
          {
            v1204 = *(_BYTE **)(v314 - 32);
            v1205 = (_BYTE *)(v314 - 47);
            if ( v1084 )
              memcpy(v1205, *(const void **)(v314 - 32), ((unsigned __int64)((unsigned __int8)v1081 & 0xFE) >> 1) + 1);
            else
              *v1205 = *v1204;
            free(v1204);
            *(_BYTE *)v315 = 2 * v1083;
          }
          else
          {
            v1206 = malloc(v1111 + 1);
            v973 = v1111 > v1082;
            v1207 = v1206;
            if ( v973 || v1206 )
            {
              if ( (v1084 & 1) != 0 )
              {
                memcpy(v1206, (const void *)(v314 - 47), ((unsigned __int64)((unsigned __int8)v1081 & 0xFE) >> 1) + 1);
              }
              else
              {
                v1224 = *(_BYTE **)(v314 - 32);
                *v1207 = *v1224;
                free(v1224);
              }
              *(_QWORD *)(v314 - 32) = v1207;
              *(_QWORD *)(v314 - 48) = (v1111 + 1) | 1;
              *(_QWORD *)(v314 - 40) = v1083;
            }
          }
LABEL_1820:
          *(_QWORD *)(v314 - 32) = p;
          *(_OWORD *)v315 = *(_OWORD *)v1338;
          v1338[1] = 0LL;
          p = 0LL;
          v1338[0] = 0LL;
          v1225 = (unsigned __int64)(unsigned __int8)v1340 >> 1;
          if ( (v1340 & 1) != 0 )
          {
            v1225 = *((_QWORD *)&v1340 + 1);
            v1226 = (char *)v1341;
          }
          else
          {
            v1226 = (char *)&v1340 + 1;
          }
          if ( v1225 >= 2 )
            v1227 = 2LL;
          else
            v1227 = v1225;
          v1355 = 0LL;
          v1354 = 0uLL;
          LOBYTE(v1354) = 2 * v1227;
          if ( v1227 )
            memcpy((char *)&v1354 + 1, v1226, v1227);
          *((_BYTE *)&v1354 + v1227 + 1) = 0;
          v1228 = *((_QWORD *)&v1354 + 1);
          v1229 = 0;
          if ( (v1354 & 1) == 0 )
            v1228 = (unsigned __int64)(unsigned __int8)v1354 >> 1;
          if ( v1228 == 2 )
          {
            v1230 = v1355;
            if ( (v1354 & 1) == 0 )
              v1230 = (unsigned __int16 *)((char *)&v1354 + 1);
            v1229 = *v1230 == 23328;
          }
          if ( (v1354 & 1) != 0 )
            free(v1355);
          if ( v1229 )
          {
            v1231 = (unsigned __int64)(unsigned __int8)v1340 >> 1;
            if ( (v1340 & 1) != 0 )
            {
              v1231 = *((_QWORD *)&v1340 + 1);
              v1232 = (char *)v1341;
            }
            else
            {
              v1232 = (char *)&v1340 + 1;
            }
            v1233 = v1231 != 0;
            v1234 = v1231 - v1233;
            if ( v1231 != v1233 )
              memmove(v1232, &v1232[v1233], v1231 - v1233);
            if ( (v1340 & 1) != 0 )
              *((_QWORD *)&v1340 + 1) = v1234;
            else
              LOBYTE(v1340) = 2 * v1234;
            v1232[v1234] = 0;
          }
          if ( (v1352 & 1) != 0 )
            v1235 = v1353;
          else
            v1235 = (char *)&v1352 + 1;
          if ( (v1352 & 1) != 0 )
            v1236 = *((_QWORD *)&v1352 + 1);
          else
            v1236 = (unsigned __int64)(unsigned __int8)v1352 >> 1;
          sub_9CFD0((size_t *)&v1350, v1235, v1236);
          v1237 = v1351;
          v1238 = v1350;
          v1351 = 0LL;
          v1350 = 0uLL;
          v1347 = v1237;
          v1346 = v1238;
          sub_9CDD8((size_t *)&v1346, 0LL, " [", 2uLL);
          v1239 = (char *)v1347;
          v1240 = v1346;
          v1347 = 0LL;
          v1346 = 0uLL;
          v1349 = v1239;
          v1348 = v1240;
          sub_9CFD0((size_t *)&v1348, "]", 1uLL);
          v1241 = (unsigned __int16 *)v1349;
          v1242 = v1348;
          v1349 = 0LL;
          v1348 = 0uLL;
          v1243 = v1340;
          v1355 = v1241;
          v1354 = v1242;
          if ( (v1340 & 1) != 0 )
            v1244 = (char *)v1341;
          else
            v1244 = (char *)&v1340 + 1;
          v1331 = v1341;
          if ( (v1340 & 1) != 0 )
            v1245 = *((_QWORD *)&v1340 + 1);
          else
            v1245 = (unsigned __int64)(unsigned __int8)v1340 >> 1;
          sub_9CFD0((size_t *)&v1354, v1244, v1245);
          v1246 = *(_QWORD *)((char *)&v1354 + 1);
          deste = v1354;
          v1247 = *((_QWORD *)&v1354 + 1);
          v1248 = v1355;
          v1354 = 0uLL;
          v1355 = 0LL;
          *(_QWORD *)((char *)&v1343 + 7) = v1247;
          *(_QWORD *)&v1343 = v1246;
          v1249 = *(_QWORD *)(a3 + 8);
          v1250 = (__int64 *)(v1249 - 24);
          if ( (*(_BYTE *)(v1249 - 24) & 1) == 0 )
          {
            *(_WORD *)(v1249 - 24) = 0;
            v1251 = (const void **)(v1249 - 8);
            goto LABEL_1880;
          }
          v1251 = (const void **)(v1249 - 8);
          **(_BYTE **)(v1249 - 8) = 0;
          LOBYTE(v1252) = *(_BYTE *)(v1249 - 24);
          *(_QWORD *)(v1249 - 16) = 0LL;
          if ( (v1252 & 1) != 0 )
          {
            v1252 = *v1250;
            v1253 = (*v1250 & 0xFFFFFFFFFFFFFFFELL) - 1;
            if ( (*v1250 & 1) != 0 )
            {
              v1319 = 0LL;
              v1310 = 0;
              goto LABEL_1866;
            }
          }
          else
          {
            v1253 = 22LL;
          }
          v1319 = (unsigned __int64)((unsigned __int8)v1252 & 0xFE) >> 1;
          if ( (unsigned __int8)v1252 >= 0x2Eu )
          {
            v1254 = ((unsigned __int8)(v1319 + 16) & 0xF0) - 1LL;
            v1310 = 1;
            if ( v1254 == v1253 )
              goto LABEL_1880;
LABEL_1869:
            if ( v1254 == 22 )
            {
              v1255 = *v1251;
              v1256 = (_BYTE *)(v1249 - 23);
              if ( v1310 )
                memcpy(v1256, *v1251, ((unsigned __int64)((unsigned __int8)v1252 & 0xFE) >> 1) + 1);
              else
                *v1256 = *v1255;
              free(v1255);
              *(_BYTE *)v1250 = 2 * v1319;
            }
            else
            {
              v1257 = malloc(v1254 + 1);
              v973 = v1254 > v1253;
              v1258 = v1257;
              if ( v973 || v1257 )
              {
                if ( (v1310 & 1) != 0 )
                {
                  memcpy(
                    v1257,
                    (const void *)(v1249 - 23),
                    ((unsigned __int64)((unsigned __int8)v1252 & 0xFE) >> 1) + 1);
                }
                else
                {
                  v1259 = (void *)*v1251;
                  *v1258 = *(_BYTE *)*v1251;
                  free(v1259);
                }
                *(_QWORD *)(v1249 - 24) = (v1254 + 1) | 1;
                *(_QWORD *)(v1249 - 16) = v1319;
                *(_QWORD *)(v1249 - 8) = v1258;
              }
            }
LABEL_1880:
            *(_BYTE *)(v1249 - 24) = deste;
            *(_QWORD *)(v1249 - 23) = v1343;
            *(_QWORD *)(v1249 - 16) = *(_QWORD *)((char *)&v1343 + 7);
            *v1251 = v1248;
            *(_QWORD *)&v1343 = 0LL;
            *(_QWORD *)((char *)&v1343 + 7) = 0LL;
            if ( (v1354 & 1) != 0 )
            {
              free(v1355);
              if ( (v1348 & 1) == 0 )
              {
LABEL_1882:
                if ( (v1346 & 1) == 0 )
                  goto LABEL_1883;
                goto LABEL_1890;
              }
            }
            else if ( (v1348 & 1) == 0 )
            {
              goto LABEL_1882;
            }
            free(v1349);
            if ( (v1346 & 1) == 0 )
            {
LABEL_1883:
              if ( (v1352 & 1) == 0 )
                goto LABEL_1884;
              goto LABEL_1891;
            }
LABEL_1890:
            free(v1347);
            if ( (v1352 & 1) == 0 )
            {
LABEL_1884:
              if ( (v1350 & 1) == 0 )
                goto LABEL_1885;
              goto LABEL_1892;
            }
LABEL_1891:
            free(v1353);
            if ( (v1350 & 1) == 0 )
            {
LABEL_1885:
              if ( (v1243 & 1) == 0 )
                goto LABEL_1886;
              goto LABEL_1893;
            }
LABEL_1892:
            free(v1351);
            if ( (v1243 & 1) == 0 )
            {
LABEL_1886:
              if ( ((__int64)v1338[0] & 1) == 0 )
              {
LABEL_1896:
                v23 = (_QWORD *)a3;
                if ( (unsigned __int8 *)v24 != v4 )
                {
LABEL_1166:
                  v879 = v23[1];
                  v14 = (__int64)v4;
                  if ( *v23 == v879 )
                    return (unsigned __int8 *)v14;
                  *(_QWORD *)&v1350 = v23[3];
                  sub_9D15C((size_t **)v1338, v879 - 48, (__int64 *)&v1350);
                  v880 = v23[5];
                  v881 = v23[6];
                  if ( v880 < v881 )
                  {
                    *(_QWORD *)(v880 + 24) = v1340;
                    *(_OWORD *)v880 = *(_OWORD *)v1338;
                    *(_QWORD *)(v880 + 16) = p;
                    v1338[1] = 0LL;
                    p = 0LL;
                    v1338[0] = 0LL;
                    v23[5] += 32LL;
                    v178 = (void **)v1338[0];
                    if ( !v1338[0] )
                      return (unsigned __int8 *)v24;
                    goto LABEL_1502;
                  }
                  v888 = v23[4];
                  v889 = (__int64)(v880 - v888) >> 5;
                  if ( (unsigned __int64)(v889 + 1) >> 59 )
                    abort();
                  v890 = v881 - v888;
                  if ( (unsigned __int64)(v890 >> 5) > 0x3FFFFFFFFFFFFFELL )
                  {
                    v892 = 0x7FFFFFFFFFFFFFFLL;
                  }
                  else
                  {
                    v891 = v890 >> 4;
                    if ( v891 >= v889 + 1 )
                      v892 = v891;
                    else
                      v892 = v889 + 1;
                    if ( !v892 )
                    {
                      v893 = 0LL;
LABEL_1475:
                      v1054 = &v893[32 * v889];
                      *((_QWORD *)v1054 + 1) = 0LL;
                      *((_QWORD *)v1054 + 2) = 0LL;
                      v1055 = v1054 + 32;
                      *((_QWORD *)v1054 + 3) = v1340;
                      *(_OWORD *)v1054 = *(_OWORD *)v1338;
                      *((_QWORD *)v1054 + 2) = p;
                      v1338[1] = 0LL;
                      p = 0LL;
                      v1338[0] = 0LL;
                      v1057 = (void **)v23[4];
                      v1056 = (void **)v23[5];
                      v1058 = &v893[32 * v892];
                      if ( v1056 == v1057 )
                      {
                        v1060 = (void **)v23[4];
                      }
                      else
                      {
                        do
                        {
                          *((_QWORD *)v1054 - 3) = 0LL;
                          *((_QWORD *)v1054 - 2) = 0LL;
                          *((_QWORD *)v1054 - 4) = 0LL;
                          *((_QWORD *)v1054 - 1) = *(v1056 - 1);
                          v1059 = *((_OWORD *)v1056 - 2);
                          v1056 -= 4;
                          *((_OWORD *)v1054 - 2) = v1059;
                          *((_QWORD *)v1054 - 2) = v1056[2];
                          v1054 -= 32;
                          v1056[1] = 0LL;
                          v1056[2] = 0LL;
                          *v1056 = 0LL;
                        }
                        while ( v1057 != v1056 );
                        v1060 = (void **)v23[4];
                        v1057 = (void **)v23[5];
                      }
                      v1061 = v23[6];
                      v23[4] = v1054;
                      v23[5] = v1055;
                      v23[6] = v1058;
                      while ( v1060 != v1057 )
                      {
                        v1057 -= 4;
                        sub_9D32C(v1057);
                      }
                      if ( v1060 )
                      {
                        v1062 = v23[7];
                        if ( v1062 + 4096 < (unsigned __int64)v1060 || v1062 > (unsigned __int64)v1060 )
                        {
                          free(v1060);
                        }
                        else if ( *(_QWORD *)(v1062 + 4096) == v1061 )
                        {
                          *(_QWORD *)(v1062 + 4096) = v1060;
                          v178 = (void **)v1338[0];
                          if ( !v1338[0] )
                            return (unsigned __int8 *)v24;
LABEL_1502:
                          v1072 = (void **)v1338[1];
                          if ( v1338[1] != v178 )
                          {
                            do
                            {
                              if ( (*(_BYTE *)(v1072 - 3) & 1) != 0 )
                                free(*(v1072 - 1));
                              v1073 = v1072 - 6;
                              if ( (*(_BYTE *)(v1072 - 6) & 1) != 0 )
                                free(*(v1072 - 4));
                              v1072 -= 6;
                            }
                            while ( v178 != v1073 );
                          }
LABEL_1508:
                          v1338[1] = v178;
                          if ( (__int64)v1340 + 4096 >= (unsigned __int64)v178
                            && (unsigned __int64)v1340 <= (unsigned __int64)v178 )
                          {
                            if ( *(void **)(v1340 + 4096) == p )
                            {
                              *(_QWORD *)(v1340 + 4096) = v178;
                              return (unsigned __int8 *)v24;
                            }
                            return (unsigned __int8 *)v24;
                          }
                          v1074 = v178;
LABEL_1513:
                          free(v1074);
                          return (unsigned __int8 *)v24;
                        }
                      }
                      v178 = (void **)v1338[0];
                      if ( !v1338[0] )
                        return (unsigned __int8 *)v24;
                      goto LABEL_1502;
                    }
                  }
                  v990 = v23[7];
                  v893 = *(char **)(v990 + 4096);
                  if ( v990 + 4096 - (__int64)v893 >= (unsigned __int64)(32 * v892) )
                    *(_QWORD *)(v990 + 4096) = &v893[32 * v892];
                  else
                    v893 = (char *)malloc(32 * v892);
                  v23 = (_QWORD *)a3;
                  goto LABEL_1475;
                }
                return v4;
              }
              goto LABEL_1894;
            }
LABEL_1893:
            free(v1331);
            if ( ((__int64)v1338[0] & 1) == 0 )
              goto LABEL_1896;
LABEL_1894:
            v1135 = p;
            goto LABEL_1895;
          }
          v1310 = 1;
LABEL_1866:
          v1254 = 22LL;
          if ( v1253 == 22 )
            goto LABEL_1880;
          goto LABEL_1869;
        }
        v1084 = 1;
LABEL_1604:
        v1111 = 22LL;
        if ( v1082 == 22 )
          goto LABEL_1820;
        goto LABEL_1788;
      case 'C':
        v24 = sub_925FC(v4 + 1, v3, a3);
        if ( (unsigned __int8 *)v24 == v4 + 1 )
          return v4;
        v174 = *(_QWORD *)(a3 + 8);
        v14 = (__int64)v4;
        if ( *(_QWORD *)a3 == v174 )
          return (unsigned __int8 *)v14;
        sub_9CFD0((size_t *)(v174 - 48), " complex", 8uLL);
        v175 = *(_QWORD *)(a3 + 8) - 48LL;
        *(_QWORD *)&v1350 = *(_QWORD *)(a3 + 24);
        sub_9D15C((size_t **)v1338, v175, (__int64 *)&v1350);
        v176 = *(_QWORD *)(a3 + 40);
        v177 = *(_QWORD *)(a3 + 48);
        if ( v176 < v177 )
        {
          *(_QWORD *)(v176 + 24) = v1340;
          *(_OWORD *)v176 = *(_OWORD *)v1338;
          *(_QWORD *)(v176 + 16) = p;
          v1338[1] = 0LL;
          p = 0LL;
          v1338[0] = 0LL;
          *(_QWORD *)(a3 + 40) += 32LL;
          v178 = (void **)v1338[0];
          if ( !v1338[0] )
            return (unsigned __int8 *)v24;
          goto LABEL_1073;
        }
        v295 = *(_QWORD *)(a3 + 32);
        v296 = (__int64)(v176 - v295) >> 5;
        if ( (unsigned __int64)(v296 + 1) >> 59 )
          abort();
        v297 = v177 - v295;
        if ( (unsigned __int64)(v297 >> 5) > 0x3FFFFFFFFFFFFFELL )
        {
          v299 = 0x7FFFFFFFFFFFFFFLL;
        }
        else
        {
          v298 = v297 >> 4;
          if ( v298 >= v296 + 1 )
            v299 = v298;
          else
            v299 = v296 + 1;
          if ( !v299 )
          {
            v300 = 0LL;
            goto LABEL_973;
          }
        }
        v645 = *(_QWORD *)(a3 + 56);
        v300 = *(char **)(v645 + 4096);
        if ( v645 + 4096 - (__int64)v300 >= (unsigned __int64)(32 * v299) )
          *(_QWORD *)(v645 + 4096) = &v300[32 * v299];
        else
          v300 = (char *)malloc(32 * v299);
LABEL_973:
        v728 = &v300[32 * v296];
        *((_QWORD *)v728 + 1) = 0LL;
        *((_QWORD *)v728 + 2) = 0LL;
        v729 = v728 + 32;
        *((_QWORD *)v728 + 3) = v1340;
        *(_OWORD *)v728 = *(_OWORD *)v1338;
        *((_QWORD *)v728 + 2) = p;
        v1338[1] = 0LL;
        p = 0LL;
        v1338[0] = 0LL;
        v731 = *(void ***)(a3 + 32);
        v730 = *(void ***)(a3 + 40);
        v732 = &v300[32 * v299];
        if ( v730 == v731 )
        {
          v734 = *(void ***)(a3 + 32);
        }
        else
        {
          do
          {
            *((_QWORD *)v728 - 3) = 0LL;
            *((_QWORD *)v728 - 2) = 0LL;
            *((_QWORD *)v728 - 4) = 0LL;
            *((_QWORD *)v728 - 1) = *(v730 - 1);
            v733 = *((_OWORD *)v730 - 2);
            v730 -= 4;
            *((_OWORD *)v728 - 2) = v733;
            *((_QWORD *)v728 - 2) = v730[2];
            v728 -= 32;
            v730[1] = 0LL;
            v730[2] = 0LL;
            *v730 = 0LL;
          }
          while ( v731 != v730 );
          v734 = *(void ***)(a3 + 32);
          v731 = *(void ***)(a3 + 40);
        }
        v742 = *(_QWORD *)(a3 + 48);
        *(_QWORD *)(a3 + 32) = v728;
        *(_QWORD *)(a3 + 40) = v729;
        *(_QWORD *)(a3 + 48) = v732;
        while ( v734 != v731 )
        {
          v731 -= 4;
          sub_9D32C(v731);
        }
        if ( !v734 )
          goto LABEL_1072;
        v743 = *(_QWORD *)(a3 + 56);
        if ( v743 + 4096 < (unsigned __int64)v734 || v743 > (unsigned __int64)v734 )
        {
          free(v734);
        }
        else if ( *(_QWORD *)(v743 + 4096) == v742 )
        {
          *(_QWORD *)(v743 + 4096) = v734;
          v178 = (void **)v1338[0];
          if ( !v1338[0] )
            return (unsigned __int8 *)v24;
          goto LABEL_1073;
        }
LABEL_1072:
        v178 = (void **)v1338[0];
        if ( !v1338[0] )
          return (unsigned __int8 *)v24;
LABEL_1073:
        v820 = (void **)v1338[1];
        if ( v1338[1] != v178 )
        {
          do
          {
            if ( (*(_BYTE *)(v820 - 3) & 1) != 0 )
              free(*(v820 - 1));
            v821 = v820 - 6;
            if ( (*(_BYTE *)(v820 - 6) & 1) != 0 )
              free(*(v820 - 4));
            v820 -= 6;
          }
          while ( v178 != v821 );
        }
        goto LABEL_1508;
      case 'D':
        if ( v4 + 1 == v3 )
          goto LABEL_1249;
        switch ( v4[1] )
        {
          case 'T':
          case 't':
            v126 = sub_A0A48(v4, v3, (_QWORD *)a3);
            if ( v126 == v4 )
              goto LABEL_1249;
            v14 = (__int64)v4;
            v127 = *(_QWORD *)(a3 + 8);
            if ( *(_QWORD *)a3 == v127 )
              return (unsigned __int8 *)v14;
            *(_QWORD *)&v1350 = *(_QWORD *)(a3 + 24);
            sub_9D15C((size_t **)v1338, v127 - 48, (__int64 *)&v1350);
            v128 = *(_QWORD *)(a3 + 40);
            v129 = *(_QWORD *)(a3 + 48);
            if ( v128 < v129 )
            {
              *(_QWORD *)(v128 + 24) = v1340;
              *(_OWORD *)v128 = *(_OWORD *)v1338;
              *(_QWORD *)(v128 + 16) = p;
              v1338[1] = 0LL;
              p = 0LL;
              v1338[0] = 0LL;
              *(_QWORD *)(a3 + 40) += 32LL;
              v130 = (void **)v1338[0];
              if ( !v1338[0] )
                return v126;
              goto LABEL_1352;
            }
            v832 = *(_QWORD *)(a3 + 32);
            v833 = (__int64)(v128 - v832) >> 5;
            if ( (unsigned __int64)(v833 + 1) >> 59 )
              abort();
            v834 = v129 - v832;
            if ( (unsigned __int64)(v834 >> 5) > 0x3FFFFFFFFFFFFFELL )
            {
              v836 = 0x7FFFFFFFFFFFFFFLL;
            }
            else
            {
              v835 = v834 >> 4;
              if ( v835 >= v833 + 1 )
                v836 = v835;
              else
                v836 = v833 + 1;
              if ( !v836 )
              {
                v837 = 0LL;
                goto LABEL_1291;
              }
            }
            v907 = *(_QWORD *)(a3 + 56);
            v837 = *(char **)(v907 + 4096);
            if ( v907 + 4096 - (__int64)v837 >= (unsigned __int64)(32 * v836) )
              *(_QWORD *)(v907 + 4096) = &v837[32 * v836];
            else
              v837 = (char *)malloc(32 * v836);
LABEL_1291:
            v950 = &v837[32 * v833];
            *((_QWORD *)v950 + 1) = 0LL;
            *((_QWORD *)v950 + 2) = 0LL;
            v951 = v950 + 32;
            *((_QWORD *)v950 + 3) = v1340;
            *(_OWORD *)v950 = *(_OWORD *)v1338;
            *((_QWORD *)v950 + 2) = p;
            v1338[1] = 0LL;
            p = 0LL;
            v1338[0] = 0LL;
            v953 = *(void ***)(a3 + 32);
            v952 = *(void ***)(a3 + 40);
            v954 = &v837[32 * v836];
            if ( v952 == v953 )
            {
              v956 = *(void ***)(a3 + 32);
            }
            else
            {
              do
              {
                *((_QWORD *)v950 - 3) = 0LL;
                *((_QWORD *)v950 - 2) = 0LL;
                *((_QWORD *)v950 - 4) = 0LL;
                *((_QWORD *)v950 - 1) = *(v952 - 1);
                v955 = *((_OWORD *)v952 - 2);
                v952 -= 4;
                *((_OWORD *)v950 - 2) = v955;
                *((_QWORD *)v950 - 2) = v952[2];
                v950 -= 32;
                v952[1] = 0LL;
                v952[2] = 0LL;
                *v952 = 0LL;
              }
              while ( v953 != v952 );
              v956 = *(void ***)(a3 + 32);
              v953 = *(void ***)(a3 + 40);
            }
            v960 = *(_QWORD *)(a3 + 48);
            *(_QWORD *)(a3 + 32) = v950;
            *(_QWORD *)(a3 + 40) = v951;
            *(_QWORD *)(a3 + 48) = v954;
            while ( v956 != v953 )
            {
              v953 -= 4;
              sub_9D32C(v953);
            }
            if ( !v956 )
              goto LABEL_1351;
            v961 = *(_QWORD *)(a3 + 56);
            if ( v961 + 4096 < (unsigned __int64)v956 || v961 > (unsigned __int64)v956 )
            {
              free(v956);
            }
            else if ( *(_QWORD *)(v961 + 4096) == v960 )
            {
              *(_QWORD *)(v961 + 4096) = v956;
              v130 = (void **)v1338[0];
              if ( !v1338[0] )
                return v126;
              goto LABEL_1352;
            }
LABEL_1351:
            v130 = (void **)v1338[0];
            if ( !v1338[0] )
              return v126;
LABEL_1352:
            v984 = (void **)v1338[1];
            if ( v1338[1] != v130 )
            {
              do
              {
                if ( (*(_BYTE *)(v984 - 3) & 1) != 0 )
                  free(*(v984 - 1));
                v985 = v984 - 6;
                if ( (*(_BYTE *)(v984 - 6) & 1) != 0 )
                  free(*(v984 - 4));
                v984 -= 6;
              }
              while ( v130 != v985 );
            }
            goto LABEL_1525;
          case 'p':
            v371 = *(void ***)a3;
            v372 = *(_QWORD *)(a3 + 8);
            v14 = sub_925FC(v4 + 2, v3, a3);
            if ( (unsigned __int8 *)v14 == v4 + 2 )
              goto LABEL_1249;
            v373 = (__int64 *)a3;
            v374 = *(_QWORD **)(a3 + 40);
            v375 = *(_QWORD *)(a3 + 48);
            v376 = *(void ***)a3;
            v377 = *(_QWORD *)(a3 + 8);
            v378 = *(_QWORD *)(a3 + 24);
            if ( (unsigned __int64)v374 < v375 )
            {
              *v374 = 0LL;
              v374[1] = 0LL;
              v374[2] = 0LL;
              v374[3] = v378;
              *(_QWORD *)(a3 + 40) += 32LL;
              goto LABEL_1398;
            }
            v852 = *(_QWORD *)(a3 + 32);
            v853 = ((__int64)v374 - v852) >> 5;
            if ( (unsigned __int64)(v853 + 1) >> 59 )
              goto LABEL_1805;
            v854 = v375 - v852;
            if ( (unsigned __int64)(v854 >> 5) > 0x3FFFFFFFFFFFFFELL )
            {
              v856 = 0x7FFFFFFFFFFFFFFLL;
            }
            else
            {
              v855 = v854 >> 4;
              if ( v855 >= v853 + 1 )
                v856 = v855;
              else
                v856 = v853 + 1;
              if ( !v856 )
              {
                v857 = 0LL;
LABEL_1338:
                v975 = &v857[32 * v853];
                *(_QWORD *)v975 = 0LL;
                *((_QWORD *)v975 + 1) = 0LL;
                *((_QWORD *)v975 + 2) = 0LL;
                *((_QWORD *)v975 + 3) = v378;
                v977 = *(void ***)(a3 + 32);
                v976 = *(void ***)(a3 + 40);
                v978 = &v857[32 * v856];
                v979 = v975 + 32;
                if ( v976 == v977 )
                {
                  v981 = *(void ***)(a3 + 32);
                }
                else
                {
                  do
                  {
                    *((_QWORD *)v975 - 3) = 0LL;
                    *((_QWORD *)v975 - 2) = 0LL;
                    *((_QWORD *)v975 - 4) = 0LL;
                    *((_QWORD *)v975 - 1) = *(v976 - 1);
                    v980 = *((_OWORD *)v976 - 2);
                    v976 -= 4;
                    *((_OWORD *)v975 - 2) = v980;
                    *((_QWORD *)v975 - 2) = v976[2];
                    v975 -= 32;
                    v976[1] = 0LL;
                    v976[2] = 0LL;
                    *v976 = 0LL;
                  }
                  while ( v977 != v976 );
                  v981 = *(void ***)(a3 + 32);
                  v977 = *(void ***)(a3 + 40);
                }
                v988 = *(_QWORD *)(a3 + 48);
                *(_QWORD *)(a3 + 32) = v975;
                *(_QWORD *)(a3 + 40) = v979;
                *(_QWORD *)(a3 + 48) = v978;
                while ( v981 != v977 )
                {
                  v977 -= 4;
                  sub_9D32C(v977);
                }
                if ( v981 )
                {
                  v989 = *(_QWORD *)(a3 + 56);
                  if ( v989 + 4096 < (unsigned __int64)v981 || v989 > (unsigned __int64)v981 )
                  {
                    free(v981);
                  }
                  else if ( *(_QWORD *)(v989 + 4096) == v988 )
                  {
                    *(_QWORD *)(v989 + 4096) = v981;
                  }
                }
LABEL_1398:
                v994 = 0xAAAAAAAAAAAAAAABLL * ((v372 - (__int64)v371) >> 4);
                destd = 0xAAAAAAAAAAAAAAABLL * ((v377 - (__int64)v376) >> 4);
                if ( v994 >= destd )
                  return (unsigned __int8 *)v14;
                while ( 1 )
                {
                  v1024 = v373[5];
                  v1025 = *v373;
                  v1027 = *(size_t **)(v1024 - 24);
                  v1026 = *(size_t **)(v1024 - 16);
                  v1028 = *v373 + 48 * v994;
                  if ( v1027 == v1026 )
                  {
                    v1029 = *(_QWORD *)(v1024 - 32);
                    v1030 = 0xAAAAAAAAAAAAAAABLL * (((__int64)v1027 - v1029) >> 4);
                    if ( v1030 + 1 > 0x555555555555555LL )
                      goto LABEL_1805;
                    v1031 = 0xAAAAAAAAAAAAAAABLL * (((__int64)v1026 - v1029) >> 4);
                    v1032 = 0x555555555555555LL;
                    if ( v1031 >= 0x2AAAAAAAAAAAAAALL
                      || ((v1033 = 2 * v1031, v1033 >= v1030 + 1) ? (v1032 = v1033) : (v1032 = v1030 + 1), v1032) )
                    {
                      v1034 = *(_QWORD *)(v1024 - 8);
                      v1035 = 48 * v1032;
                      v995 = *(char **)(v1034 + 4096);
                      if ( v1034 + 4096 - (__int64)v995 >= (unsigned __int64)(48 * v1032) )
                        *(_QWORD *)(v1034 + 4096) = &v995[v1035];
                      else
                        v995 = (char *)malloc(v1035);
                    }
                    else
                    {
                      v995 = 0LL;
                    }
                    v996 = (size_t *)&v995[48 * v1030];
                    v996[1] = 0LL;
                    v996[2] = 0LL;
                    *v996 = 0LL;
                    v997 = &v995[48 * v1032];
                    v1329 = v997;
                    if ( (*(_BYTE *)v1028 & 1) == 0 )
                    {
                      v996[2] = *(_QWORD *)(v1028 + 16);
                      *(_OWORD *)v996 = *(_OWORD *)v1028;
                      goto LABEL_1411;
                    }
                    v998 = v1025 + 48 * v994;
                    v999 = *(_QWORD *)(v998 + 8);
                    if ( v999 >= 0xFFFFFFFFFFFFFFF0LL )
                      abort();
                    v1000 = *(const void **)(v998 + 16);
                    if ( v999 >= 0x17 )
                    {
                      v1002 = *(const void **)(v998 + 16);
                      v1003 = malloc((v999 + 16) & 0xFFFFFFFFFFFFFFF0LL);
                      v1000 = v1002;
                      v1001 = v1003;
                      v1004 = &v995[48 * v1030];
                      *((_QWORD *)v1004 + 1) = v999;
                      *((_QWORD *)v1004 + 2) = v1003;
                      *v996 = (v999 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
                    }
                    else
                    {
                      *(_BYTE *)v996 = 2 * v999;
                      v1001 = (char *)v996 + 1;
                      if ( !v999 )
                        goto LABEL_1410;
                    }
                    memcpy(v1001, v1000, v999);
LABEL_1410:
                    *((_BYTE *)v1001 + v999) = 0;
                    v373 = (__int64 *)a3;
                    v997 = &v995[48 * v1032];
LABEL_1411:
                    v1005 = &v995[48 * v1030];
                    *((_QWORD *)v1005 + 3) = 0LL;
                    v1006 = v1005 + 24;
                    v1007 = v1025 + 48 * v994;
                    *((_QWORD *)v1006 + 1) = 0LL;
                    *((_QWORD *)v1006 + 2) = 0LL;
                    v1009 = *(_BYTE *)(v1007 + 24);
                    v1008 = v1007 + 24;
                    if ( (v1009 & 1) == 0 )
                    {
                      *((_QWORD *)v1006 + 2) = *(_QWORD *)(v1008 + 16);
                      *(_OWORD *)v1006 = *(_OWORD *)v1008;
LABEL_1420:
                      v1017 = *(void ***)(v1024 - 32);
                      v1016 = *(void ***)(v1024 - 24);
                      v1018 = v996 + 6;
                      if ( v1016 == v1017 )
                      {
                        v1020 = *(void ***)(v1024 - 32);
                      }
                      else
                      {
                        do
                        {
                          *(v996 - 4) = (size_t)*(v1016 - 4);
                          *((_OWORD *)v996 - 3) = *((_OWORD *)v1016 - 3);
                          v1019 = (size_t)*(v1016 - 1);
                          *(v1016 - 5) = 0LL;
                          *(v1016 - 4) = 0LL;
                          *(v1016 - 6) = 0LL;
                          *(v996 - 1) = v1019;
                          *(_OWORD *)(v996 - 3) = *(_OWORD *)(v1016 - 3);
                          *(v1016 - 2) = 0LL;
                          *(v1016 - 1) = 0LL;
                          *(v1016 - 3) = 0LL;
                          v1016 -= 6;
                          v996 -= 6;
                        }
                        while ( v1017 != v1016 );
                        v1020 = *(void ***)(v1024 - 32);
                        v1017 = *(void ***)(v1024 - 24);
                      }
                      v1021 = *(_QWORD *)(v1024 - 16);
                      *(_QWORD *)(v1024 - 32) = v996;
                      *(_QWORD *)(v1024 - 24) = v1018;
                      *(_QWORD *)(v1024 - 16) = v997;
                      if ( v1017 != v1020 )
                      {
                        do
                        {
                          if ( (*(_BYTE *)(v1017 - 3) & 1) != 0 )
                            free(*(v1017 - 1));
                          v1022 = v1017 - 6;
                          if ( (*(_BYTE *)(v1017 - 6) & 1) != 0 )
                            free(*(v1017 - 4));
                          v1017 -= 6;
                        }
                        while ( v1020 != v1022 );
                      }
                      if ( v1020 )
                      {
                        v1023 = *(_QWORD *)(v1024 - 8);
                        if ( v1023 + 4096 < (unsigned __int64)v1020 || v1023 > (unsigned __int64)v1020 )
                        {
                          free(v1020);
                        }
                        else if ( *(_QWORD *)(v1023 + 4096) == v1021 )
                        {
                          *(_QWORD *)(v1023 + 4096) = v1020;
                        }
                      }
                      goto LABEL_1464;
                    }
                    v1010 = v1025 + 48 * v994;
                    v1011 = *(_QWORD *)(v1010 + 32);
                    if ( v1011 >= 0xFFFFFFFFFFFFFFF0LL )
                      abort();
                    v1012 = *(const void **)(v1010 + 40);
                    if ( v1011 >= 0x17 )
                    {
                      v1014 = malloc((v1011 + 16) & 0xFFFFFFFFFFFFFFF0LL);
                      v373 = (__int64 *)a3;
                      v1015 = &v995[48 * v1030];
                      *((_QWORD *)v1015 + 4) = v1011;
                      *((_QWORD *)v1015 + 5) = v1014;
                      *(_QWORD *)v1006 = (v1011 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
                      v1013 = v1014;
                    }
                    else
                    {
                      *v1006 = 2 * v1011;
                      v1013 = v1006 + 1;
                      if ( !v1011 )
                        goto LABEL_1419;
                    }
                    memcpy(v1013, v1012, v1011);
LABEL_1419:
                    *((_BYTE *)v1013 + v1011) = 0;
                    v997 = v1329;
                    goto LABEL_1420;
                  }
                  v1027[1] = 0LL;
                  v1027[2] = 0LL;
                  *v1027 = 0LL;
                  if ( (*(_BYTE *)v1028 & 1) == 0 )
                  {
                    v1027[2] = *(_QWORD *)(v1028 + 16);
                    *(_OWORD *)v1027 = *(_OWORD *)v1028;
                    goto LABEL_1454;
                  }
                  v1036 = v1025 + 48 * v994;
                  v1037 = *(_QWORD *)(v1036 + 8);
                  if ( v1037 >= 0xFFFFFFFFFFFFFFF0LL )
                    goto LABEL_1805;
                  v1038 = *(const void **)(v1036 + 16);
                  if ( v1037 >= 0x17 )
                  {
                    v1039 = malloc((v1037 + 16) & 0xFFFFFFFFFFFFFFF0LL);
                    v1027[1] = v1037;
                    v1027[2] = (size_t)v1039;
                    *v1027 = (v1037 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
                  }
                  else
                  {
                    *(_BYTE *)v1027 = 2 * v1037;
                    v1039 = (char *)v1027 + 1;
                    if ( !v1037 )
                      goto LABEL_1453;
                  }
                  memcpy(v1039, v1038, v1037);
LABEL_1453:
                  *((_BYTE *)v1039 + v1037) = 0;
LABEL_1454:
                  v1027[3] = 0LL;
                  v1040 = v1027 + 3;
                  v1041 = v1025 + 48 * v994;
                  v1027[4] = 0LL;
                  v1027[5] = 0LL;
                  v1043 = *(_BYTE *)(v1041 + 24);
                  v1042 = v1041 + 24;
                  if ( (v1043 & 1) != 0 )
                  {
                    v1044 = v1025 + 48 * v994;
                    v1045 = *(_QWORD *)(v1044 + 32);
                    if ( v1045 >= 0xFFFFFFFFFFFFFFF0LL )
                      abort();
                    v1046 = *(const void **)(v1044 + 40);
                    if ( v1045 >= 0x17 )
                    {
                      v1047 = malloc((v1045 + 16) & 0xFFFFFFFFFFFFFFF0LL);
                      v1027[4] = v1045;
                      v1027[5] = (size_t)v1047;
                      v1027[3] = (v1045 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
                    }
                    else
                    {
                      *v1040 = 2 * v1045;
                      v1047 = (char *)v1027 + 25;
                      if ( !v1045 )
                        goto LABEL_1462;
                    }
                    memcpy(v1047, v1046, v1045);
LABEL_1462:
                    *((_BYTE *)v1047 + v1045) = 0;
                    goto LABEL_1463;
                  }
                  v1027[5] = *(_QWORD *)(v1042 + 16);
                  *(_OWORD *)v1040 = *(_OWORD *)v1042;
LABEL_1463:
                  *(_QWORD *)(v1024 - 24) += 48LL;
LABEL_1464:
                  if ( ++v994 >= destd )
                    return (unsigned __int8 *)v14;
                }
              }
            }
            v957 = *(_QWORD *)(a3 + 56);
            v857 = *(char **)(v957 + 4096);
            if ( v957 + 4096 - (__int64)v857 >= (unsigned __int64)(32 * v856) )
              *(_QWORD *)(v957 + 4096) = &v857[32 * v856];
            else
              v857 = (char *)malloc(32 * v856);
            goto LABEL_1338;
          case 'v':
            v365 = v3;
            if ( v3 - v4 < 4 )
              goto LABEL_1248;
            v367 = v4 + 2;
            v366 = v4[2];
            if ( (unsigned int)(v366 - 49) <= 8 )
            {
              if ( v367 != v365 )
              {
                v126 = v4 + 4;
                do
                {
                  if ( v126 - v365 == 1 )
                    goto LABEL_1248;
                  v368 = *(v126++ - 1);
                }
                while ( (unsigned int)(v368 - 48) < 0xA );
                if ( v126 - v365 != 2 && *(v126 - 2) == 95 && v126 - v365 != 1 )
                {
                  v369 = v126 - 2 - v367;
                  if ( *(v126 - 1) == 112 )
                  {
                    v1351 = 0LL;
                    v1350 = 0uLL;
                    if ( v369 >= 0xFFFFFFFFFFFFFFF0LL )
                      goto LABEL_1805;
                    if ( v369 >= 0x17 )
                    {
                      v370 = (char *)malloc((v369 + 16) & 0xFFFFFFFFFFFFFFF0LL);
                      *((_QWORD *)&v1350 + 1) = v126 - 2 - v367;
                      v1351 = v370;
                      *(_QWORD *)&v1350 = (v369 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
                    }
                    else
                    {
                      v370 = (char *)&v1350 + 1;
                      LOBYTE(v1350) = 2 * v369;
                      if ( !v369 )
                      {
LABEL_1808:
                        v370[v369] = 0;
                        sub_9CDD8((size_t *)&v1350, 0LL, "pixel vector[", 0xDuLL);
                        v1210 = v1351;
                        v1211 = v1350;
                        v1351 = 0LL;
                        v1350 = 0uLL;
                        p = v1210;
                        *(_OWORD *)v1338 = v1211;
                        sub_9CFD0((size_t *)v1338, "]", 1uLL);
                        v1212 = *(__int64 *)((char *)v1338 + 1);
                        v1213 = v1338[1];
                        v1214 = p;
                        v1215 = (char)v1338[0];
                        v1338[1] = 0LL;
                        p = 0LL;
                        v1338[0] = 0LL;
                        *(_QWORD *)((char *)&v1346 + 7) = v1213;
                        BYTE7(v1346) = HIBYTE(v1212);
                        *(_QWORD *)((char *)&v1348 + 7) = 0LL;
                        *(_QWORD *)&v1348 = 0LL;
                        *(_QWORD *)((char *)&v1354 + 7) = *(_QWORD *)((char *)&v1346 + 7);
                        *(_QWORD *)&v1354 = v1212;
                        *(_QWORD *)((char *)&v1346 + 7) = 0LL;
                        *(_QWORD *)&v1346 = 0LL;
                        v1216 = *(_QWORD *)(a3 + 8);
                        v1217 = *(_QWORD *)(a3 + 16);
                        if ( v1216 < v1217 )
                        {
                          *(_BYTE *)v1216 = v1215;
                          *(_QWORD *)(v1216 + 8) = *(_QWORD *)((char *)&v1354 + 7);
                          *(_QWORD *)(v1216 + 16) = v1214;
                          *(_QWORD *)(v1216 + 1) = v1354;
                          *(_QWORD *)((char *)&v1354 + 7) = 0LL;
                          *(_QWORD *)&v1354 = 0LL;
                          *(_BYTE *)(v1216 + 24) = 0;
                          *(_QWORD *)(v1216 + 32) = *(_QWORD *)((char *)&v1348 + 7);
                          *(_QWORD *)(v1216 + 40) = 0LL;
                          *(_QWORD *)(v1216 + 25) = v1348;
                          *(_QWORD *)((char *)&v1348 + 7) = 0LL;
                          *(_QWORD *)&v1348 = 0LL;
                          *(_QWORD *)(a3 + 8) += 48LL;
                          if ( ((__int64)v1338[0] & 1) == 0 )
                            goto LABEL_1939;
                          goto LABEL_1938;
                        }
                        v1218 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v1216 - *(_QWORD *)a3) >> 4);
                        v1219 = v1218 + 1;
                        if ( v1218 + 1 > 0x555555555555555LL )
                          abort();
                        v1220 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v1217 - *(_QWORD *)a3) >> 4);
                        if ( v1220 >= 0x2AAAAAAAAAAAAAALL )
                          goto LABEL_1816;
                        v1221 = 2 * v1220;
                        if ( v1221 >= v1219 )
                          v1219 = v1221;
                        v1300 = v1219;
                        if ( v1219 )
                        {
LABEL_1816:
                          v1222 = *(_QWORD *)(a3 + 24);
                          v1223 = *(char **)(v1222 + 4096);
                          if ( v1222 + 4096 - (__int64)v1223 >= (unsigned __int64)(48 * v1300) )
                            *(_QWORD *)(v1222 + 4096) = &v1223[48 * v1300];
                          else
                            v1223 = (char *)malloc(48 * v1300);
                        }
                        else
                        {
                          v1300 = 0LL;
                          v1223 = 0LL;
                        }
                        v1269 = &v1223[48 * v1218];
                        *v1269 = v1215;
                        *((_QWORD *)v1269 + 1) = *(_QWORD *)((char *)&v1354 + 7);
                        *((_QWORD *)v1269 + 2) = v1214;
                        *(_QWORD *)(v1269 + 1) = v1354;
                        *(_QWORD *)((char *)&v1354 + 7) = 0LL;
                        *(_QWORD *)&v1354 = 0LL;
                        v1269[24] = 0;
                        *((_QWORD *)v1269 + 4) = *(_QWORD *)((char *)&v1348 + 7);
                        *((_QWORD *)v1269 + 5) = 0LL;
                        *(_QWORD *)(v1269 + 25) = v1348;
                        *(_QWORD *)((char *)&v1348 + 7) = 0LL;
                        *(_QWORD *)&v1348 = 0LL;
                        v1271 = *(void ***)a3;
                        v1270 = *(void ***)(a3 + 8);
                        v1272 = v1269 + 48;
                        if ( v1270 == *(void ***)a3 )
                        {
                          v1274 = *(void ***)a3;
                        }
                        else
                        {
                          do
                          {
                            *((_QWORD *)v1269 - 4) = *(v1270 - 4);
                            *((_OWORD *)v1269 - 3) = *((_OWORD *)v1270 - 3);
                            v1273 = (__int64)*(v1270 - 1);
                            *(v1270 - 5) = 0LL;
                            *(v1270 - 4) = 0LL;
                            *(v1270 - 6) = 0LL;
                            *((_QWORD *)v1269 - 1) = v1273;
                            *(_OWORD *)(v1269 - 24) = *(_OWORD *)(v1270 - 3);
                            *(v1270 - 2) = 0LL;
                            *(v1270 - 1) = 0LL;
                            *(v1270 - 3) = 0LL;
                            v1270 -= 6;
                            v1269 -= 48;
                          }
                          while ( v1271 != v1270 );
                          v1274 = *(void ***)a3;
                          v1271 = *(void ***)(a3 + 8);
                        }
                        v1275 = *(_QWORD *)(a3 + 16);
                        *(_QWORD *)a3 = v1269;
                        *(_QWORD *)(a3 + 8) = v1272;
                        *(_QWORD *)(a3 + 16) = &v1223[48 * v1300];
                        if ( v1271 != v1274 )
                        {
                          do
                          {
                            if ( (*(_BYTE *)(v1271 - 3) & 1) != 0 )
                              free(*(v1271 - 1));
                            v1276 = v1271 - 6;
                            if ( (*(_BYTE *)(v1271 - 6) & 1) != 0 )
                              free(*(v1271 - 4));
                            v1271 -= 6;
                          }
                          while ( v1274 != v1276 );
                        }
                        if ( v1274 )
                        {
                          v1277 = *(_QWORD *)(a3 + 24);
                          if ( v1277 + 4096 < (unsigned __int64)v1274 || v1277 > (unsigned __int64)v1274 )
                          {
                            free(v1274);
                          }
                          else if ( *(_QWORD *)(v1277 + 4096) == v1275 )
                          {
                            *(_QWORD *)(v1277 + 4096) = v1274;
                            if ( ((__int64)v1338[0] & 1) == 0 )
                            {
LABEL_1939:
                              if ( (v1350 & 1) != 0 )
                                free(v1351);
LABEL_1941:
                              v3 = v365;
                              if ( v126 != v4 )
                              {
                                v14 = (__int64)v4;
                                v1278 = *(_QWORD *)(a3 + 8);
                                if ( *(_QWORD *)a3 == v1278 )
                                  return (unsigned __int8 *)v14;
                                *(_QWORD *)&v1350 = *(_QWORD *)(a3 + 24);
                                sub_9D15C((size_t **)v1338, v1278 - 48, (__int64 *)&v1350);
                                v1279 = *(_QWORD *)(a3 + 40);
                                v1280 = *(_QWORD *)(a3 + 48);
                                if ( v1279 < v1280 )
                                {
                                  *(_QWORD *)(v1279 + 24) = v1340;
                                  *(_OWORD *)v1279 = *(_OWORD *)v1338;
                                  *(_QWORD *)(v1279 + 16) = p;
                                  v1338[1] = 0LL;
                                  p = 0LL;
                                  v1338[0] = 0LL;
                                  *(_QWORD *)(a3 + 40) += 32LL;
                                  v130 = (void **)v1338[0];
                                  if ( !v1338[0] )
                                    return v126;
                                  goto LABEL_1971;
                                }
                                v1281 = *(_QWORD *)(a3 + 32);
                                v1282 = (__int64)(v1279 - v1281) >> 5;
                                if ( (unsigned __int64)(v1282 + 1) >> 59 )
                                  abort();
                                v1283 = v1280 - v1281;
                                if ( (unsigned __int64)(v1283 >> 5) > 0x3FFFFFFFFFFFFFELL )
                                {
                                  v1285 = 0x7FFFFFFFFFFFFFFLL;
                                }
                                else
                                {
                                  v1284 = v1283 >> 4;
                                  if ( v1284 >= v1282 + 1 )
                                    v1285 = v1284;
                                  else
                                    v1285 = v1282 + 1;
                                  if ( !v1285 )
                                  {
                                    v1286 = 0LL;
LABEL_1957:
                                    v1288 = &v1286[32 * v1282];
                                    *((_QWORD *)v1288 + 1) = 0LL;
                                    *((_QWORD *)v1288 + 2) = 0LL;
                                    v1289 = v1288 + 32;
                                    *((_QWORD *)v1288 + 3) = v1340;
                                    *(_OWORD *)v1288 = *(_OWORD *)v1338;
                                    *((_QWORD *)v1288 + 2) = p;
                                    v1338[1] = 0LL;
                                    p = 0LL;
                                    v1338[0] = 0LL;
                                    v1291 = *(void ***)(a3 + 32);
                                    v1290 = *(void ***)(a3 + 40);
                                    v1292 = &v1286[32 * v1285];
                                    if ( v1290 == v1291 )
                                    {
                                      v1294 = *(void ***)(a3 + 32);
                                    }
                                    else
                                    {
                                      do
                                      {
                                        *((_QWORD *)v1288 - 3) = 0LL;
                                        *((_QWORD *)v1288 - 2) = 0LL;
                                        *((_QWORD *)v1288 - 4) = 0LL;
                                        *((_QWORD *)v1288 - 1) = *(v1290 - 1);
                                        v1293 = *((_OWORD *)v1290 - 2);
                                        v1290 -= 4;
                                        *((_OWORD *)v1288 - 2) = v1293;
                                        *((_QWORD *)v1288 - 2) = v1290[2];
                                        v1288 -= 32;
                                        v1290[1] = 0LL;
                                        v1290[2] = 0LL;
                                        *v1290 = 0LL;
                                      }
                                      while ( v1291 != v1290 );
                                      v1294 = *(void ***)(a3 + 32);
                                      v1291 = *(void ***)(a3 + 40);
                                    }
                                    v1295 = *(_QWORD *)(a3 + 48);
                                    *(_QWORD *)(a3 + 32) = v1288;
                                    *(_QWORD *)(a3 + 40) = v1289;
                                    *(_QWORD *)(a3 + 48) = v1292;
                                    while ( v1294 != v1291 )
                                    {
                                      v1291 -= 4;
                                      sub_9D32C(v1291);
                                    }
                                    if ( v1294 )
                                    {
                                      v1296 = *(_QWORD *)(a3 + 56);
                                      if ( v1296 + 4096 < (unsigned __int64)v1294 || v1296 > (unsigned __int64)v1294 )
                                      {
                                        free(v1294);
                                      }
                                      else if ( *(_QWORD *)(v1296 + 4096) == v1295 )
                                      {
                                        *(_QWORD *)(v1296 + 4096) = v1294;
                                        v130 = (void **)v1338[0];
                                        if ( !v1338[0] )
                                          return v126;
                                        goto LABEL_1971;
                                      }
                                    }
                                    v130 = (void **)v1338[0];
                                    if ( v1338[0] )
                                    {
LABEL_1971:
                                      v1297 = (void **)v1338[1];
                                      if ( v1338[1] != v130 )
                                      {
                                        do
                                        {
                                          if ( (*(_BYTE *)(v1297 - 3) & 1) != 0 )
                                            free(*(v1297 - 1));
                                          v1298 = v1297 - 6;
                                          if ( (*(_BYTE *)(v1297 - 6) & 1) != 0 )
                                            free(*(v1297 - 4));
                                          v1297 -= 6;
                                        }
                                        while ( v130 != v1298 );
                                      }
LABEL_1525:
                                      v1338[1] = v130;
                                      if ( (__int64)v1340 + 4096 < (unsigned __int64)v130
                                        || (unsigned __int64)v1340 > (unsigned __int64)v130 )
                                      {
                                        free(v130);
                                      }
                                      else if ( *(void **)(v1340 + 4096) == p )
                                      {
                                        *(_QWORD *)(v1340 + 4096) = v130;
                                      }
                                    }
                                    return v126;
                                  }
                                }
                                v1287 = *(_QWORD *)(a3 + 56);
                                v1286 = *(char **)(v1287 + 4096);
                                if ( v1287 + 4096 - (__int64)v1286 >= (unsigned __int64)(32 * v1285) )
                                  *(_QWORD *)(v1287 + 4096) = &v1286[32 * v1285];
                                else
                                  v1286 = (char *)malloc(32 * v1285);
                                goto LABEL_1957;
                              }
LABEL_1249:
                              v14 = sub_B2B20(v4, v3, a3);
                              if ( (unsigned __int8 *)v14 != v4 )
                                return (unsigned __int8 *)v14;
                              v24 = sub_9AA00(v4, v3, a3, 0LL);
                              if ( (unsigned __int8 *)v24 == v4 )
                                return v4;
                              v928 = *(_QWORD *)(a3 + 8);
                              v14 = (__int64)v4;
                              if ( *(_QWORD *)a3 == v928 )
                                return (unsigned __int8 *)v14;
                              *(_QWORD *)&v1350 = *(_QWORD *)(a3 + 24);
                              sub_9D15C((size_t **)v1338, v928 - 48, (__int64 *)&v1350);
                              v929 = *(_QWORD *)(a3 + 40);
                              v930 = *(_QWORD *)(a3 + 48);
                              if ( v929 < v930 )
                              {
                                *(_QWORD *)(v929 + 24) = v1340;
                                *(_OWORD *)v929 = *(_OWORD *)v1338;
                                *(_QWORD *)(v929 + 16) = p;
                                v1338[1] = 0LL;
                                p = 0LL;
                                v1338[0] = 0LL;
                                *(_QWORD *)(a3 + 40) += 32LL;
                                v178 = (void **)v1338[0];
                                if ( !v1338[0] )
                                  return (unsigned __int8 *)v24;
                                goto LABEL_1280;
                              }
                              v931 = *(_QWORD *)(a3 + 32);
                              v932 = (__int64)(v929 - v931) >> 5;
                              if ( (unsigned __int64)(v932 + 1) >> 59 )
                                abort();
                              v933 = v930 - v931;
                              if ( (unsigned __int64)(v933 >> 5) > 0x3FFFFFFFFFFFFFELL )
                              {
                                v935 = 0x7FFFFFFFFFFFFFFLL;
                              }
                              else
                              {
                                v934 = v933 >> 4;
                                if ( v934 >= v932 + 1 )
                                  v935 = v934;
                                else
                                  v935 = v932 + 1;
                                if ( !v935 )
                                {
                                  v936 = 0LL;
                                  goto LABEL_1266;
                                }
                              }
                              v937 = *(_QWORD *)(a3 + 56);
                              v936 = *(char **)(v937 + 4096);
                              if ( v937 + 4096 - (__int64)v936 >= (unsigned __int64)(32 * v935) )
                                *(_QWORD *)(v937 + 4096) = &v936[32 * v935];
                              else
                                v936 = (char *)malloc(32 * v935);
LABEL_1266:
                              v938 = &v936[32 * v932];
                              *((_QWORD *)v938 + 1) = 0LL;
                              *((_QWORD *)v938 + 2) = 0LL;
                              v939 = v938 + 32;
                              *((_QWORD *)v938 + 3) = v1340;
                              *(_OWORD *)v938 = *(_OWORD *)v1338;
                              *((_QWORD *)v938 + 2) = p;
                              v1338[1] = 0LL;
                              p = 0LL;
                              v1338[0] = 0LL;
                              v941 = *(void ***)(a3 + 32);
                              v940 = *(void ***)(a3 + 40);
                              v942 = &v936[32 * v935];
                              if ( v940 == v941 )
                              {
                                v944 = *(void ***)(a3 + 32);
                              }
                              else
                              {
                                do
                                {
                                  *((_QWORD *)v938 - 3) = 0LL;
                                  *((_QWORD *)v938 - 2) = 0LL;
                                  *((_QWORD *)v938 - 4) = 0LL;
                                  *((_QWORD *)v938 - 1) = *(v940 - 1);
                                  v943 = *((_OWORD *)v940 - 2);
                                  v940 -= 4;
                                  *((_OWORD *)v938 - 2) = v943;
                                  *((_QWORD *)v938 - 2) = v940[2];
                                  v938 -= 32;
                                  v940[1] = 0LL;
                                  v940[2] = 0LL;
                                  *v940 = 0LL;
                                }
                                while ( v941 != v940 );
                                v944 = *(void ***)(a3 + 32);
                                v941 = *(void ***)(a3 + 40);
                              }
                              v945 = *(_QWORD *)(a3 + 48);
                              *(_QWORD *)(a3 + 32) = v938;
                              *(_QWORD *)(a3 + 40) = v939;
                              *(_QWORD *)(a3 + 48) = v942;
                              while ( v944 != v941 )
                              {
                                v941 -= 4;
                                sub_9D32C(v941);
                              }
                              if ( v944 )
                              {
                                v946 = *(_QWORD *)(a3 + 56);
                                if ( v946 + 4096 < (unsigned __int64)v944 || v946 > (unsigned __int64)v944 )
                                {
                                  free(v944);
                                }
                                else if ( *(_QWORD *)(v946 + 4096) == v945 )
                                {
                                  *(_QWORD *)(v946 + 4096) = v944;
                                  v178 = (void **)v1338[0];
                                  if ( !v1338[0] )
                                    return (unsigned __int8 *)v24;
LABEL_1280:
                                  v947 = (void **)v1338[1];
                                  if ( v1338[1] != v178 )
                                  {
                                    do
                                    {
                                      if ( (*(_BYTE *)(v947 - 3) & 1) != 0 )
                                        free(*(v947 - 1));
                                      v948 = v947 - 6;
                                      if ( (*(_BYTE *)(v947 - 6) & 1) != 0 )
                                        free(*(v947 - 4));
                                      v947 -= 6;
                                    }
                                    while ( v178 != v948 );
                                  }
                                  goto LABEL_1508;
                                }
                              }
                              v178 = (void **)v1338[0];
                              if ( !v1338[0] )
                                return (unsigned __int8 *)v24;
                              goto LABEL_1280;
                            }
LABEL_1938:
                            free(p);
                            goto LABEL_1939;
                          }
                        }
                        if ( ((__int64)v1338[0] & 1) == 0 )
                          goto LABEL_1939;
                        goto LABEL_1938;
                      }
                    }
                    memcpy(v370, v4 + 2, v369);
                    goto LABEL_1808;
                  }
                  v1208 = sub_925FC(v126 - 1, v365, a3);
                  if ( &v126[-v1208] != (_BYTE *)&dword_0 + 1 && *(_QWORD *)a3 != *(_QWORD *)(a3 + 8) )
                  {
                    v1355 = 0LL;
                    v1354 = 0uLL;
                    if ( v369 >= 0xFFFFFFFFFFFFFFF0LL )
                      goto LABEL_1805;
                    if ( v369 >= 0x17 )
                    {
                      v1209 = (char *)malloc((v369 + 16) & 0xFFFFFFFFFFFFFFF0LL);
                      *((_QWORD *)&v1354 + 1) = v369;
                      v1355 = (unsigned __int16 *)v1209;
                      *(_QWORD *)&v1354 = (v369 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
                    }
                    else
                    {
                      v1209 = (char *)&v1354 + 1;
                      LOBYTE(v1354) = 2 * v369;
                      if ( !v369 )
                      {
LABEL_1903:
                        v1209[v369] = 0;
                        sub_9CDD8((size_t *)&v1354, 0LL, " vector[", 8uLL);
                        v1261 = (char *)v1355;
                        v1262 = v1354;
                        v1355 = 0LL;
                        v1354 = 0uLL;
                        v1351 = v1261;
                        v1350 = v1262;
                        sub_9CFD0((size_t *)&v1350, "]", 1uLL);
                        v1263 = v1351;
                        v1264 = v1350;
                        v1351 = 0LL;
                        v1350 = 0uLL;
                        p = v1263;
                        *(_OWORD *)v1338 = v1264;
                        v1265 = v1264;
                        v1266 = v1263;
                        if ( (v1264 & 1) != 0 )
                          v1267 = v1263;
                        else
                          v1267 = (char *)v1338 + 1;
                        if ( (v1264 & 1) != 0 )
                          v1268 = *((_QWORD *)&v1264 + 1);
                        else
                          v1268 = (unsigned __int64)(unsigned __int8)v1264 >> 1;
                        sub_9CFD0((size_t *)(*(_QWORD *)(a3 + 8) - 48LL), v1267, v1268);
                        if ( (v1265 & 1) != 0 )
                        {
                          free(v1266);
                          if ( (v1350 & 1) == 0 )
                          {
LABEL_1911:
                            if ( (v1354 & 1) == 0 )
                            {
LABEL_1913:
                              v126 = (unsigned __int8 *)v1208;
                              goto LABEL_1941;
                            }
LABEL_1912:
                            free(v1355);
                            goto LABEL_1913;
                          }
                        }
                        else if ( (v1350 & 1) == 0 )
                        {
                          goto LABEL_1911;
                        }
                        free(v1351);
                        if ( (v1354 & 1) == 0 )
                          goto LABEL_1913;
                        goto LABEL_1912;
                      }
                    }
                    memcpy(v1209, v4 + 2, v369);
                    goto LABEL_1903;
                  }
                }
              }
LABEL_1248:
              v3 = v365;
              goto LABEL_1249;
            }
            v1338[1] = 0LL;
            p = 0LL;
            v1338[0] = 0LL;
            if ( v366 == 95 || (v861 = sub_A20BC(v4 + 2, v365, a3), (unsigned __int8 *)v861 == v367) )
            {
              v874 = 0LL;
              v873 = 0;
              if ( v367 == v365 )
                goto LABEL_1245;
            }
            else
            {
              v862 = *(_QWORD *)(a3 + 8);
              if ( *(_QWORD *)a3 == v862 )
                goto LABEL_1248;
              v863 = *(unsigned __int8 *)(v862 - 24);
              v864 = *(_QWORD *)(v862 - 16);
              v865 = *(void **)(v862 - 8);
              v866 = (size_t *)(v862 - 48);
              v867 = (void *)(v862 - 23);
              v868 = (v863 & 1) == 0;
              v869 = v863 >> 1;
              if ( v868 )
                v870 = v867;
              else
                v870 = v865;
              if ( v868 )
                v871 = v869;
              else
                v871 = v864;
              v872 = sub_9CFD0(v866, v870, v871);
              v873 = *(_BYTE *)v872;
              *(_QWORD *)((char *)&v1350 + 7) = v872[1];
              *(_QWORD *)&v1350 = *(size_t *)((char *)v872 + 1);
              *v872 = 0LL;
              v872[1] = 0LL;
              v874 = (void *)v872[2];
              v872[2] = 0LL;
              v875 = *(_QWORD *)(a3 + 8);
              LOBYTE(v1338[0]) = v873;
              v1338[1] = *(void **)((char *)&v1350 + 7);
              p = v874;
              *(void **)((char *)v1338 + 1) = (void *)v1350;
              v876 = (_BYTE *)(v875 - 48);
              if ( (*(_BYTE *)(v875 - 24) & 1) != 0 )
                free(*(void **)(v875 - 8));
              if ( (*v876 & 1) != 0 )
                free(*(void **)(v875 - 32));
              v367 = (unsigned __int8 *)v861;
              *(_QWORD *)(a3 + 8) = v876;
              if ( (unsigned __int8 *)v861 == v365 )
              {
LABEL_1245:
                v927 = 0;
                v126 = v4;
                if ( (v873 & 1) == 0 )
                  goto LABEL_1247;
                goto LABEL_1246;
              }
            }
            if ( *v367 != 95 )
              goto LABEL_1245;
            v920 = v367 + 1;
            if ( v920 == v365 )
              goto LABEL_1245;
            v126 = (unsigned __int8 *)sub_925FC(v920, v365, a3);
            if ( v126 == v920 )
              goto LABEL_1245;
            if ( *(_QWORD *)a3 == *(_QWORD *)(a3 + 8) )
            {
              v927 = 1;
              v126 = v4;
              if ( (v873 & 1) != 0 )
LABEL_1246:
                free(v874);
            }
            else
            {
              sub_9F8F0(" vector[", (unsigned __int8 *)v1338, (size_t *)&v1354);
              sub_9CFD0((size_t *)&v1354, "]", 1uLL);
              v921 = (char *)v1355;
              v922 = v1354;
              v1355 = 0LL;
              v1354 = 0uLL;
              v1351 = v921;
              v1350 = v922;
              v923 = v922;
              v924 = v921;
              if ( (v922 & 1) != 0 )
                v925 = v1351;
              else
                v925 = (char *)&v1350 + 1;
              if ( (v922 & 1) != 0 )
                v926 = *((_QWORD *)&v1350 + 1);
              else
                v926 = (unsigned __int64)(unsigned __int8)v922 >> 1;
              sub_9CFD0((size_t *)(*(_QWORD *)(a3 + 8) - 48LL), v925, v926);
              if ( (v923 & 1) != 0 )
                free(v924);
              if ( (v1354 & 1) != 0 )
                free(v1355);
              v927 = 0;
              if ( (v873 & 1) != 0 )
                goto LABEL_1246;
            }
LABEL_1247:
            if ( !v927 )
              goto LABEL_1941;
            goto LABEL_1248;
          default:
            goto LABEL_1249;
        }
      case 'F':
        v197 = v4 + 1;
        if ( v4 + 1 == v3 )
          return v4;
        if ( *v197 == 89 )
        {
          v197 = v4 + 2;
          if ( v4 + 2 == v3 )
            return v4;
        }
        v198 = (unsigned __int8 *)sub_925FC(v197, v3, a3);
        if ( v198 == v197 )
          return v4;
        v1338[1] = 0LL;
        p = 0LL;
        v1338[0] = &stru_27F8 + 10;
        if ( v198 == v3 )
        {
          v227 = (_QWORD *)a3;
          v200 = (__int64 *)(a3 + 8);
          goto LABEL_453;
        }
        v199 = v3;
        v200 = (__int64 *)(a3 + 8);
        v1323 = 0;
        while ( 2 )
        {
          while ( 2 )
          {
            v201 = v198;
LABEL_234:
            v202 = *v201;
            if ( v202 > 0x51 )
            {
              if ( v202 == 82 )
              {
                v198 = v201 + 1;
                if ( v201 + 1 != v199 && *v198 == 69 )
                {
                  v1323 = 1;
                  if ( v198 == v199 )
                  {
LABEL_282:
                    v227 = (_QWORD *)a3;
LABEL_453:
                    v379 = *v200;
                    if ( *v227 != *v200 )
                    {
                      v380 = (_BYTE *)(v379 - 48);
                      if ( (*(_BYTE *)(v379 - 24) & 1) != 0 )
                        free(*(void **)(v379 - 8));
                      if ( (*v380 & 1) != 0 )
                        free(*(void **)(v379 - 32));
                      *v200 = (__int64)v380;
                    }
LABEL_459:
                    v208 = 1;
LABEL_460:
                    v126 = v4;
                    if ( ((__int64)v1338[0] & 1) == 0 )
                      goto LABEL_462;
                    goto LABEL_461;
                  }
                  continue;
                }
              }
              else if ( v202 == 118 )
              {
                v203 = v201 + 1;
                v204 = v199;
LABEL_277:
                v201 = v203;
                if ( v203 == v204 )
                  goto LABEL_282;
                goto LABEL_234;
              }
              goto LABEL_246;
            }
            break;
          }
          if ( v202 == 79 )
          {
            v198 = v201 + 1;
            if ( v201 + 1 != v199 && *v198 == 69 )
            {
              v1323 = 2;
              if ( v198 == v199 )
                goto LABEL_282;
              continue;
            }
            goto LABEL_246;
          }
          break;
        }
        if ( v202 != 69 )
        {
LABEL_246:
          v205 = *(void ***)a3;
          v206 = *(_QWORD *)(a3 + 8);
          v207 = sub_925FC(v201, v199, a3);
          v203 = (unsigned __int8 *)v207;
          v208 = 1;
          if ( (unsigned __int8 *)v207 == v201 || (v204 = v199, (unsigned __int8 *)v207 == v199) )
          {
            v227 = (_QWORD *)a3;
            goto LABEL_460;
          }
          v209 = 0xAAAAAAAAAAAAAAABLL * ((v206 - (__int64)v205) >> 4);
          v210 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(*(_QWORD *)(a3 + 8) - *(_QWORD *)a3) >> 4);
          if ( v209 < v210 )
          {
            destc = v200;
            v211 = 48 * v209;
            v212 = v209;
            do
            {
              if ( ((__int64)v1338[0] & 1) != 0 )
                v213 = v1338[1];
              else
                v213 = (void *)((unsigned __int64)LOBYTE(v1338[0]) >> 1);
              if ( (unsigned __int64)v213 >= 2 )
                sub_9CFD0((size_t *)v1338, ", ", 2uLL);
              v214 = *(_QWORD *)a3 + v211;
              v215 = *(unsigned __int8 *)(v214 + 24);
              v216 = (v215 & 1) == 0;
              v217 = v215 >> 1;
              if ( v216 )
                v218 = (void *)(v214 + 25);
              else
                v218 = *(void **)(v214 + 40);
              if ( v216 )
                v219 = v217;
              else
                v219 = *(_QWORD *)(v214 + 32);
              v220 = sub_9CFD0((size_t *)v214, v218, v219);
              v1351 = (char *)v220[2];
              v1350 = *(_OWORD *)v220;
              v220[1] = 0LL;
              v220[2] = 0LL;
              *v220 = 0LL;
              v221 = v1350;
              v222 = v1351;
              if ( (v1350 & 1) != 0 )
                v223 = v1351;
              else
                v223 = (char *)&v1350 + 1;
              if ( (v1350 & 1) != 0 )
                v224 = *((_QWORD *)&v1350 + 1);
              else
                v224 = (unsigned __int64)(unsigned __int8)v1350 >> 1;
              sub_9CFD0((size_t *)v1338, v223, v224);
              if ( (v221 & 1) != 0 )
                free(v222);
              ++v212;
              v211 += 48LL;
              v204 = v199;
            }
            while ( v212 < v210 );
            v200 = destc;
            if ( v209 < v210 )
            {
              v225 = v210 - v209;
              v226 = *destc - 48;
              do
              {
                if ( (*(_BYTE *)(v226 + 24) & 1) != 0 )
                  free(*(void **)(v226 + 40));
                if ( (*(_BYTE *)v226 & 1) != 0 )
                  free(*(void **)(v226 + 16));
                *destc = v226;
                --v225;
                v226 -= 48LL;
              }
              while ( v225 );
            }
          }
          goto LABEL_277;
        }
        sub_9CFD0((size_t *)v1338, ")", 1uLL);
        v227 = (_QWORD *)a3;
        v962 = v1323 & 3;
        if ( v962 == 1 )
        {
          sub_9CFD0((size_t *)v1338, " &", 2uLL);
        }
        else if ( v962 == 2 )
        {
          sub_9CFD0((size_t *)v1338, " &&", 3uLL);
        }
        v1085 = *(_QWORD *)(a3 + 8);
        if ( *(_QWORD *)a3 == v1085 )
          goto LABEL_459;
        sub_9CFD0((size_t *)(v1085 - 48), " ", 1uLL);
        if ( ((__int64)v1338[0] & 1) != 0 )
          v1086 = v1338[1];
        else
          v1086 = (void *)((unsigned __int64)LOBYTE(v1338[0]) >> 1);
        if ( ((__int64)v1338[0] & 1) != 0 )
          v1087 = (char *)p;
        else
          v1087 = (char *)v1338 + 1;
        sub_9CDD8((size_t *)(*v200 - 24), 0LL, v1087, (size_t)v1086);
        v208 = 0;
        v126 = v201 + 1;
        if ( ((__int64)v1338[0] & 1) != 0 )
LABEL_461:
          free(p);
LABEL_462:
        if ( v208 || v126 == v4 )
          return v4;
        v381 = v227[1];
        v14 = (__int64)v4;
        if ( *v227 == v381 )
          return (unsigned __int8 *)v14;
        *(_QWORD *)&v1350 = v227[3];
        sub_9D15C((size_t **)v1338, v381 - 48, (__int64 *)&v1350);
        v382 = v227[5];
        v383 = v227[6];
        if ( v382 < v383 )
        {
          *(_QWORD *)(v382 + 24) = v1340;
          *(_OWORD *)v382 = *(_OWORD *)v1338;
          *(_QWORD *)(v382 + 16) = p;
          v1338[1] = 0LL;
          p = 0LL;
          v1338[0] = 0LL;
          v227[5] += 32LL;
          v130 = (void **)v1338[0];
          if ( !v1338[0] )
            return v126;
          goto LABEL_1519;
        }
        v894 = v227[4];
        v895 = (__int64)(v382 - v894) >> 5;
        if ( (unsigned __int64)(v895 + 1) >> 59 )
          abort();
        v896 = v383 - v894;
        if ( (unsigned __int64)(v896 >> 5) > 0x3FFFFFFFFFFFFFELL )
        {
          v898 = 0x7FFFFFFFFFFFFFFLL;
        }
        else
        {
          v897 = v896 >> 4;
          if ( v897 >= v895 + 1 )
            v898 = v897;
          else
            v898 = v895 + 1;
          if ( !v898 )
          {
            v899 = 0LL;
LABEL_1488:
            v1063 = &v899[32 * v895];
            *((_QWORD *)v1063 + 1) = 0LL;
            *((_QWORD *)v1063 + 2) = 0LL;
            v1064 = v1063 + 32;
            *((_QWORD *)v1063 + 3) = v1340;
            *(_OWORD *)v1063 = *(_OWORD *)v1338;
            *((_QWORD *)v1063 + 2) = p;
            v1338[1] = 0LL;
            p = 0LL;
            v1338[0] = 0LL;
            v1065 = &v899[32 * v898];
            v1067 = *(void ***)(a3 + 32);
            v1066 = *(void ***)(a3 + 40);
            if ( v1066 == v1067 )
            {
              v1069 = *(void ***)(a3 + 32);
            }
            else
            {
              do
              {
                *((_QWORD *)v1063 - 3) = 0LL;
                *((_QWORD *)v1063 - 2) = 0LL;
                *((_QWORD *)v1063 - 4) = 0LL;
                *((_QWORD *)v1063 - 1) = *(v1066 - 1);
                v1068 = *((_OWORD *)v1066 - 2);
                v1066 -= 4;
                *((_OWORD *)v1063 - 2) = v1068;
                *((_QWORD *)v1063 - 2) = v1066[2];
                v1063 -= 32;
                v1066[1] = 0LL;
                v1066[2] = 0LL;
                *v1066 = 0LL;
              }
              while ( v1067 != v1066 );
              v1069 = *(void ***)(a3 + 32);
              v1067 = *(void ***)(a3 + 40);
            }
            v1070 = *(_QWORD *)(a3 + 48);
            *(_QWORD *)(a3 + 32) = v1063;
            *(_QWORD *)(a3 + 40) = v1064;
            *(_QWORD *)(a3 + 48) = v1065;
            while ( v1069 != v1067 )
            {
              v1067 -= 4;
              sub_9D32C(v1067);
            }
            if ( v1069 )
            {
              v1071 = *(_QWORD *)(a3 + 56);
              if ( v1071 + 4096 < (unsigned __int64)v1069 || v1071 > (unsigned __int64)v1069 )
              {
                free(v1069);
              }
              else if ( *(_QWORD *)(v1071 + 4096) == v1070 )
              {
                *(_QWORD *)(v1071 + 4096) = v1069;
                v130 = (void **)v1338[0];
                if ( !v1338[0] )
                  return v126;
                goto LABEL_1519;
              }
            }
            v130 = (void **)v1338[0];
            if ( !v1338[0] )
              return v126;
LABEL_1519:
            v1075 = (void **)v1338[1];
            if ( v1338[1] != v130 )
            {
              do
              {
                if ( (*(_BYTE *)(v1075 - 3) & 1) != 0 )
                  free(*(v1075 - 1));
                v1076 = v1075 - 6;
                if ( (*(_BYTE *)(v1075 - 6) & 1) != 0 )
                  free(*(v1075 - 4));
                v1075 -= 6;
              }
              while ( v130 != v1076 );
            }
            goto LABEL_1525;
          }
        }
        v993 = *(_QWORD *)(a3 + 56);
        v899 = *(char **)(v993 + 4096);
        if ( v993 + 4096 - (__int64)v899 >= (unsigned __int64)(32 * v898) )
          *(_QWORD *)(v993 + 4096) = &v899[32 * v898];
        else
          v899 = (char *)malloc(32 * v898);
        goto LABEL_1488;
      case 'G':
        v24 = sub_925FC(v4 + 1, v3, a3);
        if ( (unsigned __int8 *)v24 == v4 + 1 )
          return v4;
        v228 = *(_QWORD *)(a3 + 8);
        v14 = (__int64)v4;
        if ( *(_QWORD *)a3 == v228 )
          return (unsigned __int8 *)v14;
        sub_9CFD0((size_t *)(v228 - 48), " imaginary", 0xAuLL);
        v229 = *(_QWORD *)(a3 + 8) - 48LL;
        *(_QWORD *)&v1350 = *(_QWORD *)(a3 + 24);
        sub_9D15C((size_t **)v1338, v229, (__int64 *)&v1350);
        v230 = *(_QWORD *)(a3 + 40);
        v231 = *(_QWORD *)(a3 + 48);
        if ( v230 < v231 )
        {
          *(_QWORD *)(v230 + 24) = v1340;
          *(_OWORD *)v230 = *(_OWORD *)v1338;
          *(_QWORD *)(v230 + 16) = p;
          v1338[1] = 0LL;
          p = 0LL;
          v1338[0] = 0LL;
          *(_QWORD *)(a3 + 40) += 32LL;
          v178 = (void **)v1338[0];
          if ( !v1338[0] )
            return (unsigned __int8 *)v24;
          goto LABEL_1095;
        }
        v301 = *(_QWORD *)(a3 + 32);
        v302 = (__int64)(v230 - v301) >> 5;
        if ( (unsigned __int64)(v302 + 1) >> 59 )
          abort();
        v303 = v231 - v301;
        if ( (unsigned __int64)(v303 >> 5) > 0x3FFFFFFFFFFFFFELL )
        {
          v305 = 0x7FFFFFFFFFFFFFFLL;
        }
        else
        {
          v304 = v303 >> 4;
          if ( v304 >= v302 + 1 )
            v305 = v304;
          else
            v305 = v302 + 1;
          if ( !v305 )
          {
            v306 = 0LL;
            goto LABEL_977;
          }
        }
        v646 = *(_QWORD *)(a3 + 56);
        v306 = *(char **)(v646 + 4096);
        if ( v646 + 4096 - (__int64)v306 >= (unsigned __int64)(32 * v305) )
          *(_QWORD *)(v646 + 4096) = &v306[32 * v305];
        else
          v306 = (char *)malloc(32 * v305);
LABEL_977:
        v735 = &v306[32 * v302];
        *((_QWORD *)v735 + 1) = 0LL;
        *((_QWORD *)v735 + 2) = 0LL;
        v736 = v735 + 32;
        *((_QWORD *)v735 + 3) = v1340;
        *(_OWORD *)v735 = *(_OWORD *)v1338;
        *((_QWORD *)v735 + 2) = p;
        v1338[1] = 0LL;
        p = 0LL;
        v1338[0] = 0LL;
        v738 = *(void ***)(a3 + 32);
        v737 = *(void ***)(a3 + 40);
        v739 = &v306[32 * v305];
        if ( v737 == v738 )
        {
          v741 = *(void ***)(a3 + 32);
        }
        else
        {
          do
          {
            *((_QWORD *)v735 - 3) = 0LL;
            *((_QWORD *)v735 - 2) = 0LL;
            *((_QWORD *)v735 - 4) = 0LL;
            *((_QWORD *)v735 - 1) = *(v737 - 1);
            v740 = *((_OWORD *)v737 - 2);
            v737 -= 4;
            *((_OWORD *)v735 - 2) = v740;
            *((_QWORD *)v735 - 2) = v737[2];
            v735 -= 32;
            v737[1] = 0LL;
            v737[2] = 0LL;
            *v737 = 0LL;
          }
          while ( v738 != v737 );
          v741 = *(void ***)(a3 + 32);
          v738 = *(void ***)(a3 + 40);
        }
        v744 = *(_QWORD *)(a3 + 48);
        *(_QWORD *)(a3 + 32) = v735;
        *(_QWORD *)(a3 + 40) = v736;
        *(_QWORD *)(a3 + 48) = v739;
        while ( v741 != v738 )
        {
          v738 -= 4;
          sub_9D32C(v738);
        }
        if ( !v741 )
          goto LABEL_1094;
        v745 = *(_QWORD *)(a3 + 56);
        if ( v745 + 4096 < (unsigned __int64)v741 || v745 > (unsigned __int64)v741 )
        {
          free(v741);
        }
        else if ( *(_QWORD *)(v745 + 4096) == v744 )
        {
          *(_QWORD *)(v745 + 4096) = v741;
          v178 = (void **)v1338[0];
          if ( !v1338[0] )
            return (unsigned __int8 *)v24;
          goto LABEL_1095;
        }
LABEL_1094:
        v178 = (void **)v1338[0];
        if ( !v1338[0] )
          return (unsigned __int8 *)v24;
LABEL_1095:
        v830 = (void **)v1338[1];
        if ( v1338[1] != v178 )
        {
          do
          {
            if ( (*(_BYTE *)(v830 - 3) & 1) != 0 )
              free(*(v830 - 1));
            v831 = v830 - 6;
            if ( (*(_BYTE *)(v830 - 6) & 1) != 0 )
              free(*(v830 - 4));
            v830 -= 6;
          }
          while ( v178 != v831 );
        }
        goto LABEL_1508;
      case 'M':
        v131 = sub_925FC(v4 + 1, v3, a3);
        v132 = v131;
        if ( (unsigned __int8 *)v131 == v4 + 1 )
          return v4;
        v133 = sub_925FC(v131, v3, a3);
        v134 = a3;
        if ( v133 == v132 )
          return v4;
        v135 = *(_QWORD *)(a3 + 8);
        if ( 0xAAAAAAAAAAAAAAABLL * ((v135 - *(_QWORD *)a3) >> 4) < 2 )
          return v4;
        p = *(void **)(v135 - 32);
        *(_OWORD *)v1338 = *(_OWORD *)(v135 - 48);
        v136 = *(void **)(v135 - 8);
        *(_QWORD *)(v135 - 40) = 0LL;
        *(_QWORD *)(v135 - 32) = 0LL;
        *(_QWORD *)(v135 - 48) = 0LL;
        v1341 = v136;
        v1340 = *(_OWORD *)(v135 - 24);
        *(_QWORD *)(v135 - 16) = 0LL;
        *(_QWORD *)(v135 - 8) = 0LL;
        *(_QWORD *)(v135 - 24) = 0LL;
        v137 = *(_QWORD *)(a3 + 8);
        v138 = (_BYTE *)(v137 - 48);
        if ( (*(_BYTE *)(v137 - 24) & 1) != 0 )
          free(*(void **)(v137 - 8));
        if ( (*v138 & 1) != 0 )
          free(*(void **)(v137 - 32));
        *(_QWORD *)(a3 + 8) = v138;
        v1351 = *(char **)(v137 - 80);
        v1350 = *(_OWORD *)(v137 - 96);
        v139 = *(char **)(v137 - 56);
        *(_QWORD *)(v137 - 88) = 0LL;
        *(_QWORD *)(v137 - 80) = 0LL;
        *(_QWORD *)(v137 - 96) = 0LL;
        v1353 = v139;
        v1352 = *(_OWORD *)(v137 - 72);
        *(_QWORD *)(v137 - 64) = 0LL;
        *(_QWORD *)(v137 - 56) = 0LL;
        *(_QWORD *)(v137 - 72) = 0LL;
        destb = (unsigned __int8 *)v133;
        if ( (v1340 & 1) != 0 )
          v140 = *((_QWORD *)&v1340 + 1);
        else
          v140 = (unsigned __int64)(unsigned __int8)v1340 >> 1;
        if ( v140 )
        {
          v141 = v1341;
          if ( (v1340 & 1) == 0 )
            v141 = (char *)&v1340 + 1;
          if ( *v141 == 40 )
          {
            sub_9CFD0((size_t *)v1338, "(", 1uLL);
            v142 = *(_OWORD *)v1338;
            v1349 = (char *)p;
            if ( (v1352 & 1) != 0 )
              v143 = v1353;
            else
              v143 = (char *)&v1352 + 1;
            v1338[1] = 0LL;
            p = 0LL;
            v1338[0] = 0LL;
            v1348 = v142;
            if ( (v1352 & 1) != 0 )
              v144 = *((_QWORD *)&v1352 + 1);
            else
              v144 = (unsigned __int64)(unsigned __int8)v1352 >> 1;
            sub_9CFD0((size_t *)&v1350, v143, v144);
            v145 = v1350;
            v146 = v1351;
            v1351 = 0LL;
            v1346 = v1350;
            v1347 = v146;
            v147 = v1350;
            v148 = v146;
            v1350 = 0uLL;
            if ( (v1346 & 1) != 0 )
              v149 = (char *)v1347;
            else
              v149 = (char *)&v1346 + 1;
            if ( (v145 & 1) != 0 )
              v150 = *((_QWORD *)&v145 + 1);
            else
              v150 = (unsigned __int64)(unsigned __int8)v145 >> 1;
            sub_9CFD0((size_t *)&v1348, v149, v150);
            v151 = (unsigned __int16 *)v1349;
            v152 = v1348;
            v1349 = 0LL;
            v1348 = 0uLL;
            v1355 = v151;
            v1354 = v152;
            sub_9CFD0((size_t *)&v1354, "::*", 3uLL);
            v153 = v1355;
            v154 = v1354;
            v1355 = 0LL;
            *(_QWORD *)((char *)&v1343 + 7) = *((_QWORD *)&v1354 + 1);
            *(_QWORD *)&v1343 = *(_QWORD *)((char *)&v1354 + 1);
            v1354 = 0uLL;
            v155 = *(_QWORD *)(a3 + 8);
            v156 = (void **)(v155 - 48);
            if ( (*(_BYTE *)(v155 - 48) & 1) == 0 )
            {
              *(_WORD *)(v155 - 48) = 0;
              v157 = (const void **)(v155 - 32);
              goto LABEL_1705;
            }
            v1328 = v148;
            v157 = (const void **)(v155 - 32);
            **(_BYTE **)(v155 - 32) = 0;
            LOBYTE(v148) = *(_BYTE *)(v155 - 48);
            *(_QWORD *)(v155 - 40) = 0LL;
            if ( ((unsigned __int8)v148 & 1) != 0 )
            {
              v148 = *v156;
              v883 = ((unsigned __int64)*v156 & 0xFFFFFFFFFFFFFFFELL) - 1;
            }
            else
            {
              v883 = 22LL;
            }
            v1317 = v154;
            v1309 = v153;
            if ( ((unsigned __int8)v148 & 1) != 0 )
            {
              v1305 = 0LL;
              v986 = 0;
            }
            else
            {
              v1305 = (unsigned __int64)((unsigned __int8)v148 & 0xFE) >> 1;
              if ( (unsigned __int8)v148 >= 0x2Eu )
              {
                v987 = ((unsigned __int8)(v1305 + 16) & 0xF0) - 1LL;
                v986 = 1;
                if ( v987 == v883 )
                {
LABEL_1704:
                  v134 = a3;
                  v148 = v1328;
                  v154 = v1317;
                  v153 = v1309;
LABEL_1705:
                  *(_BYTE *)(v155 - 48) = v154;
                  *(_QWORD *)(v155 - 47) = v1343;
                  *(_QWORD *)(v155 - 40) = *(_QWORD *)((char *)&v1343 + 7);
                  *v157 = v153;
                  *(_QWORD *)&v1343 = 0LL;
                  *(_QWORD *)((char *)&v1343 + 7) = 0LL;
                  if ( (v1354 & 1) != 0 )
                  {
                    free(v1355);
                    if ( (v147 & 1) == 0 )
                    {
LABEL_1707:
                      if ( (v1348 & 1) == 0 )
                        goto LABEL_1709;
                      goto LABEL_1708;
                    }
                  }
                  else if ( (v147 & 1) == 0 )
                  {
                    goto LABEL_1707;
                  }
                  free(v148);
                  if ( (v1348 & 1) == 0 )
                  {
LABEL_1709:
                    sub_9CDD8((size_t *)&v1340, 0LL, ")", 1uLL);
                    v1168 = v1341;
                    v1169 = v1340;
                    v1341 = 0LL;
                    *(_QWORD *)((char *)&v1354 + 7) = *((_QWORD *)&v1340 + 1);
                    *(_QWORD *)&v1354 = *(_QWORD *)((char *)&v1340 + 1);
                    v1340 = 0uLL;
                    v1170 = *(_QWORD *)(v134 + 8);
                    v1171 = (__int64 *)(v1170 - 24);
                    if ( (*(_BYTE *)(v1170 - 24) & 1) == 0 )
                    {
                      *(_WORD *)(v1170 - 24) = 0;
                      v1172 = (const void **)(v1170 - 8);
LABEL_1735:
                      *(_BYTE *)(v1170 - 24) = v1169;
                      *(_QWORD *)(v1170 - 16) = *(_QWORD *)((char *)&v1354 + 7);
                      *(_QWORD *)(v1170 - 23) = v1354;
                      *v1172 = v1168;
LABEL_1736:
                      if ( (v1352 & 1) != 0 )
                        free(v1353);
                      if ( (v1350 & 1) != 0 )
                        free(v1351);
                      if ( (v1340 & 1) != 0 )
                      {
                        free(v1341);
                        if ( ((__int64)v1338[0] & 1) == 0 )
                        {
LABEL_1742:
                          if ( destb == v4 )
                            return v4;
                          goto LABEL_1746;
                        }
                      }
                      else if ( ((__int64)v1338[0] & 1) == 0 )
                      {
                        goto LABEL_1742;
                      }
                      free(p);
                      if ( destb == v4 )
                        return v4;
LABEL_1746:
                      v1182 = *(_QWORD *)(a3 + 8);
                      v14 = (__int64)v4;
                      if ( *(_QWORD *)a3 == v1182 )
                        return (unsigned __int8 *)v14;
                      *(_QWORD *)&v1350 = *(_QWORD *)(a3 + 24);
                      sub_9D15C((size_t **)v1338, v1182 - 48, (__int64 *)&v1350);
                      v1183 = *(_QWORD *)(a3 + 40);
                      v1184 = *(_QWORD *)(a3 + 48);
                      if ( v1183 < v1184 )
                      {
                        *(_QWORD *)(v1183 + 24) = v1340;
                        *(_OWORD *)v1183 = *(_OWORD *)v1338;
                        *(_QWORD *)(v1183 + 16) = p;
                        v1338[1] = 0LL;
                        p = 0LL;
                        v1338[0] = 0LL;
                        *(_QWORD *)(a3 + 40) += 32LL;
                        v1185 = (void **)v1338[0];
                        if ( !v1338[0] )
                          return destb;
                        goto LABEL_1775;
                      }
                      v1186 = *(_QWORD *)(a3 + 32);
                      v1187 = (__int64)(v1183 - v1186) >> 5;
                      if ( (unsigned __int64)(v1187 + 1) >> 59 )
                        abort();
                      v1188 = v1184 - v1186;
                      if ( (unsigned __int64)(v1188 >> 5) > 0x3FFFFFFFFFFFFFELL )
                      {
                        v1190 = 0x7FFFFFFFFFFFFFFLL;
                      }
                      else
                      {
                        v1189 = v1188 >> 4;
                        if ( v1189 >= v1187 + 1 )
                          v1190 = v1189;
                        else
                          v1190 = v1187 + 1;
                        if ( !v1190 )
                        {
                          v1191 = 0LL;
                          goto LABEL_1761;
                        }
                      }
                      v1192 = *(_QWORD *)(a3 + 56);
                      v1191 = *(char **)(v1192 + 4096);
                      if ( v1192 + 4096 - (__int64)v1191 >= (unsigned __int64)(32 * v1190) )
                        *(_QWORD *)(v1192 + 4096) = &v1191[32 * v1190];
                      else
                        v1191 = (char *)malloc(32 * v1190);
LABEL_1761:
                      v1193 = &v1191[32 * v1187];
                      *((_QWORD *)v1193 + 1) = 0LL;
                      *((_QWORD *)v1193 + 2) = 0LL;
                      v1194 = v1193 + 32;
                      *((_QWORD *)v1193 + 3) = v1340;
                      *(_OWORD *)v1193 = *(_OWORD *)v1338;
                      *((_QWORD *)v1193 + 2) = p;
                      v1338[1] = 0LL;
                      p = 0LL;
                      v1338[0] = 0LL;
                      v1196 = *(void ***)(a3 + 32);
                      v1195 = *(void ***)(a3 + 40);
                      v1197 = &v1191[32 * v1190];
                      if ( v1195 == v1196 )
                      {
                        v1199 = *(void ***)(a3 + 32);
                      }
                      else
                      {
                        do
                        {
                          *((_QWORD *)v1193 - 3) = 0LL;
                          *((_QWORD *)v1193 - 2) = 0LL;
                          *((_QWORD *)v1193 - 4) = 0LL;
                          *((_QWORD *)v1193 - 1) = *(v1195 - 1);
                          v1198 = *((_OWORD *)v1195 - 2);
                          v1195 -= 4;
                          *((_OWORD *)v1193 - 2) = v1198;
                          *((_QWORD *)v1193 - 2) = v1195[2];
                          v1193 -= 32;
                          v1195[1] = 0LL;
                          v1195[2] = 0LL;
                          *v1195 = 0LL;
                        }
                        while ( v1196 != v1195 );
                        v1199 = *(void ***)(a3 + 32);
                        v1196 = *(void ***)(a3 + 40);
                      }
                      v1200 = *(_QWORD *)(a3 + 48);
                      *(_QWORD *)(a3 + 32) = v1193;
                      *(_QWORD *)(a3 + 40) = v1194;
                      *(_QWORD *)(a3 + 48) = v1197;
                      while ( v1199 != v1196 )
                      {
                        v1196 -= 4;
                        sub_9D32C(v1196);
                      }
                      if ( v1199 )
                      {
                        v1201 = *(_QWORD *)(a3 + 56);
                        if ( v1201 + 4096 < (unsigned __int64)v1199 || v1201 > (unsigned __int64)v1199 )
                        {
                          free(v1199);
                        }
                        else if ( *(_QWORD *)(v1201 + 4096) == v1200 )
                        {
                          *(_QWORD *)(v1201 + 4096) = v1199;
                          v1185 = (void **)v1338[0];
                          if ( !v1338[0] )
                            return destb;
LABEL_1775:
                          v1202 = (void **)v1338[1];
                          if ( v1338[1] != v1185 )
                          {
                            do
                            {
                              if ( (*(_BYTE *)(v1202 - 3) & 1) != 0 )
                                free(*(v1202 - 1));
                              v1203 = v1202 - 6;
                              if ( (*(_BYTE *)(v1202 - 6) & 1) != 0 )
                                free(*(v1202 - 4));
                              v1202 -= 6;
                            }
                            while ( v1185 != v1203 );
                          }
                          v1338[1] = v1185;
                          if ( (__int64)v1340 + 4096 < (unsigned __int64)v1185
                            || (unsigned __int64)v1340 > (unsigned __int64)v1185 )
                          {
                            free(v1185);
                          }
                          else if ( *(void **)(v1340 + 4096) == p )
                          {
                            *(_QWORD *)(v1340 + 4096) = v1185;
                            return destb;
                          }
                          return destb;
                        }
                      }
                      v1185 = (void **)v1338[0];
                      if ( !v1338[0] )
                        return destb;
                      goto LABEL_1775;
                    }
                    v1172 = (const void **)(v1170 - 8);
                    **(_BYTE **)(v1170 - 8) = 0;
                    LOBYTE(v1173) = *(_BYTE *)(v1170 - 24);
                    *(_QWORD *)(v1170 - 16) = 0LL;
                    if ( (v1173 & 1) != 0 )
                    {
                      v1173 = *v1171;
                      v1174 = (*v1171 & 0xFFFFFFFFFFFFFFFELL) - 1;
                      v1330 = v1169;
                      if ( (*v1171 & 1) != 0 )
                      {
                        v1318 = 0LL;
                        v1175 = 0;
                        goto LABEL_1720;
                      }
                    }
                    else
                    {
                      v1174 = 22LL;
                      v1330 = v1169;
                    }
                    v1318 = (unsigned __int64)((unsigned __int8)v1173 & 0xFE) >> 1;
                    if ( (unsigned __int8)v1173 >= 0x2Eu )
                    {
                      v1175 = 1;
                      v1176 = ((unsigned __int8)(v1318 + 16) & 0xF0) - 1LL;
                      if ( v1176 == v1174 )
                      {
LABEL_1734:
                        v1169 = v1330;
                        goto LABEL_1735;
                      }
LABEL_1723:
                      if ( v1176 == 22 )
                      {
                        v1177 = *v1172;
                        v1178 = (_BYTE *)(v1170 - 23);
                        if ( v1175 )
                          memcpy(v1178, *v1172, ((unsigned __int64)((unsigned __int8)v1173 & 0xFE) >> 1) + 1);
                        else
                          *v1178 = *v1177;
                        free(v1177);
                        *(_BYTE *)v1171 = 2 * v1318;
                      }
                      else
                      {
                        v1179 = malloc(v1176 + 1);
                        v973 = v1176 > v1174;
                        v1180 = v1179;
                        if ( v973 || v1179 )
                        {
                          if ( (v1175 & 1) != 0 )
                          {
                            memcpy(
                              v1179,
                              (const void *)(v1170 - 23),
                              ((unsigned __int64)((unsigned __int8)v1173 & 0xFE) >> 1) + 1);
                          }
                          else
                          {
                            v1181 = (void *)*v1172;
                            *v1180 = *(_BYTE *)*v1172;
                            free(v1181);
                          }
                          *(_QWORD *)(v1170 - 24) = (v1176 + 1) | 1;
                          *(_QWORD *)(v1170 - 16) = v1318;
                          *(_QWORD *)(v1170 - 8) = v1180;
                        }
                      }
                      goto LABEL_1734;
                    }
                    v1175 = 1;
LABEL_1720:
                    v1176 = 22LL;
                    if ( v1174 == 22 )
                      goto LABEL_1734;
                    goto LABEL_1723;
                  }
LABEL_1708:
                  free(v1349);
                  goto LABEL_1709;
                }
LABEL_1532:
                v1301 = v986;
                if ( v987 == 22 )
                {
                  v1077 = *v157;
                  v1078 = (_BYTE *)(v155 - 47);
                  if ( v986 )
                    memcpy(v1078, *v157, ((unsigned __int64)((unsigned __int8)v148 & 0xFE) >> 1) + 1);
                  else
                    *v1078 = *v1077;
                  free(v1077);
                  *(_BYTE *)v156 = 2 * v1305;
                }
                else
                {
                  v1079 = malloc(v987 + 1);
                  v973 = v987 > v883;
                  v1080 = v1079;
                  if ( v973 || v1079 )
                  {
                    if ( (v1301 & 1) != 0 )
                    {
                      memcpy(
                        v1079,
                        (const void *)(v155 - 47),
                        ((unsigned __int64)((unsigned __int8)v148 & 0xFE) >> 1) + 1);
                    }
                    else
                    {
                      v1167 = (void *)*v157;
                      *v1080 = *(_BYTE *)*v157;
                      free(v1167);
                    }
                    *(_QWORD *)(v155 - 48) = (v987 + 1) | 1;
                    *(_QWORD *)(v155 - 40) = v1305;
                    *(_QWORD *)(v155 - 32) = v1080;
                  }
                }
                goto LABEL_1704;
              }
              v986 = 1;
            }
            v987 = 22LL;
            if ( v883 == 22 )
              goto LABEL_1704;
            goto LABEL_1532;
          }
        }
        sub_9CFD0((size_t *)v1338, " ", 1uLL);
        v320 = *(_OWORD *)v1338;
        v1349 = (char *)p;
        if ( (v1352 & 1) != 0 )
          v321 = v1353;
        else
          v321 = (char *)&v1352 + 1;
        v1338[1] = 0LL;
        p = 0LL;
        v1338[0] = 0LL;
        v1348 = v320;
        if ( (v1352 & 1) != 0 )
          v322 = *((_QWORD *)&v1352 + 1);
        else
          v322 = (unsigned __int64)(unsigned __int8)v1352 >> 1;
        sub_9CFD0((size_t *)&v1350, v321, v322);
        v323 = v1350;
        v324 = v1351;
        v1351 = 0LL;
        v1346 = v1350;
        v1347 = v324;
        v325 = v1350;
        v326 = v324;
        v1350 = 0uLL;
        if ( (v1346 & 1) != 0 )
          v327 = (char *)v1347;
        else
          v327 = (char *)&v1346 + 1;
        if ( (v323 & 1) != 0 )
          v328 = *((_QWORD *)&v323 + 1);
        else
          v328 = (unsigned __int64)(unsigned __int8)v323 >> 1;
        sub_9CFD0((size_t *)&v1348, v327, v328);
        v329 = (unsigned __int16 *)v1349;
        v330 = v1348;
        v1349 = 0LL;
        v1348 = 0uLL;
        v1355 = v329;
        v1354 = v330;
        sub_9CFD0((size_t *)&v1354, "::*", 3uLL);
        v331 = v1355;
        v332 = v1354;
        v1355 = 0LL;
        *(_QWORD *)((char *)&v1343 + 7) = *((_QWORD *)&v1354 + 1);
        *(_QWORD *)&v1343 = *(_QWORD *)((char *)&v1354 + 1);
        v1354 = 0uLL;
        v333 = *(_QWORD *)(a3 + 8);
        v334 = (__int64 *)(v333 - 48);
        if ( (*(_BYTE *)(v333 - 48) & 1) == 0 )
        {
          *(_WORD *)(v333 - 48) = 0;
          v335 = (const void **)(v333 - 32);
          goto LABEL_1570;
        }
        v1327 = v326;
        v335 = (const void **)(v333 - 32);
        **(_BYTE **)(v333 - 32) = 0;
        LOBYTE(v746) = *(_BYTE *)(v333 - 48);
        *(_QWORD *)(v333 - 40) = 0LL;
        if ( (v746 & 1) != 0 )
        {
          v746 = *v334;
          v747 = (*v334 & 0xFFFFFFFFFFFFFFFELL) - 1;
          if ( (*v334 & 1) != 0 )
          {
            v748 = 0LL;
            v749 = 0;
            goto LABEL_1141;
          }
        }
        else
        {
          v747 = 22LL;
        }
        v748 = (unsigned __int64)((unsigned __int8)v746 & 0xFE) >> 1;
        if ( (unsigned __int8)v746 >= 0x2Eu )
        {
          v860 = ((unsigned __int8)(v748 + 16) & 0xF0) - 1LL;
          v749 = 1;
          if ( v860 == v747 )
            goto LABEL_1142;
          goto LABEL_1330;
        }
        v749 = 1;
LABEL_1141:
        v860 = 22LL;
        if ( v747 == 22 )
        {
LABEL_1142:
          v326 = v1327;
          goto LABEL_1570;
        }
LABEL_1330:
        v1308 = v748;
        v1316 = v332;
        if ( v860 == 22 )
        {
          v970 = *v335;
          v971 = (_BYTE *)(v333 - 47);
          if ( v749 )
            memcpy(v971, *v335, ((unsigned __int64)((unsigned __int8)v746 & 0xFE) >> 1) + 1);
          else
            *v971 = *v970;
          free(v970);
          *(_BYTE *)v334 = 2 * v1308;
        }
        else
        {
          v1304 = v749;
          v972 = malloc(v860 + 1);
          v973 = v860 > v747;
          v974 = v972;
          if ( v973 || v972 )
          {
            if ( (v1304 & 1) != 0 )
            {
              memcpy(v972, (const void *)(v333 - 47), ((unsigned __int64)((unsigned __int8)v746 & 0xFE) >> 1) + 1);
            }
            else
            {
              v1097 = (void *)*v335;
              *v974 = *(_BYTE *)*v335;
              free(v1097);
            }
            *(_QWORD *)(v333 - 48) = (v860 + 1) | 1;
            *(_QWORD *)(v333 - 40) = v1308;
            *(_QWORD *)(v333 - 32) = v974;
          }
        }
        v326 = v1327;
        v332 = v1316;
LABEL_1570:
        *(_BYTE *)(v333 - 48) = v332;
        *(_QWORD *)(v333 - 47) = v1343;
        *(_QWORD *)(v333 - 40) = *(_QWORD *)((char *)&v1343 + 7);
        *v335 = v331;
        *(_QWORD *)&v1343 = 0LL;
        *(_QWORD *)((char *)&v1343 + 7) = 0LL;
        if ( (v1354 & 1) != 0 )
        {
          free(v1355);
          v1098 = a3;
          if ( (v325 & 1) == 0 )
          {
LABEL_1572:
            if ( (v1348 & 1) == 0 )
              goto LABEL_1574;
            goto LABEL_1573;
          }
        }
        else
        {
          v1098 = a3;
          if ( (v325 & 1) == 0 )
            goto LABEL_1572;
        }
        free(v326);
        if ( (v1348 & 1) == 0 )
        {
LABEL_1574:
          v1099 = *(_QWORD *)(v1098 + 8);
          v1100 = (_WORD *)(v1099 - 24);
          if ( (*(_BYTE *)(v1099 - 24) & 1) == 0 )
          {
            *v1100 = 0;
LABEL_1599:
            *(_QWORD *)(v1099 - 8) = v1341;
            *(_OWORD *)v1100 = v1340;
            v1341 = 0LL;
            v1340 = 0uLL;
            goto LABEL_1736;
          }
          **(_BYTE **)(v1099 - 8) = 0;
          LOBYTE(v1101) = *(_BYTE *)(v1099 - 24);
          *(_QWORD *)(v1099 - 16) = 0LL;
          if ( (v1101 & 1) != 0 )
          {
            v1101 = *(_QWORD *)v1100;
            v1102 = (*(_QWORD *)v1100 & 0xFFFFFFFFFFFFFFFELL) - 1;
            if ( (*(_QWORD *)v1100 & 1) != 0 )
            {
              v1103 = 0LL;
              v1104 = 0;
              goto LABEL_1585;
            }
          }
          else
          {
            v1102 = 22LL;
          }
          v1103 = (unsigned __int64)((unsigned __int8)v1101 & 0xFE) >> 1;
          if ( (unsigned __int8)v1101 >= 0x2Eu )
          {
            v1105 = ((unsigned __int8)(v1103 + 16) & 0xF0) - 1LL;
            v1104 = 1;
            if ( v1105 == v1102 )
              goto LABEL_1599;
LABEL_1588:
            if ( v1105 == 22 )
            {
              v1106 = *(_BYTE **)(v1099 - 8);
              v1107 = (_BYTE *)(v1099 - 23);
              if ( v1104 )
                memcpy(v1107, *(const void **)(v1099 - 8), ((unsigned __int64)((unsigned __int8)v1101 & 0xFE) >> 1) + 1);
              else
                *v1107 = *v1106;
              free(v1106);
              *(_BYTE *)v1100 = 2 * v1103;
            }
            else
            {
              v1108 = malloc(v1105 + 1);
              v973 = v1105 > v1102;
              v1109 = v1108;
              if ( v973 || v1108 )
              {
                if ( (v1104 & 1) != 0 )
                {
                  memcpy(
                    v1108,
                    (const void *)(v1099 - 23),
                    ((unsigned __int64)((unsigned __int8)v1101 & 0xFE) >> 1) + 1);
                }
                else
                {
                  v1110 = *(_BYTE **)(v1099 - 8);
                  *v1109 = *v1110;
                  free(v1110);
                }
                *(_QWORD *)(v1099 - 24) = (v1105 + 1) | 1;
                *(_QWORD *)(v1099 - 16) = v1103;
                *(_QWORD *)(v1099 - 8) = v1109;
              }
            }
            goto LABEL_1599;
          }
          v1104 = 1;
LABEL_1585:
          v1105 = 22LL;
          if ( v1102 == 22 )
            goto LABEL_1599;
          goto LABEL_1588;
        }
LABEL_1573:
        free(v1349);
        goto LABEL_1574;
      case 'O':
        v179 = *(void ***)a3;
        v180 = *(_QWORD *)(a3 + 8);
        v181 = sub_925FC(v4 + 1, v3, a3);
        v14 = (__int64)v4;
        if ( (unsigned __int8 *)v181 == v4 + 1 )
          return (unsigned __int8 *)v14;
        v1307 = (unsigned __int8 *)v181;
        v182 = *(_QWORD **)(a3 + 40);
        v183 = *(_QWORD *)(a3 + 48);
        v184 = *(void ***)a3;
        v185 = *(_QWORD *)(a3 + 8);
        v186 = *(_QWORD *)(a3 + 24);
        v187 = (__int64 *)a3;
        if ( (unsigned __int64)v182 < v183 )
        {
          *v182 = 0LL;
          v182[1] = 0LL;
          v182[2] = 0LL;
          v182[3] = v186;
          *(_QWORD *)(a3 + 40) += 32LL;
          goto LABEL_591;
        }
        v277 = *(_QWORD *)(a3 + 32);
        v278 = ((__int64)v182 - v277) >> 5;
        if ( (unsigned __int64)(v278 + 1) >> 59 )
          goto LABEL_1805;
        v279 = v183 - v277;
        if ( (unsigned __int64)(v279 >> 5) > 0x3FFFFFFFFFFFFFELL )
        {
          v281 = 0x7FFFFFFFFFFFFFFLL;
        }
        else
        {
          v280 = v279 >> 4;
          if ( v280 >= v278 + 1 )
            v281 = v280;
          else
            v281 = v278 + 1;
          if ( !v281 )
          {
            v282 = 0LL;
LABEL_424:
            v344 = &v282[32 * v278];
            *(_QWORD *)v344 = 0LL;
            *((_QWORD *)v344 + 1) = 0LL;
            *((_QWORD *)v344 + 2) = 0LL;
            *((_QWORD *)v344 + 3) = v186;
            v346 = *(void ***)(a3 + 32);
            v345 = *(void ***)(a3 + 40);
            v347 = &v282[32 * v281];
            v348 = v344 + 32;
            if ( v345 == v346 )
            {
              v350 = *(void ***)(a3 + 32);
            }
            else
            {
              do
              {
                *((_QWORD *)v344 - 3) = 0LL;
                *((_QWORD *)v344 - 2) = 0LL;
                *((_QWORD *)v344 - 4) = 0LL;
                *((_QWORD *)v344 - 1) = *(v345 - 1);
                v349 = *((_OWORD *)v345 - 2);
                v345 -= 4;
                *((_OWORD *)v344 - 2) = v349;
                *((_QWORD *)v344 - 2) = v345[2];
                v344 -= 32;
                v345[1] = 0LL;
                v345[2] = 0LL;
                *v345 = 0LL;
              }
              while ( v346 != v345 );
              v350 = *(void ***)(a3 + 32);
              v346 = *(void ***)(a3 + 40);
            }
            v386 = *(_QWORD *)(a3 + 48);
            *(_QWORD *)(a3 + 32) = v344;
            *(_QWORD *)(a3 + 40) = v348;
            *(_QWORD *)(a3 + 48) = v347;
            while ( v350 != v346 )
            {
              v346 -= 4;
              sub_9D32C(v346);
            }
            if ( v350 )
            {
              v387 = *(_QWORD *)(a3 + 56);
              if ( v387 + 4096 < (unsigned __int64)v350 || v387 > (unsigned __int64)v350 )
              {
                free(v350);
              }
              else if ( *(_QWORD *)(v387 + 4096) == v386 )
              {
                *(_QWORD *)(v387 + 4096) = v350;
              }
            }
LABEL_591:
            v463 = 0xAAAAAAAAAAAAAAABLL * ((v180 - (__int64)v179) >> 4);
            v464 = 0xAAAAAAAAAAAAAAABLL * ((v185 - (__int64)v184) >> 4);
            if ( v463 < v464 )
            {
              v1313 = v464;
              do
              {
                v492 = *v187;
                v1338[1] = 0LL;
                p = 0LL;
                v1338[0] = 0LL;
                v493 = v492 + 48 * v463;
                v494 = *(unsigned __int8 *)(v493 + 24);
                v495 = *(_QWORD *)(v493 + 32);
                v496 = *(const void **)(v493 + 40);
                v497 = (const void *)(v493 + 25);
                v30 = (v494 & 1) == 0;
                v498 = v494 >> 1;
                if ( v30 )
                {
                  v499 = v497;
                }
                else
                {
                  v498 = v495;
                  v499 = v496;
                }
                if ( v498 >= 2 )
                  v500 = 2LL;
                else
                  v500 = v498;
                LOBYTE(v1338[0]) = 2 * v500;
                if ( v500 )
                  memcpy((char *)v1338 + 1, v499, v500);
                *((_BYTE *)v1338 + v500 + 1) = 0;
                v501 = (char *)v1338[1];
                v502 = 0;
                if ( ((__int64)v1338[0] & 1) == 0 )
                  v501 = (char *)((unsigned __int64)LOBYTE(v1338[0]) >> 1);
                if ( v501 == (_BYTE *)&dword_0 + 2 )
                {
                  v503 = (unsigned __int16 *)p;
                  if ( ((__int64)v1338[0] & 1) == 0 )
                    v503 = (unsigned __int16 *)((char *)v1338 + 1);
                  v502 = *v503 == 23328;
                  if ( ((__int64)v1338[0] & 1) != 0 )
                  {
LABEL_643:
                    free(p);
                    v504 = *v187;
                    if ( v502 )
                      goto LABEL_649;
                    goto LABEL_644;
                  }
                }
                else if ( ((__int64)v1338[0] & 1) != 0 )
                {
                  goto LABEL_643;
                }
                v504 = *v187;
                if ( v502 )
                {
LABEL_649:
                  v509 = 48 * v463;
                  v510 = (size_t *)(v504 + 48 * v463);
                  v511 = 2LL;
                  v512 = " (";
LABEL_656:
                  sub_9CFD0(v510, v512, v511);
                  sub_9CDD8((size_t *)(*v187 + v509 + 24), 0LL, ")", 1uLL);
                  goto LABEL_657;
                }
LABEL_644:
                v505 = v504 + 48 * v463;
                v508 = *(unsigned __int8 *)(v505 + 24);
                v506 = v505 + 24;
                v507 = v508;
                if ( (v508 & 1) != 0 )
                {
                  if ( !*(_QWORD *)(v504 + 48 * v463 + 32) )
                    goto LABEL_657;
                }
                else if ( !(v507 >> 1) )
                {
                  goto LABEL_657;
                }
                if ( (v507 & 1) != 0 )
                  v513 = *(_BYTE **)(v504 + 48 * v463 + 40);
                else
                  v513 = (_BYTE *)(v506 + 1);
                if ( *v513 == 40 )
                {
                  v509 = 48 * v463;
                  v510 = (size_t *)(v504 + 48 * v463);
                  v511 = 1LL;
                  v512 = "(";
                  goto LABEL_656;
                }
LABEL_657:
                sub_9CFD0((size_t *)(*v187 + 48 * v463), "&&", 2uLL);
                v514 = v187[5];
                v515 = *v187;
                v517 = *(size_t **)(v514 - 24);
                v516 = *(size_t **)(v514 - 16);
                v518 = *v187 + 48 * v463;
                if ( v517 == v516 )
                {
                  v519 = *(_QWORD *)(v514 - 32);
                  v520 = 0xAAAAAAAAAAAAAAABLL * (((__int64)v517 - v519) >> 4);
                  if ( v520 + 1 > 0x555555555555555LL )
                    goto LABEL_1805;
                  v521 = 0xAAAAAAAAAAAAAAABLL * (((__int64)v516 - v519) >> 4);
                  v522 = 0x555555555555555LL;
                  if ( v521 >= 0x2AAAAAAAAAAAAAALL
                    || ((v523 = 2 * v521, v523 >= v520 + 1) ? (v522 = v523) : (v522 = v520 + 1), v522) )
                  {
                    v524 = *(_QWORD *)(v514 - 8);
                    v525 = 48 * v522;
                    v465 = *(char **)(v524 + 4096);
                    if ( v524 + 4096 - (__int64)v465 >= (unsigned __int64)(48 * v522) )
                      *(_QWORD *)(v524 + 4096) = &v465[v525];
                    else
                      v465 = (char *)malloc(v525);
                  }
                  else
                  {
                    v465 = 0LL;
                  }
                  v466 = (size_t *)&v465[48 * v520];
                  v466[1] = 0LL;
                  v466[2] = 0LL;
                  *v466 = 0LL;
                  v467 = &v465[48 * v522];
                  v1325 = v467;
                  if ( (*(_BYTE *)v518 & 1) == 0 )
                  {
                    v466[2] = *(_QWORD *)(v518 + 16);
                    *(_OWORD *)v466 = *(_OWORD *)v518;
                    v464 = v1313;
                    goto LABEL_604;
                  }
                  v468 = v515 + 48 * v463;
                  v469 = *(_QWORD *)(v468 + 8);
                  if ( v469 >= 0xFFFFFFFFFFFFFFF0LL )
                    abort();
                  v470 = *(const void **)(v468 + 16);
                  if ( v469 >= 0x17 )
                  {
                    v471 = malloc((v469 + 16) & 0xFFFFFFFFFFFFFFF0LL);
                    v472 = &v465[48 * v520];
                    *((_QWORD *)v472 + 1) = v469;
                    *((_QWORD *)v472 + 2) = v471;
                    *v466 = (v469 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
                    v464 = v1313;
                  }
                  else
                  {
                    *(_BYTE *)v466 = 2 * v469;
                    v471 = (char *)v466 + 1;
                    v464 = v1313;
                    if ( !v469 )
                      goto LABEL_603;
                  }
                  memcpy(v471, v470, v469);
LABEL_603:
                  *((_BYTE *)v471 + v469) = 0;
                  v467 = v1325;
LABEL_604:
                  v473 = &v465[48 * v520];
                  *((_QWORD *)v473 + 3) = 0LL;
                  v474 = v473 + 24;
                  v475 = v515 + 48 * v463;
                  *((_QWORD *)v474 + 1) = 0LL;
                  *((_QWORD *)v474 + 2) = 0LL;
                  v477 = *(_BYTE *)(v475 + 24);
                  v476 = v475 + 24;
                  if ( (v477 & 1) == 0 )
                  {
                    *((_QWORD *)v474 + 2) = *(_QWORD *)(v476 + 16);
                    *(_OWORD *)v474 = *(_OWORD *)v476;
LABEL_613:
                    v485 = *(void ***)(v514 - 32);
                    v484 = *(void ***)(v514 - 24);
                    v486 = v466 + 6;
                    if ( v484 == v485 )
                    {
                      v488 = *(void ***)(v514 - 32);
                    }
                    else
                    {
                      do
                      {
                        *(v466 - 4) = (size_t)*(v484 - 4);
                        *((_OWORD *)v466 - 3) = *((_OWORD *)v484 - 3);
                        v487 = (size_t)*(v484 - 1);
                        *(v484 - 5) = 0LL;
                        *(v484 - 4) = 0LL;
                        *(v484 - 6) = 0LL;
                        *(v466 - 1) = v487;
                        *(_OWORD *)(v466 - 3) = *(_OWORD *)(v484 - 3);
                        *(v484 - 2) = 0LL;
                        *(v484 - 1) = 0LL;
                        *(v484 - 3) = 0LL;
                        v484 -= 6;
                        v466 -= 6;
                      }
                      while ( v485 != v484 );
                      v488 = *(void ***)(v514 - 32);
                      v485 = *(void ***)(v514 - 24);
                    }
                    v489 = *(_QWORD *)(v514 - 16);
                    *(_QWORD *)(v514 - 32) = v466;
                    *(_QWORD *)(v514 - 24) = v486;
                    *(_QWORD *)(v514 - 16) = v467;
                    v187 = (__int64 *)a3;
                    if ( v485 != v488 )
                    {
                      do
                      {
                        if ( (*(_BYTE *)(v485 - 3) & 1) != 0 )
                          free(*(v485 - 1));
                        v490 = v485 - 6;
                        if ( (*(_BYTE *)(v485 - 6) & 1) != 0 )
                          free(*(v485 - 4));
                        v485 -= 6;
                      }
                      while ( v488 != v490 );
                    }
                    if ( v488 )
                    {
                      v491 = *(_QWORD *)(v514 - 8);
                      if ( v491 + 4096 < (unsigned __int64)v488 || v491 > (unsigned __int64)v488 )
                      {
                        free(v488);
                      }
                      else if ( *(_QWORD *)(v491 + 4096) == v489 )
                      {
                        *(_QWORD *)(v491 + 4096) = v488;
                      }
                    }
                    goto LABEL_685;
                  }
                  v478 = v515 + 48 * v463;
                  v479 = *(_QWORD *)(v478 + 32);
                  if ( v479 >= 0xFFFFFFFFFFFFFFF0LL )
                    abort();
                  v480 = *(const void **)(v478 + 40);
                  if ( v479 >= 0x17 )
                  {
                    v482 = malloc((v479 + 16) & 0xFFFFFFFFFFFFFFF0LL);
                    v464 = v1313;
                    v483 = &v465[48 * v520];
                    *((_QWORD *)v483 + 4) = v479;
                    *((_QWORD *)v483 + 5) = v482;
                    *(_QWORD *)v474 = (v479 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
                    v481 = v482;
                  }
                  else
                  {
                    *v474 = 2 * v479;
                    v481 = v474 + 1;
                    if ( !v479 )
                      goto LABEL_612;
                  }
                  memcpy(v481, v480, v479);
LABEL_612:
                  *((_BYTE *)v481 + v479) = 0;
                  v467 = v1325;
                  goto LABEL_613;
                }
                v517[1] = 0LL;
                v517[2] = 0LL;
                *v517 = 0LL;
                if ( (*(_BYTE *)v518 & 1) == 0 )
                {
                  v517[2] = *(_QWORD *)(v518 + 16);
                  *(_OWORD *)v517 = *(_OWORD *)v518;
                  goto LABEL_675;
                }
                v526 = v515 + 48 * v463;
                v527 = *(_QWORD *)(v526 + 8);
                if ( v527 >= 0xFFFFFFFFFFFFFFF0LL )
                  goto LABEL_1805;
                v528 = *(const void **)(v526 + 16);
                if ( v527 >= 0x17 )
                {
                  v529 = malloc((v527 + 16) & 0xFFFFFFFFFFFFFFF0LL);
                  v517[2] = (size_t)v529;
                  v187 = (__int64 *)a3;
                  *v517 = (v527 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
                  v517[1] = v527;
                }
                else
                {
                  *(_BYTE *)v517 = 2 * v527;
                  v529 = (char *)v517 + 1;
                  if ( !v527 )
                    goto LABEL_674;
                }
                memcpy(v529, v528, v527);
LABEL_674:
                *((_BYTE *)v529 + v527) = 0;
LABEL_675:
                v517[3] = 0LL;
                v530 = v517 + 3;
                v531 = v515 + 48 * v463;
                v517[4] = 0LL;
                v517[5] = 0LL;
                v533 = *(_BYTE *)(v531 + 24);
                v532 = v531 + 24;
                if ( (v533 & 1) != 0 )
                {
                  v534 = v515 + 48 * v463;
                  v535 = *(_QWORD *)(v534 + 32);
                  if ( v535 >= 0xFFFFFFFFFFFFFFF0LL )
                    abort();
                  v536 = *(const void **)(v534 + 40);
                  if ( v535 >= 0x17 )
                  {
                    v537 = malloc((v535 + 16) & 0xFFFFFFFFFFFFFFF0LL);
                    v517[5] = (size_t)v537;
                    v187 = (__int64 *)a3;
                    v517[3] = (v535 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
                    v517[4] = v535;
                  }
                  else
                  {
                    *v530 = 2 * v535;
                    v537 = (char *)v517 + 25;
                    if ( !v535 )
                      goto LABEL_683;
                  }
                  memcpy(v537, v536, v535);
LABEL_683:
                  *((_BYTE *)v537 + v535) = 0;
                  goto LABEL_684;
                }
                v517[5] = *(_QWORD *)(v532 + 16);
                *(_OWORD *)v530 = *(_OWORD *)v532;
LABEL_684:
                *(_QWORD *)(v514 - 24) += 48LL;
LABEL_685:
                ++v463;
              }
              while ( v463 < v464 );
            }
            return v1307;
          }
        }
        v317 = *(_QWORD *)(a3 + 56);
        v282 = *(char **)(v317 + 4096);
        if ( v317 + 4096 - (__int64)v282 >= (unsigned __int64)(32 * v281) )
          *(_QWORD *)(v317 + 4096) = &v282[32 * v281];
        else
          v282 = (char *)malloc(32 * v281);
        goto LABEL_424;
      case 'P':
        v188 = *(void ***)a3;
        v189 = *(_QWORD *)(a3 + 8);
        v190 = sub_925FC(v4 + 1, v3, a3);
        v14 = (__int64)v4;
        v1322 = v4 + 1;
        if ( (unsigned __int8 *)v190 == v4 + 1 )
          return (unsigned __int8 *)v14;
        v1303 = v190;
        v191 = *(_QWORD **)(a3 + 40);
        v192 = *(_QWORD *)(a3 + 48);
        v193 = *(void ***)a3;
        v194 = *(_QWORD *)(a3 + 8);
        v195 = *(_QWORD *)(a3 + 24);
        v196 = (__int64 *)a3;
        if ( (unsigned __int64)v191 < v192 )
        {
          *v191 = 0LL;
          v191[1] = 0LL;
          v191[2] = 0LL;
          v191[3] = v195;
          *(_QWORD *)(a3 + 40) += 32LL;
          goto LABEL_688;
        }
        v283 = *(_QWORD *)(a3 + 32);
        v284 = ((__int64)v191 - v283) >> 5;
        if ( (unsigned __int64)(v284 + 1) >> 59 )
          goto LABEL_1805;
        v285 = v192 - v283;
        if ( (unsigned __int64)(v285 >> 5) > 0x3FFFFFFFFFFFFFELL )
        {
          v287 = 0x7FFFFFFFFFFFFFFLL;
        }
        else
        {
          v286 = v285 >> 4;
          if ( v286 >= v284 + 1 )
            v287 = v286;
          else
            v287 = v284 + 1;
          if ( !v287 )
          {
            v288 = 0LL;
LABEL_428:
            v351 = &v288[32 * v284];
            *(_QWORD *)v351 = 0LL;
            *((_QWORD *)v351 + 1) = 0LL;
            *((_QWORD *)v351 + 2) = 0LL;
            *((_QWORD *)v351 + 3) = v195;
            v353 = *(void ***)(a3 + 32);
            v352 = *(void ***)(a3 + 40);
            v354 = &v288[32 * v287];
            v355 = v351 + 32;
            if ( v352 == v353 )
            {
              v357 = *(void ***)(a3 + 32);
            }
            else
            {
              do
              {
                *((_QWORD *)v351 - 3) = 0LL;
                *((_QWORD *)v351 - 2) = 0LL;
                *((_QWORD *)v351 - 4) = 0LL;
                *((_QWORD *)v351 - 1) = *(v352 - 1);
                v356 = *((_OWORD *)v352 - 2);
                v352 -= 4;
                *((_OWORD *)v351 - 2) = v356;
                *((_QWORD *)v351 - 2) = v352[2];
                v351 -= 32;
                v352[1] = 0LL;
                v352[2] = 0LL;
                *v352 = 0LL;
              }
              while ( v353 != v352 );
              v357 = *(void ***)(a3 + 32);
              v353 = *(void ***)(a3 + 40);
            }
            v388 = *(_QWORD *)(a3 + 48);
            *(_QWORD *)(a3 + 32) = v351;
            *(_QWORD *)(a3 + 40) = v355;
            *(_QWORD *)(a3 + 48) = v354;
            while ( v357 != v353 )
            {
              v353 -= 4;
              sub_9D32C(v353);
            }
            if ( v357 )
            {
              v389 = *(_QWORD *)(a3 + 56);
              if ( v389 + 4096 < (unsigned __int64)v357 || v389 > (unsigned __int64)v357 )
              {
                free(v357);
              }
              else if ( *(_QWORD *)(v389 + 4096) == v388 )
              {
                *(_QWORD *)(v389 + 4096) = v357;
              }
            }
LABEL_688:
            v538 = 0xAAAAAAAAAAAAAAABLL * ((v189 - (__int64)v188) >> 4);
            v1314 = 0xAAAAAAAAAAAAAAABLL * ((v194 - (__int64)v193) >> 4);
            if ( v538 >= v1314 )
              return (unsigned __int8 *)v1303;
            while ( 1 )
            {
              v567 = *v196;
              v1338[1] = 0LL;
              p = 0LL;
              v1338[0] = 0LL;
              v568 = v567 + 48 * v538;
              v569 = *(unsigned __int8 *)(v568 + 24);
              v570 = *(_QWORD *)(v568 + 32);
              v571 = *(const void **)(v568 + 40);
              v572 = (const void *)(v568 + 25);
              v30 = (v569 & 1) == 0;
              v573 = v569 >> 1;
              if ( v30 )
              {
                v574 = v572;
              }
              else
              {
                v573 = v570;
                v574 = v571;
              }
              if ( v573 >= 2 )
                v575 = 2LL;
              else
                v575 = v573;
              LOBYTE(v1338[0]) = 2 * v575;
              if ( v575 )
                memcpy((char *)v1338 + 1, v574, v575);
              *((_BYTE *)v1338 + v575 + 1) = 0;
              v576 = (char *)v1338[1];
              v577 = 0;
              if ( ((__int64)v1338[0] & 1) == 0 )
                v576 = (char *)((unsigned __int64)LOBYTE(v1338[0]) >> 1);
              if ( v576 == (_BYTE *)&dword_0 + 2 )
              {
                v578 = (unsigned __int16 *)p;
                if ( ((__int64)v1338[0] & 1) == 0 )
                  v578 = (unsigned __int16 *)((char *)v1338 + 1);
                v577 = *v578 == 23328;
                if ( ((__int64)v1338[0] & 1) != 0 )
                {
LABEL_741:
                  free(p);
                  v579 = *v196;
                  if ( v577 )
                    goto LABEL_747;
                  goto LABEL_742;
                }
              }
              else if ( ((__int64)v1338[0] & 1) != 0 )
              {
                goto LABEL_741;
              }
              v579 = *v196;
              if ( v577 )
              {
LABEL_747:
                v584 = 48 * v538;
                v585 = (size_t *)(v579 + 48 * v538);
                v586 = 2LL;
                v587 = " (";
LABEL_754:
                sub_9CFD0(v585, v587, v586);
                sub_9CDD8((size_t *)(*v196 + v584 + 24), 0LL, ")", 1uLL);
                goto LABEL_755;
              }
LABEL_742:
              v580 = v579 + 48 * v538;
              v583 = *(unsigned __int8 *)(v580 + 24);
              v581 = v580 + 24;
              v582 = v583;
              if ( (v583 & 1) != 0 )
              {
                if ( !*(_QWORD *)(v579 + 48 * v538 + 32) )
                  goto LABEL_755;
              }
              else if ( !(v582 >> 1) )
              {
                goto LABEL_755;
              }
              if ( (v582 & 1) != 0 )
                v588 = *(_BYTE **)(v579 + 48 * v538 + 40);
              else
                v588 = (_BYTE *)(v581 + 1);
              if ( *v588 == 40 )
              {
                v584 = 48 * v538;
                v585 = (size_t *)(v579 + 48 * v538);
                v586 = 1LL;
                v587 = "(";
                goto LABEL_754;
              }
LABEL_755:
              if ( *v1322 != 85 )
              {
                v596 = (size_t *)(*v196 + 48 * v538);
LABEL_778:
                sub_9CFD0(v596, "*", 1uLL);
                v601 = (__int64 *)a3;
                goto LABEL_832;
              }
              v589 = *v196;
              v1338[1] = 0LL;
              p = 0LL;
              v1338[0] = 0LL;
              v590 = (unsigned __int8 *)(v589 + 48 * v538);
              v591 = *v590;
              v592 = (v591 & 1) == 0;
              if ( (v591 & 1) != 0 )
                v593 = *((_QWORD *)v590 + 1);
              else
                v593 = v591 >> 1;
              if ( v592 )
                v594 = v590 + 1;
              else
                v594 = (const void *)*((_QWORD *)v590 + 2);
              if ( v593 >= 0xC )
                v595 = 12LL;
              else
                v595 = v593;
              LOBYTE(v1338[0]) = 2 * v595;
              if ( v595 )
                memcpy((char *)v1338 + 1, v594, v595);
              *((_BYTE *)v1338 + v595 + 1) = 0;
              v597 = (char *)v1338[1];
              if ( ((__int64)v1338[0] & 1) == 0 )
                v597 = (char *)((unsigned __int64)LOBYTE(v1338[0]) >> 1);
              if ( v597 == &byte_9[3] )
              {
                if ( ((__int64)v1338[0] & 1) != 0 )
                  v598 = (char *)p;
                else
                  v598 = (char *)v1338 + 1;
                v599 = memcmp(v598, "objc_object<", 0xCuLL) != 0;
                if ( ((__int64)v1338[0] & 1) != 0 )
LABEL_776:
                  free(p);
              }
              else
              {
                v599 = 1;
                if ( ((__int64)v1338[0] & 1) != 0 )
                  goto LABEL_776;
              }
              v600 = *v196;
              v596 = (size_t *)(*v196 + 48 * v538);
              if ( v599 )
                goto LABEL_778;
              v602 = *(unsigned __int8 *)v596;
              if ( (v602 & 1) != 0 )
              {
                v602 = *v596;
                v603 = *(_QWORD *)(v600 + 48 * v538 + 8);
                if ( v603 >= 0xB )
                  v566 = 11LL;
                else
                  v566 = *(_QWORD *)(v600 + 48 * v538 + 8);
                v604 = (*v596 & 0xFFFFFFFFFFFFFFFELL) - 1;
              }
              else
              {
                v603 = v602 >> 1;
                if ( v602 >> 1 >= 0xB )
                  v566 = 11LL;
                else
                  v566 = v602 >> 1;
                v604 = 22LL;
              }
              if ( v566 - v603 + v604 < 2 )
              {
                v605 = v603 - v566;
                v606 = v603 - v566 + 2;
                if ( -18LL - v604 < v606 - v604 )
                  goto LABEL_1805;
                if ( (v602 & 1) != 0 )
                  v607 = *(char **)(v600 + 48 * v538 + 16);
                else
                  v607 = (char *)v596 + 1;
                if ( v604 > 0x7FFFFFFFFFFFFFE6LL )
                {
                  v614 = -17LL;
                }
                else
                {
                  v613 = 2 * v604;
                  if ( v606 >= 2 * v604 )
                    v613 = v603 - v566 + 2;
                  if ( v613 >= 0x17 )
                    v614 = (v613 + 16) & 0xFFFFFFFFFFFFFFF0LL;
                  else
                    v614 = 23LL;
                }
                v615 = malloc(v614);
                v616 = v615;
                *v615 = 25705;
                if ( v605 )
                  memcpy(v615 + 1, &v607[v566], v605);
                if ( v604 != 22 )
                  free(v607);
                v617 = v600 + 48 * v538;
                *(_QWORD *)(v617 + 8) = v606;
                *(_QWORD *)(v617 + 16) = v616;
                *v596 = v614 | 1;
                v601 = (__int64 *)a3;
                v618 = (char *)v616 + v606;
                goto LABEL_831;
              }
              if ( (v602 & 1) != 0 )
              {
                v608 = *(char **)(v600 + 48 * v538 + 16);
                if ( v566 == 2 )
                {
LABEL_796:
                  v609 = 0LL;
                  v610 = "id";
                  v611 = 2LL;
                  goto LABEL_826;
                }
              }
              else
              {
                v608 = (char *)v596 + 1;
                if ( v566 == 2 )
                  goto LABEL_796;
              }
              if ( v603 == v566 )
              {
                v609 = 0LL;
                v610 = "id";
                goto LABEL_825;
              }
              if ( v566 < 3 )
              {
                v619 = &v608[v566];
                if ( v608 >= "id" )
                {
                  v610 = "id";
                  goto LABEL_824;
                }
                v610 = "id";
                if ( &v608[v603] <= "id" )
                  goto LABEL_824;
                if ( v619 <= "id" )
                {
                  v610 = &aStdBadTypeid[2 - v566 + 13];
LABEL_824:
                  memmove(v608 + 2, v619, v603 - v566);
                  v609 = 0LL;
LABEL_825:
                  v611 = 2LL;
LABEL_826:
                  memmove(&v608[v609], v610, v611);
                  v612 = v611;
                  goto LABEL_827;
                }
                if ( v566 )
                {
                  memcpy(v608, "id", v566);
                  v619 = &v608[v566];
                }
                v611 = 2 - v566;
                memmove(v608 + 2, v619, v603 - v566);
                v612 = 0LL;
                if ( 2 != v566 )
                {
                  v610 = "";
                  v609 = v566;
                  v566 = 0LL;
                  goto LABEL_826;
                }
                v566 = 0LL;
              }
              else
              {
                *(_WORD *)v608 = 25705;
                memmove(v608 + 2, &v608[v566], v603 - v566);
                v612 = 2LL;
              }
LABEL_827:
              v620 = v612 - v566 + v603;
              if ( (*(_BYTE *)v596 & 1) != 0 )
                *(_QWORD *)(v600 + 48 * v538 + 8) = v620;
              else
                *(_BYTE *)v596 = 2 * v620;
              v601 = (__int64 *)a3;
              v618 = &v608[v620];
LABEL_831:
              *v618 = 0;
LABEL_832:
              v621 = v601[5];
              v622 = *v601;
              v624 = *(size_t **)(v621 - 24);
              v623 = *(size_t **)(v621 - 16);
              v625 = v622 + 48 * v538;
              if ( v624 == v623 )
              {
                v626 = *(_QWORD *)(v621 - 32);
                v627 = 0xAAAAAAAAAAAAAAABLL * (((__int64)v624 - v626) >> 4);
                if ( v627 + 1 > 0x555555555555555LL )
                  goto LABEL_1805;
                v628 = 0xAAAAAAAAAAAAAAABLL * (((__int64)v623 - v626) >> 4);
                v629 = 0x555555555555555LL;
                if ( v628 >= 0x2AAAAAAAAAAAAAALL
                  || ((v630 = 2 * v628, v630 >= v627 + 1) ? (v629 = v630) : (v629 = v627 + 1), v629) )
                {
                  v631 = *(_QWORD *)(v621 - 8);
                  v632 = 48 * v629;
                  v539 = *(char **)(v631 + 4096);
                  if ( v631 + 4096 - (__int64)v539 >= (unsigned __int64)(48 * v629) )
                    *(_QWORD *)(v631 + 4096) = &v539[v632];
                  else
                    v539 = (char *)malloc(v632);
                }
                else
                {
                  v539 = 0LL;
                }
                v540 = (size_t *)&v539[48 * v627];
                v540[1] = 0LL;
                v540[2] = 0LL;
                *v540 = 0LL;
                v541 = &v539[48 * v629];
                if ( (*(_BYTE *)v625 & 1) == 0 )
                {
                  v540[2] = *(_QWORD *)(v625 + 16);
                  *(_OWORD *)v540 = *(_OWORD *)v625;
                  goto LABEL_701;
                }
                v542 = v622 + 48 * v538;
                v543 = *(_QWORD *)(v542 + 8);
                if ( v543 >= 0xFFFFFFFFFFFFFFF0LL )
                  abort();
                v544 = *(const void **)(v542 + 16);
                if ( v543 >= 0x17 )
                {
                  v545 = malloc((v543 + 16) & 0xFFFFFFFFFFFFFFF0LL);
                  v546 = &v539[48 * v627];
                  *((_QWORD *)v546 + 1) = v543;
                  *((_QWORD *)v546 + 2) = v545;
                  *v540 = (v543 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
                }
                else
                {
                  *(_BYTE *)v540 = 2 * v543;
                  v545 = (char *)v540 + 1;
                  if ( !v543 )
                    goto LABEL_700;
                }
                memcpy(v545, v544, v543);
LABEL_700:
                *((_BYTE *)v545 + v543) = 0;
LABEL_701:
                v547 = &v539[48 * v627];
                *((_QWORD *)v547 + 3) = 0LL;
                v548 = v547 + 24;
                v549 = v622 + 48 * v538;
                *((_QWORD *)v548 + 1) = 0LL;
                *((_QWORD *)v548 + 2) = 0LL;
                v551 = *(_BYTE *)(v549 + 24);
                v550 = v549 + 24;
                if ( (v551 & 1) == 0 )
                {
                  *((_QWORD *)v548 + 2) = *(_QWORD *)(v550 + 16);
                  *(_OWORD *)v548 = *(_OWORD *)v550;
LABEL_710:
                  v559 = *(void ***)(v621 - 32);
                  v558 = *(void ***)(v621 - 24);
                  v560 = v540 + 6;
                  if ( v558 == v559 )
                  {
                    v562 = *(void ***)(v621 - 32);
                  }
                  else
                  {
                    do
                    {
                      *(v540 - 4) = (size_t)*(v558 - 4);
                      *((_OWORD *)v540 - 3) = *((_OWORD *)v558 - 3);
                      v561 = (size_t)*(v558 - 1);
                      *(v558 - 5) = 0LL;
                      *(v558 - 4) = 0LL;
                      *(v558 - 6) = 0LL;
                      *(v540 - 1) = v561;
                      *(_OWORD *)(v540 - 3) = *(_OWORD *)(v558 - 3);
                      *(v558 - 2) = 0LL;
                      *(v558 - 1) = 0LL;
                      *(v558 - 3) = 0LL;
                      v558 -= 6;
                      v540 -= 6;
                    }
                    while ( v559 != v558 );
                    v562 = *(void ***)(v621 - 32);
                    v559 = *(void ***)(v621 - 24);
                  }
                  v563 = *(_QWORD *)(v621 - 16);
                  *(_QWORD *)(v621 - 32) = v540;
                  *(_QWORD *)(v621 - 24) = v560;
                  *(_QWORD *)(v621 - 16) = v541;
                  if ( v559 != v562 )
                  {
                    do
                    {
                      if ( (*(_BYTE *)(v559 - 3) & 1) != 0 )
                        free(*(v559 - 1));
                      v564 = v559 - 6;
                      if ( (*(_BYTE *)(v559 - 6) & 1) != 0 )
                        free(*(v559 - 4));
                      v559 -= 6;
                    }
                    while ( v562 != v564 );
                  }
                  if ( v562 )
                  {
                    v565 = *(_QWORD *)(v621 - 8);
                    if ( v565 + 4096 < (unsigned __int64)v562 || v565 > (unsigned __int64)v562 )
                    {
                      free(v562);
                    }
                    else if ( *(_QWORD *)(v565 + 4096) == v563 )
                    {
                      *(_QWORD *)(v565 + 4096) = v562;
                    }
                  }
                  goto LABEL_860;
                }
                v552 = v622 + 48 * v538;
                v553 = *(_QWORD *)(v552 + 32);
                if ( v553 >= 0xFFFFFFFFFFFFFFF0LL )
                  abort();
                v554 = *(const void **)(v552 + 40);
                if ( v553 >= 0x17 )
                {
                  v556 = malloc((v553 + 16) & 0xFFFFFFFFFFFFFFF0LL);
                  v557 = &v539[48 * v627];
                  *((_QWORD *)v557 + 4) = v553;
                  *((_QWORD *)v557 + 5) = v556;
                  *(_QWORD *)v548 = (v553 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
                  v555 = v556;
                }
                else
                {
                  *v548 = 2 * v553;
                  v555 = v548 + 1;
                  if ( !v553 )
                    goto LABEL_709;
                }
                memcpy(v555, v554, v553);
LABEL_709:
                *((_BYTE *)v555 + v553) = 0;
                goto LABEL_710;
              }
              v624[1] = 0LL;
              v624[2] = 0LL;
              *v624 = 0LL;
              if ( (*(_BYTE *)v625 & 1) == 0 )
              {
                v624[2] = *(_QWORD *)(v625 + 16);
                *(_OWORD *)v624 = *(_OWORD *)v625;
                goto LABEL_850;
              }
              v633 = v622 + 48 * v538;
              v634 = *(_QWORD *)(v633 + 8);
              if ( v634 >= 0xFFFFFFFFFFFFFFF0LL )
                goto LABEL_1805;
              v635 = *(const void **)(v633 + 16);
              if ( v634 >= 0x17 )
              {
                v636 = malloc((v634 + 16) & 0xFFFFFFFFFFFFFFF0LL);
                v624[1] = v634;
                v624[2] = (size_t)v636;
                *v624 = (v634 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
              }
              else
              {
                *(_BYTE *)v624 = 2 * v634;
                v636 = (char *)v624 + 1;
                if ( !v634 )
                  goto LABEL_849;
              }
              memcpy(v636, v635, v634);
LABEL_849:
              *((_BYTE *)v636 + v634) = 0;
LABEL_850:
              v624[3] = 0LL;
              v637 = v624 + 3;
              v638 = v622 + 48 * v538;
              v624[4] = 0LL;
              v624[5] = 0LL;
              v640 = *(_BYTE *)(v638 + 24);
              v639 = v638 + 24;
              if ( (v640 & 1) != 0 )
              {
                v641 = v622 + 48 * v538;
                v642 = *(_QWORD *)(v641 + 32);
                if ( v642 >= 0xFFFFFFFFFFFFFFF0LL )
                  abort();
                v643 = *(const void **)(v641 + 40);
                if ( v642 >= 0x17 )
                {
                  v644 = malloc((v642 + 16) & 0xFFFFFFFFFFFFFFF0LL);
                  v624[4] = v642;
                  v624[5] = (size_t)v644;
                  v624[3] = (v642 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
                }
                else
                {
                  *v637 = 2 * v642;
                  v644 = (char *)v624 + 25;
                  if ( !v642 )
                    goto LABEL_858;
                }
                memcpy(v644, v643, v642);
LABEL_858:
                *((_BYTE *)v644 + v642) = 0;
                goto LABEL_859;
              }
              v624[5] = *(_QWORD *)(v639 + 16);
              *(_OWORD *)v637 = *(_OWORD *)v639;
LABEL_859:
              *(_QWORD *)(v621 - 24) += 48LL;
LABEL_860:
              v196 = (__int64 *)a3;
              if ( ++v538 >= v1314 )
                return (unsigned __int8 *)v1303;
            }
          }
        }
        v318 = *(_QWORD *)(a3 + 56);
        v288 = *(char **)(v318 + 4096);
        if ( v318 + 4096 - (__int64)v288 >= (unsigned __int64)(32 * v287) )
          *(_QWORD *)(v318 + 4096) = &v288[32 * v287];
        else
          v288 = (char *)malloc(32 * v287);
        goto LABEL_428;
      case 'R':
        v235 = *(void ***)a3;
        v236 = *(_QWORD *)(a3 + 8);
        v237 = sub_925FC(v4 + 1, v3, a3);
        v14 = (__int64)v4;
        if ( (unsigned __int8 *)v237 == v4 + 1 )
          return (unsigned __int8 *)v14;
        v1307 = (unsigned __int8 *)v237;
        v238 = *(_QWORD **)(a3 + 40);
        v239 = *(_QWORD *)(a3 + 48);
        v240 = *(void ***)a3;
        v241 = *(_QWORD *)(a3 + 8);
        v242 = *(_QWORD *)(a3 + 24);
        v243 = (__int64 *)a3;
        if ( (unsigned __int64)v238 < v239 )
        {
          *v238 = 0LL;
          v238[1] = 0LL;
          v238[2] = 0LL;
          v238[3] = v242;
          *(_QWORD *)(a3 + 40) += 32LL;
LABEL_869:
          v647 = 0xAAAAAAAAAAAAAAABLL * ((v236 - (__int64)v235) >> 4);
          v648 = 0xAAAAAAAAAAAAAAABLL * ((v241 - (__int64)v240) >> 4);
          if ( v647 >= v648 )
            return v1307;
          v1315 = v648;
          while ( 1 )
          {
            v676 = *v243;
            v1338[1] = 0LL;
            p = 0LL;
            v1338[0] = 0LL;
            v677 = v676 + 48 * v647;
            v678 = *(unsigned __int8 *)(v677 + 24);
            v679 = *(_QWORD *)(v677 + 32);
            v680 = *(const void **)(v677 + 40);
            v681 = (const void *)(v677 + 25);
            v30 = (v678 & 1) == 0;
            v682 = v678 >> 1;
            if ( v30 )
            {
              v683 = v681;
            }
            else
            {
              v682 = v679;
              v683 = v680;
            }
            if ( v682 >= 2 )
              v684 = 2LL;
            else
              v684 = v682;
            LOBYTE(v1338[0]) = 2 * v684;
            if ( v684 )
              memcpy((char *)v1338 + 1, v683, v684);
            *((_BYTE *)v1338 + v684 + 1) = 0;
            v685 = (char *)v1338[1];
            v686 = 0;
            if ( ((__int64)v1338[0] & 1) == 0 )
              v685 = (char *)((unsigned __int64)LOBYTE(v1338[0]) >> 1);
            if ( v685 == (_BYTE *)&dword_0 + 2 )
            {
              v687 = (unsigned __int16 *)p;
              if ( ((__int64)v1338[0] & 1) == 0 )
                v687 = (unsigned __int16 *)((char *)v1338 + 1);
              v686 = *v687 == 23328;
              if ( ((__int64)v1338[0] & 1) != 0 )
              {
LABEL_921:
                free(p);
                v688 = *v243;
                if ( v686 )
                  goto LABEL_927;
                goto LABEL_922;
              }
            }
            else if ( ((__int64)v1338[0] & 1) != 0 )
            {
              goto LABEL_921;
            }
            v688 = *v243;
            if ( v686 )
            {
LABEL_927:
              v693 = 48 * v647;
              v694 = (size_t *)(v688 + 48 * v647);
              v695 = 2LL;
              v696 = " (";
LABEL_934:
              sub_9CFD0(v694, v696, v695);
              sub_9CDD8((size_t *)(*v243 + v693 + 24), 0LL, ")", 1uLL);
              goto LABEL_935;
            }
LABEL_922:
            v689 = v688 + 48 * v647;
            v692 = *(unsigned __int8 *)(v689 + 24);
            v690 = v689 + 24;
            v691 = v692;
            if ( (v692 & 1) != 0 )
            {
              if ( !*(_QWORD *)(v688 + 48 * v647 + 32) )
                goto LABEL_935;
            }
            else if ( !(v691 >> 1) )
            {
              goto LABEL_935;
            }
            if ( (v691 & 1) != 0 )
              v697 = *(_BYTE **)(v688 + 48 * v647 + 40);
            else
              v697 = (_BYTE *)(v690 + 1);
            if ( *v697 == 40 )
            {
              v693 = 48 * v647;
              v694 = (size_t *)(v688 + 48 * v647);
              v695 = 1LL;
              v696 = "(";
              goto LABEL_934;
            }
LABEL_935:
            sub_9CFD0((size_t *)(*v243 + 48 * v647), "&", 1uLL);
            v698 = v243[5];
            v699 = *v243;
            v701 = *(size_t **)(v698 - 24);
            v700 = *(size_t **)(v698 - 16);
            v702 = *v243 + 48 * v647;
            if ( v701 == v700 )
            {
              v703 = *(_QWORD *)(v698 - 32);
              v704 = 0xAAAAAAAAAAAAAAABLL * (((__int64)v701 - v703) >> 4);
              if ( v704 + 1 > 0x555555555555555LL )
                goto LABEL_1805;
              v705 = 0xAAAAAAAAAAAAAAABLL * (((__int64)v700 - v703) >> 4);
              v706 = 0x555555555555555LL;
              if ( v705 >= 0x2AAAAAAAAAAAAAALL
                || ((v707 = 2 * v705, v707 >= v704 + 1) ? (v706 = v707) : (v706 = v704 + 1), v706) )
              {
                v708 = *(_QWORD *)(v698 - 8);
                v709 = 48 * v706;
                v649 = *(char **)(v708 + 4096);
                if ( v708 + 4096 - (__int64)v649 >= (unsigned __int64)(48 * v706) )
                  *(_QWORD *)(v708 + 4096) = &v649[v709];
                else
                  v649 = (char *)malloc(v709);
              }
              else
              {
                v649 = 0LL;
              }
              v650 = (size_t *)&v649[48 * v704];
              v650[1] = 0LL;
              v650[2] = 0LL;
              *v650 = 0LL;
              v651 = &v649[48 * v706];
              v1326 = v651;
              if ( (*(_BYTE *)v702 & 1) == 0 )
              {
                v650[2] = *(_QWORD *)(v702 + 16);
                *(_OWORD *)v650 = *(_OWORD *)v702;
                v648 = v1315;
                goto LABEL_882;
              }
              v652 = v699 + 48 * v647;
              v653 = *(_QWORD *)(v652 + 8);
              if ( v653 >= 0xFFFFFFFFFFFFFFF0LL )
                abort();
              v654 = *(const void **)(v652 + 16);
              if ( v653 >= 0x17 )
              {
                v655 = malloc((v653 + 16) & 0xFFFFFFFFFFFFFFF0LL);
                v656 = &v649[48 * v704];
                *((_QWORD *)v656 + 1) = v653;
                *((_QWORD *)v656 + 2) = v655;
                *v650 = (v653 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
                v648 = v1315;
              }
              else
              {
                *(_BYTE *)v650 = 2 * v653;
                v655 = (char *)v650 + 1;
                v648 = v1315;
                if ( !v653 )
                  goto LABEL_881;
              }
              memcpy(v655, v654, v653);
LABEL_881:
              *((_BYTE *)v655 + v653) = 0;
              v651 = v1326;
LABEL_882:
              v657 = &v649[48 * v704];
              *((_QWORD *)v657 + 3) = 0LL;
              v658 = v657 + 24;
              v659 = v699 + 48 * v647;
              *((_QWORD *)v658 + 1) = 0LL;
              *((_QWORD *)v658 + 2) = 0LL;
              v661 = *(_BYTE *)(v659 + 24);
              v660 = v659 + 24;
              if ( (v661 & 1) == 0 )
              {
                *((_QWORD *)v658 + 2) = *(_QWORD *)(v660 + 16);
                *(_OWORD *)v658 = *(_OWORD *)v660;
LABEL_891:
                v669 = *(void ***)(v698 - 32);
                v668 = *(void ***)(v698 - 24);
                v670 = v650 + 6;
                if ( v668 == v669 )
                {
                  v672 = *(void ***)(v698 - 32);
                }
                else
                {
                  do
                  {
                    *(v650 - 4) = (size_t)*(v668 - 4);
                    *((_OWORD *)v650 - 3) = *((_OWORD *)v668 - 3);
                    v671 = (size_t)*(v668 - 1);
                    *(v668 - 5) = 0LL;
                    *(v668 - 4) = 0LL;
                    *(v668 - 6) = 0LL;
                    *(v650 - 1) = v671;
                    *(_OWORD *)(v650 - 3) = *(_OWORD *)(v668 - 3);
                    *(v668 - 2) = 0LL;
                    *(v668 - 1) = 0LL;
                    *(v668 - 3) = 0LL;
                    v668 -= 6;
                    v650 -= 6;
                  }
                  while ( v669 != v668 );
                  v672 = *(void ***)(v698 - 32);
                  v669 = *(void ***)(v698 - 24);
                }
                v673 = *(_QWORD *)(v698 - 16);
                *(_QWORD *)(v698 - 32) = v650;
                *(_QWORD *)(v698 - 24) = v670;
                *(_QWORD *)(v698 - 16) = v651;
                v243 = (__int64 *)a3;
                if ( v669 != v672 )
                {
                  do
                  {
                    if ( (*(_BYTE *)(v669 - 3) & 1) != 0 )
                      free(*(v669 - 1));
                    v674 = v669 - 6;
                    if ( (*(_BYTE *)(v669 - 6) & 1) != 0 )
                      free(*(v669 - 4));
                    v669 -= 6;
                  }
                  while ( v672 != v674 );
                }
                if ( v672 )
                {
                  v675 = *(_QWORD *)(v698 - 8);
                  if ( v675 + 4096 < (unsigned __int64)v672 || v675 > (unsigned __int64)v672 )
                  {
                    free(v672);
                  }
                  else if ( *(_QWORD *)(v675 + 4096) == v673 )
                  {
                    *(_QWORD *)(v675 + 4096) = v672;
                  }
                }
                goto LABEL_963;
              }
              v662 = v699 + 48 * v647;
              v663 = *(_QWORD *)(v662 + 32);
              if ( v663 >= 0xFFFFFFFFFFFFFFF0LL )
                abort();
              v664 = *(const void **)(v662 + 40);
              if ( v663 >= 0x17 )
              {
                v666 = malloc((v663 + 16) & 0xFFFFFFFFFFFFFFF0LL);
                v648 = v1315;
                v667 = &v649[48 * v704];
                *((_QWORD *)v667 + 4) = v663;
                *((_QWORD *)v667 + 5) = v666;
                *(_QWORD *)v658 = (v663 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
                v665 = v666;
              }
              else
              {
                *v658 = 2 * v663;
                v665 = v658 + 1;
                if ( !v663 )
                  goto LABEL_890;
              }
              memcpy(v665, v664, v663);
LABEL_890:
              *((_BYTE *)v665 + v663) = 0;
              v651 = v1326;
              goto LABEL_891;
            }
            v701[1] = 0LL;
            v701[2] = 0LL;
            *v701 = 0LL;
            if ( (*(_BYTE *)v702 & 1) == 0 )
            {
              v701[2] = *(_QWORD *)(v702 + 16);
              *(_OWORD *)v701 = *(_OWORD *)v702;
              goto LABEL_953;
            }
            v710 = v699 + 48 * v647;
            v711 = *(_QWORD *)(v710 + 8);
            if ( v711 >= 0xFFFFFFFFFFFFFFF0LL )
              goto LABEL_1805;
            v712 = *(const void **)(v710 + 16);
            if ( v711 >= 0x17 )
            {
              v713 = malloc((v711 + 16) & 0xFFFFFFFFFFFFFFF0LL);
              v701[2] = (size_t)v713;
              v243 = (__int64 *)a3;
              *v701 = (v711 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
              v701[1] = v711;
            }
            else
            {
              *(_BYTE *)v701 = 2 * v711;
              v713 = (char *)v701 + 1;
              if ( !v711 )
                goto LABEL_952;
            }
            memcpy(v713, v712, v711);
LABEL_952:
            *((_BYTE *)v713 + v711) = 0;
LABEL_953:
            v701[3] = 0LL;
            v714 = v701 + 3;
            v715 = v699 + 48 * v647;
            v701[4] = 0LL;
            v701[5] = 0LL;
            v717 = *(_BYTE *)(v715 + 24);
            v716 = v715 + 24;
            if ( (v717 & 1) != 0 )
            {
              v718 = v699 + 48 * v647;
              v719 = *(_QWORD *)(v718 + 32);
              if ( v719 >= 0xFFFFFFFFFFFFFFF0LL )
                abort();
              v720 = *(const void **)(v718 + 40);
              if ( v719 >= 0x17 )
              {
                v721 = malloc((v719 + 16) & 0xFFFFFFFFFFFFFFF0LL);
                v701[5] = (size_t)v721;
                v243 = (__int64 *)a3;
                v701[3] = (v719 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
                v701[4] = v719;
              }
              else
              {
                *v714 = 2 * v719;
                v721 = (char *)v701 + 25;
                if ( !v719 )
                  goto LABEL_961;
              }
              memcpy(v721, v720, v719);
LABEL_961:
              *((_BYTE *)v721 + v719) = 0;
              goto LABEL_962;
            }
            v701[5] = *(_QWORD *)(v716 + 16);
            *(_OWORD *)v714 = *(_OWORD *)v716;
LABEL_962:
            *(_QWORD *)(v698 - 24) += 48LL;
LABEL_963:
            if ( ++v647 >= v648 )
              return v1307;
          }
        }
        v289 = *(_QWORD *)(a3 + 32);
        v290 = ((__int64)v238 - v289) >> 5;
        if ( (unsigned __int64)(v290 + 1) >> 59 )
          goto LABEL_1805;
        v291 = v239 - v289;
        if ( (unsigned __int64)(v291 >> 5) > 0x3FFFFFFFFFFFFFELL )
        {
          v293 = 0x7FFFFFFFFFFFFFFLL;
        }
        else
        {
          v292 = v291 >> 4;
          if ( v292 >= v290 + 1 )
            v293 = v292;
          else
            v293 = v290 + 1;
          if ( !v293 )
          {
            v294 = 0LL;
LABEL_432:
            v358 = &v294[32 * v290];
            *(_QWORD *)v358 = 0LL;
            *((_QWORD *)v358 + 1) = 0LL;
            *((_QWORD *)v358 + 2) = 0LL;
            *((_QWORD *)v358 + 3) = v242;
            v360 = *(void ***)(a3 + 32);
            v359 = *(void ***)(a3 + 40);
            v361 = &v294[32 * v293];
            v362 = v358 + 32;
            if ( v359 == v360 )
            {
              v364 = *(void ***)(a3 + 32);
            }
            else
            {
              do
              {
                *((_QWORD *)v358 - 3) = 0LL;
                *((_QWORD *)v358 - 2) = 0LL;
                *((_QWORD *)v358 - 4) = 0LL;
                *((_QWORD *)v358 - 1) = *(v359 - 1);
                v363 = *((_OWORD *)v359 - 2);
                v359 -= 4;
                *((_OWORD *)v358 - 2) = v363;
                *((_QWORD *)v358 - 2) = v359[2];
                v358 -= 32;
                v359[1] = 0LL;
                v359[2] = 0LL;
                *v359 = 0LL;
              }
              while ( v360 != v359 );
              v364 = *(void ***)(a3 + 32);
              v360 = *(void ***)(a3 + 40);
            }
            v390 = *(_QWORD *)(a3 + 48);
            *(_QWORD *)(a3 + 32) = v358;
            *(_QWORD *)(a3 + 40) = v362;
            *(_QWORD *)(a3 + 48) = v361;
            while ( v364 != v360 )
            {
              v360 -= 4;
              sub_9D32C(v360);
            }
            if ( v364 )
            {
              v391 = *(_QWORD *)(a3 + 56);
              if ( v391 + 4096 < (unsigned __int64)v364 || v391 > (unsigned __int64)v364 )
              {
                free(v364);
              }
              else if ( *(_QWORD *)(v391 + 4096) == v390 )
              {
                *(_QWORD *)(v391 + 4096) = v364;
              }
            }
            goto LABEL_869;
          }
        }
        v319 = *(_QWORD *)(a3 + 56);
        v294 = *(char **)(v319 + 4096);
        if ( v319 + 4096 - (__int64)v294 >= (unsigned __int64)(32 * v293) )
          *(_QWORD *)(v319 + 4096) = &v294[32 * v293];
        else
          v294 = (char *)malloc(32 * v293);
        goto LABEL_432;
      case 'S':
        if ( v4 + 1 != v3 && v4[1] == 116 )
        {
          v24 = sub_9AA00(v4, v3, a3, 0LL);
          if ( (unsigned __int8 *)v24 == v4 )
            return v4;
          v232 = *(_QWORD *)(a3 + 8);
          v14 = (__int64)v4;
          if ( *(_QWORD *)a3 == v232 )
            return (unsigned __int8 *)v14;
          *(_QWORD *)&v1350 = *(_QWORD *)(a3 + 24);
          sub_9D15C((size_t **)v1338, v232 - 48, (__int64 *)&v1350);
          v233 = *(_QWORD *)(a3 + 40);
          v234 = *(_QWORD *)(a3 + 48);
          if ( v233 < v234 )
          {
            *(_QWORD *)(v233 + 24) = v1340;
            *(_OWORD *)v233 = *(_OWORD *)v1338;
            *(_QWORD *)(v233 + 16) = p;
            v1338[1] = 0LL;
            p = 0LL;
            v1338[0] = 0LL;
            *(_QWORD *)(a3 + 40) += 32LL;
            v178 = (void **)v1338[0];
            if ( !v1338[0] )
              return (unsigned __int8 *)v24;
LABEL_1299:
            v958 = (void **)v1338[1];
            if ( v1338[1] != v178 )
            {
              do
              {
                if ( (*(_BYTE *)(v958 - 3) & 1) != 0 )
                  free(*(v958 - 1));
                v959 = v958 - 6;
                if ( (*(_BYTE *)(v958 - 6) & 1) != 0 )
                  free(*(v958 - 4));
                v958 -= 6;
              }
              while ( v178 != v959 );
            }
            goto LABEL_1508;
          }
          v750 = *(_QWORD *)(a3 + 32);
          v751 = (__int64)(v233 - v750) >> 5;
          if ( (unsigned __int64)(v751 + 1) >> 59 )
            abort();
          v752 = v234 - v750;
          if ( (unsigned __int64)(v752 >> 5) > 0x3FFFFFFFFFFFFFELL )
          {
            v754 = 0x7FFFFFFFFFFFFFFLL;
          }
          else
          {
            v753 = v752 >> 4;
            if ( v753 >= v751 + 1 )
              v754 = v753;
            else
              v754 = v751 + 1;
            if ( !v754 )
            {
              v755 = 0LL;
              goto LABEL_1204;
            }
          }
          v882 = *(_QWORD *)(a3 + 56);
          v755 = *(char **)(v882 + 4096);
          if ( v882 + 4096 - (__int64)v755 >= (unsigned __int64)(32 * v754) )
            *(_QWORD *)(v882 + 4096) = &v755[32 * v754];
          else
            v755 = (char *)malloc(32 * v754);
LABEL_1204:
          v900 = &v755[32 * v751];
          *((_QWORD *)v900 + 1) = 0LL;
          *((_QWORD *)v900 + 2) = 0LL;
          v901 = v900 + 32;
          *((_QWORD *)v900 + 3) = v1340;
          *(_OWORD *)v900 = *(_OWORD *)v1338;
          *((_QWORD *)v900 + 2) = p;
          v1338[1] = 0LL;
          p = 0LL;
          v1338[0] = 0LL;
          v903 = *(void ***)(a3 + 32);
          v902 = *(void ***)(a3 + 40);
          v904 = &v755[32 * v754];
          if ( v902 == v903 )
          {
            v906 = *(void ***)(a3 + 32);
          }
          else
          {
            do
            {
              *((_QWORD *)v900 - 3) = 0LL;
              *((_QWORD *)v900 - 2) = 0LL;
              *((_QWORD *)v900 - 4) = 0LL;
              *((_QWORD *)v900 - 1) = *(v902 - 1);
              v905 = *((_OWORD *)v902 - 2);
              v902 -= 4;
              *((_OWORD *)v900 - 2) = v905;
              *((_QWORD *)v900 - 2) = v902[2];
              v900 -= 32;
              v902[1] = 0LL;
              v902[2] = 0LL;
              *v902 = 0LL;
            }
            while ( v903 != v902 );
            v906 = *(void ***)(a3 + 32);
            v903 = *(void ***)(a3 + 40);
          }
          v908 = *(_QWORD *)(a3 + 48);
          *(_QWORD *)(a3 + 32) = v900;
          *(_QWORD *)(a3 + 40) = v901;
          *(_QWORD *)(a3 + 48) = v904;
          while ( v906 != v903 )
          {
            v903 -= 4;
            sub_9D32C(v903);
          }
          if ( v906 )
          {
            v909 = *(_QWORD *)(a3 + 56);
            if ( v909 + 4096 < (unsigned __int64)v906 || v909 > (unsigned __int64)v906 )
            {
              free(v906);
            }
            else if ( *(_QWORD *)(v909 + 4096) == v908 )
            {
              *(_QWORD *)(v909 + 4096) = v906;
              v178 = (void **)v1338[0];
              if ( !v1338[0] )
                return (unsigned __int8 *)v24;
              goto LABEL_1299;
            }
          }
          v178 = (void **)v1338[0];
          if ( !v1338[0] )
            return (unsigned __int8 *)v24;
          goto LABEL_1299;
        }
        v244 = sub_9E1F8(v4, v3, (void **)a3);
        v126 = v244;
        v14 = (__int64)v4;
        if ( v244 == v4 )
          return (unsigned __int8 *)v14;
        if ( !*(_BYTE *)(a3 + 111) )
          return v126;
        v4 = sub_9D3DC(v244, v3, a3);
        if ( v4 == v126 )
          return v126;
        v245 = *(_QWORD *)(a3 + 8);
        v14 = (__int64)v126;
        if ( 0xAAAAAAAAAAAAAAABLL * ((v245 - *(_QWORD *)a3) >> 4) < 2 )
          return (unsigned __int8 *)v14;
        v246 = *(unsigned __int8 *)(v245 - 24);
        v247 = (v246 & 1) == 0;
        v248 = v246 >> 1;
        if ( v247 )
          v249 = (void *)(v245 - 23);
        else
          v249 = *(void **)(v245 - 8);
        if ( v247 )
          v250 = v248;
        else
          v250 = *(_QWORD *)(v245 - 16);
        sub_9CFD0((size_t *)(v245 - 48), v249, v250);
        v1351 = *(char **)(v245 - 32);
        v1350 = *(_OWORD *)(v245 - 48);
        *(_QWORD *)(v245 - 40) = 0LL;
        *(_QWORD *)(v245 - 32) = 0LL;
        *(_QWORD *)(v245 - 48) = 0LL;
        v251 = *(_QWORD *)(a3 + 8);
        v252 = (_BYTE *)(v251 - 48);
        if ( (*(_BYTE *)(v251 - 24) & 1) != 0 )
          free(*(void **)(v251 - 8));
        if ( (*v252 & 1) != 0 )
          free(*(void **)(v251 - 32));
        *(_QWORD *)(a3 + 8) = v252;
        if ( (v1350 & 1) != 0 )
          v253 = v1351;
        else
          v253 = (char *)&v1350 + 1;
        if ( (v1350 & 1) != 0 )
          v254 = *((_QWORD *)&v1350 + 1);
        else
          v254 = (unsigned __int64)(unsigned __int8)v1350 >> 1;
        sub_9CFD0((size_t *)(v251 - 96), v253, v254);
        v255 = *(_QWORD *)(a3 + 8) - 48LL;
        *(_QWORD *)&v1354 = *(_QWORD *)(a3 + 24);
        sub_9D15C((size_t **)v1338, v255, (__int64 *)&v1354);
        v256 = *(_QWORD *)(a3 + 40);
        v257 = *(_QWORD *)(a3 + 48);
        if ( v256 < v257 )
        {
          *(_QWORD *)(v256 + 24) = v1340;
          *(_OWORD *)v256 = *(_OWORD *)v1338;
          *(_QWORD *)(v256 + 16) = p;
          v1338[1] = 0LL;
          p = 0LL;
          v1338[0] = 0LL;
          *(_QWORD *)(a3 + 40) += 32LL;
          v258 = (void **)v1338[0];
          if ( !v1338[0] )
            goto LABEL_1391;
          goto LABEL_1379;
        }
        v839 = *(_QWORD *)(a3 + 32);
        v840 = (__int64)(v256 - v839) >> 5;
        if ( (unsigned __int64)(v840 + 1) >> 59 )
          abort();
        v841 = v257 - v839;
        if ( (unsigned __int64)(v841 >> 5) > 0x3FFFFFFFFFFFFFELL )
        {
          v843 = 0x7FFFFFFFFFFFFFFLL;
        }
        else
        {
          v842 = v841 >> 4;
          if ( v842 >= v840 + 1 )
            v843 = v842;
          else
            v843 = v840 + 1;
          if ( !v843 )
          {
            v844 = 0LL;
            goto LABEL_1326;
          }
        }
        v949 = *(_QWORD *)(a3 + 56);
        v844 = *(char **)(v949 + 4096);
        if ( v949 + 4096 - (__int64)v844 >= (unsigned __int64)(32 * v843) )
          *(_QWORD *)(v949 + 4096) = &v844[32 * v843];
        else
          v844 = (char *)malloc(32 * v843);
LABEL_1326:
        v963 = &v844[32 * v840];
        *((_QWORD *)v963 + 1) = 0LL;
        *((_QWORD *)v963 + 2) = 0LL;
        v964 = v963 + 32;
        *((_QWORD *)v963 + 3) = v1340;
        *(_OWORD *)v963 = *(_OWORD *)v1338;
        *((_QWORD *)v963 + 2) = p;
        v1338[1] = 0LL;
        p = 0LL;
        v1338[0] = 0LL;
        v966 = *(void ***)(a3 + 32);
        v965 = *(void ***)(a3 + 40);
        v967 = &v844[32 * v843];
        if ( v965 == v966 )
        {
          v969 = *(void ***)(a3 + 32);
        }
        else
        {
          do
          {
            *((_QWORD *)v963 - 3) = 0LL;
            *((_QWORD *)v963 - 2) = 0LL;
            *((_QWORD *)v963 - 4) = 0LL;
            *((_QWORD *)v963 - 1) = *(v965 - 1);
            v968 = *((_OWORD *)v965 - 2);
            v965 -= 4;
            *((_OWORD *)v963 - 2) = v968;
            *((_QWORD *)v963 - 2) = v965[2];
            v963 -= 32;
            v965[1] = 0LL;
            v965[2] = 0LL;
            *v965 = 0LL;
          }
          while ( v966 != v965 );
          v969 = *(void ***)(a3 + 32);
          v966 = *(void ***)(a3 + 40);
        }
        v982 = *(_QWORD *)(a3 + 48);
        *(_QWORD *)(a3 + 32) = v963;
        *(_QWORD *)(a3 + 40) = v964;
        *(_QWORD *)(a3 + 48) = v967;
        while ( v969 != v966 )
        {
          v966 -= 4;
          sub_9D32C(v966);
        }
        if ( v969 )
        {
          v983 = *(_QWORD *)(a3 + 56);
          if ( v983 + 4096 < (unsigned __int64)v969 || v983 > (unsigned __int64)v969 )
          {
            free(v969);
          }
          else if ( *(_QWORD *)(v983 + 4096) == v982 )
          {
            *(_QWORD *)(v983 + 4096) = v969;
            v258 = (void **)v1338[0];
            if ( !v1338[0] )
              goto LABEL_1391;
            goto LABEL_1379;
          }
        }
        v258 = (void **)v1338[0];
        if ( !v1338[0] )
          goto LABEL_1391;
LABEL_1379:
        v991 = (void **)v1338[1];
        if ( v1338[1] != v258 )
        {
          do
          {
            if ( (*(_BYTE *)(v991 - 3) & 1) != 0 )
              free(*(v991 - 1));
            v992 = v991 - 6;
            if ( (*(_BYTE *)(v991 - 6) & 1) != 0 )
              free(*(v991 - 4));
            v991 -= 6;
          }
          while ( v258 != v992 );
        }
        v887 = v1340;
        v1338[1] = v258;
        if ( (__int64)v1340 + 4096 >= (unsigned __int64)v258 && (unsigned __int64)v1340 <= (unsigned __int64)v258 )
          goto LABEL_1387;
        goto LABEL_1390;
      case 'T':
        v118 = *(void ***)a3;
        v119 = *(_QWORD *)(a3 + 8);
        v120 = sub_9F9E8(v4, v3, a3);
        v14 = (__int64)v4;
        if ( (unsigned __int8 *)v120 == v4 )
          return (unsigned __int8 *)v14;
        desta = v3;
        v121 = *(_QWORD **)(a3 + 40);
        v122 = *(_QWORD *)(a3 + 48);
        v123 = *(void ***)a3;
        v124 = *(_QWORD *)(a3 + 8);
        v125 = *(_QWORD *)(a3 + 24);
        if ( (unsigned __int64)v121 < v122 )
        {
          *v121 = 0LL;
          v121[1] = 0LL;
          v121[2] = 0LL;
          v121[3] = v125;
          *(_QWORD *)(a3 + 40) += 32LL;
          goto LABEL_501;
        }
        v259 = *(_QWORD *)(a3 + 32);
        v260 = ((__int64)v121 - v259) >> 5;
        if ( (unsigned __int64)(v260 + 1) >> 59 )
          goto LABEL_1805;
        v261 = v122 - v259;
        if ( (unsigned __int64)(v261 >> 5) > 0x3FFFFFFFFFFFFFELL )
        {
          v263 = 0x7FFFFFFFFFFFFFFLL;
        }
        else
        {
          v262 = v261 >> 4;
          if ( v262 >= v260 + 1 )
            v263 = v262;
          else
            v263 = v260 + 1;
          if ( !v263 )
          {
            v264 = 0LL;
LABEL_420:
            v336 = &v264[32 * v260];
            *(_QWORD *)v336 = 0LL;
            *((_QWORD *)v336 + 1) = 0LL;
            *((_QWORD *)v336 + 2) = 0LL;
            *((_QWORD *)v336 + 3) = v125;
            v337 = v336 + 32;
            v339 = *(void ***)(a3 + 32);
            v338 = *(void ***)(a3 + 40);
            v340 = &v264[32 * v263];
            if ( v338 == v339 )
            {
              v342 = (_QWORD *)a3;
              v343 = *(void ***)(a3 + 32);
            }
            else
            {
              do
              {
                *((_QWORD *)v336 - 3) = 0LL;
                *((_QWORD *)v336 - 2) = 0LL;
                *((_QWORD *)v336 - 4) = 0LL;
                *((_QWORD *)v336 - 1) = *(v338 - 1);
                v341 = *((_OWORD *)v338 - 2);
                v338 -= 4;
                *((_OWORD *)v336 - 2) = v341;
                *((_QWORD *)v336 - 2) = v338[2];
                v336 -= 32;
                v338[1] = 0LL;
                v338[2] = 0LL;
                *v338 = 0LL;
              }
              while ( v339 != v338 );
              v342 = (_QWORD *)a3;
              v343 = *(void ***)(a3 + 32);
              v339 = *(void ***)(a3 + 40);
            }
            v384 = v342[6];
            v342[4] = v336;
            v342[5] = v337;
            v342[6] = v340;
            while ( v343 != v339 )
            {
              v339 -= 4;
              sub_9D32C(v339);
            }
            if ( v343 )
            {
              v385 = *(_QWORD *)(a3 + 56);
              if ( v385 + 4096 < (unsigned __int64)v343 || v385 > (unsigned __int64)v343 )
              {
                free(v343);
              }
              else if ( *(_QWORD *)(v385 + 4096) == v384 )
              {
                *(_QWORD *)(v385 + 4096) = v343;
              }
            }
LABEL_501:
            v392 = v124 - (_QWORD)v123;
            v393 = desta;
            v1307 = (unsigned __int8 *)v120;
            v394 = 0xAAAAAAAAAAAAAAABLL * (v392 >> 4);
            v1312 = 0xAAAAAAAAAAAAAAABLL * ((v119 - (__int64)v118) >> 4);
            if ( v1312 < v394 )
            {
              for ( i = 0xAAAAAAAAAAAAAAABLL * ((v119 - (__int64)v118) >> 4); i < v394; ++i )
              {
                v425 = *(_QWORD *)(a3 + 40);
                v426 = *(void ***)a3;
                v428 = *(size_t **)(v425 - 24);
                v427 = *(size_t **)(v425 - 16);
                v429 = *(_QWORD *)a3 + 48 * i;
                if ( v428 == v427 )
                {
                  v430 = *(_QWORD *)(v425 - 32);
                  v431 = v394;
                  v432 = 0xAAAAAAAAAAAAAAABLL * (((__int64)v428 - v430) >> 4);
                  if ( v432 + 1 > 0x555555555555555LL )
                    goto LABEL_1805;
                  v433 = 0xAAAAAAAAAAAAAAABLL * (((__int64)v427 - v430) >> 4);
                  v434 = 0x555555555555555LL;
                  if ( v433 >= 0x2AAAAAAAAAAAAAALL
                    || ((v435 = 2 * v433, v435 >= v432 + 1) ? (v434 = v435) : (v434 = v432 + 1), v434) )
                  {
                    v436 = *(_QWORD *)(v425 - 8);
                    v437 = 48 * v434;
                    v396 = *(char **)(v436 + 4096);
                    if ( v436 + 4096 - (__int64)v396 >= (unsigned __int64)(48 * v434) )
                      *(_QWORD *)(v436 + 4096) = &v396[v437];
                    else
                      v396 = (char *)malloc(v437);
                  }
                  else
                  {
                    v396 = 0LL;
                  }
                  v397 = (size_t *)&v396[48 * v432];
                  v397[1] = 0LL;
                  v397[2] = 0LL;
                  *v397 = 0LL;
                  v398 = &v396[48 * v434];
                  v1324 = v398;
                  if ( (*(_BYTE *)v429 & 1) == 0 )
                  {
                    v397[2] = *(_QWORD *)(v429 + 16);
                    *(_OWORD *)v397 = *(_OWORD *)v429;
                    goto LABEL_514;
                  }
                  v399 = &v426[6 * i];
                  v400 = (size_t)v399[1];
                  if ( v400 >= 0xFFFFFFFFFFFFFFF0LL )
                    abort();
                  v401 = v399[2];
                  if ( v400 >= 0x17 )
                  {
                    v403 = v399[2];
                    v404 = malloc((v400 + 16) & 0xFFFFFFFFFFFFFFF0LL);
                    v393 = desta;
                    v401 = v403;
                    v402 = v404;
                    v405 = &v396[48 * v432];
                    *((_QWORD *)v405 + 1) = v400;
                    *((_QWORD *)v405 + 2) = v404;
                    *v397 = (v400 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
                  }
                  else
                  {
                    *(_BYTE *)v397 = 2 * v400;
                    v402 = (char *)v397 + 1;
                    if ( !v400 )
                      goto LABEL_513;
                  }
                  memcpy(v402, v401, v400);
LABEL_513:
                  *((_BYTE *)v402 + v400) = 0;
                  v398 = v1324;
LABEL_514:
                  v406 = &v396[48 * v432];
                  *((_QWORD *)v406 + 3) = 0LL;
                  v407 = v406 + 24;
                  v408 = &v426[6 * i];
                  *((_QWORD *)v407 + 1) = 0LL;
                  *((_QWORD *)v407 + 2) = 0LL;
                  v410 = *((_BYTE *)v408 + 24);
                  v409 = v408 + 3;
                  if ( (v410 & 1) == 0 )
                  {
                    v394 = v431;
                    *((_QWORD *)v407 + 2) = v409[2];
                    *(_OWORD *)v407 = *(_OWORD *)v409;
LABEL_523:
                    v418 = *(void ***)(v425 - 32);
                    v417 = *(void ***)(v425 - 24);
                    v419 = v397 + 6;
                    if ( v417 == v418 )
                    {
                      v421 = *(void ***)(v425 - 32);
                    }
                    else
                    {
                      do
                      {
                        *(v397 - 4) = (size_t)*(v417 - 4);
                        *((_OWORD *)v397 - 3) = *((_OWORD *)v417 - 3);
                        v420 = (size_t)*(v417 - 1);
                        *(v417 - 5) = 0LL;
                        *(v417 - 4) = 0LL;
                        *(v417 - 6) = 0LL;
                        *(v397 - 1) = v420;
                        *(_OWORD *)(v397 - 3) = *(_OWORD *)(v417 - 3);
                        *(v417 - 2) = 0LL;
                        *(v417 - 1) = 0LL;
                        *(v417 - 3) = 0LL;
                        v417 -= 6;
                        v397 -= 6;
                      }
                      while ( v418 != v417 );
                      v421 = *(void ***)(v425 - 32);
                      v418 = *(void ***)(v425 - 24);
                    }
                    v422 = *(_QWORD *)(v425 - 16);
                    *(_QWORD *)(v425 - 32) = v397;
                    *(_QWORD *)(v425 - 24) = v419;
                    *(_QWORD *)(v425 - 16) = v398;
                    if ( v418 != v421 )
                    {
                      do
                      {
                        if ( (*(_BYTE *)(v418 - 3) & 1) != 0 )
                          free(*(v418 - 1));
                        v423 = v418 - 6;
                        if ( (*(_BYTE *)(v418 - 6) & 1) != 0 )
                          free(*(v418 - 4));
                        v418 -= 6;
                      }
                      while ( v421 != v423 );
                    }
                    if ( v421 )
                    {
                      v424 = *(_QWORD *)(v425 - 8);
                      if ( v424 + 4096 < (unsigned __int64)v421 || v424 > (unsigned __int64)v421 )
                      {
                        free(v421);
                      }
                      else if ( *(_QWORD *)(v424 + 4096) == v422 )
                      {
                        *(_QWORD *)(v424 + 4096) = v421;
                      }
                    }
                    continue;
                  }
                  v411 = &v426[6 * i];
                  v412 = (size_t)v411[4];
                  if ( v412 >= 0xFFFFFFFFFFFFFFF0LL )
                    abort();
                  v413 = v411[5];
                  if ( v412 >= 0x17 )
                  {
                    v415 = malloc((v412 + 16) & 0xFFFFFFFFFFFFFFF0LL);
                    v416 = &v396[48 * v432];
                    *((_QWORD *)v416 + 4) = v412;
                    *((_QWORD *)v416 + 5) = v415;
                    *(_QWORD *)v407 = (v412 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
                    v414 = v415;
                    v394 = v431;
                  }
                  else
                  {
                    *v407 = 2 * v412;
                    v414 = v407 + 1;
                    v394 = v431;
                    if ( !v412 )
                      goto LABEL_522;
                  }
                  memcpy(v414, v413, v412);
LABEL_522:
                  *((_BYTE *)v414 + v412) = 0;
                  v398 = v1324;
                  v393 = desta;
                  goto LABEL_523;
                }
                v428[1] = 0LL;
                v428[2] = 0LL;
                *v428 = 0LL;
                if ( (*(_BYTE *)v429 & 1) == 0 )
                {
                  v428[2] = *(_QWORD *)(v429 + 16);
                  *(_OWORD *)v428 = *(_OWORD *)v429;
                  goto LABEL_557;
                }
                v438 = &v426[6 * i];
                v439 = (size_t)v438[1];
                if ( v439 >= 0xFFFFFFFFFFFFFFF0LL )
                  goto LABEL_1805;
                v440 = v438[2];
                if ( v439 >= 0x17 )
                {
                  v441 = malloc((v439 + 16) & 0xFFFFFFFFFFFFFFF0LL);
                  v428[1] = v439;
                  v428[2] = (size_t)v441;
                  *v428 = (v439 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
                }
                else
                {
                  *(_BYTE *)v428 = 2 * v439;
                  v441 = (char *)v428 + 1;
                  if ( !v439 )
                    goto LABEL_556;
                }
                memcpy(v441, v440, v439);
LABEL_556:
                *((_BYTE *)v441 + v439) = 0;
                v393 = desta;
LABEL_557:
                v428[3] = 0LL;
                v442 = v428 + 3;
                v443 = &v426[6 * i];
                v428[4] = 0LL;
                v428[5] = 0LL;
                v445 = *((_BYTE *)v443 + 24);
                v444 = v443 + 3;
                if ( (v445 & 1) != 0 )
                {
                  v446 = &v426[6 * i];
                  v447 = (size_t)v446[4];
                  if ( v447 >= 0xFFFFFFFFFFFFFFF0LL )
                    abort();
                  v448 = v446[5];
                  if ( v447 >= 0x17 )
                  {
                    v449 = malloc((v447 + 16) & 0xFFFFFFFFFFFFFFF0LL);
                    v428[4] = v447;
                    v428[5] = (size_t)v449;
                    v428[3] = (v447 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
                  }
                  else
                  {
                    *v442 = 2 * v447;
                    v449 = (char *)v428 + 25;
                    if ( !v447 )
                      goto LABEL_565;
                  }
                  memcpy(v449, v448, v447);
LABEL_565:
                  *((_BYTE *)v449 + v447) = 0;
                  v393 = desta;
                  goto LABEL_566;
                }
                v428[5] = (size_t)v444[2];
                *(_OWORD *)v442 = *(_OWORD *)v444;
LABEL_566:
                *(_QWORD *)(v425 - 24) += 48LL;
              }
            }
            if ( v394 != v1312 + 1 )
              return v1307;
            v14 = (__int64)v1307;
            if ( !*(_BYTE *)(a3 + 111) )
              return (unsigned __int8 *)v14;
            v4 = sub_9D3DC(v1307, v393, a3);
            if ( v4 == v1307 )
              return (unsigned __int8 *)v14;
            v450 = *(_QWORD *)(a3 + 8);
            v451 = *(unsigned __int8 *)(v450 - 24);
            v452 = (v451 & 1) == 0;
            v453 = v451 >> 1;
            if ( v452 )
              v454 = (void *)(v450 - 23);
            else
              v454 = *(void **)(v450 - 8);
            if ( v452 )
              v455 = v453;
            else
              v455 = *(_QWORD *)(v450 - 16);
            sub_9CFD0((size_t *)(v450 - 48), v454, v455);
            v1351 = *(char **)(v450 - 32);
            v1350 = *(_OWORD *)(v450 - 48);
            *(_QWORD *)(v450 - 40) = 0LL;
            *(_QWORD *)(v450 - 32) = 0LL;
            *(_QWORD *)(v450 - 48) = 0LL;
            v456 = *(_QWORD *)(a3 + 8);
            v457 = (_BYTE *)(v456 - 48);
            if ( (*(_BYTE *)(v456 - 24) & 1) != 0 )
              free(*(void **)(v456 - 8));
            if ( (*v457 & 1) != 0 )
              free(*(void **)(v456 - 32));
            *(_QWORD *)(a3 + 8) = v457;
            if ( (v1350 & 1) != 0 )
              v458 = v1351;
            else
              v458 = (char *)&v1350 + 1;
            if ( (v1350 & 1) != 0 )
              v459 = *((_QWORD *)&v1350 + 1);
            else
              v459 = (unsigned __int64)(unsigned __int8)v1350 >> 1;
            sub_9CFD0((size_t *)(v456 - 96), v458, v459);
            v460 = *(_QWORD *)(a3 + 8) - 48LL;
            *(_QWORD *)&v1354 = *(_QWORD *)(a3 + 24);
            sub_9D15C((size_t **)v1338, v460, (__int64 *)&v1354);
            v461 = *(_QWORD *)(a3 + 40);
            v462 = *(_QWORD *)(a3 + 48);
            if ( v461 < v462 )
            {
              *(_QWORD *)(v461 + 24) = v1340;
              *(_OWORD *)v461 = *(_OWORD *)v1338;
              *(_QWORD *)(v461 + 16) = p;
              v1338[1] = 0LL;
              p = 0LL;
              v1338[0] = 0LL;
              *(_QWORD *)(a3 + 40) += 32LL;
              v258 = (void **)v1338[0];
              if ( !v1338[0] )
                goto LABEL_1391;
              goto LABEL_1180;
            }
            v722 = *(_QWORD *)(a3 + 32);
            v723 = (__int64)(v461 - v722) >> 5;
            if ( (unsigned __int64)(v723 + 1) >> 59 )
              abort();
            v724 = v462 - v722;
            if ( (unsigned __int64)(v724 >> 5) > 0x3FFFFFFFFFFFFFELL )
            {
              v726 = 0x7FFFFFFFFFFFFFFLL;
            }
            else
            {
              v725 = v724 >> 4;
              if ( v725 >= v723 + 1 )
                v726 = v725;
              else
                v726 = v723 + 1;
              if ( !v726 )
              {
                v727 = 0LL;
                goto LABEL_1120;
              }
            }
            v838 = *(_QWORD *)(a3 + 56);
            v727 = *(char **)(v838 + 4096);
            if ( v838 + 4096 - (__int64)v727 >= (unsigned __int64)(32 * v726) )
              *(_QWORD *)(v838 + 4096) = &v727[32 * v726];
            else
              v727 = (char *)malloc(32 * v726);
LABEL_1120:
            v845 = &v727[32 * v723];
            *((_QWORD *)v845 + 1) = 0LL;
            *((_QWORD *)v845 + 2) = 0LL;
            v846 = v845 + 32;
            *((_QWORD *)v845 + 3) = v1340;
            *(_OWORD *)v845 = *(_OWORD *)v1338;
            *((_QWORD *)v845 + 2) = p;
            v1338[1] = 0LL;
            p = 0LL;
            v1338[0] = 0LL;
            v848 = *(void ***)(a3 + 32);
            v847 = *(void ***)(a3 + 40);
            v849 = &v727[32 * v726];
            if ( v847 == v848 )
            {
              v851 = *(void ***)(a3 + 32);
            }
            else
            {
              do
              {
                *((_QWORD *)v845 - 3) = 0LL;
                *((_QWORD *)v845 - 2) = 0LL;
                *((_QWORD *)v845 - 4) = 0LL;
                *((_QWORD *)v845 - 1) = *(v847 - 1);
                v850 = *((_OWORD *)v847 - 2);
                v847 -= 4;
                *((_OWORD *)v845 - 2) = v850;
                *((_QWORD *)v845 - 2) = v847[2];
                v845 -= 32;
                v847[1] = 0LL;
                v847[2] = 0LL;
                *v847 = 0LL;
              }
              while ( v848 != v847 );
              v851 = *(void ***)(a3 + 32);
              v848 = *(void ***)(a3 + 40);
            }
            v858 = *(_QWORD *)(a3 + 48);
            *(_QWORD *)(a3 + 32) = v845;
            *(_QWORD *)(a3 + 40) = v846;
            *(_QWORD *)(a3 + 48) = v849;
            while ( v851 != v848 )
            {
              v848 -= 4;
              sub_9D32C(v848);
            }
            if ( v851 )
            {
              v859 = *(_QWORD *)(a3 + 56);
              if ( v859 + 4096 < (unsigned __int64)v851 || v859 > (unsigned __int64)v851 )
              {
                free(v851);
              }
              else if ( *(_QWORD *)(v859 + 4096) == v858 )
              {
                *(_QWORD *)(v859 + 4096) = v851;
                v258 = (void **)v1338[0];
                if ( !v1338[0] )
                  goto LABEL_1391;
LABEL_1180:
                v885 = (void **)v1338[1];
                if ( v1338[1] != v258 )
                {
                  do
                  {
                    if ( (*(_BYTE *)(v885 - 3) & 1) != 0 )
                      free(*(v885 - 1));
                    v886 = v885 - 6;
                    if ( (*(_BYTE *)(v885 - 6) & 1) != 0 )
                      free(*(v885 - 4));
                    v885 -= 6;
                  }
                  while ( v258 != v886 );
                }
                v887 = v1340;
                v1338[1] = v258;
                if ( (__int64)v1340 + 4096 >= (unsigned __int64)v258
                  && (unsigned __int64)v1340 <= (unsigned __int64)v258 )
                {
LABEL_1387:
                  if ( *(void **)(v887 + 4096) == p )
                  {
                    *(_QWORD *)(v887 + 4096) = v258;
                    if ( (v1350 & 1) == 0 )
                      return v4;
                    goto LABEL_1392;
                  }
LABEL_1391:
                  if ( (v1350 & 1) == 0 )
                    return v4;
LABEL_1392:
                  free(v1351);
                  return v4;
                }
LABEL_1390:
                free(v258);
                goto LABEL_1391;
              }
            }
            v258 = (void **)v1338[0];
            if ( !v1338[0] )
              goto LABEL_1391;
            goto LABEL_1180;
          }
        }
        v316 = *(_QWORD *)(a3 + 56);
        v264 = *(char **)(v316 + 4096);
        if ( v316 + 4096 - (__int64)v264 >= (unsigned __int64)(32 * v263) )
          *(_QWORD *)(v316 + 4096) = &v264[32 * v263];
        else
          v264 = (char *)malloc(32 * v263);
        goto LABEL_420;
      case 'U':
        if ( v4 + 1 == v3 )
          return v4;
        v158 = sub_B190C(v4 + 1, v3, (void **)a3);
        v159 = v158;
        if ( v158 == v4 + 1 )
          return v4;
        v24 = sub_925FC(v158, v3, a3);
        v160 = (_QWORD *)a3;
        if ( (unsigned __int8 *)v24 == v159 )
          return v4;
        v161 = *(_QWORD *)(a3 + 8);
        v14 = (__int64)v4;
        if ( 0xAAAAAAAAAAAAAAABLL * ((v161 - *(_QWORD *)a3) >> 4) < 2 )
          return (unsigned __int8 *)v14;
        v162 = *(unsigned __int8 *)(v161 - 24);
        v163 = (v162 & 1) == 0;
        v164 = v162 >> 1;
        if ( v163 )
          v165 = (void *)(v161 - 23);
        else
          v165 = *(void **)(v161 - 8);
        if ( v163 )
          v166 = v164;
        else
          v166 = *(_QWORD *)(v161 - 16);
        sub_9CFD0((size_t *)(v161 - 48), v165, v166);
        v1351 = *(char **)(v161 - 32);
        v1350 = *(_OWORD *)(v161 - 48);
        *(_QWORD *)(v161 - 40) = 0LL;
        *(_QWORD *)(v161 - 32) = 0LL;
        *(_QWORD *)(v161 - 48) = 0LL;
        v167 = *(_QWORD *)(a3 + 8);
        v168 = (_BYTE *)(v167 - 48);
        if ( (*(_BYTE *)(v167 - 24) & 1) != 0 )
          free(*(void **)(v167 - 8));
        if ( (*v168 & 1) != 0 )
          free(*(void **)(v167 - 32));
        *(_QWORD *)(a3 + 8) = v168;
        v1338[1] = 0LL;
        p = 0LL;
        v1338[0] = 0LL;
        v169 = *(unsigned __int8 *)(v167 - 96);
        v170 = (v169 & 1) == 0;
        if ( (v169 & 1) != 0 )
          v171 = *(_QWORD *)(v167 - 88);
        else
          v171 = v169 >> 1;
        if ( v170 )
          v172 = (const void *)(v167 - 95);
        else
          v172 = *(const void **)(v167 - 80);
        if ( v171 >= 9 )
          v173 = 9LL;
        else
          v173 = v171;
        LOBYTE(v1338[0]) = 2 * v173;
        if ( v173 )
          memcpy((char *)v1338 + 1, v172, v173);
        *((_BYTE *)v1338 + v173 + 1) = 0;
        v756 = (char *)v1338[1];
        if ( ((__int64)v1338[0] & 1) == 0 )
          v756 = (char *)((unsigned __int64)LOBYTE(v1338[0]) >> 1);
        if ( v756 == byte_9 )
        {
          if ( ((__int64)v1338[0] & 1) != 0 )
            v757 = (char *)p;
          else
            v757 = (char *)v1338 + 1;
          v758 = memcmp(v757, "objcproto", 9uLL) != 0;
          if ( ((__int64)v1338[0] & 1) != 0 )
            goto LABEL_1017;
        }
        else
        {
          v758 = 1;
          if ( ((__int64)v1338[0] & 1) != 0 )
LABEL_1017:
            free(p);
        }
        if ( v758 )
        {
          sub_AB28C((size_t *)&v1354, " ", (unsigned __int8 *)&v1350);
          v759 = *(_QWORD *)(a3 + 8);
          v760 = *(unsigned __int8 *)(v759 - 24);
          v761 = *(_QWORD *)(v759 - 16);
          v762 = *(void **)(v759 - 8);
          v763 = (size_t *)(v759 - 48);
          v764 = (void *)(v759 - 23);
          v765 = (v760 & 1) == 0;
          v766 = v760 >> 1;
          if ( v765 )
            v767 = v764;
          else
            v767 = v762;
          if ( v765 )
            v768 = v766;
          else
            v768 = v761;
          v769 = sub_9CFD0(v763, v767, v768);
          v1349 = (char *)v769[2];
          v1348 = *(_OWORD *)v769;
          v769[1] = 0LL;
          v769[2] = 0LL;
          *v769 = 0LL;
          v770 = v1348;
          v771 = v1349;
          if ( (v1348 & 1) != 0 )
            v772 = v1349;
          else
            v772 = (char *)&v1348 + 1;
          if ( (v1348 & 1) != 0 )
            v773 = *((_QWORD *)&v1348 + 1);
          else
            v773 = (unsigned __int64)(unsigned __int8)v1348 >> 1;
          sub_9CFD0((size_t *)&v1354, v772, v773);
          v774 = *(void **)((char *)&v1354 + 1);
          v775 = *((_QWORD *)&v1354 + 1);
          v776 = v1355;
          v777 = v1354;
          v1355 = 0LL;
          v1354 = 0uLL;
          *(_QWORD *)&v1345[23] = v775;
          v1345[23] = HIBYTE(v774);
          LOBYTE(v1338[0]) = v777;
          v778 = v774;
          v779 = *(void **)&v1345[23];
          memset(&v1345[16], 0, 15);
          *(void **)((char *)v1338 + 1) = v778;
          v1338[1] = v779;
          p = v776;
          v1341 = 0LL;
          v1340 = 0uLL;
          sub_A7174((unsigned __int64 *)(*(_QWORD *)(a3 + 8) - 48LL), (__int64)v1338);
          if ( (v1340 & 1) != 0 )
          {
            free(v1341);
            if ( ((__int64)v1338[0] & 1) == 0 )
            {
LABEL_1033:
              if ( (v770 & 1) == 0 )
                goto LABEL_1658;
              goto LABEL_1177;
            }
          }
          else if ( ((__int64)v1338[0] & 1) == 0 )
          {
            goto LABEL_1033;
          }
          free(p);
          if ( (v770 & 1) == 0 )
            goto LABEL_1658;
LABEL_1177:
          v884 = v771;
          goto LABEL_1311;
        }
        v780 = *(_QWORD *)(a3 + 8);
        v781 = *(unsigned __int8 *)(v780 - 24);
        v782 = *(_QWORD *)(v780 - 16);
        v783 = *(void **)(v780 - 8);
        v784 = (size_t *)(v780 - 48);
        v785 = (void *)(v780 - 23);
        v786 = (v781 & 1) == 0;
        v787 = v781 >> 1;
        if ( v786 )
          v788 = v785;
        else
          v788 = v783;
        if ( v786 )
          v789 = v787;
        else
          v789 = v782;
        v790 = sub_9CFD0(v784, v788, v789);
        v1355 = (unsigned __int16 *)v790[2];
        v1354 = *(_OWORD *)v790;
        v790[1] = 0LL;
        v790[2] = 0LL;
        *v790 = 0LL;
        v791 = *(_QWORD *)(a3 + 8);
        v792 = (_BYTE *)(v791 - 48);
        if ( (*(_BYTE *)(v791 - 24) & 1) != 0 )
          free(*(void **)(v791 - 8));
        if ( (*v792 & 1) != 0 )
          free(*(void **)(v791 - 32));
        *(_QWORD *)(a3 + 8) = v792;
        v793 = *((_QWORD *)&v1354 + 1);
        v794 = (unsigned __int8 *)v1355;
        if ( (v1354 & 1) == 0 )
        {
          v794 = (unsigned __int8 *)&v1354 + 1;
          v793 = (unsigned __int64)(unsigned __int8)v1354 >> 1;
        }
        v795 = sub_B190C(v794 + 9, &v794[v793], (void **)a3);
        if ( (v1354 & 1) != 0 )
          v796 = (char *)v1355;
        else
          v796 = (char *)&v1354 + 1;
        if ( v795 != (unsigned __int8 *)(v796 + 9) )
        {
          sub_AB28C((size_t *)&v1346, "<", (unsigned __int8 *)&v1350);
          v797 = *(_QWORD *)(a3 + 8);
          v798 = *(unsigned __int8 *)(v797 - 24);
          v799 = *(_QWORD *)(v797 - 16);
          v800 = *(void **)(v797 - 8);
          v801 = (size_t *)(v797 - 48);
          v802 = (void *)(v797 - 23);
          v803 = (v798 & 1) == 0;
          v804 = v798 >> 1;
          if ( v803 )
            v805 = v802;
          else
            v805 = v800;
          if ( v803 )
            v806 = v804;
          else
            v806 = v799;
          v807 = sub_9CFD0(v801, v805, v806);
          v1344 = (char *)v807[2];
          v1343 = *(_OWORD *)v807;
          v807[1] = 0LL;
          v807[2] = 0LL;
          *v807 = 0LL;
          v808 = v1343;
          v809 = v1344;
          if ( (v1343 & 1) != 0 )
            v810 = v1344;
          else
            v810 = (char *)&v1343 + 1;
          if ( (v1343 & 1) != 0 )
            v811 = *((_QWORD *)&v1343 + 1);
          else
            v811 = (unsigned __int64)(unsigned __int8)v1343 >> 1;
          sub_9CFD0((size_t *)&v1346, v810, v811);
          v812 = (char *)v1347;
          v813 = v1346;
          v1347 = 0LL;
          v1346 = 0uLL;
          v1349 = v812;
          v1348 = v813;
          sub_9CFD0((size_t *)&v1348, ">", 1uLL);
          v814 = *(void **)((char *)&v1348 + 1);
          v815 = *((_QWORD *)&v1348 + 1);
          v816 = v1349;
          v817 = v1348;
          v1349 = 0LL;
          v1348 = 0uLL;
          *(_QWORD *)&v1345[7] = v815;
          v1345[7] = HIBYTE(v814);
          LOBYTE(v1338[0]) = v817;
          v818 = v814;
          v819 = *(void **)&v1345[7];
          memset(v1345, 0, 15);
          *(void **)((char *)v1338 + 1) = v818;
          v1338[1] = v819;
          p = v816;
          v1341 = 0LL;
          v1340 = 0uLL;
          sub_A7174((unsigned __int64 *)(*(_QWORD *)(a3 + 8) - 48LL), (__int64)v1338);
          if ( (v1340 & 1) != 0 )
          {
            free(v1341);
            if ( ((__int64)v1338[0] & 1) == 0 )
            {
LABEL_1067:
              if ( (v1348 & 1) == 0 )
                goto LABEL_1068;
              goto LABEL_1308;
            }
          }
          else if ( ((__int64)v1338[0] & 1) == 0 )
          {
            goto LABEL_1067;
          }
          free(p);
          if ( (v1348 & 1) == 0 )
          {
LABEL_1068:
            if ( (v808 & 1) == 0 )
              goto LABEL_1069;
            goto LABEL_1309;
          }
LABEL_1308:
          free(v1349);
          if ( (v808 & 1) == 0 )
          {
LABEL_1069:
            if ( (v1346 & 1) == 0 )
            {
LABEL_1658:
              if ( (v1354 & 1) == 0 )
                goto LABEL_1660;
              goto LABEL_1659;
            }
            goto LABEL_1310;
          }
LABEL_1309:
          free(v809);
          if ( (v1346 & 1) == 0 )
            goto LABEL_1658;
LABEL_1310:
          v884 = v1347;
LABEL_1311:
          free(v884);
          if ( (v1354 & 1) == 0 )
          {
LABEL_1660:
            v1145 = v160[1] - 48LL;
            *(_QWORD *)&v1354 = v160[3];
            sub_9D15C((size_t **)v1338, v1145, (__int64 *)&v1354);
            v1146 = v160[5];
            v1147 = v160[6];
            if ( v1146 < v1147 )
            {
              *(_QWORD *)(v1146 + 24) = v1340;
              *(_OWORD *)v1146 = *(_OWORD *)v1338;
              *(_QWORD *)(v1146 + 16) = p;
              v1338[1] = 0LL;
              p = 0LL;
              v1338[0] = 0LL;
              v160[5] += 32LL;
              v1148 = (void **)v1338[0];
              if ( !v1338[0] )
                goto LABEL_1700;
              goto LABEL_1688;
            }
            v1149 = v160[4];
            v1150 = (__int64)(v1146 - v1149) >> 5;
            if ( (unsigned __int64)(v1150 + 1) >> 59 )
              abort();
            v1151 = v1147 - v1149;
            if ( (unsigned __int64)(v1151 >> 5) > 0x3FFFFFFFFFFFFFELL )
            {
              v1153 = 0x7FFFFFFFFFFFFFFLL;
            }
            else
            {
              v1152 = v1151 >> 4;
              if ( v1152 >= v1150 + 1 )
                v1153 = v1152;
              else
                v1153 = v1150 + 1;
              if ( !v1153 )
              {
                v1154 = 0LL;
LABEL_1674:
                v1156 = &v1154[32 * v1150];
                *((_QWORD *)v1156 + 1) = 0LL;
                *((_QWORD *)v1156 + 2) = 0LL;
                v1157 = v1156 + 32;
                *((_QWORD *)v1156 + 3) = v1340;
                *(_OWORD *)v1156 = *(_OWORD *)v1338;
                *((_QWORD *)v1156 + 2) = p;
                v1338[1] = 0LL;
                p = 0LL;
                v1338[0] = 0LL;
                v1159 = (void **)v160[4];
                v1158 = (void **)v160[5];
                v1160 = &v1154[32 * v1153];
                if ( v1158 == v1159 )
                {
                  v1162 = (void **)v160[4];
                }
                else
                {
                  do
                  {
                    *((_QWORD *)v1156 - 3) = 0LL;
                    *((_QWORD *)v1156 - 2) = 0LL;
                    *((_QWORD *)v1156 - 4) = 0LL;
                    *((_QWORD *)v1156 - 1) = *(v1158 - 1);
                    v1161 = *((_OWORD *)v1158 - 2);
                    v1158 -= 4;
                    *((_OWORD *)v1156 - 2) = v1161;
                    *((_QWORD *)v1156 - 2) = v1158[2];
                    v1156 -= 32;
                    v1158[1] = 0LL;
                    v1158[2] = 0LL;
                    *v1158 = 0LL;
                  }
                  while ( v1159 != v1158 );
                  v1162 = (void **)v160[4];
                  v1159 = (void **)v160[5];
                }
                v1163 = v160[6];
                v160[4] = v1156;
                v160[5] = v1157;
                v160[6] = v1160;
                while ( v1162 != v1159 )
                {
                  v1159 -= 4;
                  sub_9D32C(v1159);
                }
                if ( v1162 )
                {
                  v1164 = v160[7];
                  if ( v1164 + 4096 < (unsigned __int64)v1162 || v1164 > (unsigned __int64)v1162 )
                  {
                    free(v1162);
                  }
                  else if ( *(_QWORD *)(v1164 + 4096) == v1163 )
                  {
                    *(_QWORD *)(v1164 + 4096) = v1162;
                    v1148 = (void **)v1338[0];
                    if ( !v1338[0] )
                      goto LABEL_1700;
                    goto LABEL_1688;
                  }
                }
                v1148 = (void **)v1338[0];
                if ( !v1338[0] )
                  goto LABEL_1700;
LABEL_1688:
                v1165 = (void **)v1338[1];
                if ( v1338[1] != v1148 )
                {
                  do
                  {
                    if ( (*(_BYTE *)(v1165 - 3) & 1) != 0 )
                      free(*(v1165 - 1));
                    v1166 = v1165 - 6;
                    if ( (*(_BYTE *)(v1165 - 6) & 1) != 0 )
                      free(*(v1165 - 4));
                    v1165 -= 6;
                  }
                  while ( v1148 != v1166 );
                }
                v1338[1] = v1148;
                if ( (__int64)v1340 + 4096 < (unsigned __int64)v1148
                  || (unsigned __int64)v1340 > (unsigned __int64)v1148 )
                {
                  free(v1148);
                }
                else if ( *(void **)(v1340 + 4096) == p )
                {
                  *(_QWORD *)(v1340 + 4096) = v1148;
                  if ( (v1350 & 1) == 0 )
                    return (unsigned __int8 *)v24;
                  goto LABEL_1701;
                }
LABEL_1700:
                if ( (v1350 & 1) == 0 )
                  return (unsigned __int8 *)v24;
LABEL_1701:
                v1074 = (void **)v1351;
                goto LABEL_1513;
              }
            }
            v1155 = v160[7];
            v1154 = *(char **)(v1155 + 4096);
            if ( v1155 + 4096 - (__int64)v1154 >= (unsigned __int64)(32 * v1153) )
              *(_QWORD *)(v1155 + 4096) = &v1154[32 * v1153];
            else
              v1154 = (char *)malloc(32 * v1153);
            goto LABEL_1674;
          }
LABEL_1659:
          free(v1355);
          goto LABEL_1660;
        }
        sub_AB28C((size_t *)v1338, " ", (unsigned __int8 *)&v1350);
        if ( (v1354 & 1) != 0 )
          v910 = (char *)v1355;
        else
          v910 = (char *)&v1354 + 1;
        if ( (v1354 & 1) != 0 )
          v911 = *((_QWORD *)&v1354 + 1);
        else
          v911 = (unsigned __int64)(unsigned __int8)v1354 >> 1;
        sub_9CFD0((size_t *)v1338, v910, v911);
        v912 = *(__int64 *)((char *)v1338 + 1);
        v913 = v1338[1];
        v914 = p;
        v915 = (char)v1338[0];
        v1338[1] = 0LL;
        p = 0LL;
        *(_QWORD *)((char *)v1342 + 7) = v913;
        v1342[0] = v912;
        v916 = *(_QWORD *)((char *)v1342 + 7);
        v917 = v1342[0];
        v1338[0] = 0LL;
        *(_QWORD *)((char *)&v1346 + 7) = 0LL;
        *(_QWORD *)&v1346 = 0LL;
        memset(v1342, 0, 15);
        *(_QWORD *)((char *)&v1348 + 7) = v916;
        *(_QWORD *)&v1348 = v917;
        v918 = *(_QWORD *)(a3 + 8);
        v919 = *(_QWORD *)(a3 + 16);
        if ( v918 < v919 )
        {
          *(_BYTE *)v918 = v915;
          *(_QWORD *)(v918 + 8) = *(_QWORD *)((char *)&v1348 + 7);
          *(_QWORD *)(v918 + 16) = v914;
          *(_QWORD *)(v918 + 1) = v1348;
          *(_QWORD *)((char *)&v1348 + 7) = 0LL;
          *(_QWORD *)&v1348 = 0LL;
          *(_BYTE *)(v918 + 24) = 0;
          *(_QWORD *)(v918 + 32) = *(_QWORD *)((char *)&v1346 + 7);
          *(_QWORD *)(v918 + 40) = 0LL;
          *(_QWORD *)(v918 + 25) = v1346;
          *(_QWORD *)((char *)&v1346 + 7) = 0LL;
          *(_QWORD *)&v1346 = 0LL;
          *(_QWORD *)(a3 + 8) += 48LL;
          if ( ((__int64)v1338[0] & 1) == 0 )
            goto LABEL_1657;
          goto LABEL_1656;
        }
        v1048 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v918 - *(_QWORD *)a3) >> 4);
        v1049 = v1048 + 1;
        if ( v1048 + 1 > 0x555555555555555LL )
          abort();
        v1050 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v919 - *(_QWORD *)a3) >> 4);
        if ( v1050 >= 0x2AAAAAAAAAAAAAALL )
          goto LABEL_1471;
        v1051 = 2 * v1050;
        if ( v1051 >= v1049 )
          v1049 = v1051;
        v1300 = v1049;
        if ( v1049 )
        {
LABEL_1471:
          v1052 = *(_QWORD *)(a3 + 24);
          v1053 = *(char **)(v1052 + 4096);
          if ( v1052 + 4096 - (__int64)v1053 >= (unsigned __int64)(48 * v1300) )
            *(_QWORD *)(v1052 + 4096) = &v1053[48 * v1300];
          else
            v1053 = (char *)malloc(48 * v1300);
        }
        else
        {
          v1300 = 0LL;
          v1053 = 0LL;
        }
        v1136 = &v1053[48 * v1048];
        *v1136 = v915;
        *((_QWORD *)v1136 + 1) = *(_QWORD *)((char *)&v1348 + 7);
        *((_QWORD *)v1136 + 2) = v914;
        *(_QWORD *)(v1136 + 1) = v1348;
        *(_QWORD *)((char *)&v1348 + 7) = 0LL;
        *(_QWORD *)&v1348 = 0LL;
        v1136[24] = 0;
        *((_QWORD *)v1136 + 4) = *(_QWORD *)((char *)&v1346 + 7);
        *((_QWORD *)v1136 + 5) = 0LL;
        *(_QWORD *)(v1136 + 25) = v1346;
        *(_QWORD *)((char *)&v1346 + 7) = 0LL;
        *(_QWORD *)&v1346 = 0LL;
        v1138 = *(void ***)a3;
        v1137 = *(void ***)(a3 + 8);
        v1139 = v1136 + 48;
        if ( v1137 == *(void ***)a3 )
        {
          v1141 = *(void ***)a3;
        }
        else
        {
          do
          {
            *((_QWORD *)v1136 - 4) = *(v1137 - 4);
            *((_OWORD *)v1136 - 3) = *((_OWORD *)v1137 - 3);
            v1140 = (__int64)*(v1137 - 1);
            *(v1137 - 5) = 0LL;
            *(v1137 - 4) = 0LL;
            *(v1137 - 6) = 0LL;
            *((_QWORD *)v1136 - 1) = v1140;
            *(_OWORD *)(v1136 - 24) = *(_OWORD *)(v1137 - 3);
            *(v1137 - 2) = 0LL;
            *(v1137 - 1) = 0LL;
            *(v1137 - 3) = 0LL;
            v1137 -= 6;
            v1136 -= 48;
          }
          while ( v1138 != v1137 );
          v1141 = *(void ***)a3;
          v1138 = *(void ***)(a3 + 8);
        }
        v1142 = *(_QWORD *)(a3 + 16);
        *(_QWORD *)a3 = v1136;
        *(_QWORD *)(a3 + 8) = v1139;
        *(_QWORD *)(a3 + 16) = &v1053[48 * v1300];
        if ( v1138 != v1141 )
        {
          do
          {
            if ( (*(_BYTE *)(v1138 - 3) & 1) != 0 )
              free(*(v1138 - 1));
            v1143 = v1138 - 6;
            if ( (*(_BYTE *)(v1138 - 6) & 1) != 0 )
              free(*(v1138 - 4));
            v1138 -= 6;
          }
          while ( v1141 != v1143 );
        }
        if ( !v1141 )
          goto LABEL_1655;
        v1144 = *(_QWORD *)(a3 + 24);
        if ( v1144 + 4096 < (unsigned __int64)v1141 || v1144 > (unsigned __int64)v1141 )
        {
          free(v1141);
        }
        else if ( *(_QWORD *)(v1144 + 4096) == v1142 )
        {
          *(_QWORD *)(v1144 + 4096) = v1141;
          if ( ((__int64)v1338[0] & 1) == 0 )
            goto LABEL_1657;
          goto LABEL_1656;
        }
LABEL_1655:
        if ( ((__int64)v1338[0] & 1) == 0 )
        {
LABEL_1657:
          v160 = (_QWORD *)a3;
          goto LABEL_1658;
        }
LABEL_1656:
        free(p);
        goto LABEL_1657;
      default:
        goto LABEL_1249;
    }
  }
LABEL_6:
  if ( v6 == 86 )
  {
    v9 = *++v8;
    v6 = v9;
    v7 |= 2u;
  }
LABEL_8:
  if ( v6 == 75 )
    v10 = v8 + 1;
  else
    v10 = v8;
  if ( v10 == a1 )
    return v4;
  v11 = *v10;
  v12 = *(void ***)a3;
  v13 = *(_QWORD *)(a3 + 8);
  v14 = (__int64)a1;
  v1299 = sub_925FC(v10, a2, a3);
  if ( (unsigned __int8 *)v1299 == v10 )
    return (unsigned __int8 *)v14;
  v1302 = v7;
  v15 = *(void ***)a3;
  v16 = *(_QWORD *)(a3 + 8);
  v17 = *(_QWORD *)(a3 + 40);
  v18 = (__int64 *)a3;
  if ( v11 == 70 )
  {
    v17 -= 32LL;
    sub_9D32C((void **)v17);
    *(_QWORD *)(a3 + 40) = v17;
  }
  v19 = *(_QWORD *)(a3 + 48);
  v20 = *(_QWORD *)(a3 + 24);
  if ( v17 >= v19 )
  {
    v34 = *(_QWORD *)(a3 + 32);
    v35 = (__int64)(v17 - v34) >> 5;
    if ( !((unsigned __int64)(v35 + 1) >> 59) )
    {
      v36 = v19 - v34;
      if ( (unsigned __int64)(v36 >> 5) > 0x3FFFFFFFFFFFFFELL )
      {
        v38 = 0x7FFFFFFFFFFFFFFLL;
      }
      else
      {
        v37 = v36 >> 4;
        if ( v37 >= v35 + 1 )
          v38 = v37;
        else
          v38 = v35 + 1;
        if ( !v38 )
        {
          v39 = 0LL;
LABEL_46:
          v41 = &v39[32 * v35];
          *(_QWORD *)v41 = 0LL;
          *((_QWORD *)v41 + 1) = 0LL;
          *((_QWORD *)v41 + 2) = 0LL;
          *((_QWORD *)v41 + 3) = v20;
          v43 = *(void ***)(a3 + 32);
          v42 = *(void ***)(a3 + 40);
          v44 = &v39[32 * v38];
          v45 = v41 + 32;
          if ( v42 == v43 )
          {
            v47 = *(void ***)(a3 + 32);
          }
          else
          {
            do
            {
              *((_QWORD *)v41 - 3) = 0LL;
              *((_QWORD *)v41 - 2) = 0LL;
              *((_QWORD *)v41 - 4) = 0LL;
              *((_QWORD *)v41 - 1) = *(v42 - 1);
              v46 = *((_OWORD *)v42 - 2);
              v42 -= 4;
              *((_OWORD *)v41 - 2) = v46;
              *((_QWORD *)v41 - 2) = v42[2];
              v41 -= 32;
              v42[1] = 0LL;
              v42[2] = 0LL;
              *v42 = 0LL;
            }
            while ( v43 != v42 );
            v47 = *(void ***)(a3 + 32);
            v43 = *(void ***)(a3 + 40);
          }
          v48 = *(_QWORD *)(a3 + 48);
          *(_QWORD *)(a3 + 32) = v41;
          *(_QWORD *)(a3 + 40) = v45;
          *(_QWORD *)(a3 + 48) = v44;
          while ( v47 != v43 )
          {
            v43 -= 4;
            sub_9D32C(v43);
          }
          if ( v47 )
          {
            v49 = *(_QWORD *)(a3 + 56);
            if ( v49 + 4096 < (unsigned __int64)v47 || v49 > (unsigned __int64)v47 )
            {
              free(v47);
            }
            else if ( *(_QWORD *)(v49 + 4096) == v48 )
            {
              *(_QWORD *)(v49 + 4096) = v47;
            }
          }
          goto LABEL_58;
        }
      }
      v40 = *(_QWORD *)(a3 + 56);
      v39 = *(char **)(v40 + 4096);
      if ( v40 + 4096 - (__int64)v39 >= (unsigned __int64)(32 * v38) )
        *(_QWORD *)(v40 + 4096) = &v39[32 * v38];
      else
        v39 = (char *)malloc(32 * v38);
      goto LABEL_46;
    }
LABEL_1805:
    abort();
  }
  *(_QWORD *)v17 = 0LL;
  *(_QWORD *)(v17 + 8) = 0LL;
  *(_QWORD *)(v17 + 16) = 0LL;
  *(_QWORD *)(v17 + 24) = v20;
  *(_QWORD *)(a3 + 40) += 32LL;
LABEL_58:
  v50 = 0xAAAAAAAAAAAAAAABLL * ((v13 - (__int64)v12) >> 4);
  dest = 0xAAAAAAAAAAAAAAABLL * ((v16 - (__int64)v15) >> 4);
  if ( v50 < dest )
  {
    v51 = v1302;
    v1306 = v6;
    v1321 = v11;
    do
    {
      if ( v11 != 70 )
      {
        if ( v6 == 75 )
        {
          sub_9CFD0((size_t *)(*v18 + 48 * v50), " const", 6uLL);
          if ( (v51 & 2) != 0 )
          {
LABEL_101:
            sub_9CFD0((size_t *)(*v18 + 48 * v50), " volatile", 9uLL);
            if ( (v51 & 4) == 0 )
              goto LABEL_123;
LABEL_105:
            sub_9CFD0((size_t *)(*v18 + 48 * v50), " restrict", 9uLL);
            goto LABEL_123;
          }
        }
        else if ( (v51 & 2) != 0 )
        {
          goto LABEL_101;
        }
        if ( (v51 & 4) == 0 )
          goto LABEL_123;
        goto LABEL_105;
      }
      v81 = *v18;
      v82 = *v18 + 48 * v50;
      v85 = *(unsigned __int8 *)(v82 + 24);
      v83 = (size_t *)(v82 + 24);
      v84 = v85;
      if ( (v85 & 1) != 0 )
      {
        v88 = v81 + 48 * v50;
        v86 = *(_QWORD *)(v88 + 32);
        v87 = *(char **)(v88 + 40);
      }
      else
      {
        v86 = v84 >> 1;
        v87 = (char *)v83 + 1;
      }
      v89 = v86 - 2;
      if ( v87[v86 - 2] == 38
        && ((v84 & 1) != 0 ? (v90 = *(char **)(v81 + 48 * v50 + 40)) : (v90 = (char *)v83 + 1), v90[v86 - 1] == 38) )
      {
        if ( v6 == 75 )
          goto LABEL_113;
      }
      else
      {
        if ( (v84 & 1) != 0 )
        {
          v93 = v81 + 48 * v50;
          v92 = *(_QWORD *)(v93 + 32);
          v91 = *(char **)(v93 + 40);
        }
        else
        {
          v91 = (char *)v83 + 1;
          v92 = v84 >> 1;
        }
        v89 = v86 - (v91[v92 - 1] == 38);
        if ( v6 == 75 )
        {
LABEL_113:
          sub_9CDD8(v83, v89, " const", 6uLL);
          v89 += 6LL;
          if ( (v51 & 2) == 0 )
            goto LABEL_121;
          goto LABEL_114;
        }
      }
      if ( (v51 & 2) == 0 )
      {
LABEL_121:
        if ( (v51 & 4) == 0 )
          goto LABEL_123;
LABEL_122:
        sub_9CDD8((size_t *)(*v18 + 48 * v50 + 24), v89, " restrict", 9uLL);
        goto LABEL_123;
      }
LABEL_114:
      sub_9CDD8((size_t *)(*v18 + 48 * v50 + 24), v89, " volatile", 9uLL);
      v89 += 9LL;
      if ( (v51 & 4) != 0 )
        goto LABEL_122;
LABEL_123:
      v94 = v18[5];
      v95 = *v18;
      v97 = *(size_t **)(v94 - 24);
      v96 = *(size_t **)(v94 - 16);
      v98 = *v18 + 48 * v50;
      if ( v97 == v96 )
      {
        v99 = *(_QWORD *)(v94 - 32);
        v100 = 0xAAAAAAAAAAAAAAABLL * (((__int64)v97 - v99) >> 4);
        if ( v100 + 1 > 0x555555555555555LL )
          goto LABEL_1805;
        v101 = 0xAAAAAAAAAAAAAAABLL * (((__int64)v96 - v99) >> 4);
        v102 = 0x555555555555555LL;
        if ( v101 >= 0x2AAAAAAAAAAAAAALL
          || ((v103 = 2 * v101, v103 >= v100 + 1) ? (v102 = v103) : (v102 = v100 + 1), v102) )
        {
          v104 = *(_QWORD *)(v94 - 8);
          v105 = 48 * v102;
          v52 = *(char **)(v104 + 4096);
          if ( v104 + 4096 - (__int64)v52 >= (unsigned __int64)(48 * v102) )
            *(_QWORD *)(v104 + 4096) = &v52[v105];
          else
            v52 = (char *)malloc(v105);
        }
        else
        {
          v52 = 0LL;
        }
        v53 = (size_t *)&v52[48 * v100];
        v53[1] = 0LL;
        v53[2] = 0LL;
        *v53 = 0LL;
        v54 = &v52[48 * v102];
        v1311 = v54;
        if ( (*(_BYTE *)v98 & 1) == 0 )
        {
          v53[2] = *(_QWORD *)(v98 + 16);
          *(_OWORD *)v53 = *(_OWORD *)v98;
          goto LABEL_71;
        }
        v55 = v95 + 48 * v50;
        v56 = *(_QWORD *)(v55 + 8);
        if ( v56 >= 0xFFFFFFFFFFFFFFF0LL )
          abort();
        v57 = *(const void **)(v55 + 16);
        if ( v56 >= 0x17 )
        {
          v59 = *(const void **)(v55 + 16);
          v60 = malloc((v56 + 16) & 0xFFFFFFFFFFFFFFF0LL);
          v18 = (__int64 *)a3;
          v57 = v59;
          v58 = v60;
          v61 = &v52[48 * v100];
          *((_QWORD *)v61 + 1) = v56;
          *((_QWORD *)v61 + 2) = v60;
          *v53 = (v56 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
        }
        else
        {
          *(_BYTE *)v53 = 2 * v56;
          v58 = (char *)v53 + 1;
          if ( !v56 )
            goto LABEL_70;
        }
        memcpy(v58, v57, v56);
LABEL_70:
        *((_BYTE *)v58 + v56) = 0;
        v11 = v1321;
        v54 = v1311;
LABEL_71:
        v62 = &v52[48 * v100];
        *((_QWORD *)v62 + 3) = 0LL;
        v63 = v62 + 24;
        v64 = v95 + 48 * v50;
        *((_QWORD *)v63 + 1) = 0LL;
        *((_QWORD *)v63 + 2) = 0LL;
        v66 = *(_BYTE *)(v64 + 24);
        v65 = v64 + 24;
        if ( (v66 & 1) == 0 )
        {
          *((_QWORD *)v63 + 2) = *(_QWORD *)(v65 + 16);
          *(_OWORD *)v63 = *(_OWORD *)v65;
LABEL_80:
          v74 = *(void ***)(v94 - 32);
          v73 = *(void ***)(v94 - 24);
          v75 = v53 + 6;
          if ( v73 == v74 )
          {
            v77 = *(void ***)(v94 - 32);
          }
          else
          {
            do
            {
              *(v53 - 4) = (size_t)*(v73 - 4);
              *((_OWORD *)v53 - 3) = *((_OWORD *)v73 - 3);
              v76 = (size_t)*(v73 - 1);
              *(v73 - 5) = 0LL;
              *(v73 - 4) = 0LL;
              *(v73 - 6) = 0LL;
              *(v53 - 1) = v76;
              *(_OWORD *)(v53 - 3) = *(_OWORD *)(v73 - 3);
              *(v73 - 2) = 0LL;
              *(v73 - 1) = 0LL;
              *(v73 - 3) = 0LL;
              v73 -= 6;
              v53 -= 6;
            }
            while ( v74 != v73 );
            v77 = *(void ***)(v94 - 32);
            v74 = *(void ***)(v94 - 24);
          }
          v78 = *(_QWORD *)(v94 - 16);
          *(_QWORD *)(v94 - 32) = v53;
          *(_QWORD *)(v94 - 24) = v75;
          *(_QWORD *)(v94 - 16) = v54;
          v6 = v1306;
          if ( v74 != v77 )
          {
            do
            {
              if ( (*(_BYTE *)(v74 - 3) & 1) != 0 )
                free(*(v74 - 1));
              v79 = v74 - 6;
              if ( (*(_BYTE *)(v74 - 6) & 1) != 0 )
                free(*(v74 - 4));
              v74 -= 6;
            }
            while ( v77 != v79 );
          }
          v51 = v1302;
          if ( v77 )
          {
            v80 = *(_QWORD *)(v94 - 8);
            if ( v80 + 4096 < (unsigned __int64)v77 || v80 > (unsigned __int64)v77 )
            {
              free(v77);
            }
            else if ( *(_QWORD *)(v80 + 4096) == v78 )
            {
              *(_QWORD *)(v80 + 4096) = v77;
            }
          }
          goto LABEL_151;
        }
        v67 = v95 + 48 * v50;
        v68 = *(_QWORD *)(v67 + 32);
        if ( v68 >= 0xFFFFFFFFFFFFFFF0LL )
          abort();
        v69 = *(const void **)(v67 + 40);
        if ( v68 >= 0x17 )
        {
          v71 = malloc((v68 + 16) & 0xFFFFFFFFFFFFFFF0LL);
          v18 = (__int64 *)a3;
          v72 = &v52[48 * v100];
          *((_QWORD *)v72 + 4) = v68;
          *((_QWORD *)v72 + 5) = v71;
          *(_QWORD *)v63 = (v68 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
          v70 = v71;
        }
        else
        {
          *v63 = 2 * v68;
          v70 = v63 + 1;
          if ( !v68 )
            goto LABEL_79;
        }
        memcpy(v70, v69, v68);
LABEL_79:
        *((_BYTE *)v70 + v68) = 0;
        v11 = v1321;
        v54 = v1311;
        goto LABEL_80;
      }
      v97[1] = 0LL;
      v97[2] = 0LL;
      *v97 = 0LL;
      if ( (*(_BYTE *)v98 & 1) == 0 )
      {
        v97[2] = *(_QWORD *)(v98 + 16);
        *(_OWORD *)v97 = *(_OWORD *)v98;
        goto LABEL_141;
      }
      v106 = v95 + 48 * v50;
      v107 = *(_QWORD *)(v106 + 8);
      if ( v107 >= 0xFFFFFFFFFFFFFFF0LL )
        goto LABEL_1805;
      v108 = *(const void **)(v106 + 16);
      if ( v107 >= 0x17 )
      {
        v109 = malloc((v107 + 16) & 0xFFFFFFFFFFFFFFF0LL);
        v97[2] = (size_t)v109;
        v6 = v1306;
        *v97 = (v107 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
        v97[1] = v107;
      }
      else
      {
        *(_BYTE *)v97 = 2 * v107;
        v109 = (char *)v97 + 1;
        if ( !v107 )
          goto LABEL_140;
      }
      memcpy(v109, v108, v107);
LABEL_140:
      *((_BYTE *)v109 + v107) = 0;
      v11 = v1321;
LABEL_141:
      v97[3] = 0LL;
      v110 = v97 + 3;
      v111 = v95 + 48 * v50;
      v97[4] = 0LL;
      v97[5] = 0LL;
      v113 = *(_BYTE *)(v111 + 24);
      v112 = v111 + 24;
      if ( (v113 & 1) != 0 )
      {
        v114 = v95 + 48 * v50;
        v115 = *(_QWORD *)(v114 + 32);
        if ( v115 >= 0xFFFFFFFFFFFFFFF0LL )
          abort();
        v116 = *(const void **)(v114 + 40);
        if ( v115 >= 0x17 )
        {
          v117 = malloc((v115 + 16) & 0xFFFFFFFFFFFFFFF0LL);
          v97[5] = (size_t)v117;
          v6 = v1306;
          v97[3] = (v115 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
          v97[4] = v115;
        }
        else
        {
          *v110 = 2 * v115;
          v117 = (char *)v97 + 25;
          if ( !v115 )
            goto LABEL_149;
        }
        memcpy(v117, v116, v115);
LABEL_149:
        *((_BYTE *)v117 + v115) = 0;
        v11 = v1321;
        goto LABEL_150;
      }
      v97[5] = *(_QWORD *)(v112 + 16);
      *(_OWORD *)v110 = *(_OWORD *)v112;
LABEL_150:
      *(_QWORD *)(v94 - 24) += 48LL;
LABEL_151:
      ++v50;
    }
    while ( v50 < dest );
  }
  return (unsigned __int8 *)v1299;
}
// 927E8: conditional instruction was optimized away because x22.8<3u
// 927F0: conditional instruction was optimized away because x22.8<3u
// 933AC: conditional instruction was optimized away because x20.8<Au
// 933B4: conditional instruction was optimized away because x20.8<Au
// 93BEC: conditional instruction was optimized away because x23.8<3u
// 93BF4: conditional instruction was optimized away because x23.8<3u
// 94DB0: conditional instruction was optimized away because x25.8<3u
// 94DB8: conditional instruction was optimized away because x25.8<3u
// 953EC: conditional instruction was optimized away because x21.8<3u
// 953F4: conditional instruction was optimized away because x21.8<3u
// 95580: conditional instruction was optimized away because x20.8<Du
// 95588: conditional instruction was optimized away because x20.8<Du
// 95E2C: conditional instruction was optimized away because x25.8<3u
// 95E34: conditional instruction was optimized away because x25.8<3u
// 992F4: conditional instruction was optimized away because x22.8<3u
// 992FC: conditional instruction was optimized away because x22.8<3u
// 0: using guessed type int dword_0;
// 27F8: using guessed type Elf64_Sym;
// 9AA00: using guessed type __int64 __fastcall sub_9AA00(_QWORD, _QWORD, _QWORD, _QWORD);
// B2B20: using guessed type __int64 __fastcall sub_B2B20(_QWORD, _QWORD, _QWORD);

//----- (000000000009AA00) ----------------------------------------------------
unsigned __int8 *__fastcall sub_9AA00(unsigned __int8 *a1, unsigned __int8 *a2, __int64 a3, _BYTE *a4)
{
  unsigned __int8 *v4; // x20
  unsigned __int8 *v5; // x19
  _BYTE *v6; // x26
  unsigned __int8 *v8; // x22
  int v9; // w8
  unsigned __int8 *v10; // x23
  unsigned __int8 *v11; // x8
  int v12; // w9
  int v13; // w25
  unsigned __int8 *v14; // x0
  unsigned __int8 *v15; // x24
  int v16; // w8
  int v17; // w9
  int v18; // w9
  _BYTE *v19; // x27
  char v20; // w26
  unsigned __int8 *v21; // x24
  __int64 v22; // x0
  unsigned __int8 *v23; // x25
  bool v24; // zf
  unsigned __int8 *v25; // x24
  __int64 v26; // x8
  __int64 v27; // x8
  unsigned __int64 v28; // x8
  unsigned __int64 v29; // x9
  void **v30; // x23
  int v31; // t1
  unsigned __int8 *v32; // x26
  _BOOL4 v33; // w27
  int v34; // w8
  int v35; // w8
  unsigned __int8 *v36; // x0
  unsigned __int8 *v37; // x23
  __int64 v38; // x22
  unsigned __int64 v39; // x8
  bool v40; // zf
  size_t v41; // x8
  void *v42; // x1
  size_t v43; // x2
  __int64 v44; // x22
  _BYTE *v45; // x23
  __int64 v46; // x8
  size_t *v47; // x0
  char v48; // w22
  char *v49; // x1
  void *v50; // x2
  int v51; // w21
  unsigned __int64 v52; // x8
  _OWORD *v53; // x9
  unsigned __int64 v54; // x27
  __int64 v55; // x24
  unsigned __int64 v56; // x8
  unsigned __int64 v57; // x8
  __int64 v58; // x9
  char *v59; // x0
  unsigned __int8 *v60; // x8
  unsigned __int8 *v61; // x9
  int v62; // w10
  unsigned __int8 *v63; // x0
  int v64; // w8
  int v65; // w8
  __int64 v66; // x10
  __int64 v67; // x23
  __int64 v68; // x9
  unsigned __int64 v69; // x9
  __int64 v70; // x22
  char *v71; // x0
  char *v72; // x8
  __int64 v73; // x11
  __int64 v74; // x25
  char *v75; // x9
  _OWORD *v76; // x10
  __int64 v77; // x12
  void *v78; // x24
  void *v79; // x27
  unsigned __int64 v80; // x8
  int v81; // w24
  __int64 v82; // x10
  __int64 v83; // x26
  __int64 v84; // x9
  unsigned __int64 v85; // x9
  __int64 v86; // x24
  char *v87; // x0
  __int64 v88; // x9
  char *v89; // x8
  char *v90; // x10
  void **v91; // x11
  void **v92; // x26
  char *v93; // x9
  __int128 v94; // t1
  void **v95; // x27
  __int64 v96; // x24
  unsigned __int64 v97; // x8
  void **v98; // x26
  char *v99; // x8
  char *v100; // x10
  void **v101; // x11
  void **v102; // x26
  char *v103; // x9
  __int128 v104; // t1
  void **v105; // x27
  __int64 v106; // x24
  unsigned __int64 v107; // x8
  void **v108; // x26
  char *v109; // x8
  char *v110; // x10
  void **v111; // x11
  void **v112; // x26
  char *v113; // x9
  __int128 v114; // t1
  void **v115; // x27
  __int64 v116; // x24
  unsigned __int64 v117; // x8
  void **v118; // x26
  __int64 v119; // x24
  __int64 v120; // x9
  char *v121; // x0
  char *v122; // x8
  char *v123; // x10
  void **v124; // x11
  void **v125; // x26
  char *v126; // x9
  __int128 v127; // t1
  void **v128; // x27
  __int64 v129; // x24
  unsigned __int64 v130; // x8
  void **v131; // x26
  void **v132; // x24
  void **v133; // x27
  int v134; // w27
  void **v135; // x24
  void **v136; // x27
  void **v137; // x24
  void **v138; // x27
  void **v139; // x24
  void **v140; // x27
  unsigned __int8 *v141; // x0
  unsigned __int8 *v142; // x25
  __int64 v143; // x24
  unsigned __int64 v144; // x8
  bool v145; // zf
  size_t v146; // x8
  void *v147; // x1
  size_t v148; // x2
  __int64 v149; // x24
  _BYTE *v150; // x27
  __int64 v151; // x8
  unsigned __int64 v152; // x8
  char *v153; // x1
  size_t v154; // x2
  __int64 v155; // x0
  unsigned __int8 *v156; // x25
  __int64 v157; // x24
  unsigned __int64 v158; // x8
  bool v159; // zf
  size_t v160; // x8
  void *v161; // x1
  size_t v162; // x2
  __int64 v163; // x24
  _BYTE *v164; // x27
  __int64 v165; // x8
  unsigned __int64 v166; // x8
  char *v167; // x1
  size_t v168; // x2
  unsigned __int8 *v169; // x0
  unsigned __int8 *v170; // x25
  __int64 v171; // x24
  unsigned __int64 v172; // x8
  bool v173; // zf
  size_t v174; // x8
  void *v175; // x1
  size_t v176; // x2
  __int64 v177; // x24
  _BYTE *v178; // x27
  __int64 v179; // x8
  char *v180; // x1
  size_t v181; // x2
  __int64 v182; // x1
  unsigned __int64 v183; // x8
  unsigned __int64 v184; // x9
  __int64 v185; // x0
  unsigned __int8 *v186; // x25
  __int64 v187; // x24
  unsigned __int64 v188; // x8
  bool v189; // zf
  size_t v190; // x8
  void *v191; // x1
  size_t v192; // x2
  __int64 v193; // x24
  _BYTE *v194; // x27
  __int64 v195; // x8
  unsigned __int64 v196; // x8
  char *v197; // x1
  size_t v198; // x2
  unsigned __int8 *v199; // x0
  __int64 v200; // x24
  unsigned __int64 v201; // x8
  bool v202; // zf
  size_t v203; // x8
  void *v204; // x1
  size_t v205; // x2
  __int64 v206; // x24
  _BYTE *v207; // x27
  __int64 v208; // x8
  unsigned __int64 v209; // x8
  char *v210; // x1
  size_t v211; // x2
  void *v212; // x2
  char *v213; // x1
  __int64 v214; // x1
  unsigned __int64 v215; // x8
  unsigned __int64 v216; // x9
  void **v217; // x26
  __int64 v218; // x10
  __int64 v219; // x26
  __int64 v220; // x9
  unsigned __int64 v221; // x9
  __int64 v222; // x24
  char *v223; // x0
  void *v224; // x2
  char *v225; // x1
  __int64 v226; // x1
  unsigned __int64 v227; // x8
  unsigned __int64 v228; // x9
  __int64 v229; // x10
  __int64 v230; // x24
  __int64 v231; // x9
  unsigned __int64 v232; // x9
  __int64 v233; // x27
  char *v234; // x0
  __int64 v235; // x10
  __int64 v236; // x26
  __int64 v237; // x9
  unsigned __int64 v238; // x9
  __int64 v239; // x24
  char *v240; // x0
  void *v241; // x2
  char *v242; // x1
  __int64 v243; // x1
  unsigned __int64 v244; // x8
  unsigned __int64 v245; // x9
  __int64 v246; // x10
  __int64 v247; // x26
  __int64 v248; // x9
  unsigned __int64 v249; // x9
  __int64 v250; // x9
  void *v251; // x2
  char *v252; // x1
  __int64 v253; // x1
  unsigned __int64 v254; // x8
  unsigned __int64 v255; // x9
  char *v256; // x8
  char *v257; // x10
  void **v258; // x11
  void **v259; // x26
  char *v260; // x9
  __int128 v261; // t1
  void **v262; // x27
  __int64 v263; // x24
  unsigned __int64 v264; // x8
  __int64 v265; // x9
  __int64 v266; // x9
  void **v267; // x24
  void **v268; // x27
  __int64 v269; // x24
  _BYTE *v270; // x20
  __int64 v271; // x8
  __int64 v272; // x20
  __int64 v273; // x9
  unsigned __int8 *v274; // x9
  int v275; // t1
  char *v276; // x8
  char *v277; // x10
  void **v278; // x11
  void **v279; // x23
  char *v280; // x9
  __int128 v281; // t1
  void **v282; // x25
  __int64 v283; // x22
  unsigned __int64 v284; // x8
  void **v285; // x22
  void **v286; // x25
  __int64 v287; // x22
  unsigned __int64 v288; // x8
  bool v289; // zf
  size_t v290; // x8
  void *v291; // x1
  size_t v292; // x2
  __int64 v293; // x22
  _BYTE *v294; // x23
  __int64 v295; // x8
  size_t *v296; // x0
  char *v297; // x1
  void *v298; // x2
  unsigned __int8 *v299; // x8
  int v300; // t1
  unsigned __int8 *v301; // x24
  __int64 v302; // x24
  unsigned __int64 v303; // x8
  bool v304; // zf
  size_t v305; // x8
  void *v306; // x1
  size_t v307; // x2
  __int64 v308; // x24
  _BYTE *v309; // x25
  __int64 v310; // x8
  char *v311; // x1
  void *v312; // x2
  int v313; // w24
  __int64 v314; // x20
  _BYTE *v315; // x24
  unsigned __int8 *v317; // x8
  int v318; // t1
  unsigned __int8 *v319; // x9
  int v320; // w10
  __int64 v321; // x8
  unsigned __int8 *v322; // x8
  int v323; // w9
  __int64 v324; // x23
  unsigned __int64 v325; // x8
  bool v326; // zf
  size_t v327; // x8
  void *v328; // x1
  size_t v329; // x2
  __int64 v330; // x23
  _BYTE *v331; // x24
  __int64 v332; // x8
  char *v333; // x1
  void *v334; // x2
  int v335; // w24
  int v336; // [xsp+4h] [xbp-BCh]
  __int64 v337; // [xsp+8h] [xbp-B8h]
  int v339; // [xsp+18h] [xbp-A8h]
  _BOOL4 v340; // [xsp+24h] [xbp-9Ch]
  char v341; // [xsp+24h] [xbp-9Ch]
  __int64 v342; // [xsp+28h] [xbp-98h] BYREF
  void *v343[2]; // [xsp+30h] [xbp-90h] BYREF
  void *p; // [xsp+40h] [xbp-80h]
  unsigned __int64 v345; // [xsp+48h] [xbp-78h]
  __int128 v346; // [xsp+50h] [xbp-70h] BYREF
  void *v347; // [xsp+60h] [xbp-60h]
  __int64 v348; // [xsp+68h] [xbp-58h]

  v4 = a2;
  v5 = a1;
  v6 = a4;
  v348 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a2 - a1 < 2 )
    return v5;
  if ( *a1 == 76 )
    v8 = a1 + 1;
  else
    v8 = a1;
  v9 = *v8;
  v10 = v8;
  if ( v9 == 90 )
  {
    if ( v8 == a2 )
      goto LABEL_633;
    v14 = sub_91038(v8 + 1, a2, (__int64 *)a3);
    if ( v14 == v8 + 1 )
      goto LABEL_632;
    if ( v14 == v4 )
      goto LABEL_632;
    if ( *v14 != 69 )
      goto LABEL_632;
    v15 = v14 + 1;
    if ( v14 + 1 == v4 )
      goto LABEL_632;
    v16 = *v15;
    if ( v16 != 100 )
    {
      if ( v16 == 115 )
      {
        if ( v14 + 2 == v4 )
          goto LABEL_649;
        v17 = v14[2];
        if ( v17 == 95 )
        {
          if ( v14 + 3 != v4 )
          {
            v18 = v14[3];
            if ( (unsigned int)(v18 - 48) <= 9 )
            {
              v4 = v14 + 4;
              goto LABEL_649;
            }
            if ( v18 == 95 )
            {
              v319 = v14 + 4;
              if ( v14 + 4 != v4 )
              {
                while ( 1 )
                {
                  v320 = *v319;
                  if ( (unsigned int)(v320 - 48) > 9 )
                    break;
                  if ( v4 == ++v319 )
                    goto LABEL_648;
                }
                if ( v320 == 95 )
                  v4 = v319 + 1;
                else
                  v4 = v14 + 2;
                goto LABEL_649;
              }
            }
          }
        }
        else if ( (unsigned int)(v17 - 48) <= 9 )
        {
          v274 = v14 + 3;
          while ( v4 != v274 )
          {
            v275 = *v274++;
            if ( (unsigned int)(v275 - 48) >= 0xA )
              goto LABEL_648;
          }
          goto LABEL_649;
        }
LABEL_648:
        v4 = v14 + 2;
LABEL_649:
        v321 = *(_QWORD *)(a3 + 8);
        if ( *(_QWORD *)a3 != v321 )
          sub_9CFD0((size_t *)(v321 - 48), "::string literal", 0x10uLL);
        goto LABEL_633;
      }
      v63 = (unsigned __int8 *)sub_9AA00(v14 + 1, v4, a3, v6);
      if ( v63 != v15 )
      {
        if ( v63 == v4 )
          goto LABEL_656;
        v64 = *v63;
        if ( v64 == 95 )
        {
          if ( v63 + 1 != v4 )
          {
            v65 = v63[1];
            if ( (unsigned int)(v65 - 48) <= 9 )
            {
              v4 = v63 + 2;
              goto LABEL_656;
            }
            if ( v65 == 95 )
            {
              v322 = v63 + 2;
              if ( v63 + 2 != v4 )
              {
                while ( 1 )
                {
                  v323 = *v322;
                  if ( (unsigned int)(v323 - 48) > 9 )
                    break;
                  if ( v4 == ++v322 )
                    goto LABEL_655;
                }
                if ( v323 == 95 )
                  v4 = v322 + 1;
                else
                  v4 = v63;
                goto LABEL_656;
              }
            }
          }
        }
        else if ( (unsigned int)(v64 - 48) <= 9 )
        {
          v317 = v63 + 1;
          while ( v4 != v317 )
          {
            v318 = *v317++;
            if ( (unsigned int)(v318 - 48) >= 0xA )
              goto LABEL_655;
          }
LABEL_656:
          v324 = *(_QWORD *)(a3 + 8);
          if ( 0xAAAAAAAAAAAAAAABLL * ((v324 - *(_QWORD *)a3) >> 4) < 2 )
            goto LABEL_633;
          v325 = *(unsigned __int8 *)(v324 - 24);
          v326 = (v325 & 1) == 0;
          v327 = v325 >> 1;
          if ( v326 )
            v328 = (void *)(v324 - 23);
          else
            v328 = *(void **)(v324 - 8);
          if ( v326 )
            v329 = v327;
          else
            v329 = *(_QWORD *)(v324 - 16);
          sub_9CFD0((size_t *)(v324 - 48), v328, v329);
          p = *(void **)(v324 - 32);
          *(_OWORD *)v343 = *(_OWORD *)(v324 - 48);
          *(_QWORD *)(v324 - 40) = 0LL;
          *(_QWORD *)(v324 - 32) = 0LL;
          *(_QWORD *)(v324 - 48) = 0LL;
          v330 = *(_QWORD *)(a3 + 8);
          v331 = (_BYTE *)(v330 - 48);
          if ( (*(_BYTE *)(v330 - 24) & 1) != 0 )
            free(*(void **)(v330 - 8));
          if ( (*v331 & 1) != 0 )
            free(*(void **)(v330 - 32));
          v332 = *(_QWORD *)a3;
          *(_QWORD *)(a3 + 8) = v331;
          if ( (_BYTE *)v332 == v331 )
          {
            v335 = 1;
            if ( ((__int64)v343[0] & 1) != 0 )
LABEL_675:
              free(p);
          }
          else
          {
            sub_9CFD0((size_t *)(v330 - 96), "::", 2uLL);
            if ( ((__int64)v343[0] & 1) != 0 )
              v333 = (char *)p;
            else
              v333 = (char *)v343 + 1;
            if ( ((__int64)v343[0] & 1) != 0 )
              v334 = v343[1];
            else
              v334 = (void *)((unsigned __int64)LOBYTE(v343[0]) >> 1);
            sub_9CFD0((size_t *)(*(_QWORD *)(a3 + 8) - 48LL), v333, (size_t)v334);
            v335 = 0;
            if ( ((__int64)v343[0] & 1) != 0 )
              goto LABEL_675;
          }
          v10 = v4;
          if ( v335 )
          {
LABEL_634:
            if ( v10 == v8 )
              return v5;
            else
              return v10;
          }
LABEL_633:
          v10 = v4;
          goto LABEL_634;
        }
LABEL_655:
        v4 = v63;
        goto LABEL_656;
      }
      goto LABEL_626;
    }
    v60 = v14 + 2;
    if ( v14 + 2 == v4 )
      goto LABEL_632;
    if ( v14[2] == 110 )
      v61 = v14 + 3;
    else
      v61 = v14 + 2;
    if ( v61 != v4 )
    {
      v62 = *v61;
      if ( v62 == 48 )
      {
        v60 = v61 + 1;
        if ( v61 + 1 == v4 )
          goto LABEL_632;
LABEL_602:
        if ( *v60 == 95 )
        {
          v301 = v60 + 1;
          v4 = (unsigned __int8 *)sub_9AA00(v60 + 1, v4, a3, v6);
          if ( v4 == v301 )
          {
LABEL_626:
            v314 = *(_QWORD *)(a3 + 8);
            if ( *(_QWORD *)a3 != v314 )
            {
              v315 = (_BYTE *)(v314 - 48);
              if ( (*(_BYTE *)(v314 - 24) & 1) != 0 )
                free(*(void **)(v314 - 8));
              if ( (*v315 & 1) != 0 )
                free(*(void **)(v314 - 32));
              *(_QWORD *)(a3 + 8) = v315;
            }
            goto LABEL_632;
          }
          v302 = *(_QWORD *)(a3 + 8);
          if ( 0xAAAAAAAAAAAAAAABLL * ((v302 - *(_QWORD *)a3) >> 4) < 2 )
            goto LABEL_634;
          v303 = *(unsigned __int8 *)(v302 - 24);
          v304 = (v303 & 1) == 0;
          v305 = v303 >> 1;
          if ( v304 )
            v306 = (void *)(v302 - 23);
          else
            v306 = *(void **)(v302 - 8);
          if ( v304 )
            v307 = v305;
          else
            v307 = *(_QWORD *)(v302 - 16);
          sub_9CFD0((size_t *)(v302 - 48), v306, v307);
          p = *(void **)(v302 - 32);
          *(_OWORD *)v343 = *(_OWORD *)(v302 - 48);
          *(_QWORD *)(v302 - 40) = 0LL;
          *(_QWORD *)(v302 - 32) = 0LL;
          *(_QWORD *)(v302 - 48) = 0LL;
          v308 = *(_QWORD *)(a3 + 8);
          v309 = (_BYTE *)(v308 - 48);
          if ( (*(_BYTE *)(v308 - 24) & 1) != 0 )
            free(*(void **)(v308 - 8));
          if ( (*v309 & 1) != 0 )
            free(*(void **)(v308 - 32));
          v310 = *(_QWORD *)a3;
          *(_QWORD *)(a3 + 8) = v309;
          if ( (_BYTE *)v310 == v309 )
          {
            v313 = 1;
            v4 = v8;
            if ( ((__int64)v343[0] & 1) != 0 )
LABEL_623:
              free(p);
          }
          else
          {
            sub_9CFD0((size_t *)(v308 - 96), "::", 2uLL);
            if ( ((__int64)v343[0] & 1) != 0 )
              v311 = (char *)p;
            else
              v311 = (char *)v343 + 1;
            if ( ((__int64)v343[0] & 1) != 0 )
              v312 = v343[1];
            else
              v312 = (void *)((unsigned __int64)LOBYTE(v343[0]) >> 1);
            sub_9CFD0((size_t *)(*(_QWORD *)(a3 + 8) - 48LL), v311, (size_t)v312);
            v313 = 0;
            if ( ((__int64)v343[0] & 1) != 0 )
              goto LABEL_623;
          }
          if ( v313 )
            goto LABEL_634;
          goto LABEL_633;
        }
LABEL_632:
        v4 = v8;
        goto LABEL_633;
      }
      if ( (unsigned int)(v62 - 49) <= 8 )
      {
        v299 = v61 + 1;
        while ( v4 != v299 )
        {
          v300 = *v299++;
          if ( (unsigned int)(v300 - 48) >= 0xA )
          {
            v60 = v299 - 1;
            goto LABEL_601;
          }
        }
        goto LABEL_632;
      }
    }
LABEL_601:
    if ( v60 == v4 )
      goto LABEL_632;
    goto LABEL_602;
  }
  if ( v9 == 78 )
  {
    if ( v8 != a2 )
    {
      v11 = v8 + 1;
      if ( v8 + 1 == a2 )
        goto LABEL_634;
      v12 = *v11;
      if ( v12 == 114 )
      {
        v11 = v8 + 2;
        v12 = v8[2];
        v13 = 4;
      }
      else
      {
        v13 = 0;
      }
      if ( v12 == 86 )
      {
        v31 = *++v11;
        v12 = v31;
        v13 |= 2u;
      }
      v32 = v12 == 75 ? v11 + 1 : v11;
      v33 = v12 == 75;
      if ( v32 == a2 )
        goto LABEL_634;
      *(_DWORD *)(a3 + 100) = 0;
      v34 = *v32;
      if ( v34 == 79 )
      {
        v35 = 2;
      }
      else
      {
        if ( v34 != 82 )
        {
LABEL_85:
          v53 = *(_OWORD **)(a3 + 8);
          v52 = *(_QWORD *)(a3 + 16);
          if ( (unsigned __int64)v53 >= v52 )
          {
            v340 = v33;
            v54 = 0xAAAAAAAAAAAAAAABLL * (((__int64)v53 - *(_QWORD *)a3) >> 4);
            v55 = 0x555555555555555LL;
            if ( v54 + 1 > 0x555555555555555LL )
              abort();
            v56 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v52 - *(_QWORD *)a3) >> 4);
            v339 = v13;
            if ( v56 > 0x2AAAAAAAAAAAAA9LL || ((v57 = 2 * v56, v57 >= v54 + 1) ? (v55 = v57) : (v55 = v54 + 1), v55) )
            {
              v58 = *(_QWORD *)(a3 + 24);
              v59 = *(char **)(v58 + 4096);
              if ( v58 + 4096 - (__int64)v59 >= (unsigned __int64)(48 * v55) )
                *(_QWORD *)(v58 + 4096) = &v59[48 * v55];
              else
                v59 = (char *)malloc(48 * v55);
            }
            else
            {
              v59 = 0LL;
            }
            v72 = &v59[48 * v54];
            *((_OWORD *)v72 + 1) = 0u;
            *((_OWORD *)v72 + 2) = 0u;
            *(_OWORD *)v72 = 0u;
            v74 = *(_QWORD *)a3;
            v73 = *(_QWORD *)(a3 + 8);
            v75 = &v59[48 * v55];
            v76 = v72 + 48;
            if ( v73 == *(_QWORD *)a3 )
            {
              v78 = *(void **)a3;
            }
            else
            {
              do
              {
                *((_QWORD *)v72 - 4) = *(_QWORD *)(v73 - 32);
                *((_OWORD *)v72 - 3) = *(_OWORD *)(v73 - 48);
                v77 = *(_QWORD *)(v73 - 8);
                *(_QWORD *)(v73 - 40) = 0LL;
                *(_QWORD *)(v73 - 32) = 0LL;
                *(_QWORD *)(v73 - 48) = 0LL;
                *((_QWORD *)v72 - 1) = v77;
                *(_OWORD *)(v72 - 24) = *(_OWORD *)(v73 - 24);
                *(_QWORD *)(v73 - 16) = 0LL;
                *(_QWORD *)(v73 - 8) = 0LL;
                *(_QWORD *)(v73 - 24) = 0LL;
                v73 -= 48LL;
                v72 -= 48;
              }
              while ( v74 != v73 );
              v78 = *(void **)a3;
              v74 = *(_QWORD *)(a3 + 8);
            }
            v337 = *(_QWORD *)(a3 + 16);
            *(_QWORD *)a3 = v72;
            *(_QWORD *)(a3 + 8) = v76;
            *(_QWORD *)(a3 + 16) = v75;
            if ( (void *)v74 != v78 )
            {
              do
              {
                if ( (*(_BYTE *)(v74 - 24) & 1) != 0 )
                  free(*(void **)(v74 - 8));
                v79 = (void *)(v74 - 48);
                if ( (*(_BYTE *)(v74 - 48) & 1) != 0 )
                  free(*(void **)(v74 - 32));
                v74 -= 48LL;
              }
              while ( v78 != v79 );
            }
            v13 = v339;
            v33 = v340;
            if ( v78 )
            {
              v80 = *(_QWORD *)(a3 + 24);
              if ( v80 + 4096 < (unsigned __int64)v78 || v80 > (unsigned __int64)v78 )
              {
                free(v78);
              }
              else if ( *(_QWORD *)(v80 + 4096) == v337 )
              {
                *(_QWORD *)(v80 + 4096) = v78;
              }
            }
          }
          else
          {
            v53[1] = 0u;
            v53[2] = 0u;
            *v53 = 0u;
            *(_QWORD *)(a3 + 8) += 48LL;
          }
          if ( v4 - v32 >= 2 && *v32 == 83 && v32[1] == 116 )
          {
            v32 += 2;
            sub_A1F74((size_t *)(*(_QWORD *)(a3 + 8) - 48LL), "std", 3uLL);
          }
          if ( v32 == v4 )
          {
            v269 = *(_QWORD *)(a3 + 8);
            v270 = (_BYTE *)(v269 - 48);
            if ( (*(_BYTE *)(v269 - 24) & 1) != 0 )
              free(*(void **)(v269 - 8));
            if ( (*v270 & 1) != 0 )
              free(*(void **)(v269 - 32));
            *(_QWORD *)(a3 + 8) = v270;
            goto LABEL_634;
          }
          v336 = v13 | v33;
          LOBYTE(v81) = 0;
          v341 = 0;
          while ( 2 )
          {
            switch ( *v32 )
            {
              case 'D':
                if ( v32 + 1 != v4 && (v32[1] | 0x20) != 0x74 )
                  goto LABEL_317;
                v141 = sub_A0A48(v32, v4, (_QWORD *)a3);
                v142 = v141;
                if ( v141 == v32 || v141 == v4 )
                  goto LABEL_634;
                v143 = *(_QWORD *)(a3 + 8);
                v144 = *(unsigned __int8 *)(v143 - 24);
                v145 = (v144 & 1) == 0;
                v146 = v144 >> 1;
                if ( v145 )
                  v147 = (void *)(v143 - 23);
                else
                  v147 = *(void **)(v143 - 8);
                if ( v145 )
                  v148 = v146;
                else
                  v148 = *(_QWORD *)(v143 - 16);
                sub_9CFD0((size_t *)(v143 - 48), v147, v148);
                v347 = *(void **)(v143 - 32);
                v346 = *(_OWORD *)(v143 - 48);
                *(_QWORD *)(v143 - 40) = 0LL;
                *(_QWORD *)(v143 - 32) = 0LL;
                *(_QWORD *)(v143 - 48) = 0LL;
                v149 = *(_QWORD *)(a3 + 8);
                v150 = (_BYTE *)(v149 - 48);
                if ( (*(_BYTE *)(v149 - 24) & 1) != 0 )
                  free(*(void **)(v149 - 8));
                if ( (*v150 & 1) != 0 )
                  free(*(void **)(v149 - 32));
                v151 = *(_QWORD *)a3;
                *(_QWORD *)(a3 + 8) = v150;
                if ( (_BYTE *)v151 == v150 )
                {
                  v81 = 1;
                  if ( (v346 & 1) == 0 )
                  {
LABEL_272:
                    if ( !v81 )
                      continue;
                    goto LABEL_634;
                  }
LABEL_271:
                  free(v347);
                  goto LABEL_272;
                }
                v152 = *(unsigned __int8 *)(v149 - 96);
                if ( (v152 & 1) != 0 )
                {
                  if ( !*(_QWORD *)(v149 - 88) )
                  {
LABEL_307:
                    if ( (__int128 *)(v149 - 96) != &v346 )
                    {
                      if ( (v346 & 1) != 0 )
                        v153 = (char *)v347;
                      else
                        v153 = (char *)&v346 + 1;
                      if ( (v346 & 1) != 0 )
                        v154 = *((_QWORD *)&v346 + 1);
                      else
                        v154 = (unsigned __int64)(unsigned __int8)v346 >> 1;
                      sub_A1F74((size_t *)(v149 - 96), v153, v154);
                    }
                    goto LABEL_474;
                  }
                }
                else if ( !(v152 >> 1) )
                {
                  goto LABEL_307;
                }
                sub_9F8F0("::", (unsigned __int8 *)&v346, (size_t *)v343);
                if ( ((__int64)v343[0] & 1) != 0 )
                  v241 = v343[1];
                else
                  v241 = (void *)((unsigned __int64)LOBYTE(v343[0]) >> 1);
                if ( ((__int64)v343[0] & 1) != 0 )
                  v242 = (char *)p;
                else
                  v242 = (char *)v343 + 1;
                sub_9CFD0((size_t *)(*(_QWORD *)(a3 + 8) - 48LL), v242, (size_t)v241);
                if ( ((__int64)v343[0] & 1) != 0 )
                  free(p);
LABEL_474:
                v243 = *(_QWORD *)(a3 + 8) - 48LL;
                v342 = *(_QWORD *)(a3 + 24);
                sub_9D15C((size_t **)v343, v243, &v342);
                v244 = *(_QWORD *)(a3 + 40);
                v245 = *(_QWORD *)(a3 + 48);
                if ( v244 < v245 )
                {
                  *(_QWORD *)(v244 + 24) = v345;
                  *(_OWORD *)v244 = *(_OWORD *)v343;
                  *(_QWORD *)(v244 + 16) = p;
                  v343[1] = 0LL;
                  p = 0LL;
                  v343[0] = 0LL;
                  *(_QWORD *)(a3 + 40) += 32LL;
                  v131 = (void **)v343[0];
                  if ( !v343[0] )
                    goto LABEL_270;
                  goto LABEL_259;
                }
                v246 = *(_QWORD *)(a3 + 32);
                v247 = (__int64)(v244 - v246) >> 5;
                if ( (unsigned __int64)(v247 + 1) >> 59 )
                  abort();
                v248 = v245 - v246;
                if ( (unsigned __int64)(v248 >> 5) > 0x3FFFFFFFFFFFFFELL )
                {
                  v119 = 0x7FFFFFFFFFFFFFFLL;
                }
                else
                {
                  v249 = v248 >> 4;
                  if ( v249 >= v247 + 1 )
                    v119 = v249;
                  else
                    v119 = v247 + 1;
                  if ( !v119 )
                  {
                    v121 = 0LL;
                    goto LABEL_214;
                  }
                }
                v120 = *(_QWORD *)(a3 + 56);
                v121 = *(char **)(v120 + 4096);
                if ( v120 + 4096 - (__int64)v121 >= (unsigned __int64)(32 * v119) )
                  *(_QWORD *)(v120 + 4096) = &v121[32 * v119];
                else
                  v121 = (char *)malloc(32 * v119);
LABEL_214:
                v122 = &v121[32 * v247];
                *((_QWORD *)v122 + 1) = 0LL;
                *((_QWORD *)v122 + 2) = 0LL;
                v123 = v122 + 32;
                *((_QWORD *)v122 + 3) = v345;
                *(_OWORD *)v122 = *(_OWORD *)v343;
                *((_QWORD *)v122 + 2) = p;
                v343[1] = 0LL;
                p = 0LL;
                v343[0] = 0LL;
                v125 = *(void ***)(a3 + 32);
                v124 = *(void ***)(a3 + 40);
                v126 = &v121[32 * v119];
                if ( v124 == v125 )
                {
                  v128 = *(void ***)(a3 + 32);
                }
                else
                {
                  do
                  {
                    *((_QWORD *)v122 - 3) = 0LL;
                    *((_QWORD *)v122 - 2) = 0LL;
                    *((_QWORD *)v122 - 4) = 0LL;
                    *((_QWORD *)v122 - 1) = *(v124 - 1);
                    v127 = *((_OWORD *)v124 - 2);
                    v124 -= 4;
                    *((_OWORD *)v122 - 2) = v127;
                    *((_QWORD *)v122 - 2) = v124[2];
                    v122 -= 32;
                    v124[1] = 0LL;
                    v124[2] = 0LL;
                    *v124 = 0LL;
                  }
                  while ( v125 != v124 );
                  v128 = *(void ***)(a3 + 32);
                  v125 = *(void ***)(a3 + 40);
                }
                v129 = *(_QWORD *)(a3 + 48);
                *(_QWORD *)(a3 + 32) = v122;
                *(_QWORD *)(a3 + 40) = v123;
                *(_QWORD *)(a3 + 48) = v126;
                while ( v128 != v125 )
                {
                  v125 -= 4;
                  sub_9D32C(v125);
                }
                if ( v128 )
                {
                  v130 = *(_QWORD *)(a3 + 56);
                  if ( v130 + 4096 < (unsigned __int64)v128 || v130 > (unsigned __int64)v128 )
                  {
                    free(v128);
                  }
                  else if ( *(_QWORD *)(v130 + 4096) == v129 )
                  {
                    *(_QWORD *)(v130 + 4096) = v128;
                    v131 = (void **)v343[0];
                    if ( !v343[0] )
                      goto LABEL_270;
LABEL_259:
                    v137 = (void **)v343[1];
                    if ( v343[1] != v131 )
                    {
                      do
                      {
                        if ( (*(_BYTE *)(v137 - 3) & 1) != 0 )
                          free(*(v137 - 1));
                        v138 = v137 - 6;
                        if ( (*(_BYTE *)(v137 - 6) & 1) != 0 )
                          free(*(v137 - 4));
                        v137 -= 6;
                      }
                      while ( v131 != v138 );
                    }
                    v343[1] = v131;
                    if ( v345 + 4096 < (unsigned __int64)v131 || v345 > (unsigned __int64)v131 )
                    {
                      free(v131);
                    }
                    else if ( *(void **)(v345 + 4096) == p )
                    {
                      *(_QWORD *)(v345 + 4096) = v131;
                    }
LABEL_270:
                    v81 = 0;
                    v32 = v142;
                    v341 = 1;
                    if ( (v346 & 1) == 0 )
                      goto LABEL_272;
                    goto LABEL_271;
                  }
                }
                v131 = (void **)v343[0];
                if ( !v343[0] )
                  goto LABEL_270;
                goto LABEL_259;
              case 'E':
                v10 = v32 + 1;
                *(_DWORD *)(a3 + 96) = v336;
                if ( (v341 & 1) != 0 )
                {
                  v271 = *(_QWORD *)(a3 + 40);
                  if ( *(_QWORD *)(a3 + 32) != v271 )
                  {
                    v272 = v271 - 32;
                    sub_9D32C((void **)(v271 - 32));
                    *(_QWORD *)(a3 + 40) = v272;
                  }
                }
                if ( a4 )
                  *a4 = v81;
                goto LABEL_634;
              case 'I':
                v169 = sub_9D3DC(v32, v4, a3);
                v170 = v169;
                if ( v169 == v32 || v169 == v4 )
                  goto LABEL_634;
                v171 = *(_QWORD *)(a3 + 8);
                v172 = *(unsigned __int8 *)(v171 - 24);
                v173 = (v172 & 1) == 0;
                v174 = v172 >> 1;
                if ( v173 )
                  v175 = (void *)(v171 - 23);
                else
                  v175 = *(void **)(v171 - 8);
                if ( v173 )
                  v176 = v174;
                else
                  v176 = *(_QWORD *)(v171 - 16);
                sub_9CFD0((size_t *)(v171 - 48), v175, v176);
                v347 = *(void **)(v171 - 32);
                v346 = *(_OWORD *)(v171 - 48);
                *(_QWORD *)(v171 - 40) = 0LL;
                *(_QWORD *)(v171 - 32) = 0LL;
                *(_QWORD *)(v171 - 48) = 0LL;
                v177 = *(_QWORD *)(a3 + 8);
                v178 = (_BYTE *)(v177 - 48);
                if ( (*(_BYTE *)(v177 - 24) & 1) != 0 )
                  free(*(void **)(v177 - 8));
                if ( (*v178 & 1) != 0 )
                  free(*(void **)(v177 - 32));
                v179 = *(_QWORD *)a3;
                *(_QWORD *)(a3 + 8) = v178;
                if ( (_BYTE *)v179 == v178 )
                {
                  LOBYTE(v81) = 0;
                  v134 = 1;
                  v170 = v32;
                  if ( (v346 & 1) == 0 )
                  {
LABEL_242:
                    if ( !v134 )
                      goto LABEL_142;
                    goto LABEL_634;
                  }
LABEL_241:
                  free(v347);
                  goto LABEL_242;
                }
                if ( (v346 & 1) != 0 )
                  v180 = (char *)v347;
                else
                  v180 = (char *)&v346 + 1;
                if ( (v346 & 1) != 0 )
                  v181 = *((_QWORD *)&v346 + 1);
                else
                  v181 = (unsigned __int64)(unsigned __int8)v346 >> 1;
                sub_9CFD0((size_t *)(v177 - 96), v180, v181);
                v182 = *(_QWORD *)(a3 + 8) - 48LL;
                v342 = *(_QWORD *)(a3 + 24);
                sub_9D15C((size_t **)v343, v182, &v342);
                v183 = *(_QWORD *)(a3 + 40);
                v184 = *(_QWORD *)(a3 + 48);
                if ( v183 < v184 )
                {
                  *(_QWORD *)(v183 + 24) = v345;
                  *(_OWORD *)v183 = *(_OWORD *)v343;
                  *(_QWORD *)(v183 + 16) = p;
                  v343[1] = 0LL;
                  p = 0LL;
                  v343[0] = 0LL;
                  *(_QWORD *)(a3 + 40) += 32LL;
                  v108 = (void **)v343[0];
                  if ( !v343[0] )
                    goto LABEL_240;
                  goto LABEL_229;
                }
                v229 = *(_QWORD *)(a3 + 32);
                v230 = (__int64)(v183 - v229) >> 5;
                if ( (unsigned __int64)(v230 + 1) >> 59 )
                  abort();
                v231 = v184 - v229;
                if ( (unsigned __int64)(v231 >> 5) > 0x3FFFFFFFFFFFFFELL )
                {
                  v233 = 0x7FFFFFFFFFFFFFFLL;
                }
                else
                {
                  v232 = v231 >> 4;
                  if ( v232 >= v230 + 1 )
                    v233 = v232;
                  else
                    v233 = v230 + 1;
                  if ( !v233 )
                  {
                    v234 = 0LL;
                    goto LABEL_179;
                  }
                }
                v265 = *(_QWORD *)(a3 + 56);
                v234 = *(char **)(v265 + 4096);
                if ( v265 + 4096 - (__int64)v234 >= (unsigned __int64)(32 * v233) )
                  *(_QWORD *)(v265 + 4096) = &v234[32 * v233];
                else
                  v234 = (char *)malloc(32 * v233);
LABEL_179:
                v99 = &v234[32 * v230];
                *((_QWORD *)v99 + 1) = 0LL;
                *((_QWORD *)v99 + 2) = 0LL;
                v100 = v99 + 32;
                *((_QWORD *)v99 + 3) = v345;
                *(_OWORD *)v99 = *(_OWORD *)v343;
                *((_QWORD *)v99 + 2) = p;
                v343[1] = 0LL;
                p = 0LL;
                v343[0] = 0LL;
                v102 = *(void ***)(a3 + 32);
                v101 = *(void ***)(a3 + 40);
                v103 = &v234[32 * v233];
                if ( v101 == v102 )
                {
                  v105 = *(void ***)(a3 + 32);
                }
                else
                {
                  do
                  {
                    *((_QWORD *)v99 - 3) = 0LL;
                    *((_QWORD *)v99 - 2) = 0LL;
                    *((_QWORD *)v99 - 4) = 0LL;
                    *((_QWORD *)v99 - 1) = *(v101 - 1);
                    v104 = *((_OWORD *)v101 - 2);
                    v101 -= 4;
                    *((_OWORD *)v99 - 2) = v104;
                    *((_QWORD *)v99 - 2) = v101[2];
                    v99 -= 32;
                    v101[1] = 0LL;
                    v101[2] = 0LL;
                    *v101 = 0LL;
                  }
                  while ( v102 != v101 );
                  v105 = *(void ***)(a3 + 32);
                  v102 = *(void ***)(a3 + 40);
                }
                v106 = *(_QWORD *)(a3 + 48);
                *(_QWORD *)(a3 + 32) = v99;
                *(_QWORD *)(a3 + 40) = v100;
                *(_QWORD *)(a3 + 48) = v103;
                while ( v105 != v102 )
                {
                  v102 -= 4;
                  sub_9D32C(v102);
                }
                if ( v105 )
                {
                  v107 = *(_QWORD *)(a3 + 56);
                  if ( v107 + 4096 < (unsigned __int64)v105 || v107 > (unsigned __int64)v105 )
                  {
                    free(v105);
                  }
                  else if ( *(_QWORD *)(v107 + 4096) == v106 )
                  {
                    *(_QWORD *)(v107 + 4096) = v105;
                    v108 = (void **)v343[0];
                    if ( !v343[0] )
                      goto LABEL_240;
LABEL_229:
                    v132 = (void **)v343[1];
                    if ( v343[1] != v108 )
                    {
                      do
                      {
                        if ( (*(_BYTE *)(v132 - 3) & 1) != 0 )
                          free(*(v132 - 1));
                        v133 = v132 - 6;
                        if ( (*(_BYTE *)(v132 - 6) & 1) != 0 )
                          free(*(v132 - 4));
                        v132 -= 6;
                      }
                      while ( v108 != v133 );
                    }
                    v343[1] = v108;
                    if ( v345 + 4096 < (unsigned __int64)v108 || v345 > (unsigned __int64)v108 )
                    {
                      free(v108);
                    }
                    else if ( *(void **)(v345 + 4096) == p )
                    {
                      *(_QWORD *)(v345 + 4096) = v108;
                    }
LABEL_240:
                    v134 = 0;
                    LOBYTE(v81) = 1;
                    if ( (v346 & 1) == 0 )
                      goto LABEL_242;
                    goto LABEL_241;
                  }
                }
                v108 = (void **)v343[0];
                if ( !v343[0] )
                  goto LABEL_240;
                goto LABEL_229;
              case 'L':
                if ( v32 + 1 != v4 )
                {
                  LOBYTE(v81) = 0;
                  ++v32;
                  continue;
                }
                goto LABEL_634;
              case 'S':
                if ( v32 + 1 != v4 && v32[1] == 116 )
                  goto LABEL_317;
                v199 = sub_9E1F8(v32, v4, (void **)a3);
                v170 = v199;
                if ( v199 == v32 || v199 == v4 )
                  goto LABEL_634;
                v200 = *(_QWORD *)(a3 + 8);
                v201 = *(unsigned __int8 *)(v200 - 24);
                v202 = (v201 & 1) == 0;
                v203 = v201 >> 1;
                if ( v202 )
                  v204 = (void *)(v200 - 23);
                else
                  v204 = *(void **)(v200 - 8);
                if ( v202 )
                  v205 = v203;
                else
                  v205 = *(_QWORD *)(v200 - 16);
                sub_9CFD0((size_t *)(v200 - 48), v204, v205);
                v347 = *(void **)(v200 - 32);
                v346 = *(_OWORD *)(v200 - 48);
                *(_QWORD *)(v200 - 40) = 0LL;
                *(_QWORD *)(v200 - 32) = 0LL;
                *(_QWORD *)(v200 - 48) = 0LL;
                v206 = *(_QWORD *)(a3 + 8);
                v207 = (_BYTE *)(v206 - 48);
                if ( (*(_BYTE *)(v206 - 24) & 1) != 0 )
                  free(*(void **)(v206 - 8));
                if ( (*v207 & 1) != 0 )
                  free(*(void **)(v206 - 32));
                v208 = *(_QWORD *)a3;
                *(_QWORD *)(a3 + 8) = v207;
                if ( (_BYTE *)v208 == v207 )
                {
                  v81 = 1;
                  v170 = v32;
                  if ( (v346 & 1) == 0 )
                  {
LABEL_287:
                    if ( !v81 )
                    {
LABEL_142:
                      v32 = v170;
                      continue;
                    }
                    goto LABEL_634;
                  }
LABEL_286:
                  free(v347);
                  goto LABEL_287;
                }
                v209 = *(unsigned __int8 *)(v206 - 96);
                if ( (v209 & 1) != 0 )
                {
                  if ( !*(_QWORD *)(v206 - 88) )
                  {
LABEL_402:
                    if ( (__int128 *)(v206 - 96) != &v346 )
                    {
                      if ( (v346 & 1) != 0 )
                        v210 = (char *)v347;
                      else
                        v210 = (char *)&v346 + 1;
                      if ( (v346 & 1) != 0 )
                        v211 = *((_QWORD *)&v346 + 1);
                      else
                        v211 = (unsigned __int64)(unsigned __int8)v346 >> 1;
                      sub_A1F74((size_t *)(v206 - 96), v210, v211);
                    }
                    goto LABEL_285;
                  }
                }
                else if ( !(v209 >> 1) )
                {
                  goto LABEL_402;
                }
                sub_9F8F0("::", (unsigned __int8 *)&v346, (size_t *)v343);
                if ( ((__int64)v343[0] & 1) != 0 )
                  v251 = v343[1];
                else
                  v251 = (void *)((unsigned __int64)LOBYTE(v343[0]) >> 1);
                if ( ((__int64)v343[0] & 1) != 0 )
                  v252 = (char *)p;
                else
                  v252 = (char *)v343 + 1;
                sub_9CFD0((size_t *)(*(_QWORD *)(a3 + 8) - 48LL), v252, (size_t)v251);
                if ( ((__int64)v343[0] & 1) != 0 )
                  free(p);
                v253 = *(_QWORD *)(a3 + 8) - 48LL;
                v342 = *(_QWORD *)(a3 + 24);
                sub_9D15C((size_t **)v343, v253, &v342);
                v254 = *(_QWORD *)(a3 + 40);
                v255 = *(_QWORD *)(a3 + 48);
                if ( v254 < v255 )
                {
                  *(_QWORD *)(v254 + 24) = v345;
                  *(_OWORD *)v254 = *(_OWORD *)v343;
                  *(_QWORD *)(v254 + 16) = p;
                  v343[1] = 0LL;
                  p = 0LL;
                  v343[0] = 0LL;
                  *(_QWORD *)(a3 + 40) += 32LL;
                  v98 = (void **)v343[0];
                  if ( !v343[0] )
                    goto LABEL_285;
                  goto LABEL_274;
                }
                v82 = *(_QWORD *)(a3 + 32);
                v83 = (__int64)(v254 - v82) >> 5;
                if ( (unsigned __int64)(v83 + 1) >> 59 )
                  abort();
                v84 = v255 - v82;
                if ( (unsigned __int64)(v84 >> 5) > 0x3FFFFFFFFFFFFFELL )
                {
                  v86 = 0x7FFFFFFFFFFFFFFLL;
                }
                else
                {
                  v85 = v84 >> 4;
                  if ( v85 >= v83 + 1 )
                    v86 = v85;
                  else
                    v86 = v83 + 1;
                  if ( !v86 )
                  {
                    v87 = 0LL;
                    goto LABEL_163;
                  }
                }
                v88 = *(_QWORD *)(a3 + 56);
                v87 = *(char **)(v88 + 4096);
                if ( v88 + 4096 - (__int64)v87 >= (unsigned __int64)(32 * v86) )
                  *(_QWORD *)(v88 + 4096) = &v87[32 * v86];
                else
                  v87 = (char *)malloc(32 * v86);
LABEL_163:
                v89 = &v87[32 * v83];
                *((_QWORD *)v89 + 1) = 0LL;
                *((_QWORD *)v89 + 2) = 0LL;
                v90 = v89 + 32;
                *((_QWORD *)v89 + 3) = v345;
                *(_OWORD *)v89 = *(_OWORD *)v343;
                *((_QWORD *)v89 + 2) = p;
                v343[1] = 0LL;
                p = 0LL;
                v343[0] = 0LL;
                v92 = *(void ***)(a3 + 32);
                v91 = *(void ***)(a3 + 40);
                v93 = &v87[32 * v86];
                if ( v91 == v92 )
                {
                  v95 = *(void ***)(a3 + 32);
                }
                else
                {
                  do
                  {
                    *((_QWORD *)v89 - 3) = 0LL;
                    *((_QWORD *)v89 - 2) = 0LL;
                    *((_QWORD *)v89 - 4) = 0LL;
                    *((_QWORD *)v89 - 1) = *(v91 - 1);
                    v94 = *((_OWORD *)v91 - 2);
                    v91 -= 4;
                    *((_OWORD *)v89 - 2) = v94;
                    *((_QWORD *)v89 - 2) = v91[2];
                    v89 -= 32;
                    v91[1] = 0LL;
                    v91[2] = 0LL;
                    *v91 = 0LL;
                  }
                  while ( v92 != v91 );
                  v95 = *(void ***)(a3 + 32);
                  v92 = *(void ***)(a3 + 40);
                }
                v96 = *(_QWORD *)(a3 + 48);
                *(_QWORD *)(a3 + 32) = v89;
                *(_QWORD *)(a3 + 40) = v90;
                *(_QWORD *)(a3 + 48) = v93;
                while ( v95 != v92 )
                {
                  v92 -= 4;
                  sub_9D32C(v92);
                }
                if ( v95 )
                {
                  v97 = *(_QWORD *)(a3 + 56);
                  if ( v97 + 4096 < (unsigned __int64)v95 || v97 > (unsigned __int64)v95 )
                  {
                    free(v95);
                  }
                  else if ( *(_QWORD *)(v97 + 4096) == v96 )
                  {
                    *(_QWORD *)(v97 + 4096) = v95;
                    v98 = (void **)v343[0];
                    if ( !v343[0] )
                      goto LABEL_285;
LABEL_274:
                    v139 = (void **)v343[1];
                    if ( v343[1] != v98 )
                    {
                      do
                      {
                        if ( (*(_BYTE *)(v139 - 3) & 1) != 0 )
                          free(*(v139 - 1));
                        v140 = v139 - 6;
                        if ( (*(_BYTE *)(v139 - 6) & 1) != 0 )
                          free(*(v139 - 4));
                        v139 -= 6;
                      }
                      while ( v98 != v140 );
                    }
                    v343[1] = v98;
                    if ( v345 + 4096 < (unsigned __int64)v98 || v345 > (unsigned __int64)v98 )
                    {
                      free(v98);
                    }
                    else if ( *(void **)(v345 + 4096) == p )
                    {
                      *(_QWORD *)(v345 + 4096) = v98;
                    }
LABEL_285:
                    v81 = 0;
                    v341 = 1;
                    if ( (v346 & 1) == 0 )
                      goto LABEL_287;
                    goto LABEL_286;
                  }
                }
                v98 = (void **)v343[0];
                if ( !v343[0] )
                  goto LABEL_285;
                goto LABEL_274;
              case 'T':
                v185 = sub_9F9E8(v32, v4, a3);
                v186 = (unsigned __int8 *)v185;
                if ( (unsigned __int8 *)v185 == v32 || (unsigned __int8 *)v185 == v4 )
                  goto LABEL_634;
                v187 = *(_QWORD *)(a3 + 8);
                v188 = *(unsigned __int8 *)(v187 - 24);
                v189 = (v188 & 1) == 0;
                v190 = v188 >> 1;
                if ( v189 )
                  v191 = (void *)(v187 - 23);
                else
                  v191 = *(void **)(v187 - 8);
                if ( v189 )
                  v192 = v190;
                else
                  v192 = *(_QWORD *)(v187 - 16);
                sub_9CFD0((size_t *)(v187 - 48), v191, v192);
                v347 = *(void **)(v187 - 32);
                v346 = *(_OWORD *)(v187 - 48);
                *(_QWORD *)(v187 - 40) = 0LL;
                *(_QWORD *)(v187 - 32) = 0LL;
                *(_QWORD *)(v187 - 48) = 0LL;
                v193 = *(_QWORD *)(a3 + 8);
                v194 = (_BYTE *)(v193 - 48);
                if ( (*(_BYTE *)(v193 - 24) & 1) != 0 )
                  free(*(void **)(v193 - 8));
                if ( (*v194 & 1) != 0 )
                  free(*(void **)(v193 - 32));
                v195 = *(_QWORD *)a3;
                *(_QWORD *)(a3 + 8) = v194;
                if ( (_BYTE *)v195 == v194 )
                {
                  v81 = 1;
                  if ( (v346 & 1) == 0 )
                  {
LABEL_257:
                    if ( !v81 )
                      continue;
                    goto LABEL_634;
                  }
LABEL_256:
                  free(v347);
                  goto LABEL_257;
                }
                v196 = *(unsigned __int8 *)(v193 - 96);
                if ( (v196 & 1) != 0 )
                {
                  if ( !*(_QWORD *)(v193 - 88) )
                  {
LABEL_379:
                    if ( (__int128 *)(v193 - 96) != &v346 )
                    {
                      if ( (v346 & 1) != 0 )
                        v197 = (char *)v347;
                      else
                        v197 = (char *)&v346 + 1;
                      if ( (v346 & 1) != 0 )
                        v198 = *((_QWORD *)&v346 + 1);
                      else
                        v198 = (unsigned __int64)(unsigned __int8)v346 >> 1;
                      sub_A1F74((size_t *)(v193 - 96), v197, v198);
                    }
                    goto LABEL_444;
                  }
                }
                else if ( !(v196 >> 1) )
                {
                  goto LABEL_379;
                }
                sub_9F8F0("::", (unsigned __int8 *)&v346, (size_t *)v343);
                if ( ((__int64)v343[0] & 1) != 0 )
                  v224 = v343[1];
                else
                  v224 = (void *)((unsigned __int64)LOBYTE(v343[0]) >> 1);
                if ( ((__int64)v343[0] & 1) != 0 )
                  v225 = (char *)p;
                else
                  v225 = (char *)v343 + 1;
                sub_9CFD0((size_t *)(*(_QWORD *)(a3 + 8) - 48LL), v225, (size_t)v224);
                if ( ((__int64)v343[0] & 1) != 0 )
                  free(p);
LABEL_444:
                v226 = *(_QWORD *)(a3 + 8) - 48LL;
                v342 = *(_QWORD *)(a3 + 24);
                sub_9D15C((size_t **)v343, v226, &v342);
                v227 = *(_QWORD *)(a3 + 40);
                v228 = *(_QWORD *)(a3 + 48);
                if ( v227 < v228 )
                {
                  *(_QWORD *)(v227 + 24) = v345;
                  *(_OWORD *)v227 = *(_OWORD *)v343;
                  *(_QWORD *)(v227 + 16) = p;
                  v343[1] = 0LL;
                  p = 0LL;
                  v343[0] = 0LL;
                  *(_QWORD *)(a3 + 40) += 32LL;
                  v118 = (void **)v343[0];
                  if ( !v343[0] )
                    goto LABEL_255;
                  goto LABEL_244;
                }
                v235 = *(_QWORD *)(a3 + 32);
                v236 = (__int64)(v227 - v235) >> 5;
                if ( (unsigned __int64)(v236 + 1) >> 59 )
                  abort();
                v237 = v228 - v235;
                if ( (unsigned __int64)(v237 >> 5) > 0x3FFFFFFFFFFFFFELL )
                {
                  v239 = 0x7FFFFFFFFFFFFFFLL;
                }
                else
                {
                  v238 = v237 >> 4;
                  if ( v238 >= v236 + 1 )
                    v239 = v238;
                  else
                    v239 = v236 + 1;
                  if ( !v239 )
                  {
                    v240 = 0LL;
                    goto LABEL_195;
                  }
                }
                v266 = *(_QWORD *)(a3 + 56);
                v240 = *(char **)(v266 + 4096);
                if ( v266 + 4096 - (__int64)v240 >= (unsigned __int64)(32 * v239) )
                  *(_QWORD *)(v266 + 4096) = &v240[32 * v239];
                else
                  v240 = (char *)malloc(32 * v239);
LABEL_195:
                v109 = &v240[32 * v236];
                *((_QWORD *)v109 + 1) = 0LL;
                *((_QWORD *)v109 + 2) = 0LL;
                v110 = v109 + 32;
                *((_QWORD *)v109 + 3) = v345;
                *(_OWORD *)v109 = *(_OWORD *)v343;
                *((_QWORD *)v109 + 2) = p;
                v343[1] = 0LL;
                p = 0LL;
                v343[0] = 0LL;
                v112 = *(void ***)(a3 + 32);
                v111 = *(void ***)(a3 + 40);
                v113 = &v240[32 * v239];
                if ( v111 == v112 )
                {
                  v115 = *(void ***)(a3 + 32);
                }
                else
                {
                  do
                  {
                    *((_QWORD *)v109 - 3) = 0LL;
                    *((_QWORD *)v109 - 2) = 0LL;
                    *((_QWORD *)v109 - 4) = 0LL;
                    *((_QWORD *)v109 - 1) = *(v111 - 1);
                    v114 = *((_OWORD *)v111 - 2);
                    v111 -= 4;
                    *((_OWORD *)v109 - 2) = v114;
                    *((_QWORD *)v109 - 2) = v111[2];
                    v109 -= 32;
                    v111[1] = 0LL;
                    v111[2] = 0LL;
                    *v111 = 0LL;
                  }
                  while ( v112 != v111 );
                  v115 = *(void ***)(a3 + 32);
                  v112 = *(void ***)(a3 + 40);
                }
                v116 = *(_QWORD *)(a3 + 48);
                *(_QWORD *)(a3 + 32) = v109;
                *(_QWORD *)(a3 + 40) = v110;
                *(_QWORD *)(a3 + 48) = v113;
                while ( v115 != v112 )
                {
                  v112 -= 4;
                  sub_9D32C(v112);
                }
                if ( v115 )
                {
                  v117 = *(_QWORD *)(a3 + 56);
                  if ( v117 + 4096 < (unsigned __int64)v115 || v117 > (unsigned __int64)v115 )
                  {
                    free(v115);
                  }
                  else if ( *(_QWORD *)(v117 + 4096) == v116 )
                  {
                    *(_QWORD *)(v117 + 4096) = v115;
                    v118 = (void **)v343[0];
                    if ( !v343[0] )
                      goto LABEL_255;
LABEL_244:
                    v135 = (void **)v343[1];
                    if ( v343[1] != v118 )
                    {
                      do
                      {
                        if ( (*(_BYTE *)(v135 - 3) & 1) != 0 )
                          free(*(v135 - 1));
                        v136 = v135 - 6;
                        if ( (*(_BYTE *)(v135 - 6) & 1) != 0 )
                          free(*(v135 - 4));
                        v135 -= 6;
                      }
                      while ( v118 != v136 );
                    }
                    v343[1] = v118;
                    if ( v345 + 4096 < (unsigned __int64)v118 || v345 > (unsigned __int64)v118 )
                    {
                      free(v118);
                    }
                    else if ( *(void **)(v345 + 4096) == p )
                    {
                      *(_QWORD *)(v345 + 4096) = v118;
                    }
LABEL_255:
                    v81 = 0;
                    v32 = v186;
                    v341 = 1;
                    if ( (v346 & 1) == 0 )
                      goto LABEL_257;
                    goto LABEL_256;
                  }
                }
                v118 = (void **)v343[0];
                if ( !v343[0] )
                  goto LABEL_255;
                goto LABEL_244;
              default:
LABEL_317:
                v155 = sub_A0C94(v32, v4, (char **)a3);
                v156 = (unsigned __int8 *)v155;
                if ( (unsigned __int8 *)v155 == v32 || (unsigned __int8 *)v155 == v4 )
                  goto LABEL_634;
                v157 = *(_QWORD *)(a3 + 8);
                v158 = *(unsigned __int8 *)(v157 - 24);
                v159 = (v158 & 1) == 0;
                v160 = v158 >> 1;
                if ( v159 )
                  v161 = (void *)(v157 - 23);
                else
                  v161 = *(void **)(v157 - 8);
                if ( v159 )
                  v162 = v160;
                else
                  v162 = *(_QWORD *)(v157 - 16);
                sub_9CFD0((size_t *)(v157 - 48), v161, v162);
                v347 = *(void **)(v157 - 32);
                v346 = *(_OWORD *)(v157 - 48);
                *(_QWORD *)(v157 - 40) = 0LL;
                *(_QWORD *)(v157 - 32) = 0LL;
                *(_QWORD *)(v157 - 48) = 0LL;
                v163 = *(_QWORD *)(a3 + 8);
                v164 = (_BYTE *)(v163 - 48);
                if ( (*(_BYTE *)(v163 - 24) & 1) != 0 )
                  free(*(void **)(v163 - 8));
                if ( (*v164 & 1) != 0 )
                  free(*(void **)(v163 - 32));
                v165 = *(_QWORD *)a3;
                *(_QWORD *)(a3 + 8) = v164;
                if ( (_BYTE *)v165 == v164 )
                {
                  v81 = 1;
                  if ( (v346 & 1) == 0 )
                  {
LABEL_150:
                    if ( !v81 )
                      continue;
                    goto LABEL_634;
                  }
LABEL_149:
                  free(v347);
                  goto LABEL_150;
                }
                v166 = *(unsigned __int8 *)(v163 - 96);
                if ( (v166 & 1) != 0 )
                {
                  if ( !*(_QWORD *)(v163 - 88) )
                  {
LABEL_332:
                    if ( (__int128 *)(v163 - 96) != &v346 )
                    {
                      if ( (v346 & 1) != 0 )
                        v167 = (char *)v347;
                      else
                        v167 = (char *)&v346 + 1;
                      if ( (v346 & 1) != 0 )
                        v168 = *((_QWORD *)&v346 + 1);
                      else
                        v168 = (unsigned __int64)(unsigned __int8)v346 >> 1;
                      sub_A1F74((size_t *)(v163 - 96), v167, v168);
                    }
                    goto LABEL_421;
                  }
                }
                else if ( !(v166 >> 1) )
                {
                  goto LABEL_332;
                }
                sub_9F8F0("::", (unsigned __int8 *)&v346, (size_t *)v343);
                if ( ((__int64)v343[0] & 1) != 0 )
                  v212 = v343[1];
                else
                  v212 = (void *)((unsigned __int64)LOBYTE(v343[0]) >> 1);
                if ( ((__int64)v343[0] & 1) != 0 )
                  v213 = (char *)p;
                else
                  v213 = (char *)v343 + 1;
                sub_9CFD0((size_t *)(*(_QWORD *)(a3 + 8) - 48LL), v213, (size_t)v212);
                if ( ((__int64)v343[0] & 1) != 0 )
                  free(p);
LABEL_421:
                v214 = *(_QWORD *)(a3 + 8) - 48LL;
                v342 = *(_QWORD *)(a3 + 24);
                sub_9D15C((size_t **)v343, v214, &v342);
                v215 = *(_QWORD *)(a3 + 40);
                v216 = *(_QWORD *)(a3 + 48);
                if ( v215 < v216 )
                {
                  *(_QWORD *)(v215 + 24) = v345;
                  *(_OWORD *)v215 = *(_OWORD *)v343;
                  *(_QWORD *)(v215 + 16) = p;
                  v343[1] = 0LL;
                  p = 0LL;
                  v343[0] = 0LL;
                  *(_QWORD *)(a3 + 40) += 32LL;
                  v217 = (void **)v343[0];
                  if ( !v343[0] )
                    goto LABEL_148;
                  goto LABEL_520;
                }
                v218 = *(_QWORD *)(a3 + 32);
                v219 = (__int64)(v215 - v218) >> 5;
                if ( (unsigned __int64)(v219 + 1) >> 59 )
                  abort();
                v220 = v216 - v218;
                if ( (unsigned __int64)(v220 >> 5) > 0x3FFFFFFFFFFFFFELL )
                {
                  v222 = 0x7FFFFFFFFFFFFFFLL;
                }
                else
                {
                  v221 = v220 >> 4;
                  if ( v221 >= v219 + 1 )
                    v222 = v221;
                  else
                    v222 = v219 + 1;
                  if ( !v222 )
                  {
                    v223 = 0LL;
LABEL_500:
                    v256 = &v223[32 * v219];
                    *((_QWORD *)v256 + 1) = 0LL;
                    *((_QWORD *)v256 + 2) = 0LL;
                    v257 = v256 + 32;
                    *((_QWORD *)v256 + 3) = v345;
                    *(_OWORD *)v256 = *(_OWORD *)v343;
                    *((_QWORD *)v256 + 2) = p;
                    v343[1] = 0LL;
                    p = 0LL;
                    v343[0] = 0LL;
                    v259 = *(void ***)(a3 + 32);
                    v258 = *(void ***)(a3 + 40);
                    v260 = &v223[32 * v222];
                    if ( v258 == v259 )
                    {
                      v262 = *(void ***)(a3 + 32);
                    }
                    else
                    {
                      do
                      {
                        *((_QWORD *)v256 - 3) = 0LL;
                        *((_QWORD *)v256 - 2) = 0LL;
                        *((_QWORD *)v256 - 4) = 0LL;
                        *((_QWORD *)v256 - 1) = *(v258 - 1);
                        v261 = *((_OWORD *)v258 - 2);
                        v258 -= 4;
                        *((_OWORD *)v256 - 2) = v261;
                        *((_QWORD *)v256 - 2) = v258[2];
                        v256 -= 32;
                        v258[1] = 0LL;
                        v258[2] = 0LL;
                        *v258 = 0LL;
                      }
                      while ( v259 != v258 );
                      v262 = *(void ***)(a3 + 32);
                      v259 = *(void ***)(a3 + 40);
                    }
                    v263 = *(_QWORD *)(a3 + 48);
                    *(_QWORD *)(a3 + 32) = v256;
                    *(_QWORD *)(a3 + 40) = v257;
                    *(_QWORD *)(a3 + 48) = v260;
                    while ( v262 != v259 )
                    {
                      v259 -= 4;
                      sub_9D32C(v259);
                    }
                    if ( v262 )
                    {
                      v264 = *(_QWORD *)(a3 + 56);
                      if ( v264 + 4096 < (unsigned __int64)v262 || v264 > (unsigned __int64)v262 )
                      {
                        free(v262);
                      }
                      else if ( *(_QWORD *)(v264 + 4096) == v263 )
                      {
                        *(_QWORD *)(v264 + 4096) = v262;
                        v217 = (void **)v343[0];
                        if ( !v343[0] )
                          goto LABEL_148;
                        goto LABEL_520;
                      }
                    }
                    v217 = (void **)v343[0];
                    if ( !v343[0] )
                      goto LABEL_148;
LABEL_520:
                    v267 = (void **)v343[1];
                    if ( v343[1] != v217 )
                    {
                      do
                      {
                        if ( (*(_BYTE *)(v267 - 3) & 1) != 0 )
                          free(*(v267 - 1));
                        v268 = v267 - 6;
                        if ( (*(_BYTE *)(v267 - 6) & 1) != 0 )
                          free(*(v267 - 4));
                        v267 -= 6;
                      }
                      while ( v217 != v268 );
                    }
                    v343[1] = v217;
                    if ( v345 + 4096 < (unsigned __int64)v217 || v345 > (unsigned __int64)v217 )
                    {
                      free(v217);
                    }
                    else if ( *(void **)(v345 + 4096) == p )
                    {
                      *(_QWORD *)(v345 + 4096) = v217;
                    }
LABEL_148:
                    v81 = 0;
                    v32 = v156;
                    v341 = 1;
                    if ( (v346 & 1) == 0 )
                      goto LABEL_150;
                    goto LABEL_149;
                  }
                }
                v250 = *(_QWORD *)(a3 + 56);
                v223 = *(char **)(v250 + 4096);
                if ( v250 + 4096 - (__int64)v223 >= (unsigned __int64)(32 * v222) )
                  *(_QWORD *)(v250 + 4096) = &v223[32 * v222];
                else
                  v223 = (char *)malloc(32 * v222);
                goto LABEL_500;
            }
          }
        }
        v35 = 1;
      }
      ++v32;
      *(_DWORD *)(a3 + 100) = v35;
      goto LABEL_85;
    }
    goto LABEL_633;
  }
  if ( a2 - v8 >= 2 )
  {
    if ( v9 == 83 && v8[1] == 116 )
    {
      v19 = a4;
      if ( v8 + 2 == a2 )
      {
        v20 = 0;
        v21 = a2;
      }
      else
      {
        v20 = 0;
        if ( v8[2] == 76 )
          v21 = v8 + 3;
        else
          v21 = v8 + 2;
      }
    }
    else
    {
      v19 = a4;
      v20 = 1;
      v21 = v8;
    }
    v22 = sub_A0C94(v21, a2, (char **)a3);
    v23 = (unsigned __int8 *)v22;
    v24 = v22 == (_QWORD)v21;
    if ( (unsigned __int8 *)v22 == v21 )
      v25 = v8;
    else
      v25 = (unsigned __int8 *)v22;
    if ( (v20 & 1) != 0 )
    {
      v6 = v19;
      if ( v25 != v8 )
      {
LABEL_39:
        if ( v25 != v4 )
        {
          if ( *v25 == 73 )
          {
            v27 = *(_QWORD *)(a3 + 8);
            if ( *(_QWORD *)a3 == v27 )
              return v5;
            *(_QWORD *)&v346 = *(_QWORD *)(a3 + 24);
            sub_9D15C((size_t **)v343, v27 - 48, (__int64 *)&v346);
            v28 = *(_QWORD *)(a3 + 40);
            v29 = *(_QWORD *)(a3 + 48);
            if ( v28 < v29 )
            {
              *(_QWORD *)(v28 + 24) = v345;
              *(_OWORD *)v28 = *(_OWORD *)v343;
              *(_QWORD *)(v28 + 16) = p;
              v343[1] = 0LL;
              p = 0LL;
              v343[0] = 0LL;
              *(_QWORD *)(a3 + 40) += 32LL;
              v30 = (void **)v343[0];
              if ( !v343[0] )
                goto LABEL_571;
              goto LABEL_560;
            }
            v66 = *(_QWORD *)(a3 + 32);
            v67 = (__int64)(v28 - v66) >> 5;
            if ( (unsigned __int64)(v67 + 1) >> 59 )
              abort();
            v68 = v29 - v66;
            if ( (unsigned __int64)(v68 >> 5) > 0x3FFFFFFFFFFFFFELL )
            {
              v70 = 0x7FFFFFFFFFFFFFFLL;
            }
            else
            {
              v69 = v68 >> 4;
              if ( v69 >= v67 + 1 )
                v70 = v69;
              else
                v70 = v67 + 1;
              if ( !v70 )
              {
                v71 = 0LL;
LABEL_546:
                v276 = &v71[32 * v67];
                *((_QWORD *)v276 + 1) = 0LL;
                *((_QWORD *)v276 + 2) = 0LL;
                v277 = v276 + 32;
                *((_QWORD *)v276 + 3) = v345;
                *(_OWORD *)v276 = *(_OWORD *)v343;
                *((_QWORD *)v276 + 2) = p;
                v343[1] = 0LL;
                p = 0LL;
                v343[0] = 0LL;
                v279 = *(void ***)(a3 + 32);
                v278 = *(void ***)(a3 + 40);
                v280 = &v71[32 * v70];
                if ( v278 == v279 )
                {
                  v282 = *(void ***)(a3 + 32);
                }
                else
                {
                  do
                  {
                    *((_QWORD *)v276 - 3) = 0LL;
                    *((_QWORD *)v276 - 2) = 0LL;
                    *((_QWORD *)v276 - 4) = 0LL;
                    *((_QWORD *)v276 - 1) = *(v278 - 1);
                    v281 = *((_OWORD *)v278 - 2);
                    v278 -= 4;
                    *((_OWORD *)v276 - 2) = v281;
                    *((_QWORD *)v276 - 2) = v278[2];
                    v276 -= 32;
                    v278[1] = 0LL;
                    v278[2] = 0LL;
                    *v278 = 0LL;
                  }
                  while ( v279 != v278 );
                  v282 = *(void ***)(a3 + 32);
                  v279 = *(void ***)(a3 + 40);
                }
                v283 = *(_QWORD *)(a3 + 48);
                *(_QWORD *)(a3 + 32) = v276;
                *(_QWORD *)(a3 + 40) = v277;
                *(_QWORD *)(a3 + 48) = v280;
                while ( v282 != v279 )
                {
                  v279 -= 4;
                  sub_9D32C(v279);
                }
                if ( v282 )
                {
                  v284 = *(_QWORD *)(a3 + 56);
                  if ( v284 + 4096 < (unsigned __int64)v282 || v284 > (unsigned __int64)v282 )
                  {
                    free(v282);
                  }
                  else if ( *(_QWORD *)(v284 + 4096) == v283 )
                  {
                    *(_QWORD *)(v284 + 4096) = v282;
                    v30 = (void **)v343[0];
                    if ( !v343[0] )
                      goto LABEL_571;
                    goto LABEL_560;
                  }
                }
                v30 = (void **)v343[0];
                if ( !v343[0] )
                  goto LABEL_571;
LABEL_560:
                v285 = (void **)v343[1];
                if ( v343[1] != v30 )
                {
                  do
                  {
                    if ( (*(_BYTE *)(v285 - 3) & 1) != 0 )
                      free(*(v285 - 1));
                    v286 = v285 - 6;
                    if ( (*(_BYTE *)(v285 - 6) & 1) != 0 )
                      free(*(v285 - 4));
                    v285 -= 6;
                  }
                  while ( v30 != v286 );
                }
                v343[1] = v30;
                if ( v345 + 4096 < (unsigned __int64)v30 || v345 > (unsigned __int64)v30 )
                {
                  free(v30);
                }
                else if ( *(void **)(v345 + 4096) == p )
                {
                  *(_QWORD *)(v345 + 4096) = v30;
                }
LABEL_571:
                v4 = sub_9D3DC(v25, v4, a3);
                if ( v4 != v25 )
                {
                  v287 = *(_QWORD *)(a3 + 8);
                  if ( 0xAAAAAAAAAAAAAAABLL * ((v287 - *(_QWORD *)a3) >> 4) < 2 )
                    return v5;
                  v288 = *(unsigned __int8 *)(v287 - 24);
                  v289 = (v288 & 1) == 0;
                  v290 = v288 >> 1;
                  if ( v289 )
                    v291 = (void *)(v287 - 23);
                  else
                    v291 = *(void **)(v287 - 8);
                  if ( v289 )
                    v292 = v290;
                  else
                    v292 = *(_QWORD *)(v287 - 16);
                  sub_9CFD0((size_t *)(v287 - 48), v291, v292);
                  p = *(void **)(v287 - 32);
                  *(_OWORD *)v343 = *(_OWORD *)(v287 - 48);
                  *(_QWORD *)(v287 - 40) = 0LL;
                  *(_QWORD *)(v287 - 32) = 0LL;
                  *(_QWORD *)(v287 - 48) = 0LL;
                  v293 = *(_QWORD *)(a3 + 8);
                  v294 = (_BYTE *)(v293 - 48);
                  if ( (*(_BYTE *)(v293 - 24) & 1) != 0 )
                    free(*(void **)(v293 - 8));
                  if ( (*v294 & 1) != 0 )
                    free(*(void **)(v293 - 32));
                  v295 = *(_QWORD *)a3;
                  *(_QWORD *)(a3 + 8) = v294;
                  if ( (_BYTE *)v295 != v294 )
                  {
                    v296 = (size_t *)(v293 - 96);
                    v48 = (char)v343[0];
                    if ( ((__int64)v343[0] & 1) != 0 )
                      v297 = (char *)p;
                    else
                      v297 = (char *)v343 + 1;
                    if ( ((__int64)v343[0] & 1) != 0 )
                      v298 = v343[1];
                    else
                      v298 = (void *)((unsigned __int64)LOBYTE(v343[0]) >> 1);
                    sub_9CFD0(v296, v297, (size_t)v298);
                    if ( !v6 )
                      goto LABEL_591;
LABEL_79:
                    v51 = 0;
                    *v6 = 1;
                    if ( (v48 & 1) == 0 )
                      goto LABEL_81;
                    goto LABEL_80;
                  }
LABEL_594:
                  v51 = 1;
                  v4 = v5;
                  if ( ((__int64)v343[0] & 1) == 0 )
                    goto LABEL_81;
LABEL_80:
                  free(p);
                  goto LABEL_81;
                }
                return v5;
              }
            }
            v273 = *(_QWORD *)(a3 + 56);
            v71 = *(char **)(v273 + 4096);
            if ( v273 + 4096 - (__int64)v71 >= (unsigned __int64)(32 * v70) )
              *(_QWORD *)(v273 + 4096) = &v71[32 * v70];
            else
              v71 = (char *)malloc(32 * v70);
            goto LABEL_546;
          }
          return v25;
        }
        return v4;
      }
    }
    else
    {
      v6 = v19;
      if ( !v24 )
      {
        v26 = *(_QWORD *)(a3 + 8);
        if ( *(_QWORD *)a3 == v26 )
          goto LABEL_56;
        sub_9CDD8((size_t *)(v26 - 48), 0LL, "std::", 5uLL);
        v25 = v23;
      }
      if ( v25 != v8 )
        goto LABEL_39;
    }
  }
LABEL_56:
  v36 = sub_9E1F8(v8, v4, (void **)a3);
  v37 = v36;
  if ( v36 == v8 )
    return v5;
  if ( v36 == v4 )
    return v5;
  if ( *v36 != 73 )
    return v5;
  v4 = sub_9D3DC(v36, v4, a3);
  if ( v4 == v37 )
    return v5;
  v38 = *(_QWORD *)(a3 + 8);
  if ( 0xAAAAAAAAAAAAAAABLL * ((v38 - *(_QWORD *)a3) >> 4) < 2 )
    return v5;
  v39 = *(unsigned __int8 *)(v38 - 24);
  v40 = (v39 & 1) == 0;
  v41 = v39 >> 1;
  if ( v40 )
    v42 = (void *)(v38 - 23);
  else
    v42 = *(void **)(v38 - 8);
  if ( v40 )
    v43 = v41;
  else
    v43 = *(_QWORD *)(v38 - 16);
  sub_9CFD0((size_t *)(v38 - 48), v42, v43);
  p = *(void **)(v38 - 32);
  *(_OWORD *)v343 = *(_OWORD *)(v38 - 48);
  *(_QWORD *)(v38 - 40) = 0LL;
  *(_QWORD *)(v38 - 32) = 0LL;
  *(_QWORD *)(v38 - 48) = 0LL;
  v44 = *(_QWORD *)(a3 + 8);
  v45 = (_BYTE *)(v44 - 48);
  if ( (*(_BYTE *)(v44 - 24) & 1) != 0 )
    free(*(void **)(v44 - 8));
  if ( (*v45 & 1) != 0 )
    free(*(void **)(v44 - 32));
  v46 = *(_QWORD *)a3;
  *(_QWORD *)(a3 + 8) = v45;
  if ( (_BYTE *)v46 == v45 )
    goto LABEL_594;
  v47 = (size_t *)(v44 - 96);
  v48 = (char)v343[0];
  if ( ((__int64)v343[0] & 1) != 0 )
    v49 = (char *)p;
  else
    v49 = (char *)v343 + 1;
  if ( ((__int64)v343[0] & 1) != 0 )
    v50 = v343[1];
  else
    v50 = (void *)((unsigned __int64)LOBYTE(v343[0]) >> 1);
  sub_9CFD0(v47, v49, (size_t)v50);
  if ( v6 )
    goto LABEL_79;
LABEL_591:
  v51 = 0;
  if ( (v48 & 1) != 0 )
    goto LABEL_80;
LABEL_81:
  if ( !v51 )
    return v4;
  return v5;
}

//----- (000000000009CDD8) ----------------------------------------------------
size_t *__fastcall sub_9CDD8(size_t *a1, size_t a2, char *src, size_t n)
{
  size_t v5; // x8
  char *v7; // x21
  size_t v9; // x24
  size_t v10; // x22
  unsigned __int64 v11; // x28
  unsigned __int64 v12; // x24
  char *v13; // x8
  char *v14; // x25
  char *v15; // x23
  unsigned __int64 v16; // x8
  size_t v17; // x25
  size_t v19; // x8
  char *v20; // x8
  char *v21; // x0
  char *v22; // x26
  char *srca; // [xsp+8h] [xbp-58h]

  v5 = *(unsigned __int8 *)a1;
  v7 = src;
  if ( (v5 & 1) != 0 )
  {
    v9 = a1[1];
    v10 = v9 - a2;
    if ( v9 < a2 )
      goto LABEL_44;
  }
  else
  {
    v9 = v5 >> 1;
    v10 = (v5 >> 1) - a2;
    if ( v5 >> 1 < a2 )
LABEL_44:
      abort();
  }
  if ( (v5 & 1) != 0 )
  {
    v5 = *a1;
    v11 = (*a1 & 0xFFFFFFFFFFFFFFFELL) - 1;
  }
  else
  {
    v11 = 22LL;
  }
  if ( v11 - v9 < n )
  {
    v12 = v9 + n;
    if ( -18LL - v11 < v12 - v11 )
      goto LABEL_44;
    if ( (v5 & 1) != 0 )
      v13 = (char *)a1[2];
    else
      v13 = (char *)a1 + 1;
    srca = v13;
    if ( v11 > 0x7FFFFFFFFFFFFFE6LL )
    {
      v17 = -17LL;
    }
    else
    {
      v16 = 2 * v11;
      if ( v12 >= 2 * v11 )
        v16 = v12;
      if ( v16 >= 0x17 )
        v17 = (v16 + 16) & 0xFFFFFFFFFFFFFFF0LL;
      else
        v17 = 23LL;
    }
    v21 = (char *)malloc(v17);
    v22 = v21;
    if ( a2 )
      memcpy(v21, srca, a2);
    memcpy(&v22[a2], v7, n);
    if ( v10 )
      memcpy(&v22[a2 + n], &srca[a2], v10);
    if ( v11 != 22 )
      free(srca);
    *a1 = v17 | 1;
    v20 = &v22[v12];
    a1[1] = v12;
    a1[2] = (size_t)v22;
    goto LABEL_42;
  }
  if ( n )
  {
    if ( (v5 & 1) != 0 )
    {
      v14 = (char *)a1[2];
      v15 = &v14[a2];
      if ( !v10 )
      {
LABEL_30:
        memmove(v15, v7, n);
        v19 = v9 + n;
        if ( (*(_BYTE *)a1 & 1) != 0 )
          a1[1] = v19;
        else
          *(_BYTE *)a1 = 2 * v19;
        v20 = &v14[v19];
LABEL_42:
        *v20 = 0;
        return a1;
      }
    }
    else
    {
      v14 = (char *)a1 + 1;
      v15 = (char *)a1 + a2 + 1;
      if ( !v10 )
        goto LABEL_30;
    }
    if ( &v14[v9] > src && v15 <= src )
      v7 = &src[n];
    memmove(&v15[n], v15, v10);
    goto LABEL_30;
  }
  return a1;
}

//----- (000000000009CFD0) ----------------------------------------------------
size_t *__fastcall sub_9CFD0(size_t *a1, void *src, size_t n)
{
  size_t v4; // x8
  unsigned __int64 v7; // x26
  size_t v8; // x22
  unsigned __int64 v9; // x27
  void *v10; // x23
  size_t v11; // x23
  unsigned __int64 v12; // x8
  size_t v13; // x24
  __int64 v14; // x8
  char *v15; // x8
  char *v16; // x0
  char *v17; // x25

  LOBYTE(v4) = *(_BYTE *)a1;
  if ( (*(_BYTE *)a1 & 1) != 0 )
  {
    v4 = *a1;
    v7 = (*a1 & 0xFFFFFFFFFFFFFFFELL) - 1;
    if ( (*a1 & 1) != 0 )
    {
      v8 = a1[1];
      goto LABEL_6;
    }
  }
  else
  {
    v7 = 22LL;
  }
  v8 = (unsigned __int64)((unsigned __int8)v4 & 0xFE) >> 1;
LABEL_6:
  if ( v7 - v8 < n )
  {
    v9 = v8 + n;
    if ( -18LL - v7 < v8 + n - v7 )
      abort();
    if ( (v4 & 1) != 0 )
      v10 = (void *)a1[2];
    else
      v10 = (char *)a1 + 1;
    if ( v7 > 0x7FFFFFFFFFFFFFE6LL )
    {
      v13 = -17LL;
    }
    else
    {
      v12 = 2 * v7;
      if ( v9 >= 2 * v7 )
        v12 = v8 + n;
      if ( v12 >= 0x17 )
        v13 = (v12 + 16) & 0xFFFFFFFFFFFFFFF0LL;
      else
        v13 = 23LL;
    }
    v16 = (char *)malloc(v13);
    v17 = v16;
    if ( v8 )
      memcpy(v16, v10, v8);
    memcpy(&v17[v8], src, n);
    if ( v7 != 22 )
      free(v10);
    *a1 = v13 | 1;
    v15 = &v17[v9];
    a1[1] = v9;
    a1[2] = (size_t)v17;
    goto LABEL_31;
  }
  if ( n )
  {
    if ( (v4 & 1) != 0 )
      v11 = a1[2];
    else
      v11 = (size_t)a1 + 1;
    memcpy((void *)(v11 + v8), src, n);
    v14 = v8 + n;
    if ( (*(_BYTE *)a1 & 1) != 0 )
      a1[1] = v14;
    else
      *(_BYTE *)a1 = 2 * v14;
    v15 = (char *)(v11 + v14);
LABEL_31:
    *v15 = 0;
  }
  return a1;
}

//----- (000000000009D15C) ----------------------------------------------------
size_t **__fastcall sub_9D15C(size_t **result, __int64 a2, __int64 *a3)
{
  size_t **v3; // x19
  size_t *v4; // x8
  size_t *v6; // x20
  size_t v7; // x22
  const void *v8; // x23
  void *v9; // x24
  size_t v10; // x22
  const void *v11; // x21
  void *v12; // x23

  v3 = result;
  result[1] = 0LL;
  result[2] = 0LL;
  *result = 0LL;
  v4 = (size_t *)*a3;
  result[3] = (size_t *)*a3;
  v6 = (size_t *)v4[512];
  if ( (unsigned __int64)((char *)(v4 + 512) - (char *)v6) >= 0x30 )
  {
    v4[512] = (size_t)(v6 + 6);
  }
  else
  {
    result = (size_t **)malloc(0x30uLL);
    v6 = (size_t *)result;
  }
  *v3 = v6;
  v3[1] = v6;
  v3[2] = v6 + 6;
  v6[1] = 0LL;
  v6[2] = 0LL;
  *v6 = 0LL;
  if ( (*(_BYTE *)a2 & 1) == 0 )
  {
    v6[2] = *(_QWORD *)(a2 + 16);
    *(_OWORD *)v6 = *(_OWORD *)a2;
    goto LABEL_13;
  }
  v7 = *(_QWORD *)(a2 + 8);
  if ( v7 >= 0xFFFFFFFFFFFFFFF0LL )
    abort();
  v8 = *(const void **)(a2 + 16);
  if ( v7 >= 0x17 )
  {
    v9 = malloc((v7 + 16) & 0xFFFFFFFFFFFFFFF0LL);
    v6[1] = v7;
    v6[2] = (size_t)v9;
    *v6 = (v7 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
  }
  else
  {
    *(_BYTE *)v6 = 2 * v7;
    v9 = (char *)v6 + 1;
    if ( !v7 )
      goto LABEL_12;
  }
  result = (size_t **)memcpy(v9, v8, v7);
LABEL_12:
  *((_BYTE *)v9 + v7) = 0;
LABEL_13:
  v6[3] = 0LL;
  v6[4] = 0LL;
  v6[5] = 0LL;
  if ( (*(_BYTE *)(a2 + 24) & 1) != 0 )
  {
    v10 = *(_QWORD *)(a2 + 32);
    if ( v10 >= 0xFFFFFFFFFFFFFFF0LL )
      abort();
    v11 = *(const void **)(a2 + 40);
    if ( v10 >= 0x17 )
    {
      v12 = malloc((v10 + 16) & 0xFFFFFFFFFFFFFFF0LL);
      v6[4] = v10;
      v6[5] = (size_t)v12;
      v6[3] = (v10 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
    }
    else
    {
      v12 = (char *)v6 + 25;
      *((_BYTE *)v6 + 24) = 2 * v10;
      if ( !v10 )
        goto LABEL_21;
    }
    result = (size_t **)memcpy(v12, v11, v10);
LABEL_21:
    *((_BYTE *)v12 + v10) = 0;
    goto LABEL_22;
  }
  v6[5] = *(_QWORD *)(a2 + 40);
  *(_OWORD *)(v6 + 3) = *(_OWORD *)(a2 + 24);
LABEL_22:
  v3[1] += 6;
  return result;
}

//----- (000000000009D32C) ----------------------------------------------------
void __fastcall sub_9D32C(void **a1)
{
  void **v2; // x20
  void **v3; // x21
  void *v4; // x0
  void **v5; // x22
  unsigned __int64 v6; // x8

  v2 = (void **)*a1;
  if ( *a1 )
  {
    v3 = (void **)a1[1];
    v4 = *a1;
    if ( v3 != v2 )
    {
      do
      {
        if ( (*(_BYTE *)(v3 - 3) & 1) != 0 )
          free(*(v3 - 1));
        v5 = v3 - 6;
        if ( (*(_BYTE *)(v3 - 6) & 1) != 0 )
          free(*(v3 - 4));
        v3 -= 6;
      }
      while ( v2 != v5 );
      v4 = *a1;
    }
    v6 = (unsigned __int64)a1[3];
    a1[1] = v2;
    if ( v6 + 4096 < (unsigned __int64)v4 || v6 > (unsigned __int64)v4 )
    {
      free(v4);
    }
    else if ( *(void **)(v6 + 4096) == a1[2] )
    {
      *(_QWORD *)(v6 + 4096) = v4;
    }
  }
}

//----- (000000000009D3DC) ----------------------------------------------------
_BYTE *__fastcall sub_9D3DC(_BYTE *a1, _BYTE *a2, __int64 a3)
{
  __int64 v3; // x27
  __int64 v4; // x19
  void **v5; // x20
  void **i; // x21
  _BYTE *v7; // x24
  unsigned __int64 v8; // x10
  char *v9; // x9
  unsigned __int64 v10; // x8
  unsigned __int64 v11; // x12
  char *v12; // x8
  unsigned __int64 v13; // x9
  _BYTE *v14; // x19
  _QWORD *v16; // x8
  unsigned __int64 v17; // x9
  __int64 v18; // x19
  __int64 v19; // x10
  __int64 v20; // x20
  __int64 v21; // x9
  unsigned __int64 v22; // x9
  __int64 v23; // x21
  size_t v24; // x8
  char *v25; // x0
  char *v26; // x8
  char *v27; // x10
  _QWORD *v28; // x11
  _QWORD *v29; // x9
  _QWORD *v30; // x12
  __int128 v31; // t1
  __int64 v32; // x12
  char *v33; // x8
  void **v34; // x19
  __int64 v35; // x20
  void **v36; // x21
  __int64 v37; // x22
  __int64 v38; // x26
  void **v39; // x23
  void **v40; // x27
  void **v41; // x25
  void *v42; // x0
  unsigned __int64 v43; // x8
  int v44; // w23
  unsigned __int64 v45; // x26
  __int64 v46; // x19
  __int64 v47; // x20
  _QWORD *v48; // x8
  unsigned __int64 v49; // x9
  __int64 v50; // x10
  __int64 v51; // x21
  __int64 v52; // x9
  unsigned __int64 v53; // x9
  __int64 v54; // x22
  char *v55; // x0
  __int64 v56; // x9
  char *v57; // x8
  void **v58; // x11
  void **v59; // x24
  _QWORD *v60; // x10
  __int128 v61; // t1
  void **v62; // x25
  __int64 v63; // x20
  unsigned __int64 v64; // x8
  unsigned __int64 v65; // x19
  char *v66; // x24
  size_t *v67; // x27
  char *v68; // x11
  void **v69; // x8
  size_t v70; // x25
  const void *v71; // x1
  void *v72; // x20
  const void *v73; // x20
  void *v74; // x0
  char *v75; // x8
  char *v76; // x25
  char *v77; // x25
  void **v78; // x8
  void **v79; // x8
  char v80; // t1
  void **v81; // x8
  size_t v82; // x26
  const void *v83; // x23
  void *v84; // x25
  void *v85; // x0
  char *v86; // x8
  void **v87; // x9
  void **v88; // x20
  _QWORD *v89; // x8
  size_t v90; // x10
  void **v91; // x24
  __int64 v92; // x22
  void **v93; // x23
  unsigned __int64 v94; // x8
  void **v95; // x23
  __int64 v96; // x21
  __int64 v97; // x25
  size_t *v98; // x9
  size_t *v99; // x20
  __int64 v100; // x10
  unsigned __int64 v101; // x22
  unsigned __int64 v102; // x9
  __int64 v103; // x20
  unsigned __int64 v104; // x9
  __int64 v105; // x8
  size_t v106; // x0
  void **v107; // x8
  size_t v108; // x24
  const void *v109; // x25
  void *v110; // x26
  _BYTE *v111; // x24
  void **v112; // x8
  void **v113; // x8
  char v114; // t1
  void **v115; // x8
  size_t v116; // x25
  const void *v117; // x26
  void *v118; // x24
  __int64 v119; // x19
  unsigned __int64 v120; // x20
  unsigned __int64 v121; // x8
  __int64 v122; // x0
  unsigned __int64 v123; // x8
  bool v124; // zf
  size_t v125; // x8
  void *v126; // x1
  size_t v127; // x2
  size_t *v128; // x0
  char *v129; // x24
  char v130; // w21
  char *v131; // x1
  size_t v132; // x2
  __int64 v133; // x19
  _BYTE *v134; // x20
  __int64 v135; // x8
  void *v136; // x22
  __int64 v137; // x9
  char v138; // w20
  __int64 v139; // x8
  unsigned __int64 v140; // x8
  unsigned __int64 v141; // x9
  unsigned __int64 v142; // x19
  unsigned __int64 v143; // x8
  unsigned __int64 v144; // x9
  unsigned __int64 v145; // x9
  __int64 v146; // x9
  char *v147; // x0
  char *v148; // x8
  void **v149; // x11
  void **v150; // x19
  char *v151; // x10
  __int64 v152; // x12
  void **v153; // x22
  __int64 v154; // x20
  void **v155; // x21
  unsigned __int64 v156; // x8
  size_t size; // [xsp+10h] [xbp-110h]
  __int64 v158; // [xsp+20h] [xbp-100h]
  _BYTE *v159; // [xsp+28h] [xbp-F8h]
  unsigned __int64 v161; // [xsp+40h] [xbp-E0h]
  char *v162; // [xsp+48h] [xbp-D8h]
  __int64 v163; // [xsp+50h] [xbp-D0h]
  unsigned __int64 j; // [xsp+58h] [xbp-C8h]
  _BYTE *v165; // [xsp+60h] [xbp-C0h]
  __int128 v166; // [xsp+68h] [xbp-B8h] BYREF
  void *p; // [xsp+78h] [xbp-A8h]
  _BYTE v168[15]; // [xsp+80h] [xbp-A0h] BYREF
  _QWORD v169[2]; // [xsp+90h] [xbp-90h] BYREF
  __int128 v170; // [xsp+A0h] [xbp-80h] BYREF
  _QWORD *v171; // [xsp+B0h] [xbp-70h]
  char *v172; // [xsp+B8h] [xbp-68h]
  size_t v173; // [xsp+C0h] [xbp-60h]
  __int64 v174; // [xsp+C8h] [xbp-58h]

  v3 = a3;
  v165 = a1;
  v174 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a2 - a1 < 2 || *a1 != 73 )
    return a1;
  if ( *(_BYTE *)(a3 + 109) )
  {
    v4 = *(_QWORD *)(a3 + 72);
    v5 = *(void ***)(v4 - 32);
    for ( i = *(void ***)(v4 - 24); v5 != i; sub_9D32C(i) )
      i -= 4;
    *(_QWORD *)(v4 - 24) = v5;
  }
  p = 0LL;
  v166 = 0x3C02uLL;
  v7 = v165 + 1;
  v158 = 0x555555555555555LL;
  if ( v165[1] != 69 )
  {
    size = v3 + 88;
    v163 = v3;
    while ( 1 )
    {
      if ( !*(_BYTE *)(v3 + 109) )
        goto LABEL_37;
      v16 = *(_QWORD **)(v3 + 72);
      v17 = *(_QWORD *)(v3 + 80);
      v18 = *(_QWORD *)(v3 + 24);
      if ( (unsigned __int64)v16 < v17 )
      {
        *v16 = 0LL;
        v16[1] = 0LL;
        v16[2] = 0LL;
        v16[3] = v18;
        *(_QWORD *)(v3 + 72) += 32LL;
        goto LABEL_37;
      }
      v19 = *(_QWORD *)(v3 + 64);
      v20 = ((__int64)v16 - v19) >> 5;
      if ( (unsigned __int64)(v20 + 1) >> 59 )
        abort();
      v21 = v17 - v19;
      if ( (unsigned __int64)(v21 >> 5) >= 0x3FFFFFFFFFFFFFFLL )
        break;
      v22 = v21 >> 4;
      if ( v22 >= v20 + 1 )
        v23 = v22;
      else
        v23 = v20 + 1;
      v24 = size;
      v172 = 0LL;
      v173 = size;
      if ( v23 )
        goto LABEL_29;
      v25 = 0LL;
LABEL_32:
      v26 = &v25[32 * v20];
      v27 = &v25[32 * v23];
      v28 = v26 + 32;
      *(_QWORD *)&v170 = v25;
      *((_QWORD *)&v170 + 1) = v26;
      *(_QWORD *)v26 = 0LL;
      *((_QWORD *)v26 + 1) = 0LL;
      *((_QWORD *)v26 + 2) = 0LL;
      *((_QWORD *)v26 + 3) = v18;
      v171 = v26 + 32;
      v172 = v27;
      v29 = *(_QWORD **)(v3 + 64);
      v30 = *(_QWORD **)(v3 + 72);
      if ( v30 == v29 )
      {
        v32 = *(_QWORD *)(v3 + 64);
      }
      else
      {
        do
        {
          *((_QWORD *)v26 - 3) = 0LL;
          *((_QWORD *)v26 - 2) = 0LL;
          *((_QWORD *)v26 - 4) = 0LL;
          *((_QWORD *)v26 - 1) = *(v30 - 1);
          v31 = *((_OWORD *)v30 - 2);
          v30 -= 4;
          *((_OWORD *)v26 - 2) = v31;
          *((_QWORD *)v26 - 2) = v30[2];
          v30[1] = 0LL;
          v30[2] = 0LL;
          *v30 = 0LL;
          v26 = (char *)(*((_QWORD *)&v170 + 1) - 32LL);
          *((_QWORD *)&v170 + 1) -= 32LL;
        }
        while ( v29 != v30 );
        v32 = *(_QWORD *)(v3 + 64);
        v29 = *(_QWORD **)(v3 + 72);
        v28 = v171;
        v27 = v172;
      }
      *(_QWORD *)(v3 + 64) = v26;
      *(_QWORD *)(v3 + 72) = v28;
      *((_QWORD *)&v170 + 1) = v32;
      v171 = v29;
      v33 = *(char **)(v3 + 80);
      *(_QWORD *)(v3 + 80) = v27;
      *(_QWORD *)&v170 = v32;
      v172 = v33;
      sub_B2A24(&v170);
LABEL_37:
      v34 = *(void ***)v3;
      v35 = *(_QWORD *)(v3 + 8);
      v159 = (_BYTE *)sub_B28F0(v7, a2, v3);
      v36 = *(void ***)v3;
      v37 = *(_QWORD *)(v3 + 8);
      if ( *(_BYTE *)(v3 + 109) )
      {
        v38 = *(_QWORD *)(v3 + 72);
        v39 = (void **)(v38 - 32);
        v40 = *(void ***)(v38 - 32);
        if ( v40 )
        {
          v41 = *(void ***)(v38 - 24);
          v42 = *(void **)(v38 - 32);
          if ( v41 != v40 )
          {
            do
            {
              v41 -= 4;
              sub_9D32C(v41);
            }
            while ( v40 != v41 );
            v42 = *v39;
          }
          v43 = *(_QWORD *)(v38 - 8);
          *(_QWORD *)(v38 - 24) = v40;
          if ( v43 + 4096 < (unsigned __int64)v42 || v43 > (unsigned __int64)v42 )
          {
            free(v42);
          }
          else if ( *(_QWORD *)(v43 + 4096) == *(_QWORD *)(v38 - 16) )
          {
            *(_QWORD *)(v43 + 4096) = v42;
          }
        }
        v3 = v163;
        *(_QWORD *)(v163 + 72) = v39;
      }
      v44 = 1;
      if ( v159 == v7 || v159 == a2 )
      {
        v14 = v165;
        goto LABEL_205;
      }
      v45 = 0xAAAAAAAAAAAAAAABLL * ((v37 - (__int64)v36) >> 4);
      v161 = 0xAAAAAAAAAAAAAAABLL * ((v35 - (__int64)v34) >> 4);
      if ( !*(_BYTE *)(v3 + 109) )
        goto LABEL_143;
      v46 = *(_QWORD *)(v3 + 72);
      v47 = *(_QWORD *)(v3 + 24);
      v48 = *(_QWORD **)(v46 - 24);
      v49 = *(_QWORD *)(v46 - 16);
      if ( (unsigned __int64)v48 < v49 )
      {
        *v48 = 0LL;
        v48[1] = 0LL;
        v48[2] = 0LL;
        v48[3] = v47;
        *(_QWORD *)(v46 - 24) += 32LL;
        goto LABEL_76;
      }
      v50 = *(_QWORD *)(v46 - 32);
      v51 = ((__int64)v48 - v50) >> 5;
      if ( (unsigned __int64)(v51 + 1) >> 59 )
        abort();
      v52 = v49 - v50;
      if ( (unsigned __int64)(v52 >> 5) > 0x3FFFFFFFFFFFFFELL )
      {
        v54 = 0x7FFFFFFFFFFFFFFLL;
LABEL_61:
        v56 = *(_QWORD *)(v46 - 8);
        v55 = *(char **)(v56 + 4096);
        if ( v56 + 4096 - (__int64)v55 >= (unsigned __int64)(32 * v54) )
          *(_QWORD *)(v56 + 4096) = &v55[32 * v54];
        else
          v55 = (char *)malloc(32 * v54);
        goto LABEL_64;
      }
      v53 = v52 >> 4;
      if ( v53 >= v51 + 1 )
        v54 = v53;
      else
        v54 = v51 + 1;
      if ( v54 )
        goto LABEL_61;
      v55 = 0LL;
LABEL_64:
      v57 = &v55[32 * v51];
      *(_QWORD *)v57 = 0LL;
      *((_QWORD *)v57 + 1) = 0LL;
      *((_QWORD *)v57 + 2) = 0LL;
      *((_QWORD *)v57 + 3) = v47;
      v59 = *(void ***)(v46 - 32);
      v58 = *(void ***)(v46 - 24);
      v60 = v57 + 32;
      if ( v58 == v59 )
      {
        v62 = *(void ***)(v46 - 32);
      }
      else
      {
        do
        {
          *((_QWORD *)v57 - 3) = 0LL;
          *((_QWORD *)v57 - 2) = 0LL;
          *((_QWORD *)v57 - 4) = 0LL;
          *((_QWORD *)v57 - 1) = *(v58 - 1);
          v61 = *((_OWORD *)v58 - 2);
          v58 -= 4;
          *((_OWORD *)v57 - 2) = v61;
          *((_QWORD *)v57 - 2) = v58[2];
          v57 -= 32;
          v58[1] = 0LL;
          v58[2] = 0LL;
          *v58 = 0LL;
        }
        while ( v59 != v58 );
        v62 = *(void ***)(v46 - 32);
        v59 = *(void ***)(v46 - 24);
      }
      v63 = *(_QWORD *)(v46 - 16);
      *(_QWORD *)(v46 - 32) = v57;
      *(_QWORD *)(v46 - 24) = v60;
      *(_QWORD *)(v46 - 16) = &v55[32 * v54];
      while ( v62 != v59 )
      {
        v59 -= 4;
        sub_9D32C(v59);
      }
      if ( v62 )
      {
        v64 = *(_QWORD *)(v46 - 8);
        if ( v64 + 4096 < (unsigned __int64)v62 || v64 > (unsigned __int64)v62 )
        {
          free(v62);
        }
        else if ( *(_QWORD *)(v64 + 4096) == v63 )
        {
          *(_QWORD *)(v64 + 4096) = v62;
        }
      }
LABEL_76:
      v65 = v161;
      for ( j = v45; v65 < v45; ++v65 )
      {
        v95 = *(void ***)v3;
        v96 = *(_QWORD *)(*(_QWORD *)(v3 + 72) - 24LL);
        v97 = *(_QWORD *)v3 + 48 * v65;
        v99 = *(size_t **)(v96 - 24);
        v98 = *(size_t **)(v96 - 16);
        if ( v99 == v98 )
        {
          v100 = *(_QWORD *)(v96 - 32);
          v101 = 0xAAAAAAAAAAAAAAABLL * (((__int64)v99 - v100) >> 4);
          if ( v101 + 1 > 0x555555555555555LL )
            abort();
          v102 = 0xAAAAAAAAAAAAAAABLL * (((__int64)v98 - v100) >> 4);
          v103 = 0x555555555555555LL;
          if ( v102 >= 0x2AAAAAAAAAAAAAALL
            || ((v104 = 2 * v102, v104 >= v101 + 1) ? (v103 = v104) : (v103 = v101 + 1), v103) )
          {
            v105 = *(_QWORD *)(v96 - 8);
            v106 = 48 * v103;
            v66 = *(char **)(v105 + 4096);
            if ( v105 + 4096 - (__int64)v66 >= (unsigned __int64)(48 * v103) )
              *(_QWORD *)(v105 + 4096) = &v66[v106];
            else
              v66 = (char *)malloc(v106);
          }
          else
          {
            v66 = 0LL;
          }
          v67 = (size_t *)&v66[48 * v101];
          v67[1] = 0LL;
          v67[2] = 0LL;
          *v67 = 0LL;
          v68 = &v66[48 * v103];
          v162 = v68;
          if ( (*(_BYTE *)v97 & 1) == 0 )
          {
            v67[2] = *(_QWORD *)(v97 + 16);
            *(_OWORD *)v67 = *(_OWORD *)v97;
            goto LABEL_89;
          }
          v69 = &v95[6 * v65];
          v70 = (size_t)v69[1];
          if ( v70 >= 0xFFFFFFFFFFFFFFF0LL )
            abort();
          v71 = v69[2];
          if ( v70 >= 0x17 )
          {
            v73 = v69[2];
            v74 = malloc((v70 + 16) & 0xFFFFFFFFFFFFFFF0LL);
            v71 = v73;
            v72 = v74;
            v75 = &v66[48 * v101];
            *((_QWORD *)v75 + 1) = v70;
            *((_QWORD *)v75 + 2) = v74;
            *v67 = (v70 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
            v45 = j;
          }
          else
          {
            *(_BYTE *)v67 = 2 * v70;
            v72 = (char *)v67 + 1;
            v45 = j;
            if ( !v70 )
              goto LABEL_88;
          }
          memcpy(v72, v71, v70);
LABEL_88:
          *((_BYTE *)v72 + v70) = 0;
          v68 = v162;
LABEL_89:
          v76 = &v66[48 * v101];
          *((_QWORD *)v76 + 3) = 0LL;
          v77 = v76 + 24;
          v78 = &v95[6 * v65];
          *((_QWORD *)v77 + 1) = 0LL;
          *((_QWORD *)v77 + 2) = 0LL;
          v80 = *((_BYTE *)v78 + 24);
          v79 = v78 + 3;
          if ( (v80 & 1) == 0 )
          {
            *((_QWORD *)v77 + 2) = v79[2];
            *(_OWORD *)v77 = *(_OWORD *)v79;
LABEL_98:
            v88 = *(void ***)(v96 - 32);
            v87 = *(void ***)(v96 - 24);
            v89 = v67 + 6;
            if ( v87 == v88 )
            {
              v91 = *(void ***)(v96 - 32);
            }
            else
            {
              do
              {
                *(v67 - 4) = (size_t)*(v87 - 4);
                *((_OWORD *)v67 - 3) = *((_OWORD *)v87 - 3);
                v90 = (size_t)*(v87 - 1);
                *(v87 - 5) = 0LL;
                *(v87 - 4) = 0LL;
                *(v87 - 6) = 0LL;
                *(v67 - 1) = v90;
                *(_OWORD *)(v67 - 3) = *(_OWORD *)(v87 - 3);
                *(v87 - 2) = 0LL;
                *(v87 - 1) = 0LL;
                *(v87 - 3) = 0LL;
                v87 -= 6;
                v67 -= 6;
              }
              while ( v88 != v87 );
              v91 = *(void ***)(v96 - 32);
              v88 = *(void ***)(v96 - 24);
            }
            v92 = *(_QWORD *)(v96 - 16);
            *(_QWORD *)(v96 - 32) = v67;
            *(_QWORD *)(v96 - 24) = v89;
            *(_QWORD *)(v96 - 16) = v68;
            v3 = v163;
            if ( v88 != v91 )
            {
              do
              {
                if ( (*(_BYTE *)(v88 - 3) & 1) != 0 )
                  free(*(v88 - 1));
                v93 = v88 - 6;
                if ( (*(_BYTE *)(v88 - 6) & 1) != 0 )
                  free(*(v88 - 4));
                v88 -= 6;
              }
              while ( v91 != v93 );
            }
            if ( v91 )
            {
              v94 = *(_QWORD *)(v96 - 8);
              if ( v94 + 4096 < (unsigned __int64)v91 || v94 > (unsigned __int64)v91 )
              {
                free(v91);
              }
              else if ( *(_QWORD *)(v94 + 4096) == v92 )
              {
                *(_QWORD *)(v94 + 4096) = v91;
              }
            }
            continue;
          }
          v81 = &v95[6 * v65];
          v82 = (size_t)v81[4];
          if ( v82 >= 0xFFFFFFFFFFFFFFF0LL )
            abort();
          v83 = v81[5];
          if ( v82 >= 0x17 )
          {
            v85 = malloc((v82 + 16) & 0xFFFFFFFFFFFFFFF0LL);
            v86 = &v66[48 * v101];
            *((_QWORD *)v86 + 4) = v82;
            *((_QWORD *)v86 + 5) = v85;
            *(_QWORD *)v77 = (v82 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
            v84 = v85;
          }
          else
          {
            *v77 = 2 * v82;
            v84 = v77 + 1;
            if ( !v82 )
              goto LABEL_97;
          }
          memcpy(v84, v83, v82);
LABEL_97:
          *((_BYTE *)v84 + v82) = 0;
          v45 = j;
          v68 = v162;
          goto LABEL_98;
        }
        v99[1] = 0LL;
        v99[2] = 0LL;
        *v99 = 0LL;
        if ( (*(_BYTE *)v97 & 1) == 0 )
        {
          v99[2] = *(_QWORD *)(v97 + 16);
          *(_OWORD *)v99 = *(_OWORD *)v97;
          goto LABEL_132;
        }
        v107 = &v95[6 * v65];
        v108 = (size_t)v107[1];
        if ( v108 >= 0xFFFFFFFFFFFFFFF0LL )
          abort();
        v109 = v107[2];
        if ( v108 >= 0x17 )
        {
          v110 = malloc((v108 + 16) & 0xFFFFFFFFFFFFFFF0LL);
          v99[2] = (size_t)v110;
          v3 = v163;
          *v99 = (v108 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
          v99[1] = v108;
        }
        else
        {
          *(_BYTE *)v99 = 2 * v108;
          v110 = (char *)v99 + 1;
          if ( !v108 )
            goto LABEL_131;
        }
        memcpy(v110, v109, v108);
LABEL_131:
        *((_BYTE *)v110 + v108) = 0;
        v45 = j;
LABEL_132:
        v99[3] = 0LL;
        v111 = v99 + 3;
        v112 = &v95[6 * v65];
        v99[4] = 0LL;
        v99[5] = 0LL;
        v114 = *((_BYTE *)v112 + 24);
        v113 = v112 + 3;
        if ( (v114 & 1) != 0 )
        {
          v115 = &v95[6 * v65];
          v116 = (size_t)v115[4];
          if ( v116 >= 0xFFFFFFFFFFFFFFF0LL )
            abort();
          v117 = v115[5];
          if ( v116 >= 0x17 )
          {
            v118 = malloc((v116 + 16) & 0xFFFFFFFFFFFFFFF0LL);
            v99[5] = (size_t)v118;
            v3 = v163;
            v99[3] = (v116 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
            v99[4] = v116;
          }
          else
          {
            *v111 = 2 * v116;
            v118 = (char *)v99 + 25;
            if ( !v116 )
              goto LABEL_140;
          }
          memcpy(v118, v117, v116);
LABEL_140:
          *((_BYTE *)v118 + v116) = 0;
          v45 = j;
          goto LABEL_141;
        }
        v99[5] = (size_t)v113[2];
        *(_OWORD *)v111 = *(_OWORD *)v113;
LABEL_141:
        *(_QWORD *)(v96 - 24) += 48LL;
      }
LABEL_143:
      if ( v161 < v45 )
      {
        v119 = 48 * v161;
        v120 = v161;
        do
        {
          if ( (v166 & 1) != 0 )
            v121 = *((_QWORD *)&v166 + 1);
          else
            v121 = (unsigned __int64)(unsigned __int8)v166 >> 1;
          if ( v121 >= 2 )
            sub_9CFD0((size_t *)&v166, &asc_69D1AEC, 2uLL);
          v122 = *(_QWORD *)v3 + v119;
          v123 = *(unsigned __int8 *)(v122 + 24);
          v124 = (v123 & 1) == 0;
          v125 = v123 >> 1;
          if ( v124 )
            v126 = (void *)(v122 + 25);
          else
            v126 = *(void **)(v122 + 40);
          if ( v124 )
            v127 = v125;
          else
            v127 = *(_QWORD *)(v122 + 32);
          v128 = sub_9CFD0((size_t *)v122, v126, v127);
          v171 = (_QWORD *)v128[2];
          v129 = (char *)v171;
          v170 = *(_OWORD *)v128;
          v128[1] = 0LL;
          v128[2] = 0LL;
          *v128 = 0LL;
          v130 = v170;
          if ( (v170 & 1) != 0 )
            v131 = v129;
          else
            v131 = (char *)&v170 + 1;
          if ( (v170 & 1) != 0 )
            v132 = *((_QWORD *)&v170 + 1);
          else
            v132 = (unsigned __int64)(unsigned __int8)v170 >> 1;
          sub_9CFD0((size_t *)&v166, v131, v132);
          if ( (v130 & 1) != 0 )
            free(v129);
          ++v120;
          v119 += 48LL;
        }
        while ( v120 < v45 );
        if ( v161 < v45 )
        {
          v133 = *(_QWORD *)(v3 + 8);
          do
          {
            if ( *(_QWORD *)v3 != v133 )
            {
              v134 = (_BYTE *)(v133 - 48);
              if ( (*(_BYTE *)(v133 - 24) & 1) != 0 )
                free(*(void **)(v133 - 8));
              if ( (*v134 & 1) != 0 )
                free(*(void **)(v133 - 32));
              v133 -= 48LL;
              *(_QWORD *)(v3 + 8) = v134;
            }
            --v45;
          }
          while ( v45 > v161 );
        }
      }
      v7 = v159;
      if ( *v159 == 69 )
      {
        v10 = (unsigned __int8)v166;
        v8 = *((_QWORD *)&v166 + 1);
        v9 = (char *)p;
        goto LABEL_9;
      }
    }
    v24 = size;
    v23 = 0x7FFFFFFFFFFFFFFLL;
    v172 = 0LL;
    v173 = size;
LABEL_29:
    v25 = *(char **)(*(_QWORD *)v24 + 4096LL);
    if ( *(_QWORD *)v24 + 4096LL - (__int64)v25 >= (unsigned __int64)(32 * v23) )
      *(_QWORD *)(*(_QWORD *)v24 + 4096LL) = &v25[32 * v23];
    else
      v25 = (char *)malloc(32 * v23);
    goto LABEL_32;
  }
  v8 = 0LL;
  v9 = 0LL;
  v10 = 2LL;
LABEL_9:
  v11 = v10 >> 1;
  v124 = (v10 & 1) == 0;
  v12 = (char *)&v166 + 1;
  if ( v124 )
  {
    v13 = v11;
  }
  else
  {
    v12 = v9;
    v13 = v8;
  }
  if ( v12[v13 - 1] == 62 )
    sub_9CFD0((size_t *)&v166, " >", 2uLL);
  else
    sub_9CFD0((size_t *)&v166, ">", 1uLL);
  v135 = *((_QWORD *)&v166 + 1);
  v136 = p;
  v137 = *(_QWORD *)((char *)&v166 + 1);
  v138 = v166;
  v166 = 0uLL;
  *(_QWORD *)&v168[7] = v135;
  p = 0LL;
  v168[7] = HIBYTE(v137);
  v139 = *(_QWORD *)&v168[7];
  memset(v169, 0, 15);
  memset(v168, 0, sizeof(v168));
  *(_QWORD *)((char *)&v170 + 7) = v139;
  *(_QWORD *)&v170 = v137;
  v140 = *(_QWORD *)(v3 + 8);
  v141 = *(_QWORD *)(v3 + 16);
  if ( v140 >= v141 )
  {
    v142 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v140 - *(_QWORD *)v3) >> 4);
    v143 = v142 + 1;
    if ( v142 + 1 > 0x555555555555555LL )
      abort();
    v144 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v141 - *(_QWORD *)v3) >> 4);
    if ( v144 >= 0x2AAAAAAAAAAAAAALL )
      goto LABEL_184;
    v145 = 2 * v144;
    if ( v145 >= v143 )
      v143 = v145;
    v158 = v143;
    if ( v143 )
    {
LABEL_184:
      v146 = *(_QWORD *)(v3 + 24);
      v147 = *(char **)(v146 + 4096);
      if ( v146 + 4096 - (__int64)v147 >= (unsigned __int64)(48 * v158) )
        *(_QWORD *)(v146 + 4096) = &v147[48 * v158];
      else
        v147 = (char *)malloc(48 * v158);
    }
    else
    {
      v158 = 0LL;
      v147 = 0LL;
    }
    v148 = &v147[48 * v142];
    *v148 = v138;
    *((_QWORD *)v148 + 1) = *(_QWORD *)((char *)&v170 + 7);
    *((_QWORD *)v148 + 2) = v136;
    *(_QWORD *)(v148 + 1) = v170;
    *(_QWORD *)((char *)&v170 + 7) = 0LL;
    *(_QWORD *)&v170 = 0LL;
    v148[24] = 0;
    *((_QWORD *)v148 + 4) = *(_QWORD *)((char *)v169 + 7);
    *((_QWORD *)v148 + 5) = 0LL;
    *(_QWORD *)(v148 + 25) = v169[0];
    memset(v169, 0, 15);
    v150 = *(void ***)v3;
    v149 = *(void ***)(v3 + 8);
    v151 = v148 + 48;
    if ( v149 == *(void ***)v3 )
    {
      v153 = *(void ***)v3;
    }
    else
    {
      do
      {
        *((_QWORD *)v148 - 4) = *(v149 - 4);
        *((_OWORD *)v148 - 3) = *((_OWORD *)v149 - 3);
        v152 = (__int64)*(v149 - 1);
        *(v149 - 5) = 0LL;
        *(v149 - 4) = 0LL;
        *(v149 - 6) = 0LL;
        *((_QWORD *)v148 - 1) = v152;
        *(_OWORD *)(v148 - 24) = *(_OWORD *)(v149 - 3);
        *(v149 - 2) = 0LL;
        *(v149 - 1) = 0LL;
        *(v149 - 3) = 0LL;
        v149 -= 6;
        v148 -= 48;
      }
      while ( v150 != v149 );
      v153 = *(void ***)v3;
      v150 = *(void ***)(v3 + 8);
    }
    v154 = *(_QWORD *)(v3 + 16);
    *(_QWORD *)v3 = v148;
    *(_QWORD *)(v3 + 8) = v151;
    *(_QWORD *)(v3 + 16) = &v147[48 * v158];
    if ( v150 != v153 )
    {
      do
      {
        if ( (*(_BYTE *)(v150 - 3) & 1) != 0 )
          free(*(v150 - 1));
        v155 = v150 - 6;
        if ( (*(_BYTE *)(v150 - 6) & 1) != 0 )
          free(*(v150 - 4));
        v150 -= 6;
      }
      while ( v153 != v155 );
    }
    if ( v153 )
    {
      v156 = *(_QWORD *)(v3 + 24);
      if ( v156 + 4096 < (unsigned __int64)v153 || v156 > (unsigned __int64)v153 )
      {
        free(v153);
      }
      else if ( *(_QWORD *)(v156 + 4096) == v154 )
      {
        *(_QWORD *)(v156 + 4096) = v153;
      }
    }
  }
  else
  {
    *(_BYTE *)v140 = v138;
    *(_QWORD *)(v140 + 8) = *(_QWORD *)((char *)&v170 + 7);
    *(_QWORD *)(v140 + 16) = v136;
    *(_QWORD *)(v140 + 1) = v170;
    *(_QWORD *)((char *)&v170 + 7) = 0LL;
    *(_QWORD *)&v170 = 0LL;
    *(_BYTE *)(v140 + 24) = 0;
    *(_QWORD *)(v140 + 32) = *(_QWORD *)((char *)v169 + 7);
    *(_QWORD *)(v140 + 40) = 0LL;
    *(_QWORD *)(v140 + 25) = v169[0];
    memset(v169, 0, 15);
    *(_QWORD *)(v3 + 8) += 48LL;
  }
  v44 = 0;
  v14 = v7 + 1;
LABEL_205:
  if ( (v166 & 1) != 0 )
    free(p);
  if ( !v44 )
    return v14;
  return v165;
}
// B28F0: using guessed type __int64 __fastcall sub_B28F0(_QWORD, _QWORD, _QWORD);
// B2A24: using guessed type __int64 __fastcall sub_B2A24(_QWORD);

//----- (000000000009E1F8) ----------------------------------------------------
unsigned __int8 *__fastcall sub_9E1F8(_BYTE *a1, unsigned __int8 *a2, void **a3)
{
  _BYTE *v4; // x20
  void **v5; // x19
  __int64 v6; // x22
  __int64 v7; // x27
  __int64 *v8; // x8
  __int64 v9; // x20
  __int64 v10; // x28
  char *v11; // x21
  size_t *v12; // x24
  char *v13; // x25
  size_t v14; // x22
  const void *v15; // x23
  void *v16; // x27
  char *v17; // x8
  char *v18; // x22
  char *v19; // x22
  size_t v20; // x23
  const void *v21; // x27
  void *v22; // x22
  void *v23; // x0
  char *v24; // x8
  void **v25; // x9
  void **v26; // x22
  _QWORD *v27; // x8
  size_t v28; // x10
  void **v29; // x21
  void *v30; // x23
  void **v31; // x24
  unsigned __int64 v32; // x8
  char *v33; // x9
  size_t *v34; // x25
  unsigned __int64 v35; // x26
  unsigned __int64 v36; // x9
  __int64 v37; // x22
  unsigned __int64 v38; // x9
  _QWORD *v39; // x8
  size_t v40; // x0
  size_t v41; // x21
  const void *v42; // x22
  void *v43; // x23
  _BYTE *v44; // x21
  size_t v45; // x22
  const void *v46; // x23
  void *v47; // x21
  unsigned __int8 *v48; // x25
  int v49; // w8
  __int64 v50; // x23
  __int64 v51; // x22
  int v52; // w8
  char *v53; // x8
  char *v54; // x9
  unsigned __int64 v55; // x21
  unsigned __int64 v56; // x9
  unsigned __int64 v57; // x9
  _QWORD *v58; // x9
  char *v59; // x0
  char *v60; // x9
  char *v61; // x9
  _QWORD *v62; // x8
  _BYTE *v63; // x9
  char *v64; // x9
  char *v65; // x9
  unsigned __int64 v66; // x21
  unsigned __int64 v67; // x9
  unsigned __int64 v68; // x9
  _QWORD *v69; // x9
  char *v70; // x0
  unsigned __int64 v71; // x21
  unsigned __int64 v72; // x9
  unsigned __int64 v73; // x9
  _QWORD *v74; // x9
  char *v75; // x0
  unsigned __int64 v76; // x21
  unsigned __int64 v77; // x9
  unsigned __int64 v78; // x9
  _QWORD *v79; // x9
  char *v80; // x0
  unsigned __int64 v81; // x21
  unsigned __int64 v82; // x9
  unsigned __int64 v83; // x9
  _QWORD *v84; // x9
  char *v85; // x0
  unsigned __int64 v86; // x21
  unsigned __int64 v87; // x9
  unsigned __int64 v88; // x9
  _QWORD *v89; // x9
  char *v90; // x0
  _BYTE *v91; // x8
  __int64 *v92; // x8
  __int64 v93; // x26
  __int64 v94; // x28
  char *v95; // x20
  size_t *v96; // x23
  char *v97; // x24
  size_t v98; // x21
  const void *v99; // x22
  void *v100; // x27
  char *v101; // x8
  char *v102; // x21
  char *v103; // x21
  size_t v104; // x22
  const void *v105; // x27
  void *v106; // x21
  void *v107; // x0
  char *v108; // x8
  void **v109; // x9
  void **v110; // x21
  _QWORD *v111; // x8
  size_t v112; // x10
  void **v113; // x20
  void *v114; // x22
  void **v115; // x23
  unsigned __int64 v116; // x8
  char *v117; // x9
  size_t *v118; // x24
  unsigned __int64 v119; // x26
  unsigned __int64 v120; // x9
  __int64 v121; // x21
  unsigned __int64 v122; // x9
  _QWORD *v123; // x8
  size_t v124; // x0
  size_t v125; // x20
  const void *v126; // x21
  void *v127; // x22
  _BYTE *v128; // x20
  size_t v129; // x21
  const void *v130; // x22
  void *v131; // x20
  char *v132; // x8
  void **v133; // x11
  void **v134; // x22
  char *v135; // x10
  __int64 v136; // x12
  void **v137; // x21
  void *v138; // x23
  void **v139; // x24
  char *v140; // x8
  void **v141; // x11
  void **v142; // x22
  char *v143; // x10
  __int64 v144; // x12
  void **v145; // x24
  char *v146; // x8
  void **v147; // x11
  void **v148; // x22
  char *v149; // x10
  __int64 v150; // x12
  void **v151; // x24
  char *v152; // x8
  void **v153; // x11
  void **v154; // x22
  char *v155; // x10
  __int64 v156; // x12
  void **v157; // x24
  char *v158; // x8
  void **v159; // x11
  void **v160; // x22
  char *v161; // x10
  __int64 v162; // x12
  void **v163; // x24
  char *v164; // x8
  void **v165; // x11
  void **v166; // x22
  char *v167; // x10
  __int64 v168; // x12
  void **v169; // x24
  unsigned __int64 v170; // x8
  __int64 v173; // [xsp+8h] [xbp-98h]
  _QWORD v175[2]; // [xsp+28h] [xbp-78h] BYREF
  _QWORD v176[3]; // [xsp+38h] [xbp-68h] BYREF

  v4 = a1;
  v5 = a3;
  v176[2] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a2 - a1 >= 2 && *a1 == 83 )
  {
    v6 = (unsigned __int8)a1[1];
    v7 = 0x555555555555555LL;
    switch ( a1[1] )
    {
      case '_':
        v8 = (__int64 *)a3[4];
        if ( v8 == a3[5] )
          return v4;
        v10 = *v8;
        v9 = v8[1];
        if ( *v8 == v9 )
          return a1 + 2;
        while ( 1 )
        {
          v34 = (size_t *)v5[1];
          v33 = (char *)v5[2];
          if ( v34 == (size_t *)v33 )
          {
            v35 = 0xAAAAAAAAAAAAAAABLL * (((char *)v34 - (_BYTE *)*v5) >> 4);
            if ( v35 + 1 > 0x555555555555555LL )
              goto LABEL_304;
            v36 = 0xAAAAAAAAAAAAAAABLL * ((v33 - (_BYTE *)*v5) >> 4);
            v37 = 0x555555555555555LL;
            if ( v36 >= 0x2AAAAAAAAAAAAAALL || ((v38 = 2 * v36, v38 >= v35 + 1) ? (v37 = v38) : (v37 = v35 + 1), v37) )
            {
              v39 = v5[3];
              v40 = 48 * v37;
              v11 = (char *)v39[512];
              if ( (char *)(v39 + 512) - v11 >= (unsigned __int64)(48 * v37) )
                v39[512] = &v11[v40];
              else
                v11 = (char *)malloc(v40);
            }
            else
            {
              v11 = 0LL;
            }
            v12 = (size_t *)&v11[48 * v35];
            v12[1] = 0LL;
            v12[2] = 0LL;
            *v12 = 0LL;
            v13 = &v11[48 * v37];
            if ( (*(_BYTE *)v10 & 1) == 0 )
            {
              v12[2] = *(_QWORD *)(v10 + 16);
              *(_OWORD *)v12 = *(_OWORD *)v10;
              goto LABEL_18;
            }
            v14 = *(_QWORD *)(v10 + 8);
            if ( v14 >= 0xFFFFFFFFFFFFFFF0LL )
              abort();
            v15 = *(const void **)(v10 + 16);
            if ( v14 >= 0x17 )
            {
              v5 = a3;
              v16 = malloc((v14 + 16) & 0xFFFFFFFFFFFFFFF0LL);
              v17 = &v11[48 * v35];
              *((_QWORD *)v17 + 1) = v14;
              *((_QWORD *)v17 + 2) = v16;
              *v12 = (v14 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
            }
            else
            {
              *(_BYTE *)v12 = 2 * v14;
              v16 = (char *)v12 + 1;
              if ( !v14 )
                goto LABEL_17;
            }
            memcpy(v16, v15, v14);
LABEL_17:
            *((_BYTE *)v16 + v14) = 0;
LABEL_18:
            v18 = &v11[48 * v35];
            *((_QWORD *)v18 + 3) = 0LL;
            v19 = v18 + 24;
            *((_QWORD *)v19 + 1) = 0LL;
            *((_QWORD *)v19 + 2) = 0LL;
            if ( (*(_BYTE *)(v10 + 24) & 1) == 0 )
            {
              *((_QWORD *)v19 + 2) = *(_QWORD *)(v10 + 40);
              *(_OWORD *)v19 = *(_OWORD *)(v10 + 24);
LABEL_27:
              v26 = (void **)*v5;
              v25 = (void **)v5[1];
              v27 = v12 + 6;
              if ( v25 == *v5 )
              {
                v29 = (void **)*v5;
              }
              else
              {
                do
                {
                  *(v12 - 4) = (size_t)*(v25 - 4);
                  *((_OWORD *)v12 - 3) = *((_OWORD *)v25 - 3);
                  v28 = (size_t)*(v25 - 1);
                  *(v25 - 5) = 0LL;
                  *(v25 - 4) = 0LL;
                  *(v25 - 6) = 0LL;
                  *(v12 - 1) = v28;
                  *(_OWORD *)(v12 - 3) = *(_OWORD *)(v25 - 3);
                  *(v25 - 2) = 0LL;
                  *(v25 - 1) = 0LL;
                  *(v25 - 3) = 0LL;
                  v25 -= 6;
                  v12 -= 6;
                }
                while ( v26 != v25 );
                v29 = (void **)*v5;
                v26 = (void **)v5[1];
              }
              v30 = v5[2];
              *v5 = v12;
              v5[1] = v27;
              v5[2] = v13;
              if ( v26 != v29 )
              {
                do
                {
                  if ( (*(_BYTE *)(v26 - 3) & 1) != 0 )
                    free(*(v26 - 1));
                  v31 = v26 - 6;
                  if ( (*(_BYTE *)(v26 - 6) & 1) != 0 )
                    free(*(v26 - 4));
                  v26 -= 6;
                }
                while ( v29 != v31 );
              }
              if ( v29 )
              {
                v32 = (unsigned __int64)v5[3];
                if ( v32 + 4096 < (unsigned __int64)v29 || v32 > (unsigned __int64)v29 )
                {
                  free(v29);
                }
                else if ( *(void **)(v32 + 4096) == v30 )
                {
                  *(_QWORD *)(v32 + 4096) = v29;
                }
              }
              goto LABEL_71;
            }
            v20 = *(_QWORD *)(v10 + 32);
            if ( v20 >= 0xFFFFFFFFFFFFFFF0LL )
              abort();
            v21 = *(const void **)(v10 + 40);
            if ( v20 >= 0x17 )
            {
              v23 = malloc((v20 + 16) & 0xFFFFFFFFFFFFFFF0LL);
              v5 = a3;
              v24 = &v11[48 * v35];
              *((_QWORD *)v24 + 4) = v20;
              *((_QWORD *)v24 + 5) = v23;
              *(_QWORD *)v19 = (v20 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
              v22 = v23;
            }
            else
            {
              *v19 = 2 * v20;
              v22 = v19 + 1;
              if ( !v20 )
                goto LABEL_26;
            }
            memcpy(v22, v21, v20);
LABEL_26:
            *((_BYTE *)v22 + v20) = 0;
            goto LABEL_27;
          }
          v34[1] = 0LL;
          v34[2] = 0LL;
          *v34 = 0LL;
          if ( (*(_BYTE *)v10 & 1) == 0 )
          {
            v34[2] = *(_QWORD *)(v10 + 16);
            *(_OWORD *)v34 = *(_OWORD *)v10;
            goto LABEL_61;
          }
          v41 = *(_QWORD *)(v10 + 8);
          if ( v41 >= 0xFFFFFFFFFFFFFFF0LL )
            goto LABEL_304;
          v42 = *(const void **)(v10 + 16);
          if ( v41 >= 0x17 )
          {
            v43 = malloc((v41 + 16) & 0xFFFFFFFFFFFFFFF0LL);
            v34[1] = v41;
            v34[2] = (size_t)v43;
            *v34 = (v41 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
          }
          else
          {
            *(_BYTE *)v34 = 2 * v41;
            v43 = (char *)v34 + 1;
            if ( !v41 )
              goto LABEL_60;
          }
          memcpy(v43, v42, v41);
LABEL_60:
          *((_BYTE *)v43 + v41) = 0;
LABEL_61:
          v34[3] = 0LL;
          v44 = v34 + 3;
          v34[4] = 0LL;
          v34[5] = 0LL;
          if ( (*(_BYTE *)(v10 + 24) & 1) != 0 )
          {
            v45 = *(_QWORD *)(v10 + 32);
            if ( v45 >= 0xFFFFFFFFFFFFFFF0LL )
              abort();
            v46 = *(const void **)(v10 + 40);
            if ( v45 >= 0x17 )
            {
              v47 = malloc((v45 + 16) & 0xFFFFFFFFFFFFFFF0LL);
              v34[4] = v45;
              v34[5] = (size_t)v47;
              v34[3] = (v45 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
            }
            else
            {
              *v44 = 2 * v45;
              v47 = (char *)v34 + 25;
              if ( !v45 )
                goto LABEL_69;
            }
            memcpy(v47, v46, v45);
LABEL_69:
            *((_BYTE *)v47 + v45) = 0;
            goto LABEL_70;
          }
          v34[5] = *(_QWORD *)(v10 + 40);
          *(_OWORD *)v44 = *(_OWORD *)(v10 + 24);
LABEL_70:
          v5[1] = (char *)v5[1] + 48;
LABEL_71:
          v10 += 48LL;
          if ( v10 == v9 )
            return a1 + 2;
        }
      case 'a':
        *(_QWORD *)((char *)v176 + 7) = 0LL;
        v176[0] = 0LL;
        qmemcpy(v175, "std::allocator", 14);
        v53 = (char *)a3[1];
        v60 = (char *)a3[2];
        if ( v53 < v60 )
        {
          *v53 = 28;
          v4 = a1 + 2;
          *(_QWORD *)(v53 + 7) = *(_QWORD *)((char *)v175 + 6);
          v53[15] = 0;
          *((_QWORD *)v53 + 2) = 0LL;
          *(_QWORD *)(v53 + 1) = v175[0];
          *(_QWORD *)((char *)v175 + 6) = 0LL;
          goto LABEL_106;
        }
        v66 = 0xAAAAAAAAAAAAAAABLL * ((v53 - (_BYTE *)*a3) >> 4);
        if ( v66 + 1 > 0x555555555555555LL )
          abort();
        v67 = 0xAAAAAAAAAAAAAAABLL * ((v60 - (_BYTE *)*a3) >> 4);
        if ( v67 >= 0x2AAAAAAAAAAAAAALL || ((v68 = 2 * v67, v68 >= v66 + 1) ? (v7 = v68) : (v7 = v66 + 1), v7) )
        {
          v69 = a3[3];
          v70 = (char *)v69[512];
          if ( (char *)(v69 + 512) - v70 >= (unsigned __int64)(48 * v7) )
            v69[512] = &v70[48 * v7];
          else
            v70 = (char *)malloc(48 * v7);
        }
        else
        {
          v70 = 0LL;
        }
        v140 = &v70[48 * v66];
        *v140 = 28;
        *(_QWORD *)(v140 + 7) = *(_QWORD *)((char *)v175 + 6);
        v140[15] = 0;
        *((_QWORD *)v140 + 2) = 0LL;
        *(_QWORD *)(v140 + 1) = v175[0];
        *(_QWORD *)((char *)v175 + 6) = 0LL;
        v175[0] = 0LL;
        v140[24] = 0;
        *((_QWORD *)v140 + 4) = *(_QWORD *)((char *)v176 + 7);
        *((_QWORD *)v140 + 5) = 0LL;
        *(_QWORD *)(v140 + 25) = v176[0];
        *(_QWORD *)((char *)v176 + 7) = 0LL;
        v176[0] = 0LL;
        v142 = (void **)*v5;
        v141 = (void **)v5[1];
        v143 = v140 + 48;
        if ( v141 == *v5 )
        {
          v137 = (void **)*v5;
        }
        else
        {
          do
          {
            *((_QWORD *)v140 - 4) = *(v141 - 4);
            *((_OWORD *)v140 - 3) = *((_OWORD *)v141 - 3);
            v144 = (__int64)*(v141 - 1);
            *(v141 - 5) = 0LL;
            *(v141 - 4) = 0LL;
            *(v141 - 6) = 0LL;
            *((_QWORD *)v140 - 1) = v144;
            *(_OWORD *)(v140 - 24) = *(_OWORD *)(v141 - 3);
            *(v141 - 2) = 0LL;
            *(v141 - 1) = 0LL;
            *(v141 - 3) = 0LL;
            v141 -= 6;
            v140 -= 48;
          }
          while ( v142 != v141 );
          v137 = (void **)*v5;
          v142 = (void **)v5[1];
        }
        v138 = v5[2];
        *v5 = v140;
        v5[1] = v143;
        v5[2] = &v70[48 * v7];
        if ( v142 != v137 )
        {
          do
          {
            if ( (*(_BYTE *)(v142 - 3) & 1) != 0 )
              free(*(v142 - 1));
            v145 = v142 - 6;
            if ( (*(_BYTE *)(v142 - 6) & 1) != 0 )
              free(*(v142 - 4));
            v142 -= 6;
          }
          while ( v137 != v145 );
        }
        goto LABEL_296;
      case 'b':
        memset(v175, 0, 15);
        qmemcpy(v176, "std::basic_stri", 15);
        v62 = a3[1];
        v63 = a3[2];
        if ( v62 < (_QWORD *)v63 )
        {
          *(_BYTE *)v62 = 34;
          v4 = a1 + 2;
          v62[1] = *(_QWORD *)((char *)v176 + 7);
          v62[2] = 26478LL;
          *(_QWORD *)((char *)v62 + 1) = v176[0];
          *(_QWORD *)((char *)v176 + 7) = 0LL;
          v176[0] = 0LL;
          *((_BYTE *)v62 + 24) = 0;
          v62[4] = *(_QWORD *)((char *)v175 + 7);
          v62[5] = 0LL;
          *(_QWORD *)((char *)v62 + 25) = v175[0];
          memset(v175, 0, 15);
          goto LABEL_108;
        }
        v76 = 0xAAAAAAAAAAAAAAABLL * (((char *)v62 - (_BYTE *)*a3) >> 4);
        if ( v76 + 1 > 0x555555555555555LL )
          abort();
        v77 = 0xAAAAAAAAAAAAAAABLL * ((v63 - (_BYTE *)*a3) >> 4);
        if ( v77 >= 0x2AAAAAAAAAAAAAALL || ((v78 = 2 * v77, v78 >= v76 + 1) ? (v7 = v78) : (v7 = v76 + 1), v7) )
        {
          v79 = a3[3];
          v80 = (char *)v79[512];
          if ( (char *)(v79 + 512) - v80 >= (unsigned __int64)(48 * v7) )
            v79[512] = &v80[48 * v7];
          else
            v80 = (char *)malloc(48 * v7);
        }
        else
        {
          v80 = 0LL;
        }
        v152 = &v80[48 * v76];
        *v152 = 34;
        *((_QWORD *)v152 + 1) = *(_QWORD *)((char *)v176 + 7);
        *((_QWORD *)v152 + 2) = 26478LL;
        *(_QWORD *)(v152 + 1) = v176[0];
        *(_QWORD *)((char *)v176 + 7) = 0LL;
        v176[0] = 0LL;
        v152[24] = 0;
        *((_QWORD *)v152 + 4) = *(_QWORD *)((char *)v175 + 7);
        *((_QWORD *)v152 + 5) = 0LL;
        *(_QWORD *)(v152 + 25) = v175[0];
        memset(v175, 0, 15);
        v154 = (void **)*v5;
        v153 = (void **)v5[1];
        v155 = v152 + 48;
        if ( v153 == *v5 )
        {
          v137 = (void **)*v5;
        }
        else
        {
          do
          {
            *((_QWORD *)v152 - 4) = *(v153 - 4);
            *((_OWORD *)v152 - 3) = *((_OWORD *)v153 - 3);
            v156 = (__int64)*(v153 - 1);
            *(v153 - 5) = 0LL;
            *(v153 - 4) = 0LL;
            *(v153 - 6) = 0LL;
            *((_QWORD *)v152 - 1) = v156;
            *(_OWORD *)(v152 - 24) = *(_OWORD *)(v153 - 3);
            *(v153 - 2) = 0LL;
            *(v153 - 1) = 0LL;
            *(v153 - 3) = 0LL;
            v153 -= 6;
            v152 -= 48;
          }
          while ( v154 != v153 );
          v137 = (void **)*v5;
          v154 = (void **)v5[1];
        }
        v138 = v5[2];
        *v5 = v152;
        v5[1] = v155;
        v5[2] = &v80[48 * v7];
        if ( v154 != v137 )
        {
          do
          {
            if ( (*(_BYTE *)(v154 - 3) & 1) != 0 )
              free(*(v154 - 1));
            v157 = v154 - 6;
            if ( (*(_BYTE *)(v154 - 6) & 1) != 0 )
              free(*(v154 - 4));
            v154 -= 6;
          }
          while ( v137 != v157 );
        }
        goto LABEL_296;
      case 'd':
        *(_QWORD *)((char *)v176 + 7) = 0LL;
        v176[0] = 0LL;
        qmemcpy(v175, "std::iostream", 13);
        v53 = (char *)a3[1];
        v64 = (char *)a3[2];
        if ( v53 < v64 )
        {
          *v53 = 26;
          v4 = a1 + 2;
          *(_QWORD *)(v53 + 6) = *(_QWORD *)((char *)v175 + 5);
          *((_WORD *)v53 + 7) = 0;
          *((_QWORD *)v53 + 2) = 0LL;
          *(_QWORD *)(v53 + 1) = v175[0];
          *(_QWORD *)((char *)v175 + 5) = 0LL;
          goto LABEL_106;
        }
        v81 = 0xAAAAAAAAAAAAAAABLL * ((v53 - (_BYTE *)*a3) >> 4);
        if ( v81 + 1 > 0x555555555555555LL )
          abort();
        v82 = 0xAAAAAAAAAAAAAAABLL * ((v64 - (_BYTE *)*a3) >> 4);
        if ( v82 >= 0x2AAAAAAAAAAAAAALL || ((v83 = 2 * v82, v83 >= v81 + 1) ? (v7 = v83) : (v7 = v81 + 1), v7) )
        {
          v84 = a3[3];
          v85 = (char *)v84[512];
          if ( (char *)(v84 + 512) - v85 >= (unsigned __int64)(48 * v7) )
            v84[512] = &v85[48 * v7];
          else
            v85 = (char *)malloc(48 * v7);
        }
        else
        {
          v85 = 0LL;
        }
        v158 = &v85[48 * v81];
        *v158 = 26;
        *(_QWORD *)(v158 + 6) = *(_QWORD *)((char *)v175 + 5);
        *((_WORD *)v158 + 7) = 0;
        *((_QWORD *)v158 + 2) = 0LL;
        *(_QWORD *)(v158 + 1) = v175[0];
        *(_QWORD *)((char *)v175 + 5) = 0LL;
        v175[0] = 0LL;
        v158[24] = 0;
        *((_QWORD *)v158 + 4) = *(_QWORD *)((char *)v176 + 7);
        *((_QWORD *)v158 + 5) = 0LL;
        *(_QWORD *)(v158 + 25) = v176[0];
        *(_QWORD *)((char *)v176 + 7) = 0LL;
        v176[0] = 0LL;
        v160 = (void **)*v5;
        v159 = (void **)v5[1];
        v161 = v158 + 48;
        if ( v159 == *v5 )
        {
          v137 = (void **)*v5;
        }
        else
        {
          do
          {
            *((_QWORD *)v158 - 4) = *(v159 - 4);
            *((_OWORD *)v158 - 3) = *((_OWORD *)v159 - 3);
            v162 = (__int64)*(v159 - 1);
            *(v159 - 5) = 0LL;
            *(v159 - 4) = 0LL;
            *(v159 - 6) = 0LL;
            *((_QWORD *)v158 - 1) = v162;
            *(_OWORD *)(v158 - 24) = *(_OWORD *)(v159 - 3);
            *(v159 - 2) = 0LL;
            *(v159 - 1) = 0LL;
            *(v159 - 3) = 0LL;
            v159 -= 6;
            v158 -= 48;
          }
          while ( v160 != v159 );
          v137 = (void **)*v5;
          v160 = (void **)v5[1];
        }
        v138 = v5[2];
        *v5 = v158;
        v5[1] = v161;
        v5[2] = &v85[48 * v7];
        if ( v160 != v137 )
        {
          do
          {
            if ( (*(_BYTE *)(v160 - 3) & 1) != 0 )
              free(*(v160 - 1));
            v163 = v160 - 6;
            if ( (*(_BYTE *)(v160 - 6) & 1) != 0 )
              free(*(v160 - 4));
            v160 -= 6;
          }
          while ( v137 != v163 );
        }
        goto LABEL_296;
      case 'i':
        *(_QWORD *)((char *)v176 + 7) = 0LL;
        v176[0] = 0LL;
        qmemcpy(v175, "std::istream", 12);
        v53 = (char *)a3[1];
        v65 = (char *)a3[2];
        if ( v53 < v65 )
          goto LABEL_105;
        v86 = 0xAAAAAAAAAAAAAAABLL * ((v53 - (_BYTE *)*a3) >> 4);
        if ( v86 + 1 > 0x555555555555555LL )
          abort();
        v87 = 0xAAAAAAAAAAAAAAABLL * ((v65 - (_BYTE *)*a3) >> 4);
        if ( v87 >= 0x2AAAAAAAAAAAAAALL || ((v88 = 2 * v87, v88 >= v86 + 1) ? (v7 = v88) : (v7 = v86 + 1), v7) )
        {
          v89 = a3[3];
          v90 = (char *)v89[512];
          if ( (char *)(v89 + 512) - v90 >= (unsigned __int64)(48 * v7) )
            v89[512] = &v90[48 * v7];
          else
            v90 = (char *)malloc(48 * v7);
        }
        else
        {
          v90 = 0LL;
        }
        v164 = &v90[48 * v86];
        *v164 = 24;
        *(_DWORD *)(v164 + 9) = v175[1];
        v164[13] = 0;
        *((_WORD *)v164 + 7) = 0;
        *((_QWORD *)v164 + 2) = 0LL;
        *(_QWORD *)(v164 + 1) = v175[0];
        LODWORD(v175[1]) = 0;
        v175[0] = 0LL;
        v164[24] = 0;
        *((_QWORD *)v164 + 4) = *(_QWORD *)((char *)v176 + 7);
        *((_QWORD *)v164 + 5) = 0LL;
        *(_QWORD *)(v164 + 25) = v176[0];
        *(_QWORD *)((char *)v176 + 7) = 0LL;
        v176[0] = 0LL;
        v166 = (void **)*v5;
        v165 = (void **)v5[1];
        v167 = v164 + 48;
        if ( v165 == *v5 )
        {
          v137 = (void **)*v5;
        }
        else
        {
          do
          {
            *((_QWORD *)v164 - 4) = *(v165 - 4);
            *((_OWORD *)v164 - 3) = *((_OWORD *)v165 - 3);
            v168 = (__int64)*(v165 - 1);
            *(v165 - 5) = 0LL;
            *(v165 - 4) = 0LL;
            *(v165 - 6) = 0LL;
            *((_QWORD *)v164 - 1) = v168;
            *(_OWORD *)(v164 - 24) = *(_OWORD *)(v165 - 3);
            *(v165 - 2) = 0LL;
            *(v165 - 1) = 0LL;
            *(v165 - 3) = 0LL;
            v165 -= 6;
            v164 -= 48;
          }
          while ( v166 != v165 );
          v137 = (void **)*v5;
          v166 = (void **)v5[1];
        }
        v138 = v5[2];
        *v5 = v164;
        v5[1] = v167;
        v5[2] = &v90[48 * v7];
        if ( v166 != v137 )
        {
          do
          {
            if ( (*(_BYTE *)(v166 - 3) & 1) != 0 )
              free(*(v166 - 1));
            v169 = v166 - 6;
            if ( (*(_BYTE *)(v166 - 6) & 1) != 0 )
              free(*(v166 - 4));
            v166 -= 6;
          }
          while ( v137 != v169 );
        }
        goto LABEL_296;
      case 'o':
        *(_QWORD *)((char *)v176 + 7) = 0LL;
        v176[0] = 0LL;
        qmemcpy(v175, "std::ostream", 12);
        v53 = (char *)a3[1];
        v54 = (char *)a3[2];
        if ( v53 >= v54 )
        {
          v55 = 0xAAAAAAAAAAAAAAABLL * ((v53 - (_BYTE *)*a3) >> 4);
          if ( v55 + 1 > 0x555555555555555LL )
            abort();
          v56 = 0xAAAAAAAAAAAAAAABLL * ((v54 - (_BYTE *)*a3) >> 4);
          if ( v56 >= 0x2AAAAAAAAAAAAAALL || ((v57 = 2 * v56, v57 >= v55 + 1) ? (v7 = v57) : (v7 = v55 + 1), v7) )
          {
            v58 = a3[3];
            v59 = (char *)v58[512];
            if ( (char *)(v58 + 512) - v59 >= (unsigned __int64)(48 * v7) )
              v58[512] = &v59[48 * v7];
            else
              v59 = (char *)malloc(48 * v7);
          }
          else
          {
            v59 = 0LL;
          }
          v132 = &v59[48 * v55];
          *v132 = 24;
          *(_DWORD *)(v132 + 9) = v175[1];
          v132[13] = 0;
          *((_WORD *)v132 + 7) = 0;
          *((_QWORD *)v132 + 2) = 0LL;
          *(_QWORD *)(v132 + 1) = v175[0];
          LODWORD(v175[1]) = 0;
          v175[0] = 0LL;
          v132[24] = 0;
          *((_QWORD *)v132 + 4) = *(_QWORD *)((char *)v176 + 7);
          *((_QWORD *)v132 + 5) = 0LL;
          *(_QWORD *)(v132 + 25) = v176[0];
          *(_QWORD *)((char *)v176 + 7) = 0LL;
          v176[0] = 0LL;
          v134 = (void **)*v5;
          v133 = (void **)v5[1];
          v135 = v132 + 48;
          if ( v133 == *v5 )
          {
            v137 = (void **)*v5;
          }
          else
          {
            do
            {
              *((_QWORD *)v132 - 4) = *(v133 - 4);
              *((_OWORD *)v132 - 3) = *((_OWORD *)v133 - 3);
              v136 = (__int64)*(v133 - 1);
              *(v133 - 5) = 0LL;
              *(v133 - 4) = 0LL;
              *(v133 - 6) = 0LL;
              *((_QWORD *)v132 - 1) = v136;
              *(_OWORD *)(v132 - 24) = *(_OWORD *)(v133 - 3);
              *(v133 - 2) = 0LL;
              *(v133 - 1) = 0LL;
              *(v133 - 3) = 0LL;
              v133 -= 6;
              v132 -= 48;
            }
            while ( v134 != v133 );
            v137 = (void **)*v5;
            v134 = (void **)v5[1];
          }
          v138 = v5[2];
          *v5 = v132;
          v5[1] = v135;
          v5[2] = &v59[48 * v7];
          if ( v134 != v137 )
          {
            do
            {
              if ( (*(_BYTE *)(v134 - 3) & 1) != 0 )
                free(*(v134 - 1));
              v139 = v134 - 6;
              if ( (*(_BYTE *)(v134 - 6) & 1) != 0 )
                free(*(v134 - 4));
              v134 -= 6;
            }
            while ( v137 != v139 );
          }
          goto LABEL_296;
        }
LABEL_105:
        *v53 = 24;
        v4 = a1 + 2;
        *(_DWORD *)(v53 + 9) = v175[1];
        v53[13] = 0;
        *((_WORD *)v53 + 7) = 0;
        *((_QWORD *)v53 + 2) = 0LL;
        *(_QWORD *)(v53 + 1) = v175[0];
        LODWORD(v175[1]) = 0;
LABEL_106:
        v175[0] = 0LL;
        goto LABEL_107;
      case 's':
        *(_QWORD *)((char *)v176 + 7) = 0LL;
        v176[0] = 0LL;
        qmemcpy(v175, "std::string", 11);
        v53 = (char *)a3[1];
        v61 = (char *)a3[2];
        if ( v53 >= v61 )
        {
          v71 = 0xAAAAAAAAAAAAAAABLL * ((v53 - (_BYTE *)*a3) >> 4);
          if ( v71 + 1 > 0x555555555555555LL )
            abort();
          v72 = 0xAAAAAAAAAAAAAAABLL * ((v61 - (_BYTE *)*a3) >> 4);
          if ( v72 >= 0x2AAAAAAAAAAAAAALL || ((v73 = 2 * v72, v73 >= v71 + 1) ? (v7 = v73) : (v7 = v71 + 1), v7) )
          {
            v74 = a3[3];
            v75 = (char *)v74[512];
            if ( (char *)(v74 + 512) - v75 >= (unsigned __int64)(48 * v7) )
              v74[512] = &v75[48 * v7];
            else
              v75 = (char *)malloc(48 * v7);
          }
          else
          {
            v75 = 0LL;
          }
          v146 = &v75[48 * v71];
          *v146 = 22;
          *(_QWORD *)(v146 + 1) = v175[0];
          v146[11] = BYTE2(v175[1]);
          v146[12] = 0;
          *(_WORD *)(v146 + 9) = v175[1];
          *(_WORD *)(v146 + 13) = 0;
          *((_QWORD *)v146 + 2) = 0LL;
          v146[15] = 0;
          v175[0] = 0LL;
          LOWORD(v175[1]) = 0;
          BYTE2(v175[1]) = 0;
          v146[24] = 0;
          *((_QWORD *)v146 + 4) = *(_QWORD *)((char *)v176 + 7);
          *((_QWORD *)v146 + 5) = 0LL;
          *(_QWORD *)(v146 + 25) = v176[0];
          *(_QWORD *)((char *)v176 + 7) = 0LL;
          v176[0] = 0LL;
          v148 = (void **)*v5;
          v147 = (void **)v5[1];
          v149 = v146 + 48;
          if ( v147 == *v5 )
          {
            v137 = (void **)*v5;
          }
          else
          {
            do
            {
              *((_QWORD *)v146 - 4) = *(v147 - 4);
              *((_OWORD *)v146 - 3) = *((_OWORD *)v147 - 3);
              v150 = (__int64)*(v147 - 1);
              *(v147 - 5) = 0LL;
              *(v147 - 4) = 0LL;
              *(v147 - 6) = 0LL;
              *((_QWORD *)v146 - 1) = v150;
              *(_OWORD *)(v146 - 24) = *(_OWORD *)(v147 - 3);
              *(v147 - 2) = 0LL;
              *(v147 - 1) = 0LL;
              *(v147 - 3) = 0LL;
              v147 -= 6;
              v146 -= 48;
            }
            while ( v148 != v147 );
            v137 = (void **)*v5;
            v148 = (void **)v5[1];
          }
          v138 = v5[2];
          *v5 = v146;
          v5[1] = v149;
          v5[2] = &v75[48 * v7];
          if ( v148 != v137 )
          {
            do
            {
              if ( (*(_BYTE *)(v148 - 3) & 1) != 0 )
                free(*(v148 - 1));
              v151 = v148 - 6;
              if ( (*(_BYTE *)(v148 - 6) & 1) != 0 )
                free(*(v148 - 4));
              v148 -= 6;
            }
            while ( v137 != v151 );
          }
LABEL_296:
          if ( v137 )
          {
            v170 = (unsigned __int64)v5[3];
            if ( v170 + 4096 < (unsigned __int64)v137 || v170 > (unsigned __int64)v137 )
            {
              free(v137);
            }
            else if ( *(void **)(v170 + 4096) == v138 )
            {
              *(_QWORD *)(v170 + 4096) = v137;
            }
          }
          v4 += 2;
        }
        else
        {
          *v53 = 22;
          v4 = a1 + 2;
          *(_QWORD *)(v53 + 1) = v175[0];
          v53[11] = BYTE2(v175[1]);
          v53[12] = 0;
          *(_WORD *)(v53 + 9) = v175[1];
          *(_WORD *)(v53 + 13) = 0;
          *((_QWORD *)v53 + 2) = 0LL;
          v53[15] = 0;
          v175[0] = 0LL;
          LOWORD(v175[1]) = 0;
          BYTE2(v175[1]) = 0;
LABEL_107:
          v53[24] = 0;
          *((_QWORD *)v53 + 4) = *(_QWORD *)((char *)v176 + 7);
          *((_QWORD *)v53 + 5) = 0LL;
          *(_QWORD *)(v53 + 25) = v176[0];
          *(_QWORD *)((char *)v176 + 7) = 0LL;
          v176[0] = 0LL;
LABEL_108:
          a3[1] = (char *)a3[1] + 48;
        }
        return v4;
      default:
        if ( (unsigned int)(v6 - 48) >= 0xA && !isupper(v6) )
          return v4;
        v48 = v4 + 2;
        if ( v4 + 2 == a2 )
          return v4;
        if ( (unsigned int)(v6 - 48) >= 0xA )
          v49 = -55;
        else
          v49 = -48;
        v50 = v6 + v49;
        while ( 1 )
        {
          v51 = *v48;
          if ( (unsigned int)(v51 - 48) >= 0xA && !isupper(v51) )
            break;
          if ( (unsigned int)(v51 - 48) >= 0xA )
            v52 = -55;
          else
            v52 = -48;
          ++v48;
          v50 = v51 + v52 + 36 * v50;
          if ( a2 == v48 )
            return v4;
        }
        if ( (_DWORD)v51 != 95 )
          return v4;
        v91 = v5[4];
        if ( v50 + 1 >= (unsigned __int64)(((_BYTE *)v5[5] - v91) >> 5) )
          return v4;
        v92 = (__int64 *)&v91[32 * v50 + 32];
        v94 = *v92;
        v93 = v92[1];
        if ( *v92 == v93 )
          return v48 + 1;
        v173 = v92[1];
        break;
    }
    while ( 1 )
    {
      v118 = (size_t *)v5[1];
      v117 = (char *)v5[2];
      if ( v118 == (size_t *)v117 )
      {
        v119 = 0xAAAAAAAAAAAAAAABLL * (((char *)v118 - (_BYTE *)*v5) >> 4);
        if ( v119 + 1 > 0x555555555555555LL )
          goto LABEL_304;
        v120 = 0xAAAAAAAAAAAAAAABLL * ((v117 - (_BYTE *)*v5) >> 4);
        v121 = 0x555555555555555LL;
        if ( v120 >= 0x2AAAAAAAAAAAAAALL
          || ((v122 = 2 * v120, v122 >= v119 + 1) ? (v121 = v122) : (v121 = v119 + 1), v121) )
        {
          v123 = v5[3];
          v124 = 48 * v121;
          v95 = (char *)v123[512];
          if ( (char *)(v123 + 512) - v95 >= (unsigned __int64)(48 * v121) )
            v123[512] = &v95[v124];
          else
            v95 = (char *)malloc(v124);
        }
        else
        {
          v95 = 0LL;
        }
        v96 = (size_t *)&v95[48 * v119];
        v96[1] = 0LL;
        v96[2] = 0LL;
        *v96 = 0LL;
        v97 = &v95[48 * v121];
        if ( (*(_BYTE *)v94 & 1) == 0 )
        {
          v96[2] = *(_QWORD *)(v94 + 16);
          *(_OWORD *)v96 = *(_OWORD *)v94;
          goto LABEL_170;
        }
        v98 = *(_QWORD *)(v94 + 8);
        if ( v98 >= 0xFFFFFFFFFFFFFFF0LL )
          abort();
        v99 = *(const void **)(v94 + 16);
        if ( v98 >= 0x17 )
        {
          v100 = malloc((v98 + 16) & 0xFFFFFFFFFFFFFFF0LL);
          v101 = &v95[48 * v119];
          *((_QWORD *)v101 + 1) = v98;
          *((_QWORD *)v101 + 2) = v100;
          *v96 = (v98 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
        }
        else
        {
          *(_BYTE *)v96 = 2 * v98;
          v100 = (char *)v96 + 1;
          if ( !v98 )
            goto LABEL_169;
        }
        memcpy(v100, v99, v98);
LABEL_169:
        *((_BYTE *)v100 + v98) = 0;
LABEL_170:
        v102 = &v95[48 * v119];
        *((_QWORD *)v102 + 3) = 0LL;
        v103 = v102 + 24;
        *((_QWORD *)v103 + 1) = 0LL;
        *((_QWORD *)v103 + 2) = 0LL;
        if ( (*(_BYTE *)(v94 + 24) & 1) == 0 )
        {
          *((_QWORD *)v103 + 2) = *(_QWORD *)(v94 + 40);
          *(_OWORD *)v103 = *(_OWORD *)(v94 + 24);
          v93 = v173;
LABEL_179:
          v110 = (void **)*v5;
          v109 = (void **)v5[1];
          v111 = v96 + 6;
          if ( v109 == *v5 )
          {
            v113 = (void **)*v5;
          }
          else
          {
            do
            {
              *(v96 - 4) = (size_t)*(v109 - 4);
              *((_OWORD *)v96 - 3) = *((_OWORD *)v109 - 3);
              v112 = (size_t)*(v109 - 1);
              *(v109 - 5) = 0LL;
              *(v109 - 4) = 0LL;
              *(v109 - 6) = 0LL;
              *(v96 - 1) = v112;
              *(_OWORD *)(v96 - 3) = *(_OWORD *)(v109 - 3);
              *(v109 - 2) = 0LL;
              *(v109 - 1) = 0LL;
              *(v109 - 3) = 0LL;
              v109 -= 6;
              v96 -= 6;
            }
            while ( v110 != v109 );
            v113 = (void **)*v5;
            v110 = (void **)v5[1];
          }
          v114 = v5[2];
          *v5 = v96;
          v5[1] = v111;
          v5[2] = v97;
          if ( v110 != v113 )
          {
            do
            {
              if ( (*(_BYTE *)(v110 - 3) & 1) != 0 )
                free(*(v110 - 1));
              v115 = v110 - 6;
              if ( (*(_BYTE *)(v110 - 6) & 1) != 0 )
                free(*(v110 - 4));
              v110 -= 6;
            }
            while ( v113 != v115 );
          }
          if ( v113 )
          {
            v116 = (unsigned __int64)v5[3];
            if ( v116 + 4096 < (unsigned __int64)v113 || v116 > (unsigned __int64)v113 )
            {
              free(v113);
            }
            else if ( *(void **)(v116 + 4096) == v114 )
            {
              *(_QWORD *)(v116 + 4096) = v113;
            }
          }
          goto LABEL_223;
        }
        v104 = *(_QWORD *)(v94 + 32);
        if ( v104 >= 0xFFFFFFFFFFFFFFF0LL )
          abort();
        v105 = *(const void **)(v94 + 40);
        if ( v104 >= 0x17 )
        {
          v107 = malloc((v104 + 16) & 0xFFFFFFFFFFFFFFF0LL);
          v108 = &v95[48 * v119];
          *((_QWORD *)v108 + 4) = v104;
          *((_QWORD *)v108 + 5) = v107;
          *(_QWORD *)v103 = (v104 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
          v93 = v173;
          v106 = v107;
        }
        else
        {
          *v103 = 2 * v104;
          v106 = v103 + 1;
          v93 = v173;
          if ( !v104 )
            goto LABEL_178;
        }
        memcpy(v106, v105, v104);
LABEL_178:
        *((_BYTE *)v106 + v104) = 0;
        goto LABEL_179;
      }
      v118[1] = 0LL;
      v118[2] = 0LL;
      *v118 = 0LL;
      if ( (*(_BYTE *)v94 & 1) == 0 )
      {
        v118[2] = *(_QWORD *)(v94 + 16);
        *(_OWORD *)v118 = *(_OWORD *)v94;
        goto LABEL_213;
      }
      v125 = *(_QWORD *)(v94 + 8);
      if ( v125 >= 0xFFFFFFFFFFFFFFF0LL )
LABEL_304:
        abort();
      v126 = *(const void **)(v94 + 16);
      if ( v125 >= 0x17 )
      {
        v127 = malloc((v125 + 16) & 0xFFFFFFFFFFFFFFF0LL);
        v118[1] = v125;
        v118[2] = (size_t)v127;
        *v118 = (v125 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
      }
      else
      {
        *(_BYTE *)v118 = 2 * v125;
        v127 = (char *)v118 + 1;
        if ( !v125 )
          goto LABEL_212;
      }
      memcpy(v127, v126, v125);
LABEL_212:
      *((_BYTE *)v127 + v125) = 0;
LABEL_213:
      v118[3] = 0LL;
      v128 = v118 + 3;
      v118[4] = 0LL;
      v118[5] = 0LL;
      if ( (*(_BYTE *)(v94 + 24) & 1) != 0 )
      {
        v129 = *(_QWORD *)(v94 + 32);
        if ( v129 >= 0xFFFFFFFFFFFFFFF0LL )
          abort();
        v130 = *(const void **)(v94 + 40);
        if ( v129 >= 0x17 )
        {
          v131 = malloc((v129 + 16) & 0xFFFFFFFFFFFFFFF0LL);
          v118[4] = v129;
          v118[5] = (size_t)v131;
          v118[3] = (v129 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
        }
        else
        {
          *v128 = 2 * v129;
          v131 = (char *)v118 + 25;
          if ( !v129 )
            goto LABEL_221;
        }
        memcpy(v131, v130, v129);
LABEL_221:
        *((_BYTE *)v131 + v129) = 0;
        goto LABEL_222;
      }
      v118[5] = *(_QWORD *)(v94 + 40);
      *(_OWORD *)v128 = *(_OWORD *)(v94 + 24);
LABEL_222:
      v5[1] = (char *)v5[1] + 48;
LABEL_223:
      v94 += 48LL;
      if ( v94 == v93 )
        return v48 + 1;
    }
  }
  return v4;
}

//----- (000000000009F8F0) ----------------------------------------------------
size_t *__usercall sub_9F8F0@<X0>(const char *a1@<X0>, unsigned __int8 *a2@<X1>, size_t *a3@<X8>)
{
  size_t v6; // x0
  unsigned __int64 v7; // x26
  size_t v8; // x23
  size_t v9; // x22
  unsigned __int64 v10; // x8
  void *v11; // x24
  size_t v12; // x25
  void *v13; // x1

  a3[1] = 0LL;
  a3[2] = 0LL;
  *a3 = 0LL;
  v6 = strlen(a1);
  v7 = *a2;
  v8 = v6;
  if ( (v7 & 1) != 0 )
    v9 = *((_QWORD *)a2 + 1);
  else
    v9 = v7 >> 1;
  v10 = v9 + v6;
  if ( v9 + v6 >= 0xFFFFFFFFFFFFFFF0LL )
    abort();
  if ( v10 > 0x16 )
  {
    v12 = (v10 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v11 = malloc(v12);
    a3[1] = v8;
    a3[2] = (size_t)v11;
    *a3 = v12 | 1;
    if ( !v8 )
      goto LABEL_10;
    goto LABEL_9;
  }
  *(_BYTE *)a3 = 2 * v6;
  v11 = (char *)a3 + 1;
  if ( v6 )
LABEL_9:
    memcpy(v11, a1, v8);
LABEL_10:
  *((_BYTE *)v11 + v8) = 0;
  if ( (v7 & 1) != 0 )
    v13 = (void *)*((_QWORD *)a2 + 2);
  else
    v13 = a2 + 1;
  return sub_9CFD0(a3, v13, v9);
}

//----- (000000000009F9E8) ----------------------------------------------------
__int64 __fastcall sub_9F9E8(_BYTE *a1, _BYTE *a2, __int64 a3)
{
  _BYTE *v3; // x20
  __int64 v5; // x8
  __int64 v6; // x9
  __int64 *v7; // x8
  __int64 v8; // x27
  __int64 v9; // x28
  char *v10; // x21
  size_t *v11; // x24
  char *v12; // x20
  size_t v13; // x22
  const void *v14; // x23
  void *v15; // x27
  char *v16; // x8
  char *v17; // x22
  char *v18; // x22
  size_t v19; // x23
  const void *v20; // x27
  void *v21; // x22
  void *v22; // x0
  char *v23; // x8
  void **v24; // x9
  void **v25; // x22
  _QWORD *v26; // x8
  size_t v27; // x10
  void **v28; // x21
  __int64 v29; // x23
  void **v30; // x24
  unsigned __int64 v31; // x8
  size_t *v32; // x9
  size_t *v33; // x25
  unsigned __int64 v34; // x26
  unsigned __int64 v35; // x9
  __int64 v36; // x22
  unsigned __int64 v37; // x9
  __int64 v38; // x8
  size_t v39; // x0
  size_t v40; // x21
  const void *v41; // x22
  void *v42; // x23
  _BYTE *v43; // x21
  size_t v44; // x22
  const void *v45; // x23
  void *v46; // x21
  __int64 v47; // x8
  __int64 v48; // x28
  _BYTE *v49; // x24
  __int64 v50; // x12
  unsigned __int64 v51; // x8
  unsigned __int64 v52; // x9
  __int64 v53; // x9
  __int64 v54; // x9
  __int64 v55; // x10
  unsigned __int64 v56; // x8
  __int64 *v57; // x8
  __int64 v58; // x26
  __int64 v59; // x27
  unsigned __int64 v60; // x21
  unsigned __int64 v61; // x8
  unsigned __int64 v62; // x9
  unsigned __int64 v63; // x9
  __int64 v64; // x9
  char *v65; // x0
  char *v66; // x21
  size_t *v67; // x26
  char *v68; // x20
  size_t v69; // x22
  const void *v70; // x1
  void *v71; // x24
  const void *v72; // x24
  void *v73; // x0
  char *v74; // x8
  char *v75; // x22
  char *v76; // x22
  size_t v77; // x23
  const void *v78; // x1
  void *v79; // x22
  const void *v80; // x20
  void *v81; // x0
  char *v82; // x8
  void **v83; // x9
  void **v84; // x22
  _QWORD *v85; // x8
  size_t v86; // x10
  void **v87; // x21
  __int64 v88; // x23
  void **v89; // x24
  unsigned __int64 v90; // x8
  size_t *v91; // x9
  size_t *v92; // x25
  unsigned __int64 v93; // x25
  unsigned __int64 v94; // x9
  __int64 v95; // x22
  unsigned __int64 v96; // x9
  __int64 v97; // x8
  size_t v98; // x0
  size_t v99; // x21
  const void *v100; // x22
  void *v101; // x23
  _BYTE *v102; // x21
  size_t v103; // x22
  const void *v104; // x23
  void *v105; // x21
  __int64 v106; // x22
  unsigned __int64 v107; // x23
  _BYTE *v108; // x0
  char *v109; // x8
  __int64 v110; // x10
  void **v111; // x11
  void **v112; // x22
  char *v113; // x10
  __int64 v114; // x12
  void **v115; // x21
  __int64 v116; // x23
  void **v117; // x24
  unsigned __int64 v118; // x8
  __int64 v120; // x9
  char *v121; // x8
  unsigned __int64 v122; // x10
  _BYTE *v123; // x11
  _OWORD *v124; // x12
  __int128 *v125; // x13
  unsigned __int64 v126; // x14
  __int128 v127; // q0
  __int128 v128; // q1
  _BYTE *v129; // x9
  _BYTE *v130; // x10
  char v131; // t1
  __int64 v132; // x8
  _BYTE *v133; // x21
  __int64 v134; // x9
  char v135; // w23
  unsigned __int64 v136; // x8
  unsigned __int64 v137; // x9
  unsigned __int64 v138; // x20
  unsigned __int64 v139; // x8
  unsigned __int64 v140; // x9
  unsigned __int64 v141; // x9
  __int64 v142; // x9
  char *v143; // x0
  char *v144; // x8
  void **v145; // x11
  void **v146; // x21
  char *v147; // x10
  __int64 v148; // x12
  void **v149; // x20
  __int64 v150; // x23
  void **v151; // x24
  unsigned __int64 v152; // x8
  char *v153; // [xsp+8h] [xbp-B8h]
  __int64 v156; // [xsp+20h] [xbp-A0h]
  __int64 v157; // [xsp+28h] [xbp-98h]
  __int64 v158; // [xsp+28h] [xbp-98h]
  __int128 v159; // [xsp+30h] [xbp-90h] BYREF
  _BYTE *v160; // [xsp+40h] [xbp-80h]
  _QWORD v161[2]; // [xsp+48h] [xbp-78h] BYREF
  _QWORD v162[3]; // [xsp+58h] [xbp-68h] BYREF

  v3 = a1;
  v162[2] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a2 - a1 < 2 || *a1 != 84 )
    return (__int64)v3;
  v5 = (unsigned __int8)a1[1];
  v156 = 0x555555555555555LL;
  if ( v5 != 95 )
  {
    v47 = v5 - 48;
    if ( (unsigned int)v47 > 9 || a1 + 2 == a2 )
      return (__int64)v3;
    v48 = 0LL;
    while ( 1 )
    {
      v49 = &a1[v48];
      v50 = (unsigned __int8)a1[v48 + 2];
      if ( (unsigned int)(v50 - 48) > 9 )
        break;
      ++v48;
      v47 = v50 - 48 + 10 * v47;
      if ( !&a1[v48 + 2LL - (_QWORD)a2] )
        return (__int64)v3;
    }
    if ( (_DWORD)v50 != 95 )
      return (__int64)v3;
    v54 = *(_QWORD *)(a3 + 72);
    if ( *(_QWORD *)(a3 + 64) == v54 )
      return (__int64)v3;
    v55 = *(_QWORD *)(v54 - 32);
    v56 = v47 + 1;
    if ( v56 < (*(_QWORD *)(v54 - 24) - v55) >> 5 )
    {
      v57 = (__int64 *)(v55 + 32 * v56);
      v59 = *v57;
      v58 = v57[1];
      if ( *v57 == v58 )
        return (__int64)&a1[v48 + 3];
      v158 = v57[1];
      while ( 1 )
      {
        v92 = *(size_t **)(a3 + 8);
        v91 = *(size_t **)(a3 + 16);
        if ( v92 == v91 )
        {
          v93 = 0xAAAAAAAAAAAAAAABLL * (((__int64)v92 - *(_QWORD *)a3) >> 4);
          if ( v93 + 1 > 0x555555555555555LL )
            goto LABEL_228;
          v94 = 0xAAAAAAAAAAAAAAABLL * (((__int64)v91 - *(_QWORD *)a3) >> 4);
          v95 = 0x555555555555555LL;
          if ( v94 >= 0x2AAAAAAAAAAAAAALL || ((v96 = 2 * v94, v96 >= v93 + 1) ? (v95 = v96) : (v95 = v93 + 1), v95) )
          {
            v97 = *(_QWORD *)(a3 + 24);
            v98 = 48 * v95;
            v66 = *(char **)(v97 + 4096);
            if ( v97 + 4096 - (__int64)v66 >= (unsigned __int64)(48 * v95) )
              *(_QWORD *)(v97 + 4096) = &v66[v98];
            else
              v66 = (char *)malloc(v98);
          }
          else
          {
            v66 = 0LL;
          }
          v67 = (size_t *)&v66[48 * v93];
          v67[1] = 0LL;
          v67[2] = 0LL;
          *v67 = 0LL;
          v68 = &v66[48 * v95];
          if ( (*(_BYTE *)v59 & 1) == 0 )
          {
            v67[2] = *(_QWORD *)(v59 + 16);
            *(_OWORD *)v67 = *(_OWORD *)v59;
            goto LABEL_106;
          }
          v69 = *(_QWORD *)(v59 + 8);
          if ( v69 >= 0xFFFFFFFFFFFFFFF0LL )
            abort();
          v70 = *(const void **)(v59 + 16);
          if ( v69 >= 0x17 )
          {
            v72 = *(const void **)(v59 + 16);
            v73 = malloc((v69 + 16) & 0xFFFFFFFFFFFFFFF0LL);
            v70 = v72;
            v71 = v73;
            v74 = &v66[48 * v93];
            *((_QWORD *)v74 + 1) = v69;
            *((_QWORD *)v74 + 2) = v73;
            *v67 = (v69 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
          }
          else
          {
            *(_BYTE *)v67 = 2 * v69;
            v71 = (char *)v67 + 1;
            if ( !v69 )
              goto LABEL_105;
          }
          memcpy(v71, v70, v69);
LABEL_105:
          *((_BYTE *)v71 + v69) = 0;
LABEL_106:
          v75 = &v66[48 * v93];
          *((_QWORD *)v75 + 3) = 0LL;
          v76 = v75 + 24;
          *((_QWORD *)v76 + 1) = 0LL;
          *((_QWORD *)v76 + 2) = 0LL;
          if ( (*(_BYTE *)(v59 + 24) & 1) == 0 )
          {
            *((_QWORD *)v76 + 2) = *(_QWORD *)(v59 + 40);
            *(_OWORD *)v76 = *(_OWORD *)(v59 + 24);
LABEL_115:
            v84 = *(void ***)a3;
            v83 = *(void ***)(a3 + 8);
            v85 = v67 + 6;
            if ( v83 == *(void ***)a3 )
            {
              v87 = *(void ***)a3;
            }
            else
            {
              do
              {
                *(v67 - 4) = (size_t)*(v83 - 4);
                *((_OWORD *)v67 - 3) = *((_OWORD *)v83 - 3);
                v86 = (size_t)*(v83 - 1);
                *(v83 - 5) = 0LL;
                *(v83 - 4) = 0LL;
                *(v83 - 6) = 0LL;
                *(v67 - 1) = v86;
                *(_OWORD *)(v67 - 3) = *(_OWORD *)(v83 - 3);
                *(v83 - 2) = 0LL;
                *(v83 - 1) = 0LL;
                *(v83 - 3) = 0LL;
                v83 -= 6;
                v67 -= 6;
              }
              while ( v84 != v83 );
              v87 = *(void ***)a3;
              v84 = *(void ***)(a3 + 8);
            }
            v88 = *(_QWORD *)(a3 + 16);
            *(_QWORD *)a3 = v67;
            *(_QWORD *)(a3 + 8) = v85;
            *(_QWORD *)(a3 + 16) = v68;
            v58 = v158;
            if ( v84 != v87 )
            {
              do
              {
                if ( (*(_BYTE *)(v84 - 3) & 1) != 0 )
                  free(*(v84 - 1));
                v89 = v84 - 6;
                if ( (*(_BYTE *)(v84 - 6) & 1) != 0 )
                  free(*(v84 - 4));
                v84 -= 6;
              }
              while ( v87 != v89 );
            }
            if ( v87 )
            {
              v90 = *(_QWORD *)(a3 + 24);
              if ( v90 + 4096 < (unsigned __int64)v87 || v90 > (unsigned __int64)v87 )
              {
                free(v87);
              }
              else if ( *(_QWORD *)(v90 + 4096) == v88 )
              {
                *(_QWORD *)(v90 + 4096) = v87;
              }
            }
            goto LABEL_159;
          }
          v77 = *(_QWORD *)(v59 + 32);
          if ( v77 >= 0xFFFFFFFFFFFFFFF0LL )
            abort();
          v78 = *(const void **)(v59 + 40);
          if ( v77 >= 0x17 )
          {
            v153 = v68;
            v80 = *(const void **)(v59 + 40);
            v81 = malloc((v77 + 16) & 0xFFFFFFFFFFFFFFF0LL);
            v78 = v80;
            v68 = v153;
            v82 = &v66[48 * v93];
            *((_QWORD *)v82 + 4) = v77;
            *((_QWORD *)v82 + 5) = v81;
            *(_QWORD *)v76 = (v77 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
            v79 = v81;
          }
          else
          {
            *v76 = 2 * v77;
            v79 = v76 + 1;
            if ( !v77 )
              goto LABEL_114;
          }
          memcpy(v79, v78, v77);
LABEL_114:
          *((_BYTE *)v79 + v77) = 0;
          goto LABEL_115;
        }
        v92[1] = 0LL;
        v92[2] = 0LL;
        *v92 = 0LL;
        if ( (*(_BYTE *)v59 & 1) == 0 )
        {
          v92[2] = *(_QWORD *)(v59 + 16);
          *(_OWORD *)v92 = *(_OWORD *)v59;
          goto LABEL_149;
        }
        v99 = *(_QWORD *)(v59 + 8);
        if ( v99 >= 0xFFFFFFFFFFFFFFF0LL )
          goto LABEL_228;
        v100 = *(const void **)(v59 + 16);
        if ( v99 >= 0x17 )
        {
          v101 = malloc((v99 + 16) & 0xFFFFFFFFFFFFFFF0LL);
          v92[1] = v99;
          v92[2] = (size_t)v101;
          *v92 = (v99 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
        }
        else
        {
          *(_BYTE *)v92 = 2 * v99;
          v101 = (char *)v92 + 1;
          if ( !v99 )
            goto LABEL_148;
        }
        memcpy(v101, v100, v99);
LABEL_148:
        *((_BYTE *)v101 + v99) = 0;
LABEL_149:
        v92[3] = 0LL;
        v102 = v92 + 3;
        v92[4] = 0LL;
        v92[5] = 0LL;
        if ( (*(_BYTE *)(v59 + 24) & 1) != 0 )
        {
          v103 = *(_QWORD *)(v59 + 32);
          if ( v103 >= 0xFFFFFFFFFFFFFFF0LL )
            abort();
          v104 = *(const void **)(v59 + 40);
          if ( v103 >= 0x17 )
          {
            v105 = malloc((v103 + 16) & 0xFFFFFFFFFFFFFFF0LL);
            v92[4] = v103;
            v92[5] = (size_t)v105;
            v92[3] = (v103 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
          }
          else
          {
            *v102 = 2 * v103;
            v105 = (char *)v92 + 25;
            if ( !v103 )
              goto LABEL_157;
          }
          memcpy(v105, v104, v103);
LABEL_157:
          *((_BYTE *)v105 + v103) = 0;
          goto LABEL_158;
        }
        v92[5] = *(_QWORD *)(v59 + 40);
        *(_OWORD *)v102 = *(_OWORD *)(v59 + 24);
LABEL_158:
        *(_QWORD *)(a3 + 8) += 48LL;
LABEL_159:
        v59 += 48LL;
        if ( v59 == v58 )
          return (__int64)&a1[v48 + 3];
      }
    }
    v106 = (__int64)&a1[v48 + 3];
    v107 = v48 + 3;
    v160 = 0LL;
    v159 = 0uLL;
    if ( (unsigned __int64)(v48 + 3) >= 0xFFFFFFFFFFFFFFF0LL )
LABEL_228:
      abort();
    if ( v107 > 0x16 )
    {
      v108 = malloc((v48 + 19) & 0xFFFFFFFFFFFFFFF0LL);
      *((_QWORD *)&v159 + 1) = v48 + 3;
      v160 = v108;
      *(_QWORD *)&v159 = (v48 + 19) & 0xFFFFFFFFFFFFFFF0LL | 1;
      if ( v48 == -3 )
      {
LABEL_200:
        *v108 = 0;
        v132 = *((_QWORD *)&v159 + 1);
        v133 = v160;
        v134 = *(_QWORD *)((char *)&v159 + 1);
        v135 = v159;
        v159 = 0uLL;
        v160 = 0LL;
        memset(v161, 0, 15);
        *(_QWORD *)((char *)v162 + 7) = v132;
        v162[0] = v134;
        v136 = *(_QWORD *)(a3 + 8);
        v137 = *(_QWORD *)(a3 + 16);
        if ( v136 >= v137 )
        {
          v138 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v136 - *(_QWORD *)a3) >> 4);
          v139 = v138 + 1;
          if ( v138 + 1 > 0x555555555555555LL )
            abort();
          v140 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v137 - *(_QWORD *)a3) >> 4);
          if ( v140 >= 0x2AAAAAAAAAAAAAALL )
            goto LABEL_207;
          v141 = 2 * v140;
          if ( v141 >= v139 )
            v139 = v141;
          v156 = v139;
          if ( v139 )
          {
LABEL_207:
            v142 = *(_QWORD *)(a3 + 24);
            v143 = *(char **)(v142 + 4096);
            if ( v142 + 4096 - (__int64)v143 >= (unsigned __int64)(48 * v156) )
              *(_QWORD *)(v142 + 4096) = &v143[48 * v156];
            else
              v143 = (char *)malloc(48 * v156);
          }
          else
          {
            v156 = 0LL;
            v143 = 0LL;
          }
          v144 = &v143[48 * v138];
          *v144 = v135;
          *((_QWORD *)v144 + 1) = *(_QWORD *)((char *)v162 + 7);
          *((_QWORD *)v144 + 2) = v133;
          *(_QWORD *)(v144 + 1) = v162[0];
          memset(v162, 0, 15);
          v144[24] = 0;
          *((_QWORD *)v144 + 4) = *(_QWORD *)((char *)v161 + 7);
          *((_QWORD *)v144 + 5) = 0LL;
          *(_QWORD *)(v144 + 25) = v161[0];
          memset(v161, 0, 15);
          v146 = *(void ***)a3;
          v145 = *(void ***)(a3 + 8);
          v147 = v144 + 48;
          if ( v145 == *(void ***)a3 )
          {
            v149 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v144 - 4) = *(v145 - 4);
              *((_OWORD *)v144 - 3) = *((_OWORD *)v145 - 3);
              v148 = (__int64)*(v145 - 1);
              *(v145 - 5) = 0LL;
              *(v145 - 4) = 0LL;
              *(v145 - 6) = 0LL;
              *((_QWORD *)v144 - 1) = v148;
              *(_OWORD *)(v144 - 24) = *(_OWORD *)(v145 - 3);
              *(v145 - 2) = 0LL;
              *(v145 - 1) = 0LL;
              *(v145 - 3) = 0LL;
              v145 -= 6;
              v144 -= 48;
            }
            while ( v146 != v145 );
            v149 = *(void ***)a3;
            v146 = *(void ***)(a3 + 8);
          }
          v150 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v144;
          *(_QWORD *)(a3 + 8) = v147;
          *(_QWORD *)(a3 + 16) = &v143[48 * v156];
          if ( v146 != v149 )
          {
            do
            {
              if ( (*(_BYTE *)(v146 - 3) & 1) != 0 )
                free(*(v146 - 1));
              v151 = v146 - 6;
              if ( (*(_BYTE *)(v146 - 6) & 1) != 0 )
                free(*(v146 - 4));
              v146 -= 6;
            }
            while ( v149 != v151 );
          }
          if ( v149 )
          {
            v152 = *(_QWORD *)(a3 + 24);
            if ( v152 + 4096 < (unsigned __int64)v149 || v152 > (unsigned __int64)v149 )
            {
              free(v149);
            }
            else if ( *(_QWORD *)(v152 + 4096) == v150 )
            {
              *(_QWORD *)(v152 + 4096) = v149;
            }
          }
        }
        else
        {
          *(_BYTE *)v136 = v135;
          *(_QWORD *)(v136 + 8) = *(_QWORD *)((char *)v162 + 7);
          *(_QWORD *)(v136 + 16) = v133;
          *(_QWORD *)(v136 + 1) = v162[0];
          memset(v162, 0, 15);
          *(_BYTE *)(v136 + 24) = 0;
          *(_QWORD *)(v136 + 32) = *(_QWORD *)((char *)v161 + 7);
          *(_QWORD *)(v136 + 40) = 0LL;
          *(_QWORD *)(v136 + 25) = v161[0];
          memset(v161, 0, 15);
          *(_QWORD *)(a3 + 8) += 48LL;
        }
        v3 = (_BYTE *)v106;
        goto LABEL_184;
      }
    }
    else
    {
      LOBYTE(v159) = 2 * v107;
      v108 = (char *)&v159 + 1;
      if ( v48 == -3 )
        goto LABEL_200;
    }
    *v108 = 84;
    if ( v48 != -2 )
    {
      v120 = v48 + 2;
      v121 = v3 + 1;
      if ( (unsigned __int64)(v48 + 2) >= 0x20
        && (v122 = v120 & 0xFFFFFFFFFFFFFFE0LL, (v120 & 0xFFFFFFFFFFFFFFE0LL) != 0) )
      {
        if ( v108 >= v49 + 2 || (v123 = v108, v121 >= &v108[v48 + 3]) )
        {
          v121 += v122;
          v123 = &v108[v122];
          v124 = v108 + 17;
          v125 = (__int128 *)(v3 + 17);
          v126 = v120 & 0xFFFFFFFFFFFFFFE0LL;
          do
          {
            v127 = *(v125 - 1);
            v128 = *v125;
            v126 -= 32LL;
            v125 += 2;
            *(v124 - 1) = v127;
            *v124 = v128;
            v124 += 2;
          }
          while ( v126 );
          if ( v122 == v120 )
            goto LABEL_199;
        }
      }
      else
      {
        v123 = v108;
      }
      v129 = &v3[3LL - (_QWORD)v121 + v48];
      v130 = v123 + 1;
      do
      {
        v131 = *v121++;
        --v129;
        *v130++ = v131;
      }
      while ( v129 );
    }
LABEL_199:
    v108 += v107;
    goto LABEL_200;
  }
  v6 = *(_QWORD *)(a3 + 72);
  if ( *(_QWORD *)(a3 + 64) == v6 )
    return (__int64)v3;
  v7 = *(__int64 **)(v6 - 32);
  if ( v7 == *(__int64 **)(v6 - 24) )
  {
    LODWORD(v161[1]) = 0;
    v161[0] = 0LL;
    memset(v162, 0, 15);
    v51 = *(_QWORD *)(a3 + 8);
    v52 = *(_QWORD *)(a3 + 16);
    if ( v51 >= v52 )
    {
      v60 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v51 - *(_QWORD *)a3) >> 4);
      v61 = v60 + 1;
      if ( v60 + 1 > 0x555555555555555LL )
        abort();
      v62 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v52 - *(_QWORD *)a3) >> 4);
      if ( v62 >= 0x2AAAAAAAAAAAAAALL )
        goto LABEL_93;
      v63 = 2 * v62;
      if ( v63 >= v61 )
        v61 = v63;
      v156 = v61;
      if ( v61 )
      {
LABEL_93:
        v64 = *(_QWORD *)(a3 + 24);
        v65 = *(char **)(v64 + 4096);
        if ( v64 + 4096 - (__int64)v65 >= (unsigned __int64)(48 * v156) )
          *(_QWORD *)(v64 + 4096) = &v65[48 * v156];
        else
          v65 = (char *)malloc(48 * v156);
      }
      else
      {
        v156 = 0LL;
        v65 = 0LL;
      }
      v109 = &v65[48 * v60];
      *v109 = 4;
      strcpy(v109 + 1, "T_");
      *((_DWORD *)v109 + 3) = v161[1];
      v110 = v161[0];
      *((_QWORD *)v109 + 2) = 0LL;
      *(_QWORD *)(v109 + 4) = v110;
      LODWORD(v161[1]) = 0;
      v161[0] = 0LL;
      v109[24] = 0;
      *((_QWORD *)v109 + 4) = *(_QWORD *)((char *)v162 + 7);
      *((_QWORD *)v109 + 5) = 0LL;
      *(_QWORD *)(v109 + 25) = v162[0];
      memset(v162, 0, 15);
      v112 = *(void ***)a3;
      v111 = *(void ***)(a3 + 8);
      v113 = v109 + 48;
      if ( v111 == *(void ***)a3 )
      {
        v115 = *(void ***)a3;
      }
      else
      {
        do
        {
          *((_QWORD *)v109 - 4) = *(v111 - 4);
          *((_OWORD *)v109 - 3) = *((_OWORD *)v111 - 3);
          v114 = (__int64)*(v111 - 1);
          *(v111 - 5) = 0LL;
          *(v111 - 4) = 0LL;
          *(v111 - 6) = 0LL;
          *((_QWORD *)v109 - 1) = v114;
          *(_OWORD *)(v109 - 24) = *(_OWORD *)(v111 - 3);
          *(v111 - 2) = 0LL;
          *(v111 - 1) = 0LL;
          *(v111 - 3) = 0LL;
          v111 -= 6;
          v109 -= 48;
        }
        while ( v112 != v111 );
        v115 = *(void ***)a3;
        v112 = *(void ***)(a3 + 8);
      }
      v116 = *(_QWORD *)(a3 + 16);
      *(_QWORD *)a3 = v109;
      *(_QWORD *)(a3 + 8) = v113;
      *(_QWORD *)(a3 + 16) = &v65[48 * v156];
      if ( v112 != v115 )
      {
        do
        {
          if ( (*(_BYTE *)(v112 - 3) & 1) != 0 )
            free(*(v112 - 1));
          v117 = v112 - 6;
          if ( (*(_BYTE *)(v112 - 6) & 1) != 0 )
            free(*(v112 - 4));
          v112 -= 6;
        }
        while ( v115 != v117 );
      }
      if ( v115 )
      {
        v118 = *(_QWORD *)(a3 + 24);
        if ( v118 + 4096 < (unsigned __int64)v115 || v118 > (unsigned __int64)v115 )
        {
          free(v115);
        }
        else if ( *(_QWORD *)(v118 + 4096) == v116 )
        {
          *(_QWORD *)(v118 + 4096) = v115;
        }
      }
    }
    else
    {
      *(_BYTE *)v51 = 4;
      strcpy((char *)(v51 + 1), "T_");
      *(_DWORD *)(v51 + 12) = v161[1];
      v53 = v161[0];
      *(_QWORD *)(v51 + 16) = 0LL;
      *(_QWORD *)(v51 + 4) = v53;
      LODWORD(v161[1]) = 0;
      v161[0] = 0LL;
      *(_BYTE *)(v51 + 24) = 0;
      *(_QWORD *)(v51 + 32) = *(_QWORD *)((char *)v162 + 7);
      *(_QWORD *)(v51 + 40) = 0LL;
      *(_QWORD *)(v51 + 25) = v162[0];
      memset(v162, 0, 15);
      *(_QWORD *)(a3 + 8) += 48LL;
    }
    v3 += 2;
LABEL_184:
    *(_BYTE *)(a3 + 110) = 1;
    return (__int64)v3;
  }
  v9 = *v7;
  v8 = v7[1];
  if ( *v7 != v8 )
  {
    v157 = v7[1];
    do
    {
      v33 = *(size_t **)(a3 + 8);
      v32 = *(size_t **)(a3 + 16);
      if ( v33 == v32 )
      {
        v34 = 0xAAAAAAAAAAAAAAABLL * (((__int64)v33 - *(_QWORD *)a3) >> 4);
        if ( v34 + 1 > 0x555555555555555LL )
          goto LABEL_228;
        v35 = 0xAAAAAAAAAAAAAAABLL * (((__int64)v32 - *(_QWORD *)a3) >> 4);
        v36 = 0x555555555555555LL;
        if ( v35 >= 0x2AAAAAAAAAAAAAALL || ((v37 = 2 * v35, v37 >= v34 + 1) ? (v36 = v37) : (v36 = v34 + 1), v36) )
        {
          v38 = *(_QWORD *)(a3 + 24);
          v39 = 48 * v36;
          v10 = *(char **)(v38 + 4096);
          if ( v38 + 4096 - (__int64)v10 >= (unsigned __int64)(48 * v36) )
            *(_QWORD *)(v38 + 4096) = &v10[v39];
          else
            v10 = (char *)malloc(v39);
        }
        else
        {
          v10 = 0LL;
        }
        v11 = (size_t *)&v10[48 * v34];
        v11[1] = 0LL;
        v11[2] = 0LL;
        *v11 = 0LL;
        v12 = &v10[48 * v36];
        if ( (*(_BYTE *)v9 & 1) == 0 )
        {
          v11[2] = *(_QWORD *)(v9 + 16);
          *(_OWORD *)v11 = *(_OWORD *)v9;
          goto LABEL_19;
        }
        v13 = *(_QWORD *)(v9 + 8);
        if ( v13 >= 0xFFFFFFFFFFFFFFF0LL )
          abort();
        v14 = *(const void **)(v9 + 16);
        if ( v13 >= 0x17 )
        {
          v15 = malloc((v13 + 16) & 0xFFFFFFFFFFFFFFF0LL);
          v16 = &v10[48 * v34];
          *((_QWORD *)v16 + 1) = v13;
          *((_QWORD *)v16 + 2) = v15;
          *v11 = (v13 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
        }
        else
        {
          *(_BYTE *)v11 = 2 * v13;
          v15 = (char *)v11 + 1;
          if ( !v13 )
            goto LABEL_18;
        }
        memcpy(v15, v14, v13);
LABEL_18:
        *((_BYTE *)v15 + v13) = 0;
        v8 = v157;
LABEL_19:
        v17 = &v10[48 * v34];
        *((_QWORD *)v17 + 3) = 0LL;
        v18 = v17 + 24;
        *((_QWORD *)v18 + 1) = 0LL;
        *((_QWORD *)v18 + 2) = 0LL;
        if ( (*(_BYTE *)(v9 + 24) & 1) == 0 )
        {
          *((_QWORD *)v18 + 2) = *(_QWORD *)(v9 + 40);
          *(_OWORD *)v18 = *(_OWORD *)(v9 + 24);
LABEL_28:
          v25 = *(void ***)a3;
          v24 = *(void ***)(a3 + 8);
          v26 = v11 + 6;
          if ( v24 == *(void ***)a3 )
          {
            v28 = *(void ***)a3;
          }
          else
          {
            do
            {
              *(v11 - 4) = (size_t)*(v24 - 4);
              *((_OWORD *)v11 - 3) = *((_OWORD *)v24 - 3);
              v27 = (size_t)*(v24 - 1);
              *(v24 - 5) = 0LL;
              *(v24 - 4) = 0LL;
              *(v24 - 6) = 0LL;
              *(v11 - 1) = v27;
              *(_OWORD *)(v11 - 3) = *(_OWORD *)(v24 - 3);
              *(v24 - 2) = 0LL;
              *(v24 - 1) = 0LL;
              *(v24 - 3) = 0LL;
              v24 -= 6;
              v11 -= 6;
            }
            while ( v25 != v24 );
            v28 = *(void ***)a3;
            v25 = *(void ***)(a3 + 8);
          }
          v29 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v11;
          *(_QWORD *)(a3 + 8) = v26;
          *(_QWORD *)(a3 + 16) = v12;
          if ( v25 != v28 )
          {
            do
            {
              if ( (*(_BYTE *)(v25 - 3) & 1) != 0 )
                free(*(v25 - 1));
              v30 = v25 - 6;
              if ( (*(_BYTE *)(v25 - 6) & 1) != 0 )
                free(*(v25 - 4));
              v25 -= 6;
            }
            while ( v28 != v30 );
          }
          if ( v28 )
          {
            v31 = *(_QWORD *)(a3 + 24);
            if ( v31 + 4096 < (unsigned __int64)v28 || v31 > (unsigned __int64)v28 )
            {
              free(v28);
            }
            else if ( *(_QWORD *)(v31 + 4096) == v29 )
            {
              *(_QWORD *)(v31 + 4096) = v28;
            }
          }
          goto LABEL_72;
        }
        v19 = *(_QWORD *)(v9 + 32);
        if ( v19 >= 0xFFFFFFFFFFFFFFF0LL )
          abort();
        v20 = *(const void **)(v9 + 40);
        if ( v19 >= 0x17 )
        {
          v22 = malloc((v19 + 16) & 0xFFFFFFFFFFFFFFF0LL);
          v23 = &v10[48 * v34];
          *((_QWORD *)v23 + 4) = v19;
          *((_QWORD *)v23 + 5) = v22;
          *(_QWORD *)v18 = (v19 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
          v21 = v22;
        }
        else
        {
          *v18 = 2 * v19;
          v21 = v18 + 1;
          if ( !v19 )
            goto LABEL_27;
        }
        memcpy(v21, v20, v19);
LABEL_27:
        *((_BYTE *)v21 + v19) = 0;
        v8 = v157;
        goto LABEL_28;
      }
      v33[1] = 0LL;
      v33[2] = 0LL;
      *v33 = 0LL;
      if ( (*(_BYTE *)v9 & 1) == 0 )
      {
        v33[2] = *(_QWORD *)(v9 + 16);
        *(_OWORD *)v33 = *(_OWORD *)v9;
        goto LABEL_62;
      }
      v40 = *(_QWORD *)(v9 + 8);
      if ( v40 >= 0xFFFFFFFFFFFFFFF0LL )
        goto LABEL_228;
      v41 = *(const void **)(v9 + 16);
      if ( v40 >= 0x17 )
      {
        v42 = malloc((v40 + 16) & 0xFFFFFFFFFFFFFFF0LL);
        v33[1] = v40;
        v33[2] = (size_t)v42;
        *v33 = (v40 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
      }
      else
      {
        *(_BYTE *)v33 = 2 * v40;
        v42 = (char *)v33 + 1;
        if ( !v40 )
          goto LABEL_61;
      }
      memcpy(v42, v41, v40);
LABEL_61:
      *((_BYTE *)v42 + v40) = 0;
LABEL_62:
      v33[3] = 0LL;
      v43 = v33 + 3;
      v33[4] = 0LL;
      v33[5] = 0LL;
      if ( (*(_BYTE *)(v9 + 24) & 1) != 0 )
      {
        v44 = *(_QWORD *)(v9 + 32);
        if ( v44 >= 0xFFFFFFFFFFFFFFF0LL )
          abort();
        v45 = *(const void **)(v9 + 40);
        if ( v44 >= 0x17 )
        {
          v46 = malloc((v44 + 16) & 0xFFFFFFFFFFFFFFF0LL);
          v33[4] = v44;
          v33[5] = (size_t)v46;
          v33[3] = (v44 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
        }
        else
        {
          *v43 = 2 * v44;
          v46 = (char *)v33 + 25;
          if ( !v44 )
            goto LABEL_70;
        }
        memcpy(v46, v45, v44);
LABEL_70:
        *((_BYTE *)v46 + v44) = 0;
        goto LABEL_71;
      }
      v33[5] = *(_QWORD *)(v9 + 40);
      *(_OWORD *)v43 = *(_OWORD *)(v9 + 24);
LABEL_71:
      *(_QWORD *)(a3 + 8) += 48LL;
LABEL_72:
      v9 += 48LL;
    }
    while ( v9 != v8 );
  }
  return (__int64)(a1 + 2);
}

//----- (00000000000A0A48) ----------------------------------------------------
_BYTE *__fastcall sub_A0A48(_BYTE *a1, _BYTE *a2, _QWORD *a3)
{
  _BYTE *v4; // x21
  _BYTE *v6; // x23
  _BYTE *v7; // x0
  _BYTE *v8; // x19
  __int64 v9; // x22
  unsigned __int64 v10; // x8
  bool v11; // zf
  size_t v12; // x8
  void *v13; // x1
  size_t v14; // x2
  void *v15; // x8
  __int128 v16; // q0
  __int64 v17; // x9
  __int64 v18; // x10
  void *v19; // x11
  char v20; // w8
  __int64 v21; // x8
  __int64 v22; // x9
  __int128 v24; // [xsp+0h] [xbp-B0h] BYREF
  void *p; // [xsp+10h] [xbp-A0h]
  __int128 v26; // [xsp+20h] [xbp-90h] BYREF
  void *v27; // [xsp+30h] [xbp-80h]
  char v28; // [xsp+38h] [xbp-78h] BYREF
  _BYTE v29[15]; // [xsp+39h] [xbp-77h]
  void *v30; // [xsp+48h] [xbp-68h]
  __int64 v31; // [xsp+50h] [xbp-60h]
  __int64 v32; // [xsp+58h] [xbp-58h]
  void *v33; // [xsp+60h] [xbp-50h]
  _BYTE v34[15]; // [xsp+68h] [xbp-48h] BYREF
  __int64 v35; // [xsp+78h] [xbp-38h]

  v4 = a1;
  v35 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a2 - a1 >= 4 && *a1 == 68 && ((unsigned __int8)a1[1] | 0x20) == 0x74 )
  {
    v6 = a1 + 2;
    v7 = (_BYTE *)sub_A20BC(a1 + 2, a2, a3);
    v8 = v7;
    if ( v7 != v6 && v7 != a2 && *v7 == 69 )
    {
      v9 = a3[1];
      if ( *a3 != v9 )
      {
        v10 = *(unsigned __int8 *)(v9 - 24);
        v11 = (v10 & 1) == 0;
        v12 = v10 >> 1;
        if ( v11 )
          v13 = (void *)(v9 - 23);
        else
          v13 = *(void **)(v9 - 8);
        if ( v11 )
          v14 = v12;
        else
          v14 = *(_QWORD *)(v9 - 16);
        sub_9CFD0((size_t *)(v9 - 48), v13, v14);
        p = *(void **)(v9 - 32);
        v24 = *(_OWORD *)(v9 - 48);
        *(_QWORD *)(v9 - 40) = 0LL;
        *(_QWORD *)(v9 - 32) = 0LL;
        *(_QWORD *)(v9 - 48) = 0LL;
        sub_9CDD8((size_t *)&v24, 0LL, "decltype(", 9uLL);
        v15 = p;
        v16 = v24;
        p = 0LL;
        v24 = 0uLL;
        v27 = v15;
        v26 = v16;
        sub_9CFD0((size_t *)&v26, ")", 1uLL);
        v17 = *(_QWORD *)((char *)&v26 + 1);
        v18 = *((_QWORD *)&v26 + 1);
        v19 = v27;
        v20 = v26;
        v27 = 0LL;
        v26 = 0uLL;
        *(_QWORD *)&v34[7] = v18;
        v34[7] = HIBYTE(v17);
        v28 = v20;
        v21 = v17;
        v22 = *(_QWORD *)&v34[7];
        memset(v34, 0, sizeof(v34));
        *(_QWORD *)v29 = v21;
        *(_QWORD *)&v29[7] = v22;
        v30 = v19;
        v32 = 0LL;
        v33 = 0LL;
        v31 = 0LL;
        sub_A7174(a3[1] - 48LL, &v28);
        if ( (v31 & 1) != 0 )
        {
          free(v33);
          if ( (v28 & 1) == 0 )
          {
LABEL_16:
            if ( (v26 & 1) == 0 )
              goto LABEL_17;
            goto LABEL_23;
          }
        }
        else if ( (v28 & 1) == 0 )
        {
          goto LABEL_16;
        }
        free(v30);
        if ( (v26 & 1) == 0 )
        {
LABEL_17:
          if ( (v24 & 1) == 0 )
            return v8 + 1;
LABEL_18:
          free(p);
          return v8 + 1;
        }
LABEL_23:
        free(v27);
        if ( (v24 & 1) == 0 )
          return v8 + 1;
        goto LABEL_18;
      }
    }
  }
  return v4;
}
// A20BC: using guessed type __int64 __fastcall sub_A20BC(_QWORD, _QWORD, _QWORD);
// A7174: using guessed type __int64 __fastcall sub_A7174(_QWORD, _QWORD);

//----- (00000000000A0C94) ----------------------------------------------------
__int64 __fastcall sub_A0C94(unsigned __int8 *a1, unsigned __int8 *a2, char **a3)
{
  unsigned __int8 *v4; // x19
  unsigned __int8 *v6; // x23
  int v7; // w9
  __int64 v9; // x22
  char *v10; // x8
  unsigned int v11; // w9
  __int64 v12; // x8
  void *v13; // x21
  __int64 v14; // x9
  char v15; // w23
  unsigned __int64 v16; // x8
  unsigned __int64 v17; // x9
  unsigned __int64 v18; // x25
  unsigned __int64 v19; // x9
  unsigned __int64 v20; // x9
  char *v21; // x9
  char *v22; // x0
  int v23; // w8
  unsigned __int64 v24; // x9
  unsigned __int64 v25; // x10
  unsigned int v26; // w9
  __int64 v27; // x8
  __int64 v28; // x9
  unsigned __int64 v29; // x9
  unsigned __int64 v30; // x8
  void **v31; // x9
  unsigned __int64 v32; // x11
  unsigned __int64 v33; // x28
  unsigned __int64 v34; // x25
  char *v35; // x9
  char *v36; // x0
  unsigned __int64 v37; // x9
  unsigned __int64 v38; // x9
  char *v39; // x9
  char *v40; // x0
  unsigned __int64 v41; // x25
  unsigned __int64 v42; // x9
  unsigned __int64 v43; // x9
  char *v44; // x9
  char *v45; // x0
  char *v46; // x8
  char *v47; // x9
  void **v48; // x11
  void **v49; // x23
  char *v50; // x10
  __int64 v51; // x12
  void **v52; // x21
  char *v53; // x22
  void **v54; // x24
  unsigned __int64 v55; // x8
  char *v56; // x8
  char *v57; // x9
  void **v58; // x11
  void **v59; // x24
  char *v60; // x10
  __int64 v61; // x12
  void **v62; // x22
  char *v63; // x25
  void **v64; // x26
  unsigned __int64 v65; // x8
  char *v66; // x28
  int v67; // w24
  __int64 v68; // x26
  unsigned __int8 *v69; // x25
  char *v70; // x22
  char *v71; // x21
  void *v72; // x0
  char *v73; // x22
  unsigned __int64 v74; // x8
  size_t *v75; // x16
  size_t v76; // x18
  unsigned __int64 v77; // x23
  unsigned __int64 v78; // x17
  unsigned __int64 v79; // x9
  unsigned __int64 v80; // x10
  void *v81; // x0
  char *v82; // x8
  char *v83; // x8
  char *v84; // x9
  void **v85; // x11
  void **v86; // x23
  char *v87; // x10
  __int64 v88; // x12
  void **v89; // x22
  char *v90; // x24
  void **v91; // x25
  unsigned __int64 v92; // x8
  unsigned __int8 *v93; // x22
  unsigned __int8 *v94; // x2
  unsigned __int8 *v95; // x8
  unsigned __int8 *v96; // x22
  __int64 v97; // x23
  char v98; // w25
  void **v99; // x26
  __int64 v100; // x0
  void **v101; // x24
  unsigned __int8 *v102; // x9
  void **v103; // x22
  signed __int64 v104; // x11
  __int64 v105; // x23
  __int64 v106; // x26
  void **v107; // x28
  unsigned __int64 v108; // x8
  unsigned __int64 v109; // x8
  unsigned __int64 v110; // x8
  unsigned __int64 v111; // x8
  size_t *v112; // x24
  unsigned __int64 v113; // x8
  bool v114; // zf
  size_t v115; // x8
  void *v116; // x1
  size_t v117; // x2
  void *v118; // x25
  char *v119; // x1
  size_t v120; // x2
  __int64 v121; // x24
  __int64 v122; // x22
  char *v123; // x23
  int v124; // w9
  void **v125; // x8
  char *v126; // x8
  char *v127; // x9
  void **v128; // x11
  void **v129; // x23
  char *v130; // x10
  __int64 v131; // x12
  void **v132; // x24
  size_t v133; // x23
  unsigned __int64 v134; // x28
  unsigned __int8 *v135; // x8
  unsigned __int64 v136; // x9
  unsigned __int64 v137; // x10
  _BYTE *v138; // x11
  _OWORD *v139; // x12
  __int128 *v140; // x13
  unsigned __int64 v141; // x14
  __int128 v142; // q0
  __int128 v143; // q1
  unsigned __int64 v144; // x8
  size_t v145; // x8
  _BYTE *v146; // x9
  char v147; // t1
  char v148; // w22
  void *v149; // x23
  char *v150; // x1
  size_t v151; // x2
  char *v152; // x21
  char *v153; // x22
  void *v154; // x0
  void *v155; // x24
  char *v156; // x8
  char *v157; // x9
  unsigned __int64 v158; // x11
  size_t v159; // x10
  unsigned __int64 v160; // x12
  __int128 *v161; // x13
  char *v162; // x14
  unsigned __int64 v163; // x15
  __int128 v164; // q0
  __int128 v165; // q1
  char v166; // t1
  size_t v167; // x8
  size_t v168; // [xsp+8h] [xbp-D8h]
  signed __int64 v169; // [xsp+10h] [xbp-D0h]
  unsigned __int8 *v170; // [xsp+18h] [xbp-C8h]
  unsigned __int64 v171; // [xsp+18h] [xbp-C8h]
  char *v172; // [xsp+20h] [xbp-C0h]
  unsigned __int64 v173; // [xsp+28h] [xbp-B8h]
  __int64 v174; // [xsp+37h] [xbp-A9h]
  __int128 v175; // [xsp+40h] [xbp-A0h] BYREF
  _BYTE v176[15]; // [xsp+58h] [xbp-88h]
  __int128 v177; // [xsp+70h] [xbp-70h] BYREF
  void *p; // [xsp+80h] [xbp-60h]
  __int64 v179; // [xsp+88h] [xbp-58h]

  v4 = a1;
  v6 = (unsigned __int8 *)(a1 - a2);
  v179 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a1 == a2 )
    return (__int64)v4;
  v7 = *a1;
  if ( (unsigned int)(v7 - 49) < 9 )
    return sub_B190C(a1, a2, a3);
  v9 = 0x555555555555555LL;
  if ( (unsigned int)(v7 - 67) < 2 )
  {
    if ( a2 - a1 < 2 )
      return (__int64)v4;
    v10 = a3[1];
    if ( *a3 == v10 )
      return (__int64)v4;
    if ( v7 == 68 )
    {
      v26 = a1[1];
      if ( v26 > 0x35 || ((1LL << v26) & 0x27000000000000LL) == 0 )
        return (__int64)v4;
      sub_B1FF4(&v177, v10 - 48);
      sub_9CDD8((size_t *)&v177, 0LL, "~", 1uLL);
      v27 = *(_QWORD *)((char *)&v177 + 1);
      v28 = *((_QWORD *)&v177 + 1);
      v13 = p;
      v15 = v177;
      p = 0LL;
      v177 = 0uLL;
      v174 = v28;
      LOBYTE(v174) = HIBYTE(v27);
      memset(&v175, 0, 15);
      *(_QWORD *)&v176[7] = v174;
      *(_QWORD *)v176 = v27;
      v16 = (unsigned __int64)a3[1];
      v29 = (unsigned __int64)a3[2];
      if ( v16 >= v29 )
      {
        v41 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v16 - (_QWORD)*a3) >> 4);
        if ( v41 + 1 > 0x555555555555555LL )
          abort();
        v42 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v29 - (_QWORD)*a3) >> 4);
        if ( v42 >= 0x2AAAAAAAAAAAAAALL || ((v43 = 2 * v42, v43 >= v41 + 1) ? (v9 = v43) : (v9 = v41 + 1), v9) )
        {
          v44 = a3[3];
          v45 = (char *)*((_QWORD *)v44 + 512);
          if ( v44 + 4096 - v45 >= (unsigned __int64)(48 * v9) )
            *((_QWORD *)v44 + 512) = &v45[48 * v9];
          else
            v45 = (char *)malloc(48 * v9);
        }
        else
        {
          v45 = 0LL;
        }
        v126 = &v45[48 * v41];
        *v126 = v15;
        v127 = &v45[48 * v9];
        *((_QWORD *)v126 + 1) = *(_QWORD *)&v176[7];
        *((_QWORD *)v126 + 2) = v13;
        *(_QWORD *)(v126 + 1) = *(_QWORD *)v176;
        v126[24] = 0;
        *((_QWORD *)v126 + 4) = *(_QWORD *)((char *)&v175 + 7);
        *((_QWORD *)v126 + 5) = 0LL;
        *(_QWORD *)(v126 + 25) = 0LL;
        v129 = (void **)*a3;
        v128 = (void **)a3[1];
        v130 = v126 + 48;
        if ( v128 == (void **)*a3 )
        {
          v52 = (void **)*a3;
        }
        else
        {
          do
          {
            *((_QWORD *)v126 - 4) = *(v128 - 4);
            *((_OWORD *)v126 - 3) = *((_OWORD *)v128 - 3);
            v131 = (__int64)*(v128 - 1);
            *(v128 - 5) = 0LL;
            *(v128 - 4) = 0LL;
            *(v128 - 6) = 0LL;
            *((_QWORD *)v126 - 1) = v131;
            *(_OWORD *)(v126 - 24) = *(_OWORD *)(v128 - 3);
            *(v128 - 2) = 0LL;
            *(v128 - 1) = 0LL;
            *(v128 - 3) = 0LL;
            v128 -= 6;
            v126 -= 48;
          }
          while ( v129 != v128 );
          v52 = (void **)*a3;
          v129 = (void **)a3[1];
        }
        v53 = a3[2];
        *a3 = v126;
        a3[1] = v130;
        a3[2] = v127;
        if ( v129 != v52 )
        {
          do
          {
            if ( (*(_BYTE *)(v129 - 3) & 1) != 0 )
              free(*(v129 - 1));
            v132 = v129 - 6;
            if ( (*(_BYTE *)(v129 - 6) & 1) != 0 )
              free(*(v129 - 4));
            v129 -= 6;
          }
          while ( v52 != v132 );
        }
        if ( !v52 )
          goto LABEL_223;
        v55 = (unsigned __int64)a3[3];
        if ( v55 + 4096 < (unsigned __int64)v52 || v55 > (unsigned __int64)v52 )
          goto LABEL_222;
LABEL_219:
        if ( *(char **)(v55 + 4096) == v53 )
        {
          *(_QWORD *)(v55 + 4096) = v52;
          if ( (v177 & 1) == 0 )
            goto LABEL_225;
          goto LABEL_224;
        }
LABEL_223:
        if ( (v177 & 1) == 0 )
        {
LABEL_225:
          v4 += 2;
          *((_BYTE *)a3 + 108) = 1;
          return (__int64)v4;
        }
LABEL_224:
        free(p);
        goto LABEL_225;
      }
    }
    else
    {
      if ( v7 != 67 )
        return (__int64)v4;
      v11 = a1[1];
      if ( v11 > 0x35 || ((1LL << v11) & 0x2E000000000000LL) == 0 )
        return (__int64)v4;
      sub_B1FF4(&v177, v10 - 48);
      v12 = *((_QWORD *)&v177 + 1);
      v13 = p;
      v14 = *(_QWORD *)((char *)&v177 + 1);
      v15 = v177;
      v177 = 0uLL;
      p = 0LL;
      memset(&v175, 0, 15);
      *(_QWORD *)&v176[7] = v12;
      *(_QWORD *)v176 = v14;
      v16 = (unsigned __int64)a3[1];
      v17 = (unsigned __int64)a3[2];
      if ( v16 >= v17 )
      {
        v18 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v16 - (_QWORD)*a3) >> 4);
        if ( v18 + 1 > 0x555555555555555LL )
          abort();
        v19 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v17 - (_QWORD)*a3) >> 4);
        if ( v19 >= 0x2AAAAAAAAAAAAAALL || ((v20 = 2 * v19, v20 >= v18 + 1) ? (v9 = v20) : (v9 = v18 + 1), v9) )
        {
          v21 = a3[3];
          v22 = (char *)*((_QWORD *)v21 + 512);
          if ( v21 + 4096 - v22 >= (unsigned __int64)(48 * v9) )
            *((_QWORD *)v21 + 512) = &v22[48 * v9];
          else
            v22 = (char *)malloc(48 * v9);
        }
        else
        {
          v22 = 0LL;
        }
        v46 = &v22[48 * v18];
        *v46 = v15;
        v47 = &v22[48 * v9];
        *((_QWORD *)v46 + 1) = *(_QWORD *)&v176[7];
        *((_QWORD *)v46 + 2) = v13;
        *(_QWORD *)(v46 + 1) = *(_QWORD *)v176;
        v46[24] = 0;
        *((_QWORD *)v46 + 4) = *(_QWORD *)((char *)&v175 + 7);
        *((_QWORD *)v46 + 5) = 0LL;
        *(_QWORD *)(v46 + 25) = 0LL;
        v49 = (void **)*a3;
        v48 = (void **)a3[1];
        v50 = v46 + 48;
        if ( v48 == (void **)*a3 )
        {
          v52 = (void **)*a3;
        }
        else
        {
          do
          {
            *((_QWORD *)v46 - 4) = *(v48 - 4);
            *((_OWORD *)v46 - 3) = *((_OWORD *)v48 - 3);
            v51 = (__int64)*(v48 - 1);
            *(v48 - 5) = 0LL;
            *(v48 - 4) = 0LL;
            *(v48 - 6) = 0LL;
            *((_QWORD *)v46 - 1) = v51;
            *(_OWORD *)(v46 - 24) = *(_OWORD *)(v48 - 3);
            *(v48 - 2) = 0LL;
            *(v48 - 1) = 0LL;
            *(v48 - 3) = 0LL;
            v48 -= 6;
            v46 -= 48;
          }
          while ( v49 != v48 );
          v52 = (void **)*a3;
          v49 = (void **)a3[1];
        }
        v53 = a3[2];
        *a3 = v46;
        a3[1] = v50;
        a3[2] = v47;
        if ( v49 != v52 )
        {
          do
          {
            if ( (*(_BYTE *)(v49 - 3) & 1) != 0 )
              free(*(v49 - 1));
            v54 = v49 - 6;
            if ( (*(_BYTE *)(v49 - 6) & 1) != 0 )
              free(*(v49 - 4));
            v49 -= 6;
          }
          while ( v52 != v54 );
        }
        if ( !v52 )
          goto LABEL_223;
        v55 = (unsigned __int64)a3[3];
        if ( v55 + 4096 < (unsigned __int64)v52 || v55 > (unsigned __int64)v52 )
        {
LABEL_222:
          free(v52);
          goto LABEL_223;
        }
        goto LABEL_219;
      }
    }
    *(_BYTE *)v16 = v15;
    *(_QWORD *)(v16 + 8) = *(_QWORD *)&v176[7];
    *(_QWORD *)(v16 + 16) = v13;
    *(_QWORD *)(v16 + 1) = *(_QWORD *)v176;
    *(_BYTE *)(v16 + 24) = 0;
    *(_QWORD *)(v16 + 32) = *(_QWORD *)((char *)&v175 + 7);
    *(_QWORD *)(v16 + 40) = 0LL;
    *(_QWORD *)(v16 + 25) = v175;
    a3[1] += 48;
    if ( (v177 & 1) == 0 )
      goto LABEL_225;
    goto LABEL_224;
  }
  if ( v7 != 85 )
    return sub_AC0B0(a1, a2, a3);
  if ( a2 - a1 < 3 )
    return (__int64)v4;
  v23 = a1[1];
  if ( v23 == 108 )
  {
    v31 = (void **)*a3;
    v30 = (unsigned __int64)a3[1];
    *((_QWORD *)&v175 + 1) = 10240LL;
    BYTE8(v175) = aLambda[7];
    *(_QWORD *)&v177 = *(_QWORD *)"'lambda'(";
    *(_QWORD *)((char *)&v177 + 7) = *((_QWORD *)&v175 + 1);
    v32 = (unsigned __int64)a3[2];
    v33 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v30 - (_QWORD)v31) >> 4);
    if ( v32 <= v30 )
    {
      if ( v33 + 1 > 0x555555555555555LL )
        abort();
      v37 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v32 - (_QWORD)v31) >> 4);
      if ( v37 >= 0x2AAAAAAAAAAAAAALL || ((v38 = 2 * v37, v38 >= v33 + 1) ? (v9 = v38) : (v9 = v33 + 1), v9) )
      {
        v39 = a3[3];
        v40 = (char *)*((_QWORD *)v39 + 512);
        if ( v39 + 4096 - v40 >= (unsigned __int64)(48 * v9) )
          *((_QWORD *)v39 + 512) = &v40[48 * v9];
        else
          v40 = (char *)malloc(48 * v9);
      }
      else
      {
        v40 = 0LL;
      }
      v83 = &v40[48 * v33];
      *v83 = 18;
      v84 = &v40[48 * v9];
      *((_QWORD *)v83 + 1) = *(_QWORD *)((char *)&v177 + 7);
      *((_QWORD *)v83 + 2) = 0LL;
      *(_QWORD *)(v83 + 1) = v177;
      *(_QWORD *)((char *)&v177 + 7) = 0LL;
      *(_QWORD *)&v177 = 0LL;
      v83[24] = 0;
      *((_QWORD *)v83 + 4) = 0LL;
      *((_QWORD *)v83 + 5) = 0LL;
      *(_QWORD *)(v83 + 25) = 0LL;
      v86 = (void **)*a3;
      v85 = (void **)a3[1];
      v87 = v83 + 48;
      if ( v85 == (void **)*a3 )
      {
        v89 = (void **)*a3;
      }
      else
      {
        do
        {
          *((_QWORD *)v83 - 4) = *(v85 - 4);
          *((_OWORD *)v83 - 3) = *((_OWORD *)v85 - 3);
          v88 = (__int64)*(v85 - 1);
          *(v85 - 5) = 0LL;
          *(v85 - 4) = 0LL;
          *(v85 - 6) = 0LL;
          *((_QWORD *)v83 - 1) = v88;
          *(_OWORD *)(v83 - 24) = *(_OWORD *)(v85 - 3);
          *(v85 - 2) = 0LL;
          *(v85 - 1) = 0LL;
          *(v85 - 3) = 0LL;
          v85 -= 6;
          v83 -= 48;
        }
        while ( v86 != v85 );
        v89 = (void **)*a3;
        v86 = (void **)a3[1];
      }
      v90 = a3[2];
      *a3 = v83;
      a3[1] = v87;
      a3[2] = v84;
      if ( v86 != v89 )
      {
        do
        {
          if ( (*(_BYTE *)(v86 - 3) & 1) != 0 )
            free(*(v86 - 1));
          v91 = v86 - 6;
          if ( (*(_BYTE *)(v86 - 6) & 1) != 0 )
            free(*(v86 - 4));
          v86 -= 6;
        }
        while ( v89 != v91 );
      }
      if ( v89 )
      {
        v92 = (unsigned __int64)a3[3];
        if ( v92 + 4096 < (unsigned __int64)v89 || v92 > (unsigned __int64)v89 )
        {
          free(v89);
        }
        else if ( *(char **)(v92 + 4096) == v90 )
        {
          *(_QWORD *)(v92 + 4096) = v89;
        }
      }
    }
    else
    {
      *(_BYTE *)v30 = 18;
      *(_QWORD *)(v30 + 8) = *(_QWORD *)((char *)&v177 + 7);
      *(_QWORD *)(v30 + 16) = 0LL;
      *(_QWORD *)(v30 + 1) = v177;
      *(_QWORD *)((char *)&v177 + 7) = 0LL;
      *(_QWORD *)&v177 = 0LL;
      *(_BYTE *)(v30 + 24) = 0;
      *(_QWORD *)(v30 + 32) = 0LL;
      *(_QWORD *)(v30 + 40) = 0LL;
      *(_QWORD *)(v30 + 25) = 0LL;
      a3[1] += 48;
    }
    v93 = v4 + 2;
    if ( v4[2] == 118 )
    {
      sub_B23DC(a3[1] - 48, 41LL);
      v93 = v4 + 3;
      if ( v4 + 3 == a2 )
        goto LABEL_265;
    }
    else
    {
      v97 = (__int64)a3[1];
      v98 = 1;
      v173 = v33;
      while ( 1 )
      {
        v99 = (void **)*a3;
        v100 = sub_925FC(v93, a2, a3);
        v101 = (void **)a3[1];
        if ( (unsigned __int8 *)v100 == v93 )
        {
          v123 = a3[1];
          v124 = 6;
          goto LABEL_198;
        }
        v102 = v93;
        v103 = (void **)*a3;
        v104 = 0xAAAAAAAAAAAAAAABLL * ((v97 - (__int64)v99) >> 4);
        if ( v104 >= (__int64)(0xAAAAAAAAAAAAAAABLL * (((char *)v101 - *a3) >> 4)) )
          break;
        v105 = 16 * ((v97 - (__int64)v99) >> 4);
        v106 = 16 * (((char *)v101 - *a3) >> 4);
        v169 = v104;
        v170 = (unsigned __int8 *)v100;
        do
        {
          v107 = &v103[(unsigned __int64)v105 / 8];
          v108 = LOBYTE(v103[(unsigned __int64)v105 / 8]);
          if ( (v108 & 1) != 0 )
            v109 = (unsigned __int64)v103[(unsigned __int64)v105 / 8 + 1];
          else
            v109 = v108 >> 1;
          if ( v109
            || ((v110 = *((unsigned __int8 *)v107 + 24), (v110 & 1) != 0)
              ? (v111 = (unsigned __int64)v107[4])
              : (v111 = v110 >> 1),
                v111) )
          {
            v112 = (size_t *)&(*a3)[48 * v173];
            if ( !v98 )
              sub_9CFD0((size_t *)&(*a3)[48 * v173], &asc_69D1AEC, 2uLL);
            v113 = LOBYTE(v103[(unsigned __int64)v105 / 8 + 3]);
            v114 = (v113 & 1) == 0;
            v115 = v113 >> 1;
            if ( v114 )
              v116 = (char *)&v103[(unsigned __int64)v105 / 8 + 3] + 1;
            else
              v116 = v103[(unsigned __int64)v105 / 8 + 5];
            if ( v114 )
              v117 = v115;
            else
              v117 = (size_t)v103[(unsigned __int64)v105 / 8 + 4];
            sub_9CFD0((size_t *)&v103[(unsigned __int64)v105 / 8], v116, v117);
            p = v107[2];
            v177 = *(_OWORD *)v107;
            v107[1] = 0LL;
            v107[2] = 0LL;
            *v107 = 0LL;
            v118 = p;
            if ( (v177 & 1) != 0 )
              v119 = (char *)p;
            else
              v119 = (char *)&v177 + 1;
            if ( (v177 & 1) != 0 )
              v120 = *((_QWORD *)&v177 + 1);
            else
              v120 = (unsigned __int64)(unsigned __int8)v177 >> 1;
            sub_9CFD0(v112, v119, v120);
            if ( (v177 & 1) != 0 )
              free(v118);
            v98 = 0;
          }
          v106 -= 48LL;
          v103 += 6;
        }
        while ( v105 != v106 );
        v97 = (__int64)a3[1];
        v121 = (__int64)&(*a3)[48 * v169];
        if ( v121 == v97 )
        {
          v33 = v173;
        }
        else
        {
          v33 = v173;
          do
          {
            if ( (*(_BYTE *)(v97 - 24) & 1) != 0 )
              free(*(void **)(v97 - 8));
            v122 = v97 - 48;
            if ( (*(_BYTE *)(v97 - 48) & 1) != 0 )
              free(*(void **)(v97 - 32));
            v97 -= 48LL;
          }
          while ( v121 != v122 );
          v97 = v121;
          a3[1] = (char *)v121;
        }
        v93 = v170;
      }
      v123 = a3[1];
      v93 = v102;
      v124 = 1;
LABEL_198:
      if ( v124 != 6 )
        return (__int64)v4;
      v125 = (void **)*a3;
      if ( v98 )
      {
        if ( v125 == v101 )
          return (__int64)v4;
        v71 = (char *)(v101 - 6);
        if ( (*(_BYTE *)(v101 - 3) & 1) != 0 )
          free(*(v101 - 1));
        if ( (*v71 & 1) == 0 )
          goto LABEL_109;
        v72 = *(v101 - 4);
        goto LABEL_108;
      }
      if ( v125 == v101 || 0xAAAAAAAAAAAAAAABLL * ((v123 - (char *)v125) >> 4) - 1 != v33 )
        return (__int64)v4;
      sub_9CFD0((size_t *)v101 - 6, ")", 1uLL);
      if ( v93 == a2 )
        goto LABEL_265;
    }
    if ( *v93 == 69 )
    {
      v94 = v93 + 1;
      if ( v93 + 1 != a2 )
      {
        if ( (unsigned int)*v94 - 48 > 9 )
        {
          v96 = v93 + 1;
          if ( v94 == a2 )
            goto LABEL_265;
        }
        else
        {
          v95 = v93 + 2;
          v114 = v93 + 2 == a2;
          v96 = a2;
          if ( !v114 )
          {
            v96 = v95;
            while ( (unsigned int)*v96 - 48 <= 9 )
            {
              if ( a2 == ++v96 )
              {
                v96 = a2;
                break;
              }
            }
          }
          sub_B2508();
          if ( v96 == a2 )
            goto LABEL_265;
        }
        if ( *v96 == 95 )
          return (__int64)(v96 + 1);
      }
    }
LABEL_265:
    v152 = a3[1];
    if ( *a3 != v152 )
    {
      v153 = v152 - 48;
      if ( (*(v152 - 24) & 1) != 0 )
        free(*((void **)v152 - 1));
      if ( (*v153 & 1) != 0 )
        free(*((void **)v152 - 4));
      a3[1] = v153;
    }
    return (__int64)v4;
  }
  if ( v23 == 116 )
  {
    *(_QWORD *)((char *)&v177 + 7) = 100LL;
    *(_QWORD *)&v177 = 0x64656D616E6E7527LL;
    v24 = (unsigned __int64)a3[1];
    v25 = (unsigned __int64)a3[2];
    if ( v24 >= v25 )
    {
      v34 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v24 - (_QWORD)*a3) >> 4);
      if ( v34 + 1 > 0x555555555555555LL )
        abort();
      if ( 0xAAAAAAAAAAAAAAABLL * ((__int64)(v25 - (_QWORD)*a3) >> 4) >= 0x2AAAAAAAAAAAAAALL
        || (0x5555555555555556LL * ((__int64)(v25 - (_QWORD)*a3) >> 4) >= v34 + 1
          ? (v9 = 0x5555555555555556LL * ((__int64)(v25 - (_QWORD)*a3) >> 4))
          : (v9 = v34 + 1),
            v9) )
      {
        v35 = a3[3];
        v36 = (char *)*((_QWORD *)v35 + 512);
        if ( v35 + 4096 - v36 >= (unsigned __int64)(48 * v9) )
          *((_QWORD *)v35 + 512) = &v36[48 * v9];
        else
          v36 = (char *)malloc(48 * v9);
      }
      else
      {
        v36 = 0LL;
      }
      v56 = &v36[48 * v34];
      *v56 = 16;
      v57 = &v36[48 * v9];
      *((_QWORD *)v56 + 1) = *(_QWORD *)((char *)&v177 + 7);
      *((_QWORD *)v56 + 2) = 0LL;
      *(_QWORD *)(v56 + 1) = v177;
      *(_QWORD *)((char *)&v177 + 7) = 0LL;
      *(_QWORD *)&v177 = 0LL;
      v56[24] = 0;
      *((_QWORD *)v56 + 4) = 0LL;
      *((_QWORD *)v56 + 5) = 0LL;
      *(_QWORD *)(v56 + 25) = 0LL;
      v59 = (void **)*a3;
      v58 = (void **)a3[1];
      v60 = v56 + 48;
      if ( v58 == (void **)*a3 )
      {
        v62 = (void **)*a3;
      }
      else
      {
        do
        {
          *((_QWORD *)v56 - 4) = *(v58 - 4);
          *((_OWORD *)v56 - 3) = *((_OWORD *)v58 - 3);
          v61 = (__int64)*(v58 - 1);
          *(v58 - 5) = 0LL;
          *(v58 - 4) = 0LL;
          *(v58 - 6) = 0LL;
          *((_QWORD *)v56 - 1) = v61;
          *(_OWORD *)(v56 - 24) = *(_OWORD *)(v58 - 3);
          *(v58 - 2) = 0LL;
          *(v58 - 1) = 0LL;
          *(v58 - 3) = 0LL;
          v58 -= 6;
          v56 -= 48;
        }
        while ( v59 != v58 );
        v62 = (void **)*a3;
        v59 = (void **)a3[1];
      }
      v63 = a3[2];
      *a3 = v56;
      a3[1] = v60;
      a3[2] = v57;
      if ( v59 != v62 )
      {
        do
        {
          if ( (*(_BYTE *)(v59 - 3) & 1) != 0 )
            free(*(v59 - 1));
          v64 = v59 - 6;
          if ( (*(_BYTE *)(v59 - 6) & 1) != 0 )
            free(*(v59 - 4));
          v59 -= 6;
        }
        while ( v62 != v64 );
      }
      if ( v62 )
      {
        v65 = (unsigned __int64)a3[3];
        if ( v65 + 4096 < (unsigned __int64)v62 || v65 > (unsigned __int64)v62 )
        {
          free(v62);
        }
        else if ( *(char **)(v65 + 4096) == v63 )
        {
          *(_QWORD *)(v65 + 4096) = v62;
        }
      }
    }
    else
    {
      *(_BYTE *)v24 = 16;
      *(_QWORD *)(v24 + 8) = *(_QWORD *)((char *)&v177 + 7);
      *(_QWORD *)(v24 + 16) = 0LL;
      *(_QWORD *)(v24 + 1) = v177;
      *(_QWORD *)((char *)&v177 + 7) = 0LL;
      *(_QWORD *)&v177 = 0LL;
      *(_BYTE *)(v24 + 24) = 0;
      *(_QWORD *)(v24 + 32) = 0LL;
      *(_QWORD *)(v24 + 40) = 0LL;
      *(_QWORD *)(v24 + 25) = 0LL;
      a3[1] += 48;
    }
    v66 = (char *)(v4 + 2);
    if ( v4 + 2 == a2 )
    {
LABEL_104:
      v70 = a3[1];
      v71 = v70 - 48;
      if ( (*(v70 - 24) & 1) != 0 )
        free(*((void **)v70 - 1));
      if ( (*v71 & 1) == 0 )
        goto LABEL_109;
      v72 = (void *)*((_QWORD *)v70 - 4);
LABEL_108:
      free(v72);
LABEL_109:
      a3[1] = v71;
      return (__int64)v4;
    }
    v67 = (unsigned __int8)*v66;
    if ( (unsigned int)(v67 - 48) > 9 )
    {
      v69 = v4 + 2;
      goto LABEL_101;
    }
    v68 = 3LL;
    if ( v4 + 3 == a2 )
    {
LABEL_99:
      v69 = a2;
    }
    else
    {
      while ( (unsigned int)v4[v68] - 48 <= 9 )
      {
        if ( !&v6[++v68] )
          goto LABEL_99;
      }
      v69 = &v4[v68];
    }
    v73 = a3[1];
    v75 = (size_t *)(v73 - 48);
    v74 = (unsigned __int8)*(v73 - 48);
    if ( (*(v73 - 48) & 1) != 0 )
    {
      v74 = *((_QWORD *)v73 - 6);
      v76 = *((_QWORD *)v73 - 5);
      v77 = (v74 & 0xFFFFFFFFFFFFFFFELL) - 1;
      v78 = v69 - (unsigned __int8 *)v66;
      if ( v69 == (unsigned __int8 *)v66 )
        goto LABEL_101;
    }
    else
    {
      v76 = v74 >> 1;
      v77 = 22LL;
      v78 = v69 - (unsigned __int8 *)v66;
      if ( v69 == (unsigned __int8 *)v66 )
        goto LABEL_101;
    }
    if ( (v74 & 1) != 0 )
    {
      v80 = *((_QWORD *)v73 - 5);
      v79 = *((_QWORD *)v73 - 4);
      if ( v79 > (unsigned __int64)v66 )
        goto LABEL_124;
    }
    else
    {
      v79 = (unsigned __int64)(v73 - 47);
      v80 = (unsigned __int64)((unsigned __int8)v74 & 0xFE) >> 1;
      if ( v73 - 47 > v66 )
        goto LABEL_124;
    }
    if ( v79 + v80 > (unsigned __int64)v66 )
    {
      p = 0LL;
      v177 = 0uLL;
      if ( v78 >= 0xFFFFFFFFFFFFFFF0LL )
        goto LABEL_297;
      if ( v78 > 0x16 )
      {
        v133 = (v78 + 16) & 0xFFFFFFFFFFFFFFF0LL;
        v134 = v78;
        v81 = malloc(v133);
        v78 = v134;
        v75 = (size_t *)(v73 - 48);
        *((_QWORD *)&v177 + 1) = v134;
        p = v81;
        *(_QWORD *)&v177 = v133 | 1;
        if ( v68 == 2 )
          goto LABEL_254;
      }
      else
      {
        LOBYTE(v177) = 2 * v78;
        v81 = (char *)&v177 + 1;
        if ( v68 == 2 )
        {
LABEL_254:
          *(_BYTE *)v81 = 0;
          v148 = v177;
          v149 = p;
          if ( (v177 & 1) != 0 )
            v150 = (char *)p;
          else
            v150 = (char *)&v177 + 1;
          if ( (v177 & 1) != 0 )
            v151 = *((_QWORD *)&v177 + 1);
          else
            v151 = (unsigned __int64)(unsigned __int8)v177 >> 1;
          sub_9CFD0(v75, v150, v151);
          if ( (v148 & 1) != 0 )
            free(v149);
LABEL_101:
          sub_B23DC(a3[1] - 48, 39LL);
          if ( v69 != a2 && *v69 == 95 )
            return (__int64)(v69 + 1);
          goto LABEL_104;
        }
      }
      v135 = v4 + 3;
      *(_BYTE *)v81 = v67;
      if ( v4 + 3 != v69 )
      {
        v136 = (unsigned __int64)&v69[-3LL - (_QWORD)v4];
        if ( v136 >= 0x20 && (v137 = v136 & 0xFFFFFFFFFFFFFFE0LL, (v136 & 0xFFFFFFFFFFFFFFE0LL) != 0) )
        {
          if ( (char *)v81 + 1 >= (char *)v69 || (v138 = v81, v4 + 3 >= &v69[-2LL - (_QWORD)v4 + (_QWORD)v81]) )
          {
            v135 += v137;
            v138 = (char *)v81 + v137;
            v139 = (char *)v81 + 17;
            v140 = (__int128 *)(v4 + 19);
            v141 = v136 & 0xFFFFFFFFFFFFFFE0LL;
            do
            {
              v142 = *(v140 - 1);
              v143 = *v140;
              v141 -= 32LL;
              v140 += 2;
              *(v139 - 1) = v142;
              *v139 = v143;
              v139 += 2;
            }
            while ( v141 );
            if ( v137 == v136 )
              goto LABEL_253;
          }
        }
        else
        {
          v138 = v81;
        }
        v146 = v138 + 1;
        do
        {
          v147 = *v135++;
          *v146++ = v147;
        }
        while ( v69 != v135 );
      }
LABEL_253:
      v81 = (char *)v81 + v78;
      goto LABEL_254;
    }
LABEL_124:
    if ( v77 - v76 >= v78 )
    {
LABEL_277:
      if ( (v74 & 1) != 0 )
        v156 = (char *)*((_QWORD *)v73 - 4);
      else
        v156 = (char *)v75 + 1;
      v157 = &v156[v76];
      if ( v68 != 2 )
      {
        v158 = (unsigned __int64)&v69[-2LL - (_QWORD)v4];
        v159 = v76 - (_QWORD)v66;
        if ( v158 < 0x20 )
          goto LABEL_300;
        v160 = v158 & 0xFFFFFFFFFFFFFFE0LL;
        if ( (v158 & 0xFFFFFFFFFFFFFFE0LL) == 0
          || v157 < (char *)v69 && (unsigned __int8 *)v66 < &v69[v76 - 2 - (_QWORD)v4 + (_QWORD)v156] )
        {
          goto LABEL_300;
        }
        v157 += v160;
        v66 += v160;
        v161 = (__int128 *)(v4 + 18);
        v162 = &v156[v76 + 16];
        v163 = v158 & 0xFFFFFFFFFFFFFFE0LL;
        do
        {
          v164 = *(v161 - 1);
          v165 = *v161;
          v161 += 2;
          v163 -= 32LL;
          *((_OWORD *)v162 - 1) = v164;
          *(_OWORD *)v162 = v165;
          v162 += 32;
        }
        while ( v163 );
        if ( v160 != v158 )
        {
LABEL_300:
          do
          {
            v166 = *v66++;
            *v157++ = v166;
          }
          while ( v69 != (unsigned __int8 *)v66 );
        }
        v157 = (char *)&v69[v159 + (_QWORD)v156];
      }
      *v157 = 0;
      v167 = v76 + v78;
      if ( (*(_BYTE *)v75 & 1) != 0 )
        *((_QWORD *)v73 - 5) = v167;
      else
        *(_BYTE *)v75 = 2 * v167;
      goto LABEL_101;
    }
    if ( -17LL - v77 >= v76 + v78 - v77 )
    {
      if ( (v74 & 1) != 0 )
        v82 = (char *)*((_QWORD *)v73 - 4);
      else
        v82 = v73 - 47;
      v172 = v82;
      v171 = v78;
      if ( v77 > 0x7FFFFFFFFFFFFFE6LL )
      {
        v145 = -17LL;
      }
      else
      {
        v144 = 2 * v77;
        if ( v76 + v78 >= 2 * v77 )
          v144 = v76 + v78;
        if ( v144 >= 0x17 )
          v145 = (v144 + 16) & 0xFFFFFFFFFFFFFFF0LL;
        else
          v145 = 23LL;
      }
      v168 = v145;
      v154 = malloc(v145);
      v155 = v154;
      if ( v76 )
        memcpy(v154, v172, v76);
      if ( v77 != 22 )
        free(v172);
      *((_QWORD *)v73 - 4) = v155;
      LOBYTE(v74) = v168 | 1;
      *((_QWORD *)v73 - 6) = v168 | 1;
      v75 = (size_t *)(v73 - 48);
      v78 = v171;
      goto LABEL_277;
    }
LABEL_297:
    abort();
  }
  return (__int64)v4;
}
// A1C60: conditional instruction was optimized away because w8.4 is in (==1|==6)
// 925FC: using guessed type __int64 __fastcall sub_925FC(_QWORD, _QWORD, _QWORD);
// A7174: using guessed type __int64 __fastcall sub_A7174(_QWORD, _QWORD);
// AC0B0: using guessed type __int64 __fastcall sub_AC0B0(_QWORD, _QWORD, _QWORD);
// B190C: using guessed type __int64 __fastcall sub_B190C(_QWORD, _QWORD, _QWORD);
// B1FF4: using guessed type _QWORD *__fastcall sub_B1FF4(_QWORD *__return_ptr, _QWORD);
// B23DC: using guessed type __int64 __fastcall sub_B23DC(_QWORD, _QWORD);
// B2508: using guessed type __int64 sub_B2508(void);

//----- (00000000000A1F74) ----------------------------------------------------
void __fastcall sub_A1F74(size_t *a1, void *src, size_t n)
{
  size_t v4; // x8
  unsigned __int64 v7; // x25
  _BYTE *v8; // x22
  void *v9; // x22
  unsigned __int64 v10; // x8
  size_t v11; // x23
  void *v12; // x24

  LOBYTE(v4) = *(_BYTE *)a1;
  if ( (*(_BYTE *)a1 & 1) != 0 )
  {
    v4 = *a1;
    v7 = (*a1 & 0xFFFFFFFFFFFFFFFELL) - 1;
    if ( v7 >= n )
    {
LABEL_3:
      if ( (v4 & 1) != 0 )
      {
        v8 = (_BYTE *)a1[2];
        if ( !n )
          goto LABEL_12;
      }
      else
      {
        v8 = (char *)a1 + 1;
        if ( !n )
        {
LABEL_12:
          v8[n] = 0;
          if ( (*(_BYTE *)a1 & 1) != 0 )
            a1[1] = n;
          else
            *(_BYTE *)a1 = 2 * n;
          return;
        }
      }
      memmove(v8, src, n);
      goto LABEL_12;
    }
  }
  else
  {
    v7 = 22LL;
    if ( n <= 0x16 )
      goto LABEL_3;
  }
  if ( -18LL - v7 < n - v7 )
    abort();
  if ( (v4 & 1) != 0 )
    v9 = (void *)a1[2];
  else
    v9 = (char *)a1 + 1;
  if ( v7 > 0x7FFFFFFFFFFFFFE6LL )
  {
    v11 = -17LL;
  }
  else
  {
    v10 = 2 * v7;
    if ( 2 * v7 <= n )
      v10 = n;
    if ( v10 >= 0x17 )
      v11 = (v10 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    else
      v11 = 23LL;
  }
  v12 = malloc(v11);
  memcpy(v12, src, n);
  if ( v7 != 22 )
    free(v9);
  a1[1] = n;
  a1[2] = (size_t)v12;
  *a1 = v11 | 1;
  *((_BYTE *)v12 + n) = 0;
}

//----- (00000000000A20BC) ----------------------------------------------------
__int64 __fastcall sub_A20BC(unsigned __int8 *a1, unsigned __int8 *a2, __int64 a3)
{
  _BYTE *v4; // x20
  __int64 v5; // x8
  int v7; // w10
  int v8; // w9
  _BOOL4 v9; // w23
  unsigned __int8 *v10; // x9
  __int64 v11; // x24
  unsigned __int8 *v13; // x22
  __int64 v14; // x0
  int v15; // w8
  unsigned __int8 *v16; // x22
  unsigned __int8 *v17; // x0
  __int64 v18; // x0
  unsigned __int8 *v19; // x23
  __int64 v20; // x0
  __int64 v21; // x22
  __int64 v22; // x21
  __int64 v23; // x22
  unsigned __int64 v24; // x8
  bool v25; // zf
  size_t v26; // x8
  void *v27; // x1
  size_t v28; // x2
  __int64 v29; // x20
  _BYTE *v30; // x22
  unsigned __int64 v31; // x8
  bool v32; // zf
  size_t v33; // x8
  void *v34; // x1
  size_t v35; // x2
  size_t *v36; // x0
  char v37; // w22
  void *v38; // x8
  __int128 v39; // q0
  void *v40; // x20
  char *v41; // x1
  size_t v42; // x2
  char *v43; // x8
  __int128 v44; // q0
  __int64 v45; // x9
  __int64 v46; // x10
  char *v47; // x11
  char v48; // w8
  __int64 v49; // x8
  __int64 v50; // x9
  int v51; // w9
  _BYTE *v52; // x8
  _BOOL4 v53; // w23
  int v54; // w8
  unsigned __int8 *v55; // x23
  __int64 v56; // x0
  __int64 v57; // x22
  __int64 v58; // x22
  unsigned __int64 v59; // x8
  bool v60; // zf
  size_t v61; // x8
  void *v62; // x1
  size_t v63; // x2
  __int64 v64; // x22
  _BYTE *v65; // x23
  void **v66; // x8
  unsigned __int64 v67; // x8
  bool v68; // zf
  size_t v69; // x8
  void *v70; // x1
  size_t v71; // x2
  size_t *v72; // x0
  void *v73; // x8
  __int128 v74; // q0
  char *v75; // x8
  __int128 v76; // q0
  char v77; // w22
  char *v78; // x1
  size_t v79; // x2
  char *v80; // x8
  __int128 v81; // q0
  __int64 v82; // x9
  __int64 v83; // x10
  char *v84; // x11
  char v85; // w8
  __int64 v86; // x8
  __int64 v87; // x9
  int v88; // w19
  int v89; // w8
  int v90; // w9
  unsigned __int8 *v91; // x22
  void **v92; // x23
  __int64 v93; // x28
  void **v94; // x8
  __int64 v95; // x10
  void **v96; // x0
  unsigned __int64 v97; // x8
  bool v98; // zf
  size_t v99; // x8
  void *v100; // x1
  size_t v101; // x2
  size_t *v102; // x0
  char v103; // w21
  void *v104; // x20
  char *v105; // x1
  size_t v106; // x2
  unsigned __int64 v107; // x22
  unsigned __int64 v108; // x21
  unsigned __int64 v109; // x23
  __int64 v110; // x8
  void *v111; // x20
  __int64 v112; // x9
  char v113; // w21
  __int64 v114; // x8
  unsigned __int64 v115; // x9
  unsigned __int8 *v116; // x22
  __int64 v117; // x0
  __int64 v118; // x23
  __int64 v119; // x0
  __int64 v120; // x22
  __int64 v121; // x0
  __int64 v122; // x23
  unsigned __int64 v123; // x8
  unsigned __int64 v124; // x8
  bool v125; // zf
  size_t v126; // x8
  void *v127; // x1
  size_t v128; // x2
  __int64 v129; // x20
  _BYTE *v130; // x22
  unsigned __int64 v131; // x8
  bool v132; // zf
  size_t v133; // x8
  void *v134; // x1
  size_t v135; // x2
  size_t *v136; // x0
  __int64 v137; // x20
  _BYTE *v138; // x22
  unsigned __int64 v139; // x8
  bool v140; // zf
  size_t v141; // x8
  void *v142; // x1
  size_t v143; // x2
  size_t *v144; // x0
  char v145; // w23
  void *v146; // x8
  __int128 v147; // q0
  void *v148; // x20
  char *v149; // x1
  size_t v150; // x2
  void *v151; // x8
  __int128 v152; // q0
  char v153; // w24
  void *v154; // x8
  __int128 v155; // q0
  void *v156; // x22
  char *v157; // x1
  size_t v158; // x2
  char *v159; // x8
  __int128 v160; // q0
  __int64 v161; // x9
  __int64 v162; // x10
  char *v163; // x11
  char v164; // w8
  __int64 v165; // x8
  __int64 v166; // x9
  unsigned __int8 *v167; // x22
  __int64 v168; // x21
  __int64 v169; // x22
  unsigned __int64 v170; // x8
  bool v171; // zf
  size_t v172; // x8
  void *v173; // x1
  size_t v174; // x2
  __int64 v175; // x9
  __int64 v176; // x10
  char *v177; // x11
  char v178; // w8
  __int64 v179; // x8
  __int64 v180; // x9
  unsigned __int64 v181; // x8
  unsigned __int64 v182; // x9
  char v183; // w9
  char v184; // w9
  unsigned __int8 *v185; // x23
  __int64 v186; // x0
  _BYTE *v187; // x22
  __int64 v188; // x8
  unsigned __int64 v189; // x9
  size_t v190; // x10
  void *v191; // x11
  size_t *v192; // x0
  void *v193; // x8
  bool v194; // zf
  size_t v195; // x9
  void *v196; // x1
  size_t v197; // x2
  __int64 v198; // x27
  __int64 *v199; // x24
  _QWORD *v200; // x9
  char v201; // w28
  unsigned __int8 *v202; // x23
  unsigned __int8 *v203; // x0
  unsigned __int8 *v204; // x22
  unsigned __int8 *v205; // x22
  unsigned __int64 v206; // x8
  _OWORD *v207; // x9
  unsigned __int8 *v208; // x23
  __int64 v209; // x0
  __int64 v210; // x22
  __int64 v211; // x22
  unsigned __int64 v212; // x8
  bool v213; // zf
  size_t v214; // x8
  void *v215; // x1
  size_t v216; // x2
  __int64 v217; // x22
  _BYTE *v218; // x23
  void **v219; // x8
  unsigned __int64 v220; // x8
  bool v221; // zf
  size_t v222; // x8
  void *v223; // x1
  size_t v224; // x2
  size_t *v225; // x0
  void *v226; // x8
  __int128 v227; // q0
  char *v228; // x8
  __int128 v229; // q0
  char v230; // w22
  char *v231; // x1
  size_t v232; // x2
  char *v233; // x8
  __int128 v234; // q0
  __int64 v235; // x9
  __int64 v236; // x10
  char *v237; // x11
  char v238; // w8
  __int64 v239; // x8
  __int64 v240; // x9
  int v241; // w19
  _BYTE *v242; // x22
  unsigned __int8 *v243; // x22
  __int64 v244; // x21
  __int64 v245; // x23
  __int64 v246; // x8
  unsigned __int64 v247; // x8
  bool v248; // zf
  size_t v249; // x8
  void *v250; // x1
  size_t v251; // x2
  char *v252; // x8
  __int128 v253; // q0
  void *v254; // x11
  char v255; // w10
  __int64 v256; // x28
  __int64 *v257; // x19
  const void **v258; // x23
  unsigned __int8 *v259; // x23
  __int64 v260; // x0
  __int64 v261; // x22
  __int64 v262; // x22
  unsigned __int64 v263; // x8
  bool v264; // zf
  size_t v265; // x8
  void *v266; // x1
  size_t v267; // x2
  __int64 v268; // x20
  _BYTE *v269; // x22
  unsigned __int64 v270; // x8
  bool v271; // zf
  size_t v272; // x8
  void *v273; // x1
  size_t v274; // x2
  size_t *v275; // x0
  void *v276; // x8
  __int128 v277; // q0
  char *v278; // x8
  __int128 v279; // q0
  char *v280; // x1
  size_t v281; // x2
  unsigned __int8 *v282; // x22
  __int64 v283; // x22
  unsigned __int64 v284; // x8
  size_t *v285; // x0
  bool v286; // zf
  size_t v287; // x8
  void *v288; // x1
  size_t v289; // x2
  unsigned __int8 *v290; // x23
  __int64 v291; // x0
  __int64 v292; // x22
  __int64 v293; // x22
  unsigned __int64 v294; // x8
  bool v295; // zf
  size_t v296; // x8
  void *v297; // x1
  size_t v298; // x2
  __int64 v299; // x20
  _BYTE *v300; // x22
  __int64 v301; // x8
  void *v302; // x19
  char *v303; // x1
  size_t v304; // x2
  void *v305; // x0
  unsigned __int8 *v306; // x22
  unsigned __int64 v307; // x8
  bool v308; // zf
  size_t v309; // x8
  char *v310; // x8
  __int128 v311; // q0
  __int64 v312; // x9
  __int64 v313; // x10
  char *v314; // x11
  char v315; // w8
  __int64 v316; // x8
  __int64 v317; // x9
  _BYTE *v318; // x22
  unsigned __int8 *v319; // x22
  __int64 v320; // x22
  unsigned __int64 v321; // x8
  size_t *v322; // x0
  bool v323; // zf
  size_t v324; // x8
  void *v325; // x1
  size_t v326; // x2
  unsigned __int8 *v327; // x22
  unsigned __int64 v328; // x8
  bool v329; // zf
  size_t v330; // x8
  char *v331; // x8
  __int128 v332; // q0
  __int64 v333; // x9
  __int64 v334; // x8
  void *v335; // x23
  __int64 v336; // x24
  __int64 *v337; // x28
  const void **v338; // x27
  __int64 v339; // x21
  _BYTE *v340; // x22
  __int64 v341; // x22
  unsigned __int64 v342; // x8
  bool v343; // zf
  size_t v344; // x8
  void *v345; // x1
  size_t v346; // x2
  char *v347; // x8
  __int128 v348; // q0
  __int64 v349; // x9
  __int64 v350; // x10
  char v351; // w8
  unsigned __int8 *v352; // x22
  char *v353; // x8
  __int128 v354; // q0
  __int64 v355; // x8
  unsigned __int64 v356; // x9
  size_t v357; // x10
  void *v358; // x11
  size_t *v359; // x0
  void *v360; // x8
  bool v361; // zf
  size_t v362; // x9
  void *v363; // x1
  size_t v364; // x2
  size_t *v365; // x0
  char v366; // w23
  void *v367; // x24
  char *v368; // x1
  size_t v369; // x2
  unsigned __int8 *v370; // x22
  char *v371; // x8
  __int128 v372; // q0
  __int64 v373; // x8
  unsigned __int64 v374; // x9
  size_t v375; // x10
  void *v376; // x11
  size_t *v377; // x0
  void *v378; // x8
  bool v379; // zf
  size_t v380; // x9
  void *v381; // x1
  size_t v382; // x2
  size_t *v383; // x0
  void *v384; // x11
  char v385; // w10
  __int64 v386; // x28
  void **v387; // x19
  const void **v388; // x22
  unsigned __int64 v389; // x21
  unsigned __int64 v390; // x9
  unsigned __int64 v391; // x9
  __int64 v392; // x9
  char *v393; // x0
  unsigned __int8 *v394; // x23
  __int64 v395; // x0
  __int64 v396; // x22
  __int64 v397; // x22
  unsigned __int64 v398; // x8
  bool v399; // zf
  size_t v400; // x8
  void *v401; // x1
  size_t v402; // x2
  __int64 v403; // x22
  _BYTE *v404; // x20
  char *v405; // x1
  size_t v406; // x2
  unsigned __int8 *v407; // x23
  __int64 v408; // x0
  __int64 v409; // x22
  __int64 v410; // x22
  unsigned __int64 v411; // x8
  bool v412; // zf
  size_t v413; // x8
  void *v414; // x1
  size_t v415; // x2
  __int64 v416; // x23
  _BYTE *v417; // x22
  void **v418; // x8
  char *v419; // x1
  size_t v420; // x2
  int v421; // w19
  unsigned __int8 *v422; // x23
  __int64 v423; // x0
  __int64 v424; // x22
  __int64 v425; // x22
  unsigned __int64 v426; // x8
  bool v427; // zf
  size_t v428; // x8
  void *v429; // x1
  size_t v430; // x2
  __int64 v431; // x22
  _BYTE *v432; // x23
  void **v433; // x8
  unsigned __int64 v434; // x8
  bool v435; // zf
  size_t v436; // x8
  void *v437; // x1
  size_t v438; // x2
  size_t *v439; // x0
  void *v440; // x8
  __int128 v441; // q0
  char *v442; // x8
  __int128 v443; // q0
  char v444; // w22
  char *v445; // x1
  size_t v446; // x2
  char *v447; // x8
  __int128 v448; // q0
  __int64 v449; // x9
  __int64 v450; // x10
  char *v451; // x11
  char v452; // w8
  __int64 v453; // x8
  __int64 v454; // x9
  int v455; // w19
  __int64 v456; // x22
  unsigned __int64 v457; // x8
  bool v458; // zf
  size_t v459; // x8
  void *v460; // x1
  size_t v461; // x2
  char *v462; // x8
  __int128 v463; // q0
  __int64 v464; // x9
  __int64 v465; // x10
  char v466; // w8
  _BYTE *v467; // x21
  _BYTE *v468; // x21
  int v469; // w9
  _BYTE *v470; // x22
  char v471; // w28
  __int64 v472; // x0
  unsigned __int64 v473; // x27
  unsigned __int64 v474; // x9
  int v475; // w8
  __int64 v476; // x22
  unsigned __int64 v477; // x8
  bool v478; // zf
  size_t v479; // x8
  void *v480; // x1
  size_t v481; // x2
  char *v482; // x8
  __int128 v483; // q0
  __int64 v484; // x9
  __int64 v485; // x10
  char *v486; // x11
  char v487; // w8
  __int64 v488; // x8
  __int64 v489; // x9
  __int64 v490; // x24
  unsigned __int64 v491; // x12
  unsigned __int64 v492; // x9
  int v493; // w8
  unsigned __int8 *v494; // x22
  __int64 v495; // x22
  unsigned __int64 v496; // x8
  bool v497; // zf
  size_t v498; // x8
  void *v499; // x1
  size_t v500; // x2
  char *v501; // x8
  __int128 v502; // q0
  __int64 v503; // x9
  __int64 v504; // x10
  char v505; // w8
  unsigned __int64 v506; // x20
  char *v507; // x8
  char v508; // w10
  char v509; // w10
  void **v510; // x11
  void **v511; // x22
  char *v512; // x10
  __int64 v513; // x12
  void **v514; // x21
  __int64 v515; // x23
  void **v516; // x24
  unsigned __int64 v517; // x8
  unsigned __int8 *v518; // x23
  unsigned __int8 *v519; // x0
  _BYTE *v520; // x22
  int v521; // w8
  __int64 v522; // x0
  unsigned __int64 v523; // x27
  void *v524; // x0
  _BYTE *v525; // x20
  _BYTE *v526; // x0
  _BYTE *v527; // x0
  bool v528; // cc
  _BYTE *v529; // x20
  char v530; // w27
  _BYTE *v531; // x9
  _BYTE *v532; // x0
  size_t v533; // x2
  void *v534; // x24
  void *v535; // x0
  _BYTE *v536; // x0
  _BYTE *v537; // x27
  __int64 v538; // x20
  unsigned __int64 v539; // x19
  char *v540; // x21
  char v541; // w23
  __int64 v542; // x23
  unsigned __int64 v543; // x28
  unsigned __int64 v544; // x22
  void *v545; // x0
  void *v546; // x0
  unsigned __int8 *v547; // x23
  unsigned __int8 *v548; // x0
  _BYTE *v549; // x19
  _BYTE *v550; // x0
  _BYTE *v551; // x0
  _BYTE *v552; // x19
  __int64 v553; // x8
  unsigned __int64 v554; // x9
  size_t v555; // x10
  void *v556; // x11
  size_t *v557; // x0
  void *v558; // x8
  bool v559; // zf
  size_t v560; // x9
  void *v561; // x1
  size_t v562; // x2
  size_t *v563; // x0
  char *v564; // x8
  char *v565; // x11
  unsigned __int64 v566; // x8
  bool v567; // zf
  size_t v568; // x8
  char *v569; // x1
  size_t v570; // x2
  size_t *v571; // x0
  char *v572; // x21
  char *v573; // x23
  unsigned __int64 v574; // x8
  bool v575; // zf
  size_t v576; // x8
  char *v577; // x1
  size_t v578; // x2
  size_t *v579; // x0
  char v580; // w12
  char *v581; // x11
  char *v582; // x21
  char *v583; // x23
  int v584; // w21
  _BYTE *v585; // x19
  _BYTE *v586; // x0
  _BYTE *v587; // x28
  _BYTE *v588; // x0
  _BYTE *v589; // x28
  unsigned __int64 v590; // x21
  unsigned __int64 v591; // x8
  unsigned __int64 v592; // x8
  __int64 v593; // x9
  char *v594; // x0
  void *v595; // x8
  __int128 v596; // q0
  char v597; // w21
  void *v598; // x23
  char *v599; // x1
  size_t v600; // x2
  char *v601; // x1
  size_t v602; // x2
  void *v603; // x8
  __int128 v604; // q0
  char v605; // w21
  void *v606; // x23
  char *v607; // x1
  size_t v608; // x2
  __int64 v609; // x8
  void *v610; // x23
  __int64 v611; // x9
  char v612; // w21
  __int64 v613; // x8
  unsigned __int64 v614; // x8
  unsigned __int64 v615; // x9
  unsigned __int64 v616; // x28
  unsigned __int64 v617; // x9
  unsigned __int64 v618; // x9
  __int64 v619; // x9
  char *v620; // x0
  void *v621; // x0
  unsigned __int64 v622; // x22
  unsigned __int64 v623; // x9
  unsigned __int64 v624; // x9
  __int64 v625; // x9
  char *v626; // x0
  unsigned __int64 v627; // x20
  __int64 v628; // x28
  __int64 v629; // x8
  unsigned __int64 v630; // x9
  size_t v631; // x10
  void *v632; // x11
  size_t *v633; // x0
  void *v634; // x8
  bool v635; // zf
  size_t v636; // x9
  void *v637; // x1
  size_t v638; // x2
  size_t *v639; // x0
  char *v640; // x8
  __int128 v641; // q0
  char v642; // w23
  void *v643; // x22
  char *v644; // x1
  size_t v645; // x2
  void *v646; // x0
  __int64 v647; // x0
  _BYTE *v648; // x23
  __int64 v649; // x24
  unsigned __int64 v650; // x8
  bool v651; // zf
  size_t v652; // x8
  void *v653; // x1
  size_t v654; // x2
  __int64 v655; // x28
  _BYTE *v656; // x24
  size_t v657; // x2
  char *v658; // x1
  int v659; // w24
  __int64 v660; // x8
  char *v661; // x8
  void **v662; // x11
  void **v663; // x23
  char *v664; // x9
  _OWORD *v665; // x10
  __int64 v666; // x12
  void **v667; // x21
  __int64 v668; // x24
  void **v669; // x27
  unsigned __int64 v670; // x8
  __int64 v671; // x22
  unsigned __int64 v672; // x8
  bool v673; // zf
  size_t v674; // x8
  void *v675; // x1
  size_t v676; // x2
  __int64 v677; // x20
  _BYTE *v678; // x22
  unsigned __int64 v679; // x8
  bool v680; // zf
  size_t v681; // x8
  void *v682; // x1
  size_t v683; // x2
  size_t *v684; // x0
  void *v685; // x8
  __int128 v686; // q0
  char *v687; // x8
  __int128 v688; // q0
  char *v689; // x8
  __int128 v690; // q0
  __int64 v691; // x9
  __int64 v692; // x10
  char *v693; // x11
  char v694; // w8
  __int64 v695; // x8
  __int64 v696; // x9
  char *v697; // x8
  char *v698; // x9
  void **v699; // x11
  void **v700; // x23
  char *v701; // x10
  __int64 v702; // x12
  void **v703; // x21
  __int64 v704; // x24
  void **v705; // x26
  unsigned __int64 v706; // x8
  char *v707; // x8
  void **v708; // x11
  void **v709; // x21
  char *v710; // x10
  __int64 v711; // x12
  void **v712; // x20
  __int64 v713; // x22
  void **v714; // x23
  unsigned __int64 v715; // x8
  unsigned __int64 v716; // [xsp+10h] [xbp-1F0h]
  unsigned __int64 v717; // [xsp+10h] [xbp-1F0h]
  char v718; // [xsp+18h] [xbp-1E8h]
  char v719; // [xsp+18h] [xbp-1E8h]
  unsigned __int64 v720; // [xsp+18h] [xbp-1E8h]
  unsigned __int64 v721; // [xsp+20h] [xbp-1E0h]
  unsigned __int64 v722; // [xsp+20h] [xbp-1E0h]
  int v723; // [xsp+20h] [xbp-1E0h]
  int v724; // [xsp+20h] [xbp-1E0h]
  char *v725; // [xsp+20h] [xbp-1E0h]
  __int64 v726; // [xsp+28h] [xbp-1D8h]
  void *v727; // [xsp+28h] [xbp-1D8h]
  unsigned __int64 v728; // [xsp+28h] [xbp-1D8h]
  int v729; // [xsp+28h] [xbp-1D8h]
  char **v730; // [xsp+28h] [xbp-1D8h]
  unsigned __int64 v731; // [xsp+28h] [xbp-1D8h]
  unsigned __int64 v732; // [xsp+30h] [xbp-1D0h]
  _BOOL4 v733; // [xsp+30h] [xbp-1D0h]
  char v734; // [xsp+30h] [xbp-1D0h]
  void *v735; // [xsp+30h] [xbp-1D0h]
  unsigned __int64 v736; // [xsp+30h] [xbp-1D0h]
  unsigned __int64 v737; // [xsp+30h] [xbp-1D0h]
  unsigned __int64 v738; // [xsp+38h] [xbp-1C8h]
  char v739; // [xsp+38h] [xbp-1C8h]
  int v740; // [xsp+38h] [xbp-1C8h]
  void *v741; // [xsp+38h] [xbp-1C8h]
  char v742; // [xsp+38h] [xbp-1C8h]
  const void **v743; // [xsp+38h] [xbp-1C8h]
  __int128 v744; // [xsp+48h] [xbp-1B8h] BYREF
  void *v745; // [xsp+58h] [xbp-1A8h]
  __int128 v746; // [xsp+60h] [xbp-1A0h] BYREF
  void *v747; // [xsp+70h] [xbp-190h]
  __int128 v748; // [xsp+80h] [xbp-180h] BYREF
  void *v749; // [xsp+90h] [xbp-170h]
  _BYTE v750[48]; // [xsp+A0h] [xbp-160h] BYREF
  _QWORD v751[2]; // [xsp+D0h] [xbp-130h]
  __int128 v752; // [xsp+E0h] [xbp-120h] BYREF
  void *p; // [xsp+F0h] [xbp-110h]
  __int128 v754; // [xsp+100h] [xbp-100h] BYREF
  void *v755; // [xsp+110h] [xbp-F0h]
  __int128 v756; // [xsp+120h] [xbp-E0h] BYREF
  char *v757; // [xsp+130h] [xbp-D0h]
  __int128 v758; // [xsp+140h] [xbp-C0h] BYREF
  char *v759; // [xsp+150h] [xbp-B0h]
  __int128 v760; // [xsp+160h] [xbp-A0h] BYREF
  char *v761; // [xsp+170h] [xbp-90h]
  __int64 v762; // [xsp+178h] [xbp-88h]
  __int64 v763; // [xsp+180h] [xbp-80h]
  void *v764; // [xsp+188h] [xbp-78h]
  __int128 v765; // [xsp+190h] [xbp-70h] BYREF
  char *v766; // [xsp+1A0h] [xbp-60h]

  v4 = a1;
  v5 = a2 - a1;
  _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  if ( a2 - a1 < 2 )
    return (__int64)v4;
  if ( v5 < 4 )
  {
    v9 = 0;
    v10 = a1;
  }
  else
  {
    v7 = *a1;
    if ( v7 != 103 )
    {
      v9 = 0;
      v10 = a1;
      goto LABEL_10;
    }
    v8 = a1[1];
    v9 = v8 == 115;
    if ( v8 == 115 )
      v10 = a1 + 2;
    else
      v10 = a1;
  }
  v7 = *v10;
LABEL_10:
  v11 = 0x555555555555555LL;
  switch ( v7 )
  {
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
      return sub_A9F34(a1, a2, a3);
    case 'L':
      return sub_A743C(a1, a2, a3);
    case 'T':
      return sub_9F9E8(a1, a2, a3);
    case 'a':
      switch ( v10[1] )
      {
        case 'N':
          v13 = a1 + 2;
          v761 = 0LL;
          v760 = 0x3D2604uLL;
          v14 = sub_A9620(a1 + 2, a2, &v760, a3);
          goto LABEL_597;
        case 'S':
          v13 = a1 + 2;
          v761 = 0LL;
          v760 = 0x3D02uLL;
          v14 = sub_A9620(a1 + 2, a2, &v760, a3);
          goto LABEL_597;
        case 'a':
          v13 = a1 + 2;
          v761 = 0LL;
          v760 = 0x262604uLL;
          v14 = sub_A9620(a1 + 2, a2, &v760, a3);
          goto LABEL_597;
        case 'd':
          v13 = a1 + 2;
          v761 = 0LL;
          v760 = 0x2602uLL;
          v14 = sub_A9B9C(a1 + 2, a2, &v760, a3);
          goto LABEL_597;
        case 'n':
          v13 = a1 + 2;
          v761 = 0LL;
          v760 = 0x2602uLL;
          v14 = sub_A9620(a1 + 2, a2, &v760, a3);
          goto LABEL_597;
        case 't':
          if ( v5 < 3 )
            return (__int64)v4;
          if ( *a1 != 97 )
            return (__int64)v4;
          if ( a1[1] != 116 )
            return (__int64)v4;
          v319 = a1 + 2;
          v22 = sub_925FC(a1 + 2, a2, a3);
          if ( (unsigned __int8 *)v22 == v319 )
            return (__int64)v4;
          v320 = *(_QWORD *)(a3 + 8);
          if ( *(_QWORD *)a3 == v320 )
            return (__int64)v4;
          v321 = *(unsigned __int8 *)(v320 - 24);
          v322 = (size_t *)(v320 - 48);
          v323 = (v321 & 1) == 0;
          v324 = v321 >> 1;
          if ( v323 )
            v325 = (void *)(v320 - 23);
          else
            v325 = *(void **)(v320 - 8);
          if ( v323 )
            v326 = v324;
          else
            v326 = *(_QWORD *)(v320 - 16);
          break;
        case 'z':
          if ( v5 < 3 )
            return (__int64)v4;
          if ( *a1 != 97 )
            return (__int64)v4;
          if ( a1[1] != 122 )
            return (__int64)v4;
          v327 = a1 + 2;
          v22 = sub_A20BC(a1 + 2, a2, a3);
          if ( (unsigned __int8 *)v22 == v327 )
            return (__int64)v4;
          v320 = *(_QWORD *)(a3 + 8);
          if ( *(_QWORD *)a3 == v320 )
            return (__int64)v4;
          v328 = *(unsigned __int8 *)(v320 - 24);
          v322 = (size_t *)(v320 - 48);
          v329 = (v328 & 1) == 0;
          v330 = v328 >> 1;
          if ( v329 )
            v325 = (void *)(v320 - 23);
          else
            v325 = *(void **)(v320 - 8);
          if ( v329 )
            v326 = v330;
          else
            v326 = *(_QWORD *)(v320 - 16);
          break;
        default:
          return (__int64)v4;
      }
      sub_9CFD0(v322, v325, v326);
      v766 = *(char **)(v320 - 32);
      v765 = *(_OWORD *)(v320 - 48);
      *(_QWORD *)(v320 - 40) = 0LL;
      *(_QWORD *)(v320 - 32) = 0LL;
      *(_QWORD *)(v320 - 48) = 0LL;
      sub_9CDD8((size_t *)&v765, 0LL, "alignof (", 9uLL);
      v331 = v766;
      v332 = v765;
      v766 = 0LL;
      v765 = 0uLL;
      v761 = v331;
      v760 = v332;
      sub_9CFD0((size_t *)&v760, ")", 1uLL);
      v333 = *(_QWORD *)((char *)&v760 + 1);
      v739 = v760;
      v334 = *((_QWORD *)&v760 + 1);
      v335 = v761;
      v760 = 0uLL;
      v761 = 0LL;
      *(_QWORD *)((char *)&v758 + 7) = v334;
      *(_QWORD *)&v758 = v333;
      v336 = *(_QWORD *)(a3 + 8);
      v337 = (__int64 *)(v336 - 48);
      if ( (*(_BYTE *)(v336 - 48) & 1) == 0 )
      {
        *(_WORD *)(v336 - 48) = 0;
        v338 = (const void **)(v336 - 32);
        goto LABEL_939;
      }
      v338 = (const void **)(v336 - 32);
      **(_BYTE **)(v336 - 32) = 0;
      LOBYTE(v538) = *(_BYTE *)(v336 - 48);
      *(_QWORD *)(v336 - 40) = 0LL;
      if ( (v538 & 1) != 0 )
      {
        v538 = *v337;
        v539 = (*v337 & 0xFFFFFFFFFFFFFFFELL) - 1;
        if ( (*v337 & 1) != 0 )
        {
          v736 = 0LL;
          v729 = 0;
          goto LABEL_773;
        }
      }
      else
      {
        v539 = 22LL;
      }
      v736 = (unsigned __int64)((unsigned __int8)v538 & 0xFE) >> 1;
      if ( (unsigned __int8)v538 < 0x2Eu )
      {
        v729 = 1;
LABEL_773:
        v544 = 22LL;
        if ( v539 == 22 )
          goto LABEL_939;
        goto LABEL_806;
      }
      v544 = ((unsigned __int8)(v736 + 16) & 0xF0) - 1LL;
      v729 = 1;
      if ( v544 == v539 )
        goto LABEL_939;
LABEL_806:
      if ( v544 == 22 )
      {
        v549 = *v338;
        v550 = (_BYTE *)(v336 - 47);
        if ( v729 )
          memcpy(v550, *v338, ((unsigned __int64)((unsigned __int8)v538 & 0xFE) >> 1) + 1);
        else
          *v550 = *v549;
        free(v549);
        *(_BYTE *)v337 = 2 * v736;
      }
      else
      {
        v551 = malloc(v544 + 1);
        v528 = v544 > v539;
        v552 = v551;
        if ( v528 || v551 )
        {
          if ( (v729 & 1) != 0 )
          {
            memcpy(v551, (const void *)(v336 - 47), ((unsigned __int64)((unsigned __int8)v538 & 0xFE) >> 1) + 1);
          }
          else
          {
            v621 = (void *)*v338;
            *v552 = *(_BYTE *)*v338;
            free(v621);
          }
          *(_QWORD *)(v336 - 48) = (v544 + 1) | 1;
          *(_QWORD *)(v336 - 40) = v736;
          *(_QWORD *)(v336 - 32) = v552;
        }
      }
LABEL_939:
      *(_BYTE *)(v336 - 48) = v739;
      *(_QWORD *)(v336 - 47) = v758;
      *(_QWORD *)(v336 - 40) = *(_QWORD *)((char *)&v758 + 7);
      *v338 = v335;
      *(_QWORD *)&v758 = 0LL;
      *(_QWORD *)((char *)&v758 + 7) = 0LL;
      if ( (v760 & 1) != 0 )
        free(v761);
      goto LABEL_941;
    case 'c':
      switch ( v10[1] )
      {
        case 'c':
          if ( v5 < 3 )
            return (__int64)v4;
          if ( *a1 != 99 )
            return (__int64)v4;
          if ( a1[1] != 99 )
            return (__int64)v4;
          v55 = a1 + 2;
          v56 = sub_925FC(a1 + 2, a2, a3);
          v57 = v56;
          if ( (unsigned __int8 *)v56 == v55 )
            return (__int64)v4;
          v22 = sub_A20BC(v56, a2, a3);
          if ( v22 == v57 )
            return (__int64)v4;
          v58 = *(_QWORD *)(a3 + 8);
          if ( 0xAAAAAAAAAAAAAAABLL * ((v58 - *(_QWORD *)a3) >> 4) < 2 )
            return (__int64)v4;
          v59 = *(unsigned __int8 *)(v58 - 24);
          v60 = (v59 & 1) == 0;
          v61 = v59 >> 1;
          if ( v60 )
            v62 = (void *)(v58 - 23);
          else
            v62 = *(void **)(v58 - 8);
          if ( v60 )
            v63 = v61;
          else
            v63 = *(_QWORD *)(v58 - 16);
          sub_9CFD0((size_t *)(v58 - 48), v62, v63);
          v766 = *(char **)(v58 - 32);
          v765 = *(_OWORD *)(v58 - 48);
          *(_QWORD *)(v58 - 40) = 0LL;
          *(_QWORD *)(v58 - 32) = 0LL;
          *(_QWORD *)(v58 - 48) = 0LL;
          v64 = *(_QWORD *)(a3 + 8);
          v65 = (_BYTE *)(v64 - 48);
          if ( (*(_BYTE *)(v64 - 24) & 1) != 0 )
            free(*(void **)(v64 - 8));
          if ( (*v65 & 1) != 0 )
            free(*(void **)(v64 - 32));
          v66 = *(void ***)a3;
          *(_QWORD *)(a3 + 8) = v65;
          if ( v66 != (void **)v65 )
          {
            v67 = *(unsigned __int8 *)(v64 - 72);
            v68 = (v67 & 1) == 0;
            v69 = v67 >> 1;
            if ( v68 )
              v70 = (void *)(v64 - 71);
            else
              v70 = *(void **)(v64 - 56);
            if ( v68 )
              v71 = v69;
            else
              v71 = *(_QWORD *)(v64 - 64);
            v72 = sub_9CFD0((size_t *)(v64 - 96), v70, v71);
            p = (void *)v72[2];
            v752 = *(_OWORD *)v72;
            v72[1] = 0LL;
            v72[2] = 0LL;
            *v72 = 0LL;
            sub_9CDD8((size_t *)&v752, 0LL, "const_cast<", 0xBuLL);
            v73 = p;
            v74 = v752;
            p = 0LL;
            v752 = 0uLL;
            v755 = v73;
            v754 = v74;
            sub_9CFD0((size_t *)&v754, ">(", 2uLL);
            v75 = (char *)v755;
            v76 = v754;
            v755 = 0LL;
            v754 = 0uLL;
            v77 = v765;
            v757 = v75;
            if ( (v765 & 1) != 0 )
              v78 = v766;
            else
              v78 = (char *)&v765 + 1;
            v756 = v76;
            if ( (v765 & 1) != 0 )
              v79 = *((_QWORD *)&v765 + 1);
            else
              v79 = (unsigned __int64)(unsigned __int8)v765 >> 1;
            sub_9CFD0((size_t *)&v756, v78, v79);
            v80 = v757;
            v81 = v756;
            v757 = 0LL;
            v756 = 0uLL;
            v759 = v80;
            v758 = v81;
            sub_9CFD0((size_t *)&v758, ")", 1uLL);
            v82 = *(_QWORD *)((char *)&v758 + 1);
            v83 = *((_QWORD *)&v758 + 1);
            v84 = v759;
            v85 = v758;
            v759 = 0LL;
            v758 = 0uLL;
            *(_QWORD *)((char *)&v748 + 7) = v83;
            BYTE7(v748) = HIBYTE(v82);
            LOBYTE(v760) = v85;
            v86 = v82;
            v87 = *(_QWORD *)((char *)&v748 + 7);
            *(_QWORD *)&v748 = 0LL;
            *(_QWORD *)((char *)&v748 + 7) = 0LL;
            *(_QWORD *)((char *)&v760 + 1) = v86;
            *((_QWORD *)&v760 + 1) = v87;
            v761 = v84;
            v763 = 0LL;
            v764 = 0LL;
            v762 = 0LL;
            sub_A7174(*(_QWORD *)(a3 + 8) - 48LL, &v760);
            if ( (v762 & 1) != 0 )
            {
              free(v764);
              if ( (v760 & 1) == 0 )
              {
LABEL_98:
                if ( (v758 & 1) == 0 )
                  goto LABEL_99;
                goto LABEL_815;
              }
            }
            else if ( (v760 & 1) == 0 )
            {
              goto LABEL_98;
            }
            free(v761);
            if ( (v758 & 1) == 0 )
            {
LABEL_99:
              if ( (v756 & 1) == 0 )
                goto LABEL_100;
              goto LABEL_816;
            }
LABEL_815:
            free(v759);
            if ( (v756 & 1) == 0 )
            {
LABEL_100:
              if ( (v754 & 1) == 0 )
                goto LABEL_101;
              goto LABEL_817;
            }
LABEL_816:
            free(v757);
            if ( (v754 & 1) == 0 )
            {
LABEL_101:
              if ( (v752 & 1) == 0 )
                goto LABEL_103;
              goto LABEL_102;
            }
LABEL_817:
            free(v755);
            if ( (v752 & 1) == 0 )
            {
LABEL_103:
              v88 = 0;
              if ( (v77 & 1) == 0 )
                goto LABEL_105;
              goto LABEL_104;
            }
LABEL_102:
            free(p);
            goto LABEL_103;
          }
          v88 = 1;
          v22 = (__int64)v4;
          if ( (v765 & 1) != 0 )
LABEL_104:
            free(v766);
LABEL_105:
          if ( !v88 )
            return v22;
          return (__int64)v4;
        case 'l':
          if ( v5 < 4 )
            return (__int64)v4;
          if ( *a1 != 99 )
            return (__int64)v4;
          if ( a1[1] != 108 )
            return (__int64)v4;
          v185 = a1 + 2;
          v186 = sub_A20BC(a1 + 2, a2, a3);
          v187 = (_BYTE *)v186;
          if ( (unsigned __int8 *)v186 == v185 )
            return (__int64)v4;
          if ( (unsigned __int8 *)v186 == a2 )
            return (__int64)v4;
          v188 = *(_QWORD *)(a3 + 8);
          if ( *(_QWORD *)a3 == v188 )
            return (__int64)v4;
          v189 = *(unsigned __int8 *)(v188 - 24);
          v190 = *(_QWORD *)(v188 - 16);
          v191 = *(void **)(v188 - 8);
          v192 = (size_t *)(v188 - 48);
          v193 = (void *)(v188 - 23);
          v194 = (v189 & 1) == 0;
          v195 = v189 >> 1;
          if ( v194 )
            v196 = v193;
          else
            v196 = v191;
          if ( v194 )
            v197 = v195;
          else
            v197 = v190;
          sub_9CFD0(v192, v196, v197);
          *(_QWORD *)((char *)&v760 + 7) = 0LL;
          *(_QWORD *)&v760 = 0LL;
          v198 = *(_QWORD *)(a3 + 8);
          v199 = (__int64 *)(v198 - 24);
          if ( (*(_BYTE *)(v198 - 24) & 1) == 0 )
          {
            *(_WORD *)(v198 - 24) = 0;
            v200 = (_QWORD *)(v198 - 8);
            goto LABEL_979;
          }
          **(_BYTE **)(v198 - 8) = 0;
          LOBYTE(v542) = *(_BYTE *)(v198 - 24);
          v743 = (const void **)(v198 - 8);
          *(_QWORD *)(v198 - 16) = 0LL;
          if ( (v542 & 1) != 0 )
          {
            v542 = *v199;
            v737 = (*v199 & 0xFFFFFFFFFFFFFFFELL) - 1;
            if ( (*v199 & 1) != 0 )
            {
              v731 = 0LL;
              v724 = 0;
              v543 = 22LL;
              goto LABEL_868;
            }
          }
          else
          {
            v737 = 22LL;
          }
          v731 = (unsigned __int64)((unsigned __int8)v542 & 0xFE) >> 1;
          if ( (unsigned __int8)v542 >= 0x2Eu )
          {
            v543 = ((unsigned __int8)(v731 + 16) & 0xF0) - 1LL;
            v724 = 1;
          }
          else
          {
            v724 = 1;
            v543 = 22LL;
          }
LABEL_868:
          if ( v543 != v737 )
          {
            if ( v543 == 22 )
            {
              v586 = (_BYTE *)(v198 - 23);
              v587 = *v743;
              if ( v724 )
                memcpy(v586, *v743, ((unsigned __int64)((unsigned __int8)v542 & 0xFE) >> 1) + 1);
              else
                *v586 = *v587;
              free(v587);
              *(_BYTE *)v199 = 2 * v731;
            }
            else
            {
              v720 = v543 + 1;
              v588 = malloc(v543 + 1);
              v528 = v543 > v737;
              v589 = v588;
              if ( v528 || v588 )
              {
                if ( (v724 & 1) != 0 )
                {
                  memcpy(v588, (const void *)(v198 - 23), ((unsigned __int64)((unsigned __int8)v542 & 0xFE) >> 1) + 1);
                }
                else
                {
                  v646 = (void *)*v743;
                  *v589 = *(_BYTE *)*v743;
                  free(v646);
                }
                *(_QWORD *)(v198 - 24) = v720 | 1;
                *(_QWORD *)(v198 - 16) = v731;
                *(_QWORD *)(v198 - 8) = v589;
              }
            }
          }
          v200 = (_QWORD *)(v198 - 8);
LABEL_979:
          *(_BYTE *)(v198 - 24) = 0;
          *(_QWORD *)(v198 - 16) = *(_QWORD *)((char *)&v760 + 7);
          *(_QWORD *)(v198 - 23) = v760;
          *v200 = 0LL;
          sub_9CFD0((size_t *)(*(_QWORD *)(a3 + 8) - 48LL), "(", 1uLL);
          while ( 2 )
          {
            if ( *v187 == 69 )
            {
              v660 = *(_QWORD *)(a3 + 8);
              if ( *(_QWORD *)a3 != v660 )
              {
                v4 = v187 + 1;
                sub_9CFD0((size_t *)(v660 - 48), ")", 1uLL);
              }
              return (__int64)v4;
            }
            v647 = sub_A20BC(v187, a2, a3);
            v648 = (_BYTE *)v647;
            if ( (_BYTE *)v647 == v187 )
              return (__int64)v4;
            if ( (unsigned __int8 *)v647 == a2 )
              return (__int64)v4;
            v649 = *(_QWORD *)(a3 + 8);
            if ( *(_QWORD *)a3 == v649 )
              return (__int64)v4;
            v650 = *(unsigned __int8 *)(v649 - 24);
            v651 = (v650 & 1) == 0;
            v652 = v650 >> 1;
            if ( v651 )
              v653 = (void *)(v649 - 23);
            else
              v653 = *(void **)(v649 - 8);
            if ( v651 )
              v654 = v652;
            else
              v654 = *(_QWORD *)(v649 - 16);
            sub_9CFD0((size_t *)(v649 - 48), v653, v654);
            v761 = *(char **)(v649 - 32);
            v760 = *(_OWORD *)(v649 - 48);
            *(_QWORD *)(v649 - 40) = 0LL;
            *(_QWORD *)(v649 - 32) = 0LL;
            *(_QWORD *)(v649 - 48) = 0LL;
            v655 = *(_QWORD *)(a3 + 8);
            v656 = (_BYTE *)(v655 - 48);
            if ( (*(_BYTE *)(v655 - 24) & 1) != 0 )
              free(*(void **)(v655 - 8));
            if ( (*v656 & 1) != 0 )
              free(*(void **)(v655 - 32));
            *(_QWORD *)(a3 + 8) = v656;
            if ( (v760 & 1) != 0 )
              v657 = *((_QWORD *)&v760 + 1);
            else
              v657 = (unsigned __int64)(unsigned __int8)v760 >> 1;
            if ( !v657 )
              goto LABEL_1002;
            if ( *(_BYTE **)a3 == v656 )
            {
              v659 = 1;
              if ( (v760 & 1) != 0 )
LABEL_1003:
                free(v761);
            }
            else
            {
              if ( (v760 & 1) != 0 )
                v658 = v761;
              else
                v658 = (char *)&v760 + 1;
              sub_9CFD0((size_t *)(v655 - 96), v658, v657);
LABEL_1002:
              v659 = 0;
              v187 = v648;
              if ( (v760 & 1) != 0 )
                goto LABEL_1003;
            }
            if ( v659 )
              return (__int64)v4;
            continue;
          }
        case 'm':
          v13 = a1 + 2;
          v761 = 0LL;
          v760 = 0x2C02uLL;
          v14 = sub_A9620(a1 + 2, a2, &v760, a3);
          goto LABEL_597;
        case 'o':
          v13 = a1 + 2;
          v761 = 0LL;
          v760 = 0x7E02uLL;
          v14 = sub_A9B9C(a1 + 2, a2, &v760, a3);
          goto LABEL_597;
        case 'v':
          if ( v5 < 3 )
            return (__int64)v4;
          if ( *a1 != 99 )
            return (__int64)v4;
          if ( a1[1] != 118 )
            return (__int64)v4;
          v201 = *(_BYTE *)(a3 + 111);
          v202 = a1 + 2;
          *(_BYTE *)(a3 + 111) = 0;
          v203 = (unsigned __int8 *)sub_925FC(a1 + 2, a2, a3);
          v204 = v203;
          *(_BYTE *)(a3 + 111) = v201;
          if ( v203 == v202 || v203 == a2 )
            return (__int64)v4;
          if ( *v203 == 95 )
          {
            v205 = v203 + 1;
            if ( v203 + 1 == a2 )
              return (__int64)v4;
            if ( *v205 == 69 )
            {
              v207 = *(_OWORD **)(a3 + 8);
              v206 = *(_QWORD *)(a3 + 16);
              if ( (unsigned __int64)v207 >= v206 )
              {
                v590 = 0xAAAAAAAAAAAAAAABLL * (((__int64)v207 - *(_QWORD *)a3) >> 4);
                if ( v590 + 1 > 0x555555555555555LL )
                  abort();
                v591 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v206 - *(_QWORD *)a3) >> 4);
                if ( v591 >= 0x2AAAAAAAAAAAAAALL
                  || ((v592 = 2 * v591, v592 >= v590 + 1) ? (v11 = v592) : (v11 = v590 + 1), v11) )
                {
                  v593 = *(_QWORD *)(a3 + 24);
                  v594 = *(char **)(v593 + 4096);
                  if ( v593 + 4096 - (__int64)v594 >= (unsigned __int64)(48 * v11) )
                    *(_QWORD *)(v593 + 4096) = &v594[48 * v11];
                  else
                    v594 = (char *)malloc(48 * v11);
                }
                else
                {
                  v594 = 0LL;
                }
                v661 = &v594[48 * v590];
                *((_OWORD *)v661 + 1) = 0u;
                *((_OWORD *)v661 + 2) = 0u;
                *(_OWORD *)v661 = 0u;
                v663 = *(void ***)a3;
                v662 = *(void ***)(a3 + 8);
                v664 = &v594[48 * v11];
                v665 = v661 + 48;
                if ( v662 == *(void ***)a3 )
                {
                  v667 = *(void ***)a3;
                }
                else
                {
                  do
                  {
                    *((_QWORD *)v661 - 4) = *(v662 - 4);
                    *((_OWORD *)v661 - 3) = *((_OWORD *)v662 - 3);
                    v666 = (__int64)*(v662 - 1);
                    *(v662 - 5) = 0LL;
                    *(v662 - 4) = 0LL;
                    *(v662 - 6) = 0LL;
                    *((_QWORD *)v661 - 1) = v666;
                    *(_OWORD *)(v661 - 24) = *(_OWORD *)(v662 - 3);
                    *(v662 - 2) = 0LL;
                    *(v662 - 1) = 0LL;
                    *(v662 - 3) = 0LL;
                    v662 -= 6;
                    v661 -= 48;
                  }
                  while ( v663 != v662 );
                  v667 = *(void ***)a3;
                  v663 = *(void ***)(a3 + 8);
                }
                v668 = *(_QWORD *)(a3 + 16);
                *(_QWORD *)a3 = v661;
                *(_QWORD *)(a3 + 8) = v665;
                *(_QWORD *)(a3 + 16) = v664;
                if ( v663 != v667 )
                {
                  do
                  {
                    if ( (*(_BYTE *)(v663 - 3) & 1) != 0 )
                      free(*(v663 - 1));
                    v669 = v663 - 6;
                    if ( (*(_BYTE *)(v663 - 6) & 1) != 0 )
                      free(*(v663 - 4));
                    v663 -= 6;
                  }
                  while ( v667 != v669 );
                }
                if ( v667 )
                {
                  v670 = *(_QWORD *)(a3 + 24);
                  if ( v670 + 4096 < (unsigned __int64)v667 || v670 > (unsigned __int64)v667 )
                  {
                    free(v667);
                  }
                  else if ( *(_QWORD *)(v670 + 4096) == v668 )
                  {
                    *(_QWORD *)(v670 + 4096) = v667;
                  }
                }
              }
              else
              {
                v207[1] = 0u;
                v207[2] = 0u;
                *v207 = 0u;
                *(_QWORD *)(a3 + 8) += 48LL;
              }
            }
            else
            {
              v547 = v203 + 1;
              do
              {
                v548 = (unsigned __int8 *)sub_A20BC(v547, a2, a3);
                v205 = v548;
                if ( v548 == v547 || v548 == a2 )
                  return (__int64)v4;
                v547 = v548;
              }
              while ( *v548 != 69 );
            }
            v22 = (__int64)(v205 + 1);
          }
          else
          {
            v22 = sub_A20BC(v203, a2, a3);
            if ( (unsigned __int8 *)v22 == v204 )
              return (__int64)v4;
          }
          v671 = *(_QWORD *)(a3 + 8);
          if ( 0xAAAAAAAAAAAAAAABLL * ((v671 - *(_QWORD *)a3) >> 4) < 2 )
            return (__int64)v4;
          v672 = *(unsigned __int8 *)(v671 - 24);
          v673 = (v672 & 1) == 0;
          v674 = v672 >> 1;
          if ( v673 )
            v675 = (void *)(v671 - 23);
          else
            v675 = *(void **)(v671 - 8);
          if ( v673 )
            v676 = v674;
          else
            v676 = *(_QWORD *)(v671 - 16);
          sub_9CFD0((size_t *)(v671 - 48), v675, v676);
          v766 = *(char **)(v671 - 32);
          v765 = *(_OWORD *)(v671 - 48);
          *(_QWORD *)(v671 - 40) = 0LL;
          *(_QWORD *)(v671 - 32) = 0LL;
          *(_QWORD *)(v671 - 48) = 0LL;
          v677 = *(_QWORD *)(a3 + 8);
          v678 = (_BYTE *)(v677 - 48);
          if ( (*(_BYTE *)(v677 - 24) & 1) != 0 )
            free(*(void **)(v677 - 8));
          if ( (*v678 & 1) != 0 )
            free(*(void **)(v677 - 32));
          *(_QWORD *)(a3 + 8) = v678;
          v679 = *(unsigned __int8 *)(v677 - 72);
          v680 = (v679 & 1) == 0;
          v681 = v679 >> 1;
          if ( v680 )
            v682 = (void *)(v677 - 71);
          else
            v682 = *(void **)(v677 - 56);
          if ( v680 )
            v683 = v681;
          else
            v683 = *(_QWORD *)(v677 - 64);
          v684 = sub_9CFD0((size_t *)(v677 - 96), v682, v683);
          p = (void *)v684[2];
          v752 = *(_OWORD *)v684;
          v684[1] = 0LL;
          v684[2] = 0LL;
          *v684 = 0LL;
          sub_9CDD8((size_t *)&v752, 0LL, "(", 1uLL);
          v685 = p;
          v686 = v752;
          p = 0LL;
          v752 = 0uLL;
          v755 = v685;
          v754 = v686;
          sub_9CFD0((size_t *)&v754, ")(", 2uLL);
          v37 = v765;
          v687 = (char *)v755;
          v688 = v754;
          v755 = 0LL;
          v754 = 0uLL;
          v40 = v766;
          v757 = v687;
          if ( (v765 & 1) != 0 )
            v280 = v766;
          else
            v280 = (char *)&v765 + 1;
          v756 = v688;
          if ( (v765 & 1) != 0 )
            v281 = *((_QWORD *)&v765 + 1);
          else
            v281 = (unsigned __int64)(unsigned __int8)v765 >> 1;
          goto LABEL_1053;
        default:
          return (__int64)v4;
      }
    case 'd':
      switch ( v10[1] )
      {
        case 'V':
          v13 = a1 + 2;
          v761 = 0LL;
          v760 = 0x3D2F04uLL;
          v14 = sub_A9620(a1 + 2, a2, &v760, a3);
          goto LABEL_597;
        case 'a':
          v352 = v10 + 2;
          v22 = sub_A20BC(v10 + 2, a2, a3);
          if ( (unsigned __int8 *)v22 == v352 || *(_QWORD *)a3 == *(_QWORD *)(a3 + 8) )
            return (__int64)v4;
          v766 = 0LL;
          v765 = 0uLL;
          if ( v9 )
          {
            LOBYTE(v765) = 4;
            *(_WORD *)((char *)&v765 + 1) = 14906;
            BYTE3(v765) = 0;
          }
          sub_9CFD0((size_t *)&v765, "delete[] ", 9uLL);
          v353 = v766;
          v354 = v765;
          v766 = 0LL;
          v765 = 0uLL;
          v761 = v353;
          v760 = v354;
          v355 = *(_QWORD *)(a3 + 8);
          v356 = *(unsigned __int8 *)(v355 - 24);
          v357 = *(_QWORD *)(v355 - 16);
          v358 = *(void **)(v355 - 8);
          v359 = (size_t *)(v355 - 48);
          v360 = (void *)(v355 - 23);
          v361 = (v356 & 1) == 0;
          v362 = v356 >> 1;
          if ( v361 )
            v363 = v360;
          else
            v363 = v358;
          if ( v361 )
            v364 = v362;
          else
            v364 = v357;
          v365 = sub_9CFD0(v359, v363, v364);
          v759 = (char *)v365[2];
          v758 = *(_OWORD *)v365;
          v365[1] = 0LL;
          v365[2] = 0LL;
          *v365 = 0LL;
          v366 = v758;
          v367 = v759;
          if ( (v758 & 1) != 0 )
            v368 = v759;
          else
            v368 = (char *)&v758 + 1;
          if ( (v758 & 1) != 0 )
            v369 = *((_QWORD *)&v758 + 1);
          else
            v369 = (unsigned __int64)(unsigned __int8)v758 >> 1;
          goto LABEL_490;
        case 'c':
          if ( v5 < 3 )
            return (__int64)v4;
          if ( *a1 != 100 )
            return (__int64)v4;
          if ( a1[1] != 99 )
            return (__int64)v4;
          v422 = a1 + 2;
          v423 = sub_925FC(a1 + 2, a2, a3);
          v424 = v423;
          if ( (unsigned __int8 *)v423 == v422 )
            return (__int64)v4;
          v22 = sub_A20BC(v423, a2, a3);
          if ( v22 == v424 )
            return (__int64)v4;
          v425 = *(_QWORD *)(a3 + 8);
          if ( 0xAAAAAAAAAAAAAAABLL * ((v425 - *(_QWORD *)a3) >> 4) < 2 )
            return (__int64)v4;
          v426 = *(unsigned __int8 *)(v425 - 24);
          v427 = (v426 & 1) == 0;
          v428 = v426 >> 1;
          if ( v427 )
            v429 = (void *)(v425 - 23);
          else
            v429 = *(void **)(v425 - 8);
          if ( v427 )
            v430 = v428;
          else
            v430 = *(_QWORD *)(v425 - 16);
          sub_9CFD0((size_t *)(v425 - 48), v429, v430);
          v766 = *(char **)(v425 - 32);
          v765 = *(_OWORD *)(v425 - 48);
          *(_QWORD *)(v425 - 40) = 0LL;
          *(_QWORD *)(v425 - 32) = 0LL;
          *(_QWORD *)(v425 - 48) = 0LL;
          v431 = *(_QWORD *)(a3 + 8);
          v432 = (_BYTE *)(v431 - 48);
          if ( (*(_BYTE *)(v431 - 24) & 1) != 0 )
            free(*(void **)(v431 - 8));
          if ( (*v432 & 1) != 0 )
            free(*(void **)(v431 - 32));
          v433 = *(void ***)a3;
          *(_QWORD *)(a3 + 8) = v432;
          if ( v433 != (void **)v432 )
          {
            v434 = *(unsigned __int8 *)(v431 - 72);
            v435 = (v434 & 1) == 0;
            v436 = v434 >> 1;
            if ( v435 )
              v437 = (void *)(v431 - 71);
            else
              v437 = *(void **)(v431 - 56);
            if ( v435 )
              v438 = v436;
            else
              v438 = *(_QWORD *)(v431 - 64);
            v439 = sub_9CFD0((size_t *)(v431 - 96), v437, v438);
            p = (void *)v439[2];
            v752 = *(_OWORD *)v439;
            v439[1] = 0LL;
            v439[2] = 0LL;
            *v439 = 0LL;
            sub_9CDD8((size_t *)&v752, 0LL, "dynamic_cast<", 0xDuLL);
            v440 = p;
            v441 = v752;
            p = 0LL;
            v752 = 0uLL;
            v755 = v440;
            v754 = v441;
            sub_9CFD0((size_t *)&v754, ">(", 2uLL);
            v442 = (char *)v755;
            v443 = v754;
            v755 = 0LL;
            v754 = 0uLL;
            v444 = v765;
            v757 = v442;
            if ( (v765 & 1) != 0 )
              v445 = v766;
            else
              v445 = (char *)&v765 + 1;
            v756 = v443;
            if ( (v765 & 1) != 0 )
              v446 = *((_QWORD *)&v765 + 1);
            else
              v446 = (unsigned __int64)(unsigned __int8)v765 >> 1;
            sub_9CFD0((size_t *)&v756, v445, v446);
            v447 = v757;
            v448 = v756;
            v757 = 0LL;
            v756 = 0uLL;
            v759 = v447;
            v758 = v448;
            sub_9CFD0((size_t *)&v758, ")", 1uLL);
            v449 = *(_QWORD *)((char *)&v758 + 1);
            v450 = *((_QWORD *)&v758 + 1);
            v451 = v759;
            v452 = v758;
            v759 = 0LL;
            v758 = 0uLL;
            *(_QWORD *)((char *)&v748 + 7) = v450;
            BYTE7(v748) = HIBYTE(v449);
            LOBYTE(v760) = v452;
            v453 = v449;
            v454 = *(_QWORD *)((char *)&v748 + 7);
            *(_QWORD *)&v748 = 0LL;
            *(_QWORD *)((char *)&v748 + 7) = 0LL;
            *(_QWORD *)((char *)&v760 + 1) = v453;
            *((_QWORD *)&v760 + 1) = v454;
            v761 = v451;
            v763 = 0LL;
            v764 = 0LL;
            v762 = 0LL;
            sub_A7174(*(_QWORD *)(a3 + 8) - 48LL, &v760);
            if ( (v762 & 1) != 0 )
            {
              free(v764);
              if ( (v760 & 1) == 0 )
              {
LABEL_586:
                if ( (v758 & 1) == 0 )
                  goto LABEL_587;
                goto LABEL_892;
              }
            }
            else if ( (v760 & 1) == 0 )
            {
              goto LABEL_586;
            }
            free(v761);
            if ( (v758 & 1) == 0 )
            {
LABEL_587:
              if ( (v756 & 1) == 0 )
                goto LABEL_588;
              goto LABEL_893;
            }
LABEL_892:
            free(v759);
            if ( (v756 & 1) == 0 )
            {
LABEL_588:
              if ( (v754 & 1) == 0 )
                goto LABEL_589;
              goto LABEL_894;
            }
LABEL_893:
            free(v757);
            if ( (v754 & 1) == 0 )
            {
LABEL_589:
              if ( (v752 & 1) == 0 )
                goto LABEL_591;
              goto LABEL_590;
            }
LABEL_894:
            free(v755);
            if ( (v752 & 1) == 0 )
            {
LABEL_591:
              v455 = 0;
              if ( (v444 & 1) == 0 )
                goto LABEL_593;
              goto LABEL_592;
            }
LABEL_590:
            free(p);
            goto LABEL_591;
          }
          v455 = 1;
          v22 = (__int64)v4;
          if ( (v765 & 1) != 0 )
LABEL_592:
            free(v766);
LABEL_593:
          if ( !v455 )
            return v22;
          return (__int64)v4;
        case 'e':
          v13 = a1 + 2;
          v761 = 0LL;
          v760 = 0x2A02uLL;
          v14 = sub_A9B9C(a1 + 2, a2, &v760, a3);
          goto LABEL_597;
        case 'l':
          v370 = v10 + 2;
          v22 = sub_A20BC(v10 + 2, a2, a3);
          if ( (unsigned __int8 *)v22 == v370 || *(_QWORD *)a3 == *(_QWORD *)(a3 + 8) )
            return (__int64)v4;
          v766 = 0LL;
          v765 = 0uLL;
          if ( v9 )
          {
            LOBYTE(v765) = 4;
            *(_WORD *)((char *)&v765 + 1) = 14906;
            BYTE3(v765) = 0;
          }
          sub_9CFD0((size_t *)&v765, "delete ", 7uLL);
          v371 = v766;
          v372 = v765;
          v766 = 0LL;
          v765 = 0uLL;
          v761 = v371;
          v760 = v372;
          v373 = *(_QWORD *)(a3 + 8);
          v374 = *(unsigned __int8 *)(v373 - 24);
          v375 = *(_QWORD *)(v373 - 16);
          v376 = *(void **)(v373 - 8);
          v377 = (size_t *)(v373 - 48);
          v378 = (void *)(v373 - 23);
          v379 = (v374 & 1) == 0;
          v380 = v374 >> 1;
          if ( v379 )
            v381 = v378;
          else
            v381 = v376;
          if ( v379 )
            v382 = v380;
          else
            v382 = v375;
          v383 = sub_9CFD0(v377, v381, v382);
          v759 = (char *)v383[2];
          v758 = *(_OWORD *)v383;
          v383[1] = 0LL;
          v383[2] = 0LL;
          *v383 = 0LL;
          v366 = v758;
          v367 = v759;
          if ( (v758 & 1) != 0 )
            v368 = v759;
          else
            v368 = (char *)&v758 + 1;
          if ( (v758 & 1) != 0 )
            v369 = *((_QWORD *)&v758 + 1);
          else
            v369 = (unsigned __int64)(unsigned __int8)v758 >> 1;
LABEL_490:
          sub_9CFD0((size_t *)&v760, v368, v369);
          v384 = v761;
          v385 = v760;
          v761 = 0LL;
          *(_QWORD *)((char *)&v756 + 7) = *((_QWORD *)&v760 + 1);
          *(_QWORD *)&v756 = *(_QWORD *)((char *)&v760 + 1);
          v760 = 0uLL;
          v386 = *(_QWORD *)(a3 + 8);
          v387 = (void **)(v386 - 48);
          if ( (*(_BYTE *)(v386 - 48) & 1) == 0 )
          {
            *(_WORD *)(v386 - 48) = 0;
            v388 = (const void **)(v386 - 32);
            goto LABEL_778;
          }
          v741 = v367;
          v388 = (const void **)(v386 - 32);
          **(_BYTE **)(v386 - 32) = 0;
          LOBYTE(v367) = *(_BYTE *)(v386 - 48);
          *(_QWORD *)(v386 - 40) = 0LL;
          if ( ((unsigned __int8)v367 & 1) != 0 )
          {
            v367 = *v387;
            v473 = ((unsigned __int64)*v387 & 0xFFFFFFFFFFFFFFFELL) - 1;
            if ( ((unsigned int)*v387 & 1) != 0 )
            {
              v474 = 0LL;
              v475 = 0;
              goto LABEL_696;
            }
          }
          else
          {
            v473 = 22LL;
          }
          v474 = (unsigned __int64)((unsigned __int8)v367 & 0xFE) >> 1;
          if ( (unsigned __int8)v367 >= 0x2Eu )
          {
            v506 = ((unsigned __int8)(v474 + 16) & 0xF0) - 1LL;
            v475 = 1;
            if ( v506 == v473 )
              goto LABEL_697;
            goto LABEL_735;
          }
          v475 = 1;
LABEL_696:
          v506 = 22LL;
          if ( v473 == 22 )
          {
LABEL_697:
            v367 = v741;
            goto LABEL_778;
          }
LABEL_735:
          v721 = v474;
          v727 = v384;
          v734 = v385;
          if ( v506 == 22 )
          {
            v525 = *v388;
            v526 = (_BYTE *)(v386 - 47);
            if ( v475 )
              memcpy(v526, *v388, ((unsigned __int64)((unsigned __int8)v367 & 0xFE) >> 1) + 1);
            else
              *v526 = *v525;
            free(v525);
            *(_BYTE *)v387 = 2 * v721;
          }
          else
          {
            v718 = v475;
            v716 = v506 + 1;
            v527 = malloc(v506 + 1);
            v528 = v506 > v473;
            v529 = v527;
            if ( v528 || v527 )
            {
              if ( (v718 & 1) != 0 )
              {
                memcpy(v527, (const void *)(v386 - 47), ((unsigned __int64)((unsigned __int8)v367 & 0xFE) >> 1) + 1);
              }
              else
              {
                v545 = (void *)*v388;
                *v529 = *(_BYTE *)*v388;
                free(v545);
              }
              *(_QWORD *)(v386 - 48) = v716 | 1;
              *(_QWORD *)(v386 - 40) = v721;
              *(_QWORD *)(v386 - 32) = v529;
            }
          }
          v367 = v741;
          v385 = v734;
          v384 = v727;
LABEL_778:
          *(_BYTE *)(v386 - 48) = v385;
          *(_QWORD *)(v386 - 47) = v756;
          *(_QWORD *)(v386 - 40) = *(_QWORD *)((char *)&v756 + 7);
          *v388 = v384;
          *(_QWORD *)((char *)&v756 + 7) = 0LL;
          *(_QWORD *)&v756 = 0LL;
          if ( (v366 & 1) != 0 )
          {
            free(v367);
            if ( (v760 & 1) == 0 )
            {
LABEL_941:
              if ( (v765 & 1) == 0 )
                return v22;
LABEL_942:
              v305 = v766;
              goto LABEL_943;
            }
          }
          else if ( (v760 & 1) == 0 )
          {
            goto LABEL_941;
          }
          free(v761);
          if ( (v765 & 1) == 0 )
            return v22;
          goto LABEL_942;
        case 'n':
          return sub_A9F34(a1, a2, a3);
        case 's':
          if ( v5 < 3 )
            return (__int64)v4;
          if ( *a1 != 100 )
            return (__int64)v4;
          if ( a1[1] != 115 )
            return (__int64)v4;
          v394 = a1 + 2;
          v395 = sub_A20BC(a1 + 2, a2, a3);
          v396 = v395;
          if ( (unsigned __int8 *)v395 == v394 )
            return (__int64)v4;
          v22 = sub_A20BC(v395, a2, a3);
          if ( v22 == v396 )
            return (__int64)v4;
          v397 = *(_QWORD *)(a3 + 8);
          if ( 0xAAAAAAAAAAAAAAABLL * ((v397 - *(_QWORD *)a3) >> 4) < 2 )
            return (__int64)v4;
          v398 = *(unsigned __int8 *)(v397 - 24);
          v399 = (v398 & 1) == 0;
          v400 = v398 >> 1;
          if ( v399 )
            v401 = (void *)(v397 - 23);
          else
            v401 = *(void **)(v397 - 8);
          if ( v399 )
            v402 = v400;
          else
            v402 = *(_QWORD *)(v397 - 16);
          sub_9CFD0((size_t *)(v397 - 48), v401, v402);
          v761 = *(char **)(v397 - 32);
          v760 = *(_OWORD *)(v397 - 48);
          *(_QWORD *)(v397 - 40) = 0LL;
          *(_QWORD *)(v397 - 32) = 0LL;
          *(_QWORD *)(v397 - 48) = 0LL;
          v403 = *(_QWORD *)(a3 + 8);
          v404 = (_BYTE *)(v403 - 48);
          if ( (*(_BYTE *)(v403 - 24) & 1) != 0 )
            free(*(void **)(v403 - 8));
          if ( (*v404 & 1) != 0 )
            free(*(void **)(v403 - 32));
          *(_QWORD *)(a3 + 8) = v404;
          sub_9F8F0(".*", (unsigned __int8 *)&v760, (size_t *)&v765);
          if ( (v765 & 1) != 0 )
            v405 = v766;
          else
            v405 = (char *)&v765 + 1;
          if ( (v765 & 1) != 0 )
            v406 = *((_QWORD *)&v765 + 1);
          else
            v406 = (unsigned __int64)(unsigned __int8)v765 >> 1;
          sub_9CFD0((size_t *)(*(_QWORD *)(a3 + 8) - 48LL), v405, v406);
          if ( (v765 & 1) != 0 )
            free(v766);
          if ( (v760 & 1) == 0 )
            return v22;
          v305 = v761;
          goto LABEL_943;
        case 't':
          if ( v5 < 3 )
            return (__int64)v4;
          if ( *a1 != 100 )
            return (__int64)v4;
          if ( a1[1] != 116 )
            return (__int64)v4;
          v407 = a1 + 2;
          v408 = sub_A20BC(a1 + 2, a2, a3);
          v409 = v408;
          if ( (unsigned __int8 *)v408 == v407 )
            return (__int64)v4;
          v22 = sub_A9F34(v408, a2, a3);
          if ( v22 == v409 )
            return (__int64)v4;
          v410 = *(_QWORD *)(a3 + 8);
          if ( 0xAAAAAAAAAAAAAAABLL * ((v410 - *(_QWORD *)a3) >> 4) < 2 )
            return (__int64)v4;
          v411 = *(unsigned __int8 *)(v410 - 24);
          v412 = (v411 & 1) == 0;
          v413 = v411 >> 1;
          if ( v412 )
            v414 = (void *)(v410 - 23);
          else
            v414 = *(void **)(v410 - 8);
          if ( v412 )
            v415 = v413;
          else
            v415 = *(_QWORD *)(v410 - 16);
          sub_9CFD0((size_t *)(v410 - 48), v414, v415);
          v761 = *(char **)(v410 - 32);
          v760 = *(_OWORD *)(v410 - 48);
          *(_QWORD *)(v410 - 40) = 0LL;
          *(_QWORD *)(v410 - 32) = 0LL;
          *(_QWORD *)(v410 - 48) = 0LL;
          v416 = *(_QWORD *)(a3 + 8);
          v417 = (_BYTE *)(v416 - 48);
          if ( (*(_BYTE *)(v416 - 24) & 1) != 0 )
            free(*(void **)(v416 - 8));
          if ( (*v417 & 1) != 0 )
            free(*(void **)(v416 - 32));
          v418 = *(void ***)a3;
          *(_QWORD *)(a3 + 8) = v417;
          if ( v418 == (void **)v417 )
          {
            v421 = 1;
            v22 = (__int64)v4;
            if ( (v760 & 1) != 0 )
LABEL_552:
              free(v761);
          }
          else
          {
            sub_9F8F0(".", (unsigned __int8 *)&v760, (size_t *)&v765);
            if ( (v765 & 1) != 0 )
              v419 = v766;
            else
              v419 = (char *)&v765 + 1;
            if ( (v765 & 1) != 0 )
              v420 = *((_QWORD *)&v765 + 1);
            else
              v420 = (unsigned __int64)(unsigned __int8)v765 >> 1;
            sub_9CFD0((size_t *)(*(_QWORD *)(a3 + 8) - 48LL), v419, v420);
            if ( (v765 & 1) != 0 )
              free(v766);
            v421 = 0;
            if ( (v760 & 1) != 0 )
              goto LABEL_552;
          }
          if ( !v421 )
            return v22;
          break;
        case 'v':
          v13 = a1 + 2;
          v761 = 0LL;
          v760 = 0x2F02uLL;
          v14 = sub_A9620(a1 + 2, a2, &v760, a3);
          goto LABEL_597;
        default:
          return (__int64)v4;
      }
      return (__int64)v4;
    case 'e':
      v89 = v10[1];
      switch ( v89 )
      {
        case 'O':
          v13 = a1 + 2;
          v761 = 0LL;
          v760 = 0x3D5E04uLL;
          v14 = sub_A9620(a1 + 2, a2, &v760, a3);
          break;
        case 'q':
          v13 = a1 + 2;
          v761 = 0LL;
          v760 = 0x3D3D04uLL;
          v14 = sub_A9620(a1 + 2, a2, &v760, a3);
          break;
        case 'o':
          v13 = a1 + 2;
          v761 = 0LL;
          v760 = 0x5E02uLL;
          v14 = sub_A9620(a1 + 2, a2, &v760, a3);
          break;
        default:
          return (__int64)v4;
      }
      goto LABEL_597;
    case 'f':
      return sub_A8CFC(a1, a2, a3);
    case 'g':
      v54 = v10[1];
      if ( v54 == 116 )
      {
        v13 = a1 + 2;
        v761 = 0LL;
        v760 = 0x3E02uLL;
        v14 = sub_A9620(a1 + 2, a2, &v760, a3);
      }
      else
      {
        if ( v54 != 101 )
          return (__int64)v4;
        v13 = a1 + 2;
        v761 = 0LL;
        v760 = 0x3D3E04uLL;
        v14 = sub_A9620(a1 + 2, a2, &v760, a3);
      }
LABEL_597:
      if ( (unsigned __int8 *)v14 != v13 )
        return v14;
      return (__int64)v4;
    case 'i':
      if ( v10[1] != 120 )
        return (__int64)v4;
      v19 = a1 + 2;
      v20 = sub_A20BC(a1 + 2, a2, a3);
      v21 = v20;
      if ( (unsigned __int8 *)v20 == v19 )
        return (__int64)v4;
      v22 = sub_A20BC(v20, a2, a3);
      if ( v22 == v21 )
      {
        v339 = *(_QWORD *)(a3 + 8);
        if ( *(_QWORD *)a3 != v339 )
          goto LABEL_444;
        return (__int64)v4;
      }
      v23 = *(_QWORD *)(a3 + 8);
      if ( 0xAAAAAAAAAAAAAAABLL * ((v23 - *(_QWORD *)a3) >> 4) < 2 )
        return (__int64)v4;
      v24 = *(unsigned __int8 *)(v23 - 24);
      v25 = (v24 & 1) == 0;
      v26 = v24 >> 1;
      if ( v25 )
        v27 = (void *)(v23 - 23);
      else
        v27 = *(void **)(v23 - 8);
      if ( v25 )
        v28 = v26;
      else
        v28 = *(_QWORD *)(v23 - 16);
      sub_9CFD0((size_t *)(v23 - 48), v27, v28);
      v766 = *(char **)(v23 - 32);
      v765 = *(_OWORD *)(v23 - 48);
      *(_QWORD *)(v23 - 40) = 0LL;
      *(_QWORD *)(v23 - 32) = 0LL;
      *(_QWORD *)(v23 - 48) = 0LL;
      v29 = *(_QWORD *)(a3 + 8);
      v30 = (_BYTE *)(v29 - 48);
      if ( (*(_BYTE *)(v29 - 24) & 1) != 0 )
        free(*(void **)(v29 - 8));
      if ( (*v30 & 1) != 0 )
        free(*(void **)(v29 - 32));
      *(_QWORD *)(a3 + 8) = v30;
      v31 = *(unsigned __int8 *)(v29 - 72);
      v32 = (v31 & 1) == 0;
      v33 = v31 >> 1;
      if ( v32 )
        v34 = (void *)(v29 - 71);
      else
        v34 = *(void **)(v29 - 56);
      if ( v32 )
        v35 = v33;
      else
        v35 = *(_QWORD *)(v29 - 64);
      v36 = sub_9CFD0((size_t *)(v29 - 96), v34, v35);
      v759 = (char *)v36[2];
      v758 = *(_OWORD *)v36;
      v36[1] = 0LL;
      v36[2] = 0LL;
      *v36 = 0LL;
      sub_9F8F0("(", (unsigned __int8 *)&v758, (size_t *)&v752);
      sub_9CFD0((size_t *)&v752, ")[", 2uLL);
      v37 = v765;
      v38 = p;
      v39 = v752;
      p = 0LL;
      v752 = 0uLL;
      v40 = v766;
      v755 = v38;
      if ( (v765 & 1) != 0 )
        v41 = v766;
      else
        v41 = (char *)&v765 + 1;
      v754 = v39;
      if ( (v765 & 1) != 0 )
        v42 = *((_QWORD *)&v765 + 1);
      else
        v42 = (unsigned __int64)(unsigned __int8)v765 >> 1;
      sub_9CFD0((size_t *)&v754, v41, v42);
      v43 = (char *)v755;
      v44 = v754;
      v755 = 0LL;
      v754 = 0uLL;
      v757 = v43;
      v756 = v44;
      sub_9CFD0((size_t *)&v756, "]", 1uLL);
      v45 = *(_QWORD *)((char *)&v756 + 1);
      v46 = *((_QWORD *)&v756 + 1);
      v47 = v757;
      v48 = v756;
      v757 = 0LL;
      v756 = 0uLL;
      *(_QWORD *)((char *)v751 + 7) = v46;
      HIBYTE(v751[0]) = HIBYTE(v45);
      LOBYTE(v760) = v48;
      v49 = v45;
      v50 = *(_QWORD *)((char *)v751 + 7);
      v751[0] = 0LL;
      *(_QWORD *)((char *)v751 + 7) = 0LL;
      *(_QWORD *)((char *)&v760 + 1) = v49;
      *((_QWORD *)&v760 + 1) = v50;
      v761 = v47;
      v763 = 0LL;
      v764 = 0LL;
      v762 = 0LL;
      sub_A7174(*(_QWORD *)(a3 + 8) - 48LL, &v760);
      if ( (v762 & 1) != 0 )
      {
        free(v764);
        if ( (v760 & 1) == 0 )
        {
LABEL_50:
          if ( (v756 & 1) == 0 )
            goto LABEL_51;
          goto LABEL_640;
        }
      }
      else if ( (v760 & 1) == 0 )
      {
        goto LABEL_50;
      }
      free(v761);
      if ( (v756 & 1) == 0 )
      {
LABEL_51:
        if ( (v754 & 1) == 0 )
          goto LABEL_52;
        goto LABEL_641;
      }
LABEL_640:
      free(v757);
      if ( (v754 & 1) == 0 )
      {
LABEL_52:
        if ( (v752 & 1) == 0 )
          goto LABEL_53;
        goto LABEL_642;
      }
LABEL_641:
      free(v755);
      if ( (v752 & 1) == 0 )
      {
LABEL_53:
        if ( (v758 & 1) == 0 )
        {
LABEL_643:
          if ( (v37 & 1) == 0 )
            return v22;
          goto LABEL_646;
        }
        goto LABEL_645;
      }
LABEL_642:
      free(p);
      if ( (v758 & 1) == 0 )
        goto LABEL_643;
LABEL_645:
      free(v759);
      if ( (v37 & 1) == 0 )
        return v22;
LABEL_646:
      v305 = v40;
      goto LABEL_943;
    case 'l':
      switch ( v10[1] )
      {
        case 'S':
          v13 = a1 + 2;
          v761 = 0LL;
          v760 = 0x3D3C3C06uLL;
          v14 = sub_A9620(a1 + 2, a2, &v760, a3);
          goto LABEL_597;
        case 'e':
          v13 = a1 + 2;
          v761 = 0LL;
          v760 = 0x3D3C04uLL;
          v14 = sub_A9620(a1 + 2, a2, &v760, a3);
          goto LABEL_597;
        case 's':
          v13 = a1 + 2;
          v761 = 0LL;
          v760 = 0x3C3C04uLL;
          v14 = sub_A9620(a1 + 2, a2, &v760, a3);
          goto LABEL_597;
        case 't':
          v13 = a1 + 2;
          v761 = 0LL;
          v760 = 0x3C02uLL;
          v14 = sub_A9620(a1 + 2, a2, &v760, a3);
          goto LABEL_597;
        default:
          return (__int64)v4;
      }
      return (__int64)v4;
    case 'm':
      switch ( v10[1] )
      {
        case 'I':
          v13 = a1 + 2;
          v761 = 0LL;
          v760 = 0x3D2D04uLL;
          v14 = sub_A9620(a1 + 2, a2, &v760, a3);
          goto LABEL_597;
        case 'L':
          v13 = a1 + 2;
          v761 = 0LL;
          v760 = 0x3D2A04uLL;
          v14 = sub_A9620(a1 + 2, a2, &v760, a3);
          goto LABEL_597;
        case 'i':
          v13 = a1 + 2;
          v761 = 0LL;
          v760 = 0x2D02uLL;
          v14 = sub_A9620(a1 + 2, a2, &v760, a3);
          goto LABEL_597;
        case 'l':
          v13 = a1 + 2;
          v761 = 0LL;
          v760 = 0x2A02uLL;
          v14 = sub_A9620(a1 + 2, a2, &v760, a3);
          goto LABEL_597;
        case 'm':
          v242 = a1 + 2;
          if ( a1 + 2 != a2 && *v242 == 95 )
          {
            v13 = a1 + 3;
            v761 = 0LL;
            v760 = 0x2D2D04uLL;
            v14 = sub_A9B9C(a1 + 3, a2, &v760, a3);
            goto LABEL_597;
          }
          v22 = sub_A20BC(a1 + 2, a2, a3);
          if ( (_BYTE *)v22 == v242 )
            return (__int64)v4;
          v341 = *(_QWORD *)(a3 + 8);
          if ( *(_QWORD *)a3 == v341 )
            return (__int64)v4;
          v342 = *(unsigned __int8 *)(v341 - 24);
          v343 = (v342 & 1) == 0;
          v344 = v342 >> 1;
          if ( v343 )
            v345 = (void *)(v341 - 23);
          else
            v345 = *(void **)(v341 - 8);
          if ( v343 )
            v346 = v344;
          else
            v346 = *(_QWORD *)(v341 - 16);
          sub_9CFD0((size_t *)(v341 - 48), v345, v346);
          v759 = *(char **)(v341 - 32);
          v758 = *(_OWORD *)(v341 - 48);
          *(_QWORD *)(v341 - 40) = 0LL;
          *(_QWORD *)(v341 - 32) = 0LL;
          *(_QWORD *)(v341 - 48) = 0LL;
          sub_9CDD8((size_t *)&v758, 0LL, "(", 1uLL);
          v347 = v759;
          v348 = v758;
          v759 = 0LL;
          v758 = 0uLL;
          v766 = v347;
          v765 = v348;
          sub_9CFD0((size_t *)&v765, ")--", 3uLL);
          v349 = *(_QWORD *)((char *)&v765 + 1);
          v350 = *((_QWORD *)&v765 + 1);
          v314 = v766;
          v351 = v765;
          v766 = 0LL;
          v765 = 0uLL;
          *(_QWORD *)&v750[39] = v350;
          v750[39] = HIBYTE(v349);
          LOBYTE(v760) = v351;
          v316 = v349;
          v317 = *(_QWORD *)&v750[39];
          memset(&v750[32], 0, 15);
          break;
        default:
          return (__int64)v4;
      }
      goto LABEL_609;
    case 'n':
      switch ( v10[1] )
      {
        case 'a':
        case 'w':
          if ( v5 < 4 )
            return (__int64)v4;
          v51 = *a1;
          if ( v51 == 103 )
          {
            v52 = a1 + 2;
            if ( a1[1] != 115 )
              v52 = a1;
            v53 = a1[1] == 115;
            if ( *v52 != 110 )
              return (__int64)v4;
          }
          else
          {
            v53 = 0;
            v52 = a1;
            if ( v51 != 110 )
              return (__int64)v4;
          }
          v469 = (unsigned __int8)v52[1];
          if ( v469 != 119 && v469 != 97 )
            return (__int64)v4;
          v470 = v52 + 2;
          v740 = (unsigned __int8)v52[1];
          if ( v52 + 2 == a2 )
            return (__int64)v4;
          v471 = 0;
          while ( *v470 != 95 )
          {
            v472 = sub_A20BC(v470, a2, a3);
            if ( (_BYTE *)v472 != v470 )
            {
              v471 |= v472 != (_QWORD)v470 && v472 != (_QWORD)a2;
              v470 = (_BYTE *)v472;
              if ( (unsigned __int8 *)v472 != a2 )
                continue;
            }
            return (__int64)v4;
          }
          v733 = v53;
          v518 = v470 + 1;
          v519 = (unsigned __int8 *)sub_925FC(v470 + 1, a2, a3);
          v520 = v519;
          if ( v519 == v518 || v519 == a2 )
            return (__int64)v4;
          v521 = *v519;
          if ( a2 - v519 >= 3 && v521 == 112 )
          {
            if ( v519[1] != 105 )
              return (__int64)v4;
            v520 = v519 + 2;
            while ( *v520 != 69 )
            {
              v522 = sub_A20BC(v520, a2, a3);
              if ( (_BYTE *)v522 != v520 )
              {
                v520 = (_BYTE *)v522;
                if ( (unsigned __int8 *)v522 != a2 )
                  continue;
              }
              return (__int64)v4;
            }
            v761 = 0LL;
            v760 = 0uLL;
            v553 = *(_QWORD *)(a3 + 8);
            v730 = (char **)(a3 + 8);
            if ( *(_QWORD *)a3 == v553 )
              return (__int64)v4;
            v554 = *(unsigned __int8 *)(v553 - 24);
            v555 = *(_QWORD *)(v553 - 16);
            v556 = *(void **)(v553 - 8);
            v557 = (size_t *)(v553 - 48);
            v558 = (void *)(v553 - 23);
            v559 = (v554 & 1) == 0;
            v560 = v554 >> 1;
            if ( v559 )
              v561 = v558;
            else
              v561 = v556;
            if ( v559 )
              v562 = v560;
            else
              v562 = v555;
            v563 = sub_9CFD0(v557, v561, v562);
            v541 = *(_BYTE *)v563;
            *(_QWORD *)((char *)&v765 + 7) = v563[1];
            *(_QWORD *)&v765 = *(size_t *)((char *)v563 + 1);
            *v563 = 0LL;
            v563[1] = 0LL;
            v564 = (char *)v563[2];
            v563[2] = 0LL;
            v565 = *v730;
            LOBYTE(v760) = v541;
            *((_QWORD *)&v760 + 1) = *(_QWORD *)((char *)&v765 + 7);
            v761 = v564;
            *(_QWORD *)((char *)&v760 + 1) = v765;
            v540 = v565 - 48;
            v725 = v565;
            if ( (*(v565 - 24) & 1) != 0 )
              free(*((void **)v565 - 1));
            if ( (*v540 & 1) != 0 )
              free(*((void **)v725 - 4));
            *(_QWORD *)(a3 + 8) = v540;
            v723 = 1;
          }
          else
          {
            if ( v521 != 69 )
              return (__int64)v4;
            v723 = 0;
            v761 = 0LL;
            v760 = 0uLL;
            v540 = *(char **)(a3 + 8);
            v541 = 0;
            v730 = (char **)(a3 + 8);
          }
          if ( *(char **)a3 == v540 )
          {
            v584 = 1;
            v585 = v4;
            if ( (v541 & 1) == 0 )
            {
LABEL_1092:
              if ( !v584 )
                return (__int64)v585;
              return (__int64)v4;
            }
LABEL_1091:
            free(v761);
            goto LABEL_1092;
          }
          v566 = (unsigned __int8)*(v540 - 24);
          v567 = (v566 & 1) == 0;
          v568 = v566 >> 1;
          if ( v567 )
            v569 = v540 - 23;
          else
            v569 = (char *)*((_QWORD *)v540 - 1);
          if ( v567 )
            v570 = v568;
          else
            v570 = *((_QWORD *)v540 - 2);
          v571 = sub_9CFD0((size_t *)v540 - 6, v569, v570);
          v766 = (char *)v571[2];
          v765 = *(_OWORD *)v571;
          v571[1] = 0LL;
          v571[2] = 0LL;
          *v571 = 0LL;
          v572 = *v730;
          v573 = *v730 - 48;
          if ( (*(*v730 - 24) & 1) != 0 )
            free(*((void **)v572 - 1));
          if ( (*v573 & 1) != 0 )
            free(*((void **)v572 - 4));
          *v730 = v573;
          v759 = 0LL;
          v758 = 0uLL;
          if ( (v471 & 1) == 0 )
            goto LABEL_884;
          if ( *(char **)a3 == v573 )
          {
            v584 = 1;
            v585 = v4;
            if ( (v765 & 1) != 0 )
LABEL_1089:
              free(v766);
          }
          else
          {
            v574 = (unsigned __int8)*(v572 - 72);
            v575 = (v574 & 1) == 0;
            v576 = v574 >> 1;
            if ( v575 )
              v577 = v572 - 71;
            else
              v577 = (char *)*((_QWORD *)v572 - 7);
            if ( v575 )
              v578 = v576;
            else
              v578 = *((_QWORD *)v572 - 8);
            v579 = sub_9CFD0((size_t *)v572 - 12, v577, v578);
            v580 = *(_BYTE *)v579;
            *(_QWORD *)((char *)&v756 + 7) = v579[1];
            *(_QWORD *)&v756 = *(size_t *)((char *)v579 + 1);
            *v579 = 0LL;
            v579[1] = 0LL;
            v581 = (char *)v579[2];
            v579[2] = 0LL;
            v582 = *v730;
            LOBYTE(v758) = v580;
            *((_QWORD *)&v758 + 1) = *(_QWORD *)((char *)&v756 + 7);
            *(_QWORD *)((char *)&v758 + 1) = v756;
            v759 = v581;
            v583 = v582 - 48;
            if ( (*(v582 - 24) & 1) != 0 )
              free(*((void **)v582 - 1));
            if ( (*v583 & 1) != 0 )
              free(*((void **)v582 - 4));
            *v730 = v583;
LABEL_884:
            v757 = 0LL;
            v756 = 0uLL;
            if ( v733 )
              sub_A1F74((size_t *)&v756, "::", 2uLL);
            if ( v740 == 97 )
              sub_9CFD0((size_t *)&v756, "[] ", 3uLL);
            else
              sub_9CFD0((size_t *)&v756, " ", 1uLL);
            if ( (v471 & 1) != 0 )
            {
              sub_9F8F0("(", (unsigned __int8 *)&v758, (size_t *)&v752);
              sub_9CFD0((size_t *)&v752, ") ", 2uLL);
              v595 = p;
              v596 = v752;
              p = 0LL;
              v752 = 0uLL;
              v755 = v595;
              v754 = v596;
              v597 = v596;
              v598 = v595;
              if ( (v596 & 1) != 0 )
                v599 = (char *)v755;
              else
                v599 = (char *)&v754 + 1;
              if ( (v754 & 1) != 0 )
                v600 = *((_QWORD *)&v754 + 1);
              else
                v600 = (unsigned __int64)(unsigned __int8)v754 >> 1;
              sub_9CFD0((size_t *)&v756, v599, v600);
              if ( (v597 & 1) != 0 )
                free(v598);
              if ( (v752 & 1) != 0 )
                free(p);
            }
            if ( (v765 & 1) != 0 )
              v601 = v766;
            else
              v601 = (char *)&v765 + 1;
            if ( (v765 & 1) != 0 )
              v602 = *((_QWORD *)&v765 + 1);
            else
              v602 = (unsigned __int64)(unsigned __int8)v765 >> 1;
            sub_9CFD0((size_t *)&v756, v601, v602);
            if ( v723 )
            {
              sub_9F8F0(" (", (unsigned __int8 *)&v760, (size_t *)&v752);
              sub_9CFD0((size_t *)&v752, ")", 1uLL);
              v603 = p;
              v604 = v752;
              p = 0LL;
              v752 = 0uLL;
              v755 = v603;
              v754 = v604;
              v605 = v604;
              v606 = v603;
              if ( (v604 & 1) != 0 )
                v607 = (char *)v755;
              else
                v607 = (char *)&v754 + 1;
              if ( (v754 & 1) != 0 )
                v608 = *((_QWORD *)&v754 + 1);
              else
                v608 = (unsigned __int64)(unsigned __int8)v754 >> 1;
              sub_9CFD0((size_t *)&v756, v607, v608);
              if ( (v605 & 1) != 0 )
                free(v606);
              if ( (v752 & 1) != 0 )
                free(p);
            }
            v609 = *((_QWORD *)&v756 + 1);
            v610 = v757;
            v611 = *(_QWORD *)((char *)&v756 + 1);
            v612 = v756;
            v756 = 0uLL;
            *(_QWORD *)((char *)&v748 + 7) = v609;
            BYTE7(v748) = HIBYTE(v611);
            v613 = *(_QWORD *)((char *)&v748 + 7);
            v757 = 0LL;
            *(_QWORD *)((char *)&v752 + 7) = 0LL;
            *(_QWORD *)&v752 = 0LL;
            *(_QWORD *)((char *)&v748 + 7) = 0LL;
            *(_QWORD *)&v748 = 0LL;
            *(_QWORD *)((char *)&v754 + 7) = v613;
            *(_QWORD *)&v754 = v611;
            v614 = *(_QWORD *)(a3 + 8);
            v615 = *(_QWORD *)(a3 + 16);
            if ( v614 >= v615 )
            {
              v616 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v614 - *(_QWORD *)a3) >> 4);
              if ( v616 + 1 > 0x555555555555555LL )
                abort();
              v617 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v615 - *(_QWORD *)a3) >> 4);
              if ( v617 >= 0x2AAAAAAAAAAAAAALL
                || ((v618 = 2 * v617, v618 >= v616 + 1) ? (v11 = v618) : (v11 = v616 + 1), v11) )
              {
                v619 = *(_QWORD *)(a3 + 24);
                v620 = *(char **)(v619 + 4096);
                if ( v619 + 4096 - (__int64)v620 >= (unsigned __int64)(48 * v11) )
                  *(_QWORD *)(v619 + 4096) = &v620[48 * v11];
                else
                  v620 = (char *)malloc(48 * v11);
              }
              else
              {
                v620 = 0LL;
              }
              v697 = &v620[48 * v616];
              *v697 = v612;
              v698 = &v620[48 * v11];
              *((_QWORD *)v697 + 1) = *(_QWORD *)((char *)&v754 + 7);
              *((_QWORD *)v697 + 2) = v610;
              *(_QWORD *)(v697 + 1) = v754;
              *(_QWORD *)((char *)&v754 + 7) = 0LL;
              *(_QWORD *)&v754 = 0LL;
              v697[24] = 0;
              *((_QWORD *)v697 + 4) = *(_QWORD *)((char *)&v752 + 7);
              *((_QWORD *)v697 + 5) = 0LL;
              *(_QWORD *)(v697 + 25) = v752;
              *(_QWORD *)((char *)&v752 + 7) = 0LL;
              *(_QWORD *)&v752 = 0LL;
              v700 = *(void ***)a3;
              v699 = *(void ***)(a3 + 8);
              v701 = v697 + 48;
              if ( v699 == *(void ***)a3 )
              {
                v703 = *(void ***)a3;
              }
              else
              {
                do
                {
                  *((_QWORD *)v697 - 4) = *(v699 - 4);
                  *((_OWORD *)v697 - 3) = *((_OWORD *)v699 - 3);
                  v702 = (__int64)*(v699 - 1);
                  *(v699 - 5) = 0LL;
                  *(v699 - 4) = 0LL;
                  *(v699 - 6) = 0LL;
                  *((_QWORD *)v697 - 1) = v702;
                  *(_OWORD *)(v697 - 24) = *(_OWORD *)(v699 - 3);
                  *(v699 - 2) = 0LL;
                  *(v699 - 1) = 0LL;
                  *(v699 - 3) = 0LL;
                  v699 -= 6;
                  v697 -= 48;
                }
                while ( v700 != v699 );
                v703 = *(void ***)a3;
                v700 = *(void ***)(a3 + 8);
              }
              *(_QWORD *)a3 = v697;
              *v730 = v701;
              v704 = *(_QWORD *)(a3 + 16);
              *(_QWORD *)(a3 + 16) = v698;
              if ( v700 != v703 )
              {
                do
                {
                  if ( (*(_BYTE *)(v700 - 3) & 1) != 0 )
                    free(*(v700 - 1));
                  v705 = v700 - 6;
                  if ( (*(_BYTE *)(v700 - 6) & 1) != 0 )
                    free(*(v700 - 4));
                  v700 -= 6;
                }
                while ( v703 != v705 );
              }
              if ( v703 )
              {
                v706 = *(_QWORD *)(a3 + 24);
                if ( v706 + 4096 < (unsigned __int64)v703 || v706 > (unsigned __int64)v703 )
                {
                  free(v703);
                }
                else if ( *(_QWORD *)(v706 + 4096) == v704 )
                {
                  *(_QWORD *)(v706 + 4096) = v703;
                }
              }
            }
            else
            {
              *(_BYTE *)v614 = v612;
              *(_QWORD *)(v614 + 8) = *(_QWORD *)((char *)&v754 + 7);
              *(_QWORD *)(v614 + 16) = v610;
              *(_QWORD *)(v614 + 1) = v754;
              *(_QWORD *)((char *)&v754 + 7) = 0LL;
              *(_QWORD *)&v754 = 0LL;
              *(_BYTE *)(v614 + 24) = 0;
              *(_QWORD *)(v614 + 32) = *(_QWORD *)((char *)&v752 + 7);
              *(_QWORD *)(v614 + 40) = 0LL;
              *(_QWORD *)(v614 + 25) = v752;
              *(_QWORD *)((char *)&v752 + 7) = 0LL;
              *(_QWORD *)&v752 = 0LL;
              *v730 += 48;
            }
            v585 = v520 + 1;
            if ( (v756 & 1) != 0 )
              free(v757);
            if ( (v758 & 1) != 0 )
              free(v759);
            v584 = 0;
            if ( (v765 & 1) != 0 )
              goto LABEL_1089;
          }
          if ( (v760 & 1) == 0 )
            goto LABEL_1092;
          goto LABEL_1091;
        case 'e':
          v13 = a1 + 2;
          v761 = 0LL;
          v760 = 0x3D2104uLL;
          v14 = sub_A9620(a1 + 2, a2, &v760, a3);
          goto LABEL_597;
        case 'g':
          v13 = a1 + 2;
          v761 = 0LL;
          v760 = 0x2D02uLL;
          v14 = sub_A9B9C(a1 + 2, a2, &v760, a3);
          goto LABEL_597;
        case 't':
          v13 = a1 + 2;
          v761 = 0LL;
          v760 = 0x2102uLL;
          v14 = sub_A9B9C(a1 + 2, a2, &v760, a3);
          goto LABEL_597;
        case 'x':
          v243 = a1 + 2;
          v244 = sub_A20BC(a1 + 2, a2, a3);
          if ( (unsigned __int8 *)v244 == v243 )
          {
            v246 = (__int64)(v4 + 2);
            goto LABEL_792;
          }
          v245 = *(_QWORD *)(a3 + 8);
          v246 = (__int64)(v4 + 2);
          if ( *(_QWORD *)a3 == v245 )
            goto LABEL_792;
          v247 = *(unsigned __int8 *)(v245 - 24);
          v248 = (v247 & 1) == 0;
          v249 = v247 >> 1;
          if ( v248 )
            v250 = (void *)(v245 - 23);
          else
            v250 = *(void **)(v245 - 8);
          if ( v248 )
            v251 = v249;
          else
            v251 = *(_QWORD *)(v245 - 16);
          sub_9CFD0((size_t *)(v245 - 48), v250, v251);
          v766 = *(char **)(v245 - 32);
          v765 = *(_OWORD *)(v245 - 48);
          *(_QWORD *)(v245 - 40) = 0LL;
          *(_QWORD *)(v245 - 32) = 0LL;
          *(_QWORD *)(v245 - 48) = 0LL;
          sub_9CDD8((size_t *)&v765, 0LL, "noexcept (", 0xAuLL);
          v252 = v766;
          v253 = v765;
          v766 = 0LL;
          v765 = 0uLL;
          v761 = v252;
          v760 = v253;
          sub_9CFD0((size_t *)&v760, ")", 1uLL);
          v254 = v761;
          v255 = v760;
          v761 = 0LL;
          *(_QWORD *)((char *)&v758 + 7) = *((_QWORD *)&v760 + 1);
          *(_QWORD *)&v758 = *(_QWORD *)((char *)&v760 + 1);
          v760 = 0uLL;
          v256 = *(_QWORD *)(a3 + 8);
          v257 = (__int64 *)(v256 - 48);
          if ( (*(_BYTE *)(v256 - 48) & 1) == 0 )
          {
            *(_WORD *)(v256 - 48) = 0;
            v258 = (const void **)(v256 - 32);
            goto LABEL_787;
          }
          v258 = (const void **)(v256 - 32);
          **(_BYTE **)(v256 - 32) = 0;
          LOBYTE(v490) = *(_BYTE *)(v256 - 48);
          *(_QWORD *)(v256 - 40) = 0LL;
          if ( (v490 & 1) != 0 )
          {
            v490 = *v257;
            v491 = (*v257 & 0xFFFFFFFFFFFFFFFELL) - 1;
            if ( (*v257 & 1) != 0 )
            {
              v492 = 0LL;
              v493 = 0;
              goto LABEL_728;
            }
          }
          else
          {
            v491 = 22LL;
          }
          v492 = (unsigned __int64)((unsigned __int8)v490 & 0xFE) >> 1;
          if ( (unsigned __int8)v490 >= 0x2Eu )
          {
            v523 = ((unsigned __int8)(v492 + 16) & 0xF0) - 1LL;
            v493 = 1;
            if ( v523 == v491 )
              goto LABEL_787;
LABEL_743:
            v742 = v255;
            v735 = v254;
            if ( v523 == 22 )
            {
              v530 = v492;
              v531 = *v258;
              v532 = (_BYTE *)(v256 - 47);
              if ( v493 )
              {
                v533 = ((unsigned __int64)((unsigned __int8)v490 & 0xFE) >> 1) + 1;
                v534 = (void *)*v258;
                memcpy(v532, *v258, v533);
                v535 = v534;
              }
              else
              {
                *v532 = *v531;
                v535 = v531;
              }
              free(v535);
              *(_BYTE *)v257 = 2 * v530;
            }
            else
            {
              v719 = v493;
              v722 = v492;
              v728 = v491;
              v717 = v523 + 1;
              v536 = malloc(v523 + 1);
              v528 = v523 > v728;
              v537 = v536;
              if ( v528 || v536 )
              {
                if ( (v719 & 1) != 0 )
                {
                  memcpy(v536, (const void *)(v256 - 47), ((unsigned __int64)((unsigned __int8)v490 & 0xFE) >> 1) + 1);
                }
                else
                {
                  v546 = (void *)*v258;
                  *v537 = *(_BYTE *)*v258;
                  free(v546);
                }
                *(_QWORD *)(v256 - 48) = v717 | 1;
                *(_QWORD *)(v256 - 40) = v722;
                *(_QWORD *)(v256 - 32) = v537;
              }
            }
            v255 = v742;
            v254 = v735;
LABEL_787:
            *(_BYTE *)(v256 - 48) = v255;
            *(_QWORD *)(v256 - 47) = v758;
            *(_QWORD *)(v256 - 40) = *(_QWORD *)((char *)&v758 + 7);
            *v258 = v254;
            *(_QWORD *)&v758 = 0LL;
            *(_QWORD *)((char *)&v758 + 7) = 0LL;
            if ( (v760 & 1) != 0 )
              free(v761);
            if ( (v765 & 1) != 0 )
              free(v766);
            v246 = v244;
LABEL_792:
            if ( (unsigned __int8 *)v246 != v243 )
              return v246;
            return (__int64)v4;
          }
          v493 = 1;
LABEL_728:
          v523 = 22LL;
          if ( v491 == 22 )
            goto LABEL_787;
          goto LABEL_743;
        default:
          return (__int64)v4;
      }
    case 'o':
      switch ( v10[1] )
      {
        case 'R':
          v13 = a1 + 2;
          v761 = 0LL;
          v760 = 0x3D7C04uLL;
          v14 = sub_A9620(a1 + 2, a2, &v760, a3);
          goto LABEL_597;
        case 'n':
          return sub_A9F34(a1, a2, a3);
        case 'o':
          v13 = a1 + 2;
          v761 = 0LL;
          v760 = 0x7C7C04uLL;
          v14 = sub_A9620(a1 + 2, a2, &v760, a3);
          goto LABEL_597;
        case 'r':
          v13 = a1 + 2;
          v761 = 0LL;
          v760 = 0x7C02uLL;
          v14 = sub_A9620(a1 + 2, a2, &v760, a3);
          goto LABEL_597;
        default:
          return (__int64)v4;
      }
    case 'p':
      switch ( v10[1] )
      {
        case 'L':
          v13 = a1 + 2;
          v761 = 0LL;
          v760 = 0x3D2B04uLL;
          v14 = sub_A9620(a1 + 2, a2, &v760, a3);
          goto LABEL_597;
        case 'l':
          v13 = a1 + 2;
          v761 = 0LL;
          v760 = 0x2B02uLL;
          v14 = sub_A9620(a1 + 2, a2, &v760, a3);
          goto LABEL_597;
        case 'm':
          v13 = a1 + 2;
          v761 = 0LL;
          v760 = 0x2A3E2D06uLL;
          v14 = sub_A9620(a1 + 2, a2, &v760, a3);
          goto LABEL_597;
        case 'p':
          v318 = a1 + 2;
          if ( a1 + 2 != a2 && *v318 == 95 )
          {
            v13 = a1 + 3;
            v761 = 0LL;
            v760 = 0x2B2B04uLL;
            v14 = sub_A9B9C(a1 + 3, a2, &v760, a3);
            goto LABEL_597;
          }
          v22 = sub_A20BC(a1 + 2, a2, a3);
          if ( (_BYTE *)v22 == v318 )
            return (__int64)v4;
          v456 = *(_QWORD *)(a3 + 8);
          if ( *(_QWORD *)a3 == v456 )
            return (__int64)v4;
          v457 = *(unsigned __int8 *)(v456 - 24);
          v458 = (v457 & 1) == 0;
          v459 = v457 >> 1;
          if ( v458 )
            v460 = (void *)(v456 - 23);
          else
            v460 = *(void **)(v456 - 8);
          if ( v458 )
            v461 = v459;
          else
            v461 = *(_QWORD *)(v456 - 16);
          sub_9CFD0((size_t *)(v456 - 48), v460, v461);
          v759 = *(char **)(v456 - 32);
          v758 = *(_OWORD *)(v456 - 48);
          *(_QWORD *)(v456 - 40) = 0LL;
          *(_QWORD *)(v456 - 32) = 0LL;
          *(_QWORD *)(v456 - 48) = 0LL;
          sub_9CDD8((size_t *)&v758, 0LL, "(", 1uLL);
          v462 = v759;
          v463 = v758;
          v759 = 0LL;
          v758 = 0uLL;
          v766 = v462;
          v765 = v463;
          sub_9CFD0((size_t *)&v765, ")++", 3uLL);
          v464 = *(_QWORD *)((char *)&v765 + 1);
          v465 = *((_QWORD *)&v765 + 1);
          v314 = v766;
          v466 = v765;
          v766 = 0LL;
          v765 = 0uLL;
          *(_QWORD *)&v750[23] = v465;
          v750[23] = HIBYTE(v464);
          LOBYTE(v760) = v466;
          v316 = v464;
          v317 = *(_QWORD *)&v750[23];
          memset(&v750[16], 0, 15);
          break;
        case 's':
          v13 = a1 + 2;
          v761 = 0LL;
          v760 = 0x2B02uLL;
          v14 = sub_A9B9C(a1 + 2, a2, &v760, a3);
          goto LABEL_597;
        case 't':
          if ( v5 < 3 )
            return (__int64)v4;
          if ( *a1 != 112 )
            return (__int64)v4;
          if ( a1[1] != 116 )
            return (__int64)v4;
          v290 = a1 + 2;
          v291 = sub_A20BC(a1 + 2, a2, a3);
          v292 = v291;
          if ( (unsigned __int8 *)v291 == v290 )
            return (__int64)v4;
          v22 = sub_A20BC(v291, a2, a3);
          if ( v22 == v292 )
            return (__int64)v4;
          v293 = *(_QWORD *)(a3 + 8);
          if ( 0xAAAAAAAAAAAAAAABLL * ((v293 - *(_QWORD *)a3) >> 4) < 2 )
            return (__int64)v4;
          v294 = *(unsigned __int8 *)(v293 - 24);
          v295 = (v294 & 1) == 0;
          v296 = v294 >> 1;
          if ( v295 )
            v297 = (void *)(v293 - 23);
          else
            v297 = *(void **)(v293 - 8);
          if ( v295 )
            v298 = v296;
          else
            v298 = *(_QWORD *)(v293 - 16);
          sub_9CFD0((size_t *)(v293 - 48), v297, v298);
          v761 = *(char **)(v293 - 32);
          v760 = *(_OWORD *)(v293 - 48);
          *(_QWORD *)(v293 - 40) = 0LL;
          *(_QWORD *)(v293 - 32) = 0LL;
          *(_QWORD *)(v293 - 48) = 0LL;
          v299 = *(_QWORD *)(a3 + 8);
          v300 = (_BYTE *)(v299 - 48);
          if ( (*(_BYTE *)(v299 - 24) & 1) != 0 )
            free(*(void **)(v299 - 8));
          if ( (*v300 & 1) != 0 )
            free(*(void **)(v299 - 32));
          *(_QWORD *)(a3 + 8) = v300;
          sub_9CFD0((size_t *)(v299 - 96), "->", 2uLL);
          v301 = *(_QWORD *)(a3 + 8);
          v302 = v761;
          if ( (v760 & 1) != 0 )
            v303 = v761;
          else
            v303 = (char *)&v760 + 1;
          if ( (v760 & 1) != 0 )
            v304 = *((_QWORD *)&v760 + 1);
          else
            v304 = (unsigned __int64)(unsigned __int8)v760 >> 1;
          sub_9CFD0((size_t *)(v301 - 48), v303, v304);
          if ( (v760 & 1) == 0 )
            return v22;
          v305 = v302;
          goto LABEL_943;
        default:
          return (__int64)v4;
      }
      goto LABEL_609;
    case 'q':
      if ( v10[1] != 117 )
        return (__int64)v4;
      v116 = a1 + 2;
      v117 = sub_A20BC(a1 + 2, a2, a3);
      v118 = v117;
      if ( (unsigned __int8 *)v117 == v116 )
        return (__int64)v4;
      v119 = sub_A20BC(v117, a2, a3);
      v120 = v119;
      if ( v119 != v118 )
      {
        v121 = sub_A20BC(v119, a2, a3);
        v122 = *(_QWORD *)(a3 + 8);
        v22 = v121;
        v123 = 0xAAAAAAAAAAAAAAABLL * ((v122 - *(_QWORD *)a3) >> 4);
        if ( v121 == v120 )
        {
          if ( v123 >= 2 )
          {
            v467 = (_BYTE *)(v122 - 48);
            if ( (*(_BYTE *)(v122 - 24) & 1) != 0 )
              free(*(void **)(v122 - 8));
            if ( (*v467 & 1) != 0 )
              free(*(void **)(v122 - 32));
            *(_QWORD *)(a3 + 8) = v467;
            v468 = (_BYTE *)(v122 - 96);
            if ( (*(_BYTE *)(v122 - 72) & 1) != 0 )
              free(*(void **)(v122 - 56));
            if ( (*v468 & 1) != 0 )
              free(*(void **)(v122 - 80));
            *(_QWORD *)(a3 + 8) = v468;
          }
          return (__int64)v4;
        }
        if ( v123 < 3 )
          return (__int64)v4;
        v124 = *(unsigned __int8 *)(v122 - 24);
        v125 = (v124 & 1) == 0;
        v126 = v124 >> 1;
        if ( v125 )
          v127 = (void *)(v122 - 23);
        else
          v127 = *(void **)(v122 - 8);
        if ( v125 )
          v128 = v126;
        else
          v128 = *(_QWORD *)(v122 - 16);
        sub_9CFD0((size_t *)(v122 - 48), v127, v128);
        v766 = *(char **)(v122 - 32);
        v765 = *(_OWORD *)(v122 - 48);
        *(_QWORD *)(v122 - 40) = 0LL;
        *(_QWORD *)(v122 - 32) = 0LL;
        *(_QWORD *)(v122 - 48) = 0LL;
        v129 = *(_QWORD *)(a3 + 8);
        v130 = (_BYTE *)(v129 - 48);
        if ( (*(_BYTE *)(v129 - 24) & 1) != 0 )
          free(*(void **)(v129 - 8));
        if ( (*v130 & 1) != 0 )
          free(*(void **)(v129 - 32));
        *(_QWORD *)(a3 + 8) = v130;
        v131 = *(unsigned __int8 *)(v129 - 72);
        v132 = (v131 & 1) == 0;
        v133 = v131 >> 1;
        if ( v132 )
          v134 = (void *)(v129 - 71);
        else
          v134 = *(void **)(v129 - 56);
        if ( v132 )
          v135 = v133;
        else
          v135 = *(_QWORD *)(v129 - 64);
        v136 = sub_9CFD0((size_t *)(v129 - 96), v134, v135);
        v757 = (char *)v136[2];
        v756 = *(_OWORD *)v136;
        v136[1] = 0LL;
        v136[2] = 0LL;
        *v136 = 0LL;
        v137 = *(_QWORD *)(a3 + 8);
        v138 = (_BYTE *)(v137 - 48);
        if ( (*(_BYTE *)(v137 - 24) & 1) != 0 )
          free(*(void **)(v137 - 8));
        if ( (*v138 & 1) != 0 )
          free(*(void **)(v137 - 32));
        *(_QWORD *)(a3 + 8) = v138;
        v139 = *(unsigned __int8 *)(v137 - 72);
        v140 = (v139 & 1) == 0;
        v141 = v139 >> 1;
        if ( v140 )
          v142 = (void *)(v137 - 71);
        else
          v142 = *(void **)(v137 - 56);
        if ( v140 )
          v143 = v141;
        else
          v143 = *(_QWORD *)(v137 - 64);
        v144 = sub_9CFD0((size_t *)(v137 - 96), v142, v143);
        v755 = (void *)v144[2];
        v754 = *(_OWORD *)v144;
        v144[1] = 0LL;
        v144[2] = 0LL;
        *v144 = 0LL;
        sub_9F8F0("(", (unsigned __int8 *)&v754, (size_t *)&v744);
        sub_9CFD0((size_t *)&v744, ") ? (", 5uLL);
        v145 = v756;
        v146 = v745;
        v147 = v744;
        v745 = 0LL;
        v744 = 0uLL;
        v148 = v757;
        v747 = v146;
        if ( (v756 & 1) != 0 )
          v149 = v757;
        else
          v149 = (char *)&v756 + 1;
        v746 = v147;
        if ( (v756 & 1) != 0 )
          v150 = *((_QWORD *)&v756 + 1);
        else
          v150 = (unsigned __int64)(unsigned __int8)v756 >> 1;
        sub_9CFD0((size_t *)&v746, v149, v150);
        v151 = v747;
        v152 = v746;
        v747 = 0LL;
        v746 = 0uLL;
        v749 = v151;
        v748 = v152;
        sub_9CFD0((size_t *)&v748, ") : (", 5uLL);
        v153 = v765;
        v154 = v749;
        v155 = v748;
        v749 = 0LL;
        v748 = 0uLL;
        v156 = v766;
        p = v154;
        if ( (v765 & 1) != 0 )
          v157 = v766;
        else
          v157 = (char *)&v765 + 1;
        v752 = v155;
        if ( (v765 & 1) != 0 )
          v158 = *((_QWORD *)&v765 + 1);
        else
          v158 = (unsigned __int64)(unsigned __int8)v765 >> 1;
        sub_9CFD0((size_t *)&v752, v157, v158);
        v159 = (char *)p;
        v160 = v752;
        p = 0LL;
        v752 = 0uLL;
        v759 = v159;
        v758 = v160;
        sub_9CFD0((size_t *)&v758, ")", 1uLL);
        v161 = *(_QWORD *)((char *)&v758 + 1);
        v162 = *((_QWORD *)&v758 + 1);
        v163 = v759;
        v164 = v758;
        v759 = 0LL;
        v758 = 0uLL;
        *(_QWORD *)&v750[7] = v162;
        v750[7] = HIBYTE(v161);
        LOBYTE(v760) = v164;
        v165 = v161;
        v166 = *(_QWORD *)&v750[7];
        memset(v750, 0, 15);
        *(_QWORD *)((char *)&v760 + 1) = v165;
        *((_QWORD *)&v760 + 1) = v166;
        v761 = v163;
        v763 = 0LL;
        v764 = 0LL;
        v762 = 0LL;
        sub_A7174(*(_QWORD *)(a3 + 8) - 48LL, &v760);
        if ( (v762 & 1) != 0 )
        {
          free(v764);
          if ( (v760 & 1) == 0 )
          {
LABEL_200:
            if ( (v758 & 1) == 0 )
              goto LABEL_201;
            goto LABEL_668;
          }
        }
        else if ( (v760 & 1) == 0 )
        {
          goto LABEL_200;
        }
        free(v761);
        if ( (v758 & 1) == 0 )
        {
LABEL_201:
          if ( (v752 & 1) == 0 )
            goto LABEL_202;
          goto LABEL_669;
        }
LABEL_668:
        free(v759);
        if ( (v752 & 1) == 0 )
        {
LABEL_202:
          if ( (v748 & 1) == 0 )
            goto LABEL_203;
          goto LABEL_670;
        }
LABEL_669:
        free(p);
        if ( (v748 & 1) == 0 )
        {
LABEL_203:
          if ( (v746 & 1) == 0 )
            goto LABEL_204;
          goto LABEL_671;
        }
LABEL_670:
        free(v749);
        if ( (v746 & 1) == 0 )
        {
LABEL_204:
          if ( (v744 & 1) == 0 )
            goto LABEL_205;
          goto LABEL_672;
        }
LABEL_671:
        free(v747);
        if ( (v744 & 1) == 0 )
        {
LABEL_205:
          if ( (v754 & 1) == 0 )
            goto LABEL_206;
          goto LABEL_673;
        }
LABEL_672:
        free(v745);
        if ( (v754 & 1) == 0 )
        {
LABEL_206:
          if ( (v145 & 1) == 0 )
            goto LABEL_207;
          goto LABEL_674;
        }
LABEL_673:
        free(v755);
        if ( (v145 & 1) == 0 )
        {
LABEL_207:
          if ( (v153 & 1) == 0 )
            return v22;
LABEL_675:
          v305 = v156;
          goto LABEL_943;
        }
LABEL_674:
        free(v148);
        if ( (v153 & 1) == 0 )
          return v22;
        goto LABEL_675;
      }
      v339 = *(_QWORD *)(a3 + 8);
      if ( *(_QWORD *)a3 != v339 )
      {
LABEL_444:
        v340 = (_BYTE *)(v339 - 48);
        if ( (*(_BYTE *)(v339 - 24) & 1) != 0 )
          free(*(void **)(v339 - 8));
        if ( (*v340 & 1) != 0 )
          free(*(void **)(v339 - 32));
        *(_QWORD *)(a3 + 8) = v340;
      }
      return (__int64)v4;
    case 'r':
      switch ( v10[1] )
      {
        case 'M':
          v13 = a1 + 2;
          v761 = 0LL;
          v760 = 0x3D2504uLL;
          v14 = sub_A9620(a1 + 2, a2, &v760, a3);
          goto LABEL_597;
        case 'S':
          v13 = a1 + 2;
          v761 = 0LL;
          v760 = 0x3D3E3E06uLL;
          v14 = sub_A9620(a1 + 2, a2, &v760, a3);
          goto LABEL_597;
        case 'c':
          if ( v5 < 3 )
            return (__int64)v4;
          if ( *a1 != 114 )
            return (__int64)v4;
          if ( a1[1] != 99 )
            return (__int64)v4;
          v208 = a1 + 2;
          v209 = sub_925FC(a1 + 2, a2, a3);
          v210 = v209;
          if ( (unsigned __int8 *)v209 == v208 )
            return (__int64)v4;
          v22 = sub_A20BC(v209, a2, a3);
          if ( v22 == v210 )
            return (__int64)v4;
          v211 = *(_QWORD *)(a3 + 8);
          if ( 0xAAAAAAAAAAAAAAABLL * ((v211 - *(_QWORD *)a3) >> 4) < 2 )
            return (__int64)v4;
          v212 = *(unsigned __int8 *)(v211 - 24);
          v213 = (v212 & 1) == 0;
          v214 = v212 >> 1;
          if ( v213 )
            v215 = (void *)(v211 - 23);
          else
            v215 = *(void **)(v211 - 8);
          if ( v213 )
            v216 = v214;
          else
            v216 = *(_QWORD *)(v211 - 16);
          sub_9CFD0((size_t *)(v211 - 48), v215, v216);
          v766 = *(char **)(v211 - 32);
          v765 = *(_OWORD *)(v211 - 48);
          *(_QWORD *)(v211 - 40) = 0LL;
          *(_QWORD *)(v211 - 32) = 0LL;
          *(_QWORD *)(v211 - 48) = 0LL;
          v217 = *(_QWORD *)(a3 + 8);
          v218 = (_BYTE *)(v217 - 48);
          if ( (*(_BYTE *)(v217 - 24) & 1) != 0 )
            free(*(void **)(v217 - 8));
          if ( (*v218 & 1) != 0 )
            free(*(void **)(v217 - 32));
          v219 = *(void ***)a3;
          *(_QWORD *)(a3 + 8) = v218;
          if ( v219 != (void **)v218 )
          {
            v220 = *(unsigned __int8 *)(v217 - 72);
            v221 = (v220 & 1) == 0;
            v222 = v220 >> 1;
            if ( v221 )
              v223 = (void *)(v217 - 71);
            else
              v223 = *(void **)(v217 - 56);
            if ( v221 )
              v224 = v222;
            else
              v224 = *(_QWORD *)(v217 - 64);
            v225 = sub_9CFD0((size_t *)(v217 - 96), v223, v224);
            p = (void *)v225[2];
            v752 = *(_OWORD *)v225;
            v225[1] = 0LL;
            v225[2] = 0LL;
            *v225 = 0LL;
            sub_9CDD8((size_t *)&v752, 0LL, "reinterpret_cast<", 0x11uLL);
            v226 = p;
            v227 = v752;
            p = 0LL;
            v752 = 0uLL;
            v755 = v226;
            v754 = v227;
            sub_9CFD0((size_t *)&v754, ">(", 2uLL);
            v228 = (char *)v755;
            v229 = v754;
            v755 = 0LL;
            v754 = 0uLL;
            v230 = v765;
            v757 = v228;
            if ( (v765 & 1) != 0 )
              v231 = v766;
            else
              v231 = (char *)&v765 + 1;
            v756 = v229;
            if ( (v765 & 1) != 0 )
              v232 = *((_QWORD *)&v765 + 1);
            else
              v232 = (unsigned __int64)(unsigned __int8)v765 >> 1;
            sub_9CFD0((size_t *)&v756, v231, v232);
            v233 = v757;
            v234 = v756;
            v757 = 0LL;
            v756 = 0uLL;
            v759 = v233;
            v758 = v234;
            sub_9CFD0((size_t *)&v758, ")", 1uLL);
            v235 = *(_QWORD *)((char *)&v758 + 1);
            v236 = *((_QWORD *)&v758 + 1);
            v237 = v759;
            v238 = v758;
            v759 = 0LL;
            v758 = 0uLL;
            *(_QWORD *)((char *)&v748 + 7) = v236;
            BYTE7(v748) = HIBYTE(v235);
            LOBYTE(v760) = v238;
            v239 = v235;
            v240 = *(_QWORD *)((char *)&v748 + 7);
            *(_QWORD *)&v748 = 0LL;
            *(_QWORD *)((char *)&v748 + 7) = 0LL;
            *(_QWORD *)((char *)&v760 + 1) = v239;
            *((_QWORD *)&v760 + 1) = v240;
            v761 = v237;
            v763 = 0LL;
            v764 = 0LL;
            v762 = 0LL;
            sub_A7174(*(_QWORD *)(a3 + 8) - 48LL, &v760);
            if ( (v762 & 1) != 0 )
            {
              free(v764);
              if ( (v760 & 1) == 0 )
              {
LABEL_298:
                if ( (v758 & 1) == 0 )
                  goto LABEL_299;
                goto LABEL_821;
              }
            }
            else if ( (v760 & 1) == 0 )
            {
              goto LABEL_298;
            }
            free(v761);
            if ( (v758 & 1) == 0 )
            {
LABEL_299:
              if ( (v756 & 1) == 0 )
                goto LABEL_300;
              goto LABEL_822;
            }
LABEL_821:
            free(v759);
            if ( (v756 & 1) == 0 )
            {
LABEL_300:
              if ( (v754 & 1) == 0 )
                goto LABEL_301;
              goto LABEL_823;
            }
LABEL_822:
            free(v757);
            if ( (v754 & 1) == 0 )
            {
LABEL_301:
              if ( (v752 & 1) == 0 )
                goto LABEL_303;
              goto LABEL_302;
            }
LABEL_823:
            free(v755);
            if ( (v752 & 1) == 0 )
            {
LABEL_303:
              v241 = 0;
              if ( (v230 & 1) == 0 )
                goto LABEL_305;
              goto LABEL_304;
            }
LABEL_302:
            free(p);
            goto LABEL_303;
          }
          v241 = 1;
          v22 = (__int64)v4;
          if ( (v765 & 1) != 0 )
LABEL_304:
            free(v766);
LABEL_305:
          if ( !v241 )
            return v22;
          return (__int64)v4;
        case 'm':
          v13 = a1 + 2;
          v761 = 0LL;
          v760 = 0x2502uLL;
          v14 = sub_A9620(a1 + 2, a2, &v760, a3);
          goto LABEL_597;
        case 's':
          v13 = a1 + 2;
          v761 = 0LL;
          v760 = 0x3E3E04uLL;
          v14 = sub_A9620(a1 + 2, a2, &v760, a3);
          goto LABEL_597;
        default:
          return (__int64)v4;
      }
    case 's':
      switch ( v10[1] )
      {
        case 'Z':
          if ( a2 - v10 < 3 )
            return (__int64)v4;
          v90 = v10[2];
          if ( v90 != 102 )
          {
            if ( v90 != 84 )
              return (__int64)v4;
            if ( v5 < 3 )
              return (__int64)v4;
            if ( *a1 != 115 )
              return (__int64)v4;
            if ( a1[1] != 90 )
              return (__int64)v4;
            v91 = a1 + 2;
            if ( a1[2] != 84 )
              return (__int64)v4;
            v92 = *(void ***)a3;
            v93 = *(_QWORD *)(a3 + 8);
            v726 = sub_9F9E8(a1 + 2, a2, a3);
            if ( (unsigned __int8 *)v726 == v91 )
              return (__int64)v4;
            v94 = *(void ***)a3;
            v95 = *(_QWORD *)(a3 + 8);
            *((_QWORD *)&v760 + 1) = 2633216LL;
            v761 = 0LL;
            LOBYTE(v760) = 20;
            *(_QWORD *)((char *)&v760 + 1) = *(_QWORD *)"sizeof...(";
            v732 = 0xAAAAAAAAAAAAAAABLL * ((v95 - (__int64)v94) >> 4);
            v738 = 0xAAAAAAAAAAAAAAABLL * ((v93 - (__int64)v92) >> 4);
            if ( v738 != v732 )
            {
              v96 = &v94[2 * ((v93 - (__int64)v92) >> 4)];
              v97 = *((unsigned __int8 *)v96 + 24);
              v98 = (v97 & 1) == 0;
              v99 = v97 >> 1;
              if ( v98 )
                v100 = (char *)v96 + 25;
              else
                v100 = v96[5];
              if ( v98 )
                v101 = v99;
              else
                v101 = (size_t)v96[4];
              v102 = sub_9CFD0((size_t *)v96, v100, v101);
              v766 = (char *)v102[2];
              v765 = *(_OWORD *)v102;
              v102[1] = 0LL;
              v102[2] = 0LL;
              *v102 = 0LL;
              v103 = v765;
              v104 = v766;
              if ( (v765 & 1) != 0 )
                v105 = v766;
              else
                v105 = (char *)&v765 + 1;
              if ( (v765 & 1) != 0 )
                v106 = *((_QWORD *)&v765 + 1);
              else
                v106 = (unsigned __int64)(unsigned __int8)v765 >> 1;
              sub_9CFD0((size_t *)&v760, v105, v106);
              if ( (v103 & 1) != 0 )
                free(v104);
              if ( v738 + 1 != v732 )
              {
                v627 = v732 - 1 - v738;
                v628 = 16 * ((v93 - (__int64)v92) >> 4);
                do
                {
                  v629 = *(_QWORD *)a3 + v628;
                  v630 = *(unsigned __int8 *)(v629 + 72);
                  v631 = *(_QWORD *)(v629 + 80);
                  v632 = *(void **)(v629 + 88);
                  v633 = (size_t *)(v629 + 48);
                  v634 = (void *)(v629 + 73);
                  v635 = (v630 & 1) == 0;
                  v636 = v630 >> 1;
                  if ( v635 )
                    v637 = v634;
                  else
                    v637 = v632;
                  if ( v635 )
                    v638 = v636;
                  else
                    v638 = v631;
                  v639 = sub_9CFD0(v633, v637, v638);
                  v759 = (char *)v639[2];
                  v758 = *(_OWORD *)v639;
                  v639[1] = 0LL;
                  v639[2] = 0LL;
                  *v639 = 0LL;
                  sub_9CDD8((size_t *)&v758, 0LL, ", ", 2uLL);
                  v640 = v759;
                  v641 = v758;
                  v759 = 0LL;
                  v766 = v640;
                  v765 = v758;
                  v642 = v758;
                  v643 = v640;
                  v758 = 0uLL;
                  if ( (v765 & 1) != 0 )
                    v644 = v640;
                  else
                    v644 = (char *)&v765 + 1;
                  if ( (v641 & 1) != 0 )
                    v645 = *((_QWORD *)&v641 + 1);
                  else
                    v645 = (unsigned __int64)(unsigned __int8)v641 >> 1;
                  sub_9CFD0((size_t *)&v760, v644, v645);
                  if ( (v642 & 1) != 0 )
                    free(v643);
                  if ( (v758 & 1) != 0 )
                    free(v759);
                  --v627;
                  v628 += 48LL;
                }
                while ( v627 );
              }
            }
            sub_9CFD0((size_t *)&v760, ")", 1uLL);
            v107 = *(_QWORD *)(a3 + 8);
            if ( v738 != v732 )
            {
              v108 = v107 - 48;
              v109 = v738 - v732;
              do
              {
                if ( (*(_BYTE *)(v108 + 24) & 1) != 0 )
                  free(*(void **)(v108 + 40));
                if ( (*(_BYTE *)v108 & 1) != 0 )
                  free(*(void **)(v108 + 16));
                *(_QWORD *)(a3 + 8) = v108;
                ++v109;
                v108 -= 48LL;
              }
              while ( v109 );
              v107 += 48 * (v738 - v732);
            }
            v110 = *((_QWORD *)&v760 + 1);
            v111 = v761;
            v112 = *(_QWORD *)((char *)&v760 + 1);
            v113 = v760;
            v760 = 0uLL;
            *(_QWORD *)((char *)&v746 + 7) = v110;
            BYTE7(v746) = HIBYTE(v112);
            v114 = *(_QWORD *)((char *)&v746 + 7);
            v761 = 0LL;
            *(_QWORD *)((char *)&v765 + 7) = 0LL;
            *(_QWORD *)((char *)&v746 + 7) = 0LL;
            *(_QWORD *)((char *)&v752 + 7) = v114;
            *(_QWORD *)&v746 = 0LL;
            *(_QWORD *)&v752 = v112;
            *(_QWORD *)&v765 = 0LL;
            v115 = *(_QWORD *)(a3 + 16);
            if ( v107 < v115 )
            {
              *(_BYTE *)v107 = v113;
              *(_QWORD *)(v107 + 8) = *(_QWORD *)((char *)&v752 + 7);
              *(_QWORD *)(v107 + 16) = v111;
              *(_QWORD *)(v107 + 1) = v752;
              *(_QWORD *)((char *)&v752 + 7) = 0LL;
              *(_QWORD *)&v752 = 0LL;
              *(_BYTE *)(v107 + 24) = 0;
              *(_QWORD *)(v107 + 32) = *(_QWORD *)((char *)&v765 + 7);
              *(_QWORD *)(v107 + 40) = 0LL;
              *(_QWORD *)(v107 + 25) = v765;
              *(_QWORD *)((char *)&v765 + 7) = 0LL;
              *(_QWORD *)&v765 = 0LL;
              *(_QWORD *)(a3 + 8) += 48LL;
              if ( (v760 & 1) == 0 )
                return v726;
              goto LABEL_1114;
            }
            v622 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v107 - *(_QWORD *)a3) >> 4);
            if ( v622 + 1 > 0x555555555555555LL )
              abort();
            v623 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v115 - *(_QWORD *)a3) >> 4);
            if ( v623 >= 0x2AAAAAAAAAAAAAALL
              || ((v624 = 2 * v623, v624 >= v622 + 1) ? (v11 = v624) : (v11 = v622 + 1), v11) )
            {
              v625 = *(_QWORD *)(a3 + 24);
              v626 = *(char **)(v625 + 4096);
              if ( v625 + 4096 - (__int64)v626 >= (unsigned __int64)(48 * v11) )
                *(_QWORD *)(v625 + 4096) = &v626[48 * v11];
              else
                v626 = (char *)malloc(48 * v11);
            }
            else
            {
              v626 = 0LL;
            }
            v707 = &v626[48 * v622];
            *v707 = v113;
            *((_QWORD *)v707 + 1) = *(_QWORD *)((char *)&v752 + 7);
            *((_QWORD *)v707 + 2) = v111;
            *(_QWORD *)(v707 + 1) = v752;
            *(_QWORD *)((char *)&v752 + 7) = 0LL;
            *(_QWORD *)&v752 = 0LL;
            v707[24] = 0;
            *((_QWORD *)v707 + 4) = *(_QWORD *)((char *)&v765 + 7);
            *((_QWORD *)v707 + 5) = 0LL;
            *(_QWORD *)(v707 + 25) = v765;
            *(_QWORD *)((char *)&v765 + 7) = 0LL;
            *(_QWORD *)&v765 = 0LL;
            v709 = *(void ***)a3;
            v708 = *(void ***)(a3 + 8);
            v710 = v707 + 48;
            if ( v708 == *(void ***)a3 )
            {
              v712 = *(void ***)a3;
            }
            else
            {
              do
              {
                *((_QWORD *)v707 - 4) = *(v708 - 4);
                *((_OWORD *)v707 - 3) = *((_OWORD *)v708 - 3);
                v711 = (__int64)*(v708 - 1);
                *(v708 - 5) = 0LL;
                *(v708 - 4) = 0LL;
                *(v708 - 6) = 0LL;
                *((_QWORD *)v707 - 1) = v711;
                *(_OWORD *)(v707 - 24) = *(_OWORD *)(v708 - 3);
                *(v708 - 2) = 0LL;
                *(v708 - 1) = 0LL;
                *(v708 - 3) = 0LL;
                v708 -= 6;
                v707 -= 48;
              }
              while ( v709 != v708 );
              v712 = *(void ***)a3;
              v709 = *(void ***)(a3 + 8);
            }
            v713 = *(_QWORD *)(a3 + 16);
            *(_QWORD *)a3 = v707;
            *(_QWORD *)(a3 + 8) = v710;
            *(_QWORD *)(a3 + 16) = &v626[48 * v11];
            if ( v709 != v712 )
            {
              do
              {
                if ( (*(_BYTE *)(v709 - 3) & 1) != 0 )
                  free(*(v709 - 1));
                v714 = v709 - 6;
                if ( (*(_BYTE *)(v709 - 6) & 1) != 0 )
                  free(*(v709 - 4));
                v709 -= 6;
              }
              while ( v712 != v714 );
            }
            if ( v712 )
            {
              v715 = *(_QWORD *)(a3 + 24);
              if ( v715 + 4096 < (unsigned __int64)v712 || v715 > (unsigned __int64)v712 )
              {
                free(v712);
              }
              else if ( *(_QWORD *)(v715 + 4096) == v713 )
              {
                *(_QWORD *)(v715 + 4096) = v712;
                if ( (v760 & 1) == 0 )
                  return v726;
                goto LABEL_1114;
              }
            }
            if ( (v760 & 1) == 0 )
              return v726;
LABEL_1114:
            free(v761);
            return v726;
          }
          if ( v5 < 3 )
            return (__int64)v4;
          if ( *a1 != 115 )
            return (__int64)v4;
          if ( a1[1] != 90 )
            return (__int64)v4;
          v494 = a1 + 2;
          if ( a1[2] != 102 )
            return (__int64)v4;
          v22 = sub_A8CFC(a1 + 2, a2, a3);
          if ( (unsigned __int8 *)v22 == v494 )
            return (__int64)v4;
          v495 = *(_QWORD *)(a3 + 8);
          if ( *(_QWORD *)a3 == v495 )
            return (__int64)v4;
          v496 = *(unsigned __int8 *)(v495 - 24);
          v497 = (v496 & 1) == 0;
          v498 = v496 >> 1;
          if ( v497 )
            v499 = (void *)(v495 - 23);
          else
            v499 = *(void **)(v495 - 8);
          if ( v497 )
            v500 = v498;
          else
            v500 = *(_QWORD *)(v495 - 16);
          sub_9CFD0((size_t *)(v495 - 48), v499, v500);
          v759 = *(char **)(v495 - 32);
          v758 = *(_OWORD *)(v495 - 48);
          *(_QWORD *)(v495 - 40) = 0LL;
          *(_QWORD *)(v495 - 32) = 0LL;
          *(_QWORD *)(v495 - 48) = 0LL;
          sub_9CDD8((size_t *)&v758, 0LL, "sizeof...(", 0xAuLL);
          v501 = v759;
          v502 = v758;
          v759 = 0LL;
          v758 = 0uLL;
          v766 = v501;
          v765 = v502;
          sub_9CFD0((size_t *)&v765, ")", 1uLL);
          v503 = *(_QWORD *)((char *)&v765 + 1);
          v504 = *((_QWORD *)&v765 + 1);
          v314 = v766;
          v505 = v765;
          v766 = 0LL;
          v765 = 0uLL;
          *(_QWORD *)((char *)&v752 + 7) = v504;
          BYTE7(v752) = HIBYTE(v503);
          LOBYTE(v760) = v505;
          v316 = v503;
          v317 = *(_QWORD *)((char *)&v752 + 7);
          *(_QWORD *)&v752 = 0LL;
          *(_QWORD *)((char *)&v752 + 7) = 0LL;
LABEL_609:
          *(_QWORD *)((char *)&v760 + 1) = v316;
          *((_QWORD *)&v760 + 1) = v317;
          v761 = v314;
          v763 = 0LL;
          v764 = 0LL;
          v762 = 0LL;
          sub_A7174(*(_QWORD *)(a3 + 8) - 48LL, &v760);
          if ( (v762 & 1) != 0 )
          {
            free(v764);
            if ( (v760 & 1) == 0 )
            {
LABEL_611:
              if ( (v765 & 1) == 0 )
                goto LABEL_612;
              goto LABEL_636;
            }
          }
          else if ( (v760 & 1) == 0 )
          {
            goto LABEL_611;
          }
          free(v761);
          if ( (v765 & 1) == 0 )
          {
LABEL_612:
            if ( (v758 & 1) != 0 )
              goto LABEL_637;
            return v22;
          }
LABEL_636:
          free(v766);
          if ( (v758 & 1) != 0 )
          {
LABEL_637:
            v305 = v759;
LABEL_943:
            free(v305);
          }
          return v22;
        case 'c':
          if ( v5 < 3 )
            return (__int64)v4;
          if ( *a1 != 115 )
            return (__int64)v4;
          if ( a1[1] != 99 )
            return (__int64)v4;
          v259 = a1 + 2;
          v260 = sub_925FC(a1 + 2, a2, a3);
          v261 = v260;
          if ( (unsigned __int8 *)v260 == v259 )
            return (__int64)v4;
          v22 = sub_A20BC(v260, a2, a3);
          if ( v22 == v261 )
            return (__int64)v4;
          v262 = *(_QWORD *)(a3 + 8);
          if ( 0xAAAAAAAAAAAAAAABLL * ((v262 - *(_QWORD *)a3) >> 4) < 2 )
            return (__int64)v4;
          v263 = *(unsigned __int8 *)(v262 - 24);
          v264 = (v263 & 1) == 0;
          v265 = v263 >> 1;
          if ( v264 )
            v266 = (void *)(v262 - 23);
          else
            v266 = *(void **)(v262 - 8);
          if ( v264 )
            v267 = v265;
          else
            v267 = *(_QWORD *)(v262 - 16);
          sub_9CFD0((size_t *)(v262 - 48), v266, v267);
          v766 = *(char **)(v262 - 32);
          v765 = *(_OWORD *)(v262 - 48);
          *(_QWORD *)(v262 - 40) = 0LL;
          *(_QWORD *)(v262 - 32) = 0LL;
          *(_QWORD *)(v262 - 48) = 0LL;
          v268 = *(_QWORD *)(a3 + 8);
          v269 = (_BYTE *)(v268 - 48);
          if ( (*(_BYTE *)(v268 - 24) & 1) != 0 )
            free(*(void **)(v268 - 8));
          if ( (*v269 & 1) != 0 )
            free(*(void **)(v268 - 32));
          *(_QWORD *)(a3 + 8) = v269;
          v270 = *(unsigned __int8 *)(v268 - 72);
          v271 = (v270 & 1) == 0;
          v272 = v270 >> 1;
          if ( v271 )
            v273 = (void *)(v268 - 71);
          else
            v273 = *(void **)(v268 - 56);
          if ( v271 )
            v274 = v272;
          else
            v274 = *(_QWORD *)(v268 - 64);
          v275 = sub_9CFD0((size_t *)(v268 - 96), v273, v274);
          p = (void *)v275[2];
          v752 = *(_OWORD *)v275;
          v275[1] = 0LL;
          v275[2] = 0LL;
          *v275 = 0LL;
          sub_9CDD8((size_t *)&v752, 0LL, "static_cast<", 0xCuLL);
          v276 = p;
          v277 = v752;
          p = 0LL;
          v752 = 0uLL;
          v755 = v276;
          v754 = v277;
          sub_9CFD0((size_t *)&v754, ">(", 2uLL);
          v37 = v765;
          v278 = (char *)v755;
          v279 = v754;
          v755 = 0LL;
          v754 = 0uLL;
          v40 = v766;
          v757 = v278;
          if ( (v765 & 1) != 0 )
            v280 = v766;
          else
            v280 = (char *)&v765 + 1;
          v756 = v279;
          if ( (v765 & 1) != 0 )
            v281 = *((_QWORD *)&v765 + 1);
          else
            v281 = (unsigned __int64)(unsigned __int8)v765 >> 1;
LABEL_1053:
          sub_9CFD0((size_t *)&v756, v280, v281);
          v689 = v757;
          v690 = v756;
          v757 = 0LL;
          v756 = 0uLL;
          v759 = v689;
          v758 = v690;
          sub_9CFD0((size_t *)&v758, ")", 1uLL);
          v691 = *(_QWORD *)((char *)&v758 + 1);
          v692 = *((_QWORD *)&v758 + 1);
          v693 = v759;
          v694 = v758;
          v759 = 0LL;
          v758 = 0uLL;
          *(_QWORD *)((char *)&v748 + 7) = v692;
          BYTE7(v748) = HIBYTE(v691);
          LOBYTE(v760) = v694;
          v695 = v691;
          v696 = *(_QWORD *)((char *)&v748 + 7);
          *(_QWORD *)&v748 = 0LL;
          *(_QWORD *)((char *)&v748 + 7) = 0LL;
          *(_QWORD *)((char *)&v760 + 1) = v695;
          *((_QWORD *)&v760 + 1) = v696;
          v761 = v693;
          v763 = 0LL;
          v764 = 0LL;
          v762 = 0LL;
          sub_A7174(*(_QWORD *)(a3 + 8) - 48LL, &v760);
          if ( (v762 & 1) != 0 )
          {
            free(v764);
            if ( (v760 & 1) == 0 )
            {
LABEL_1055:
              if ( (v758 & 1) == 0 )
                goto LABEL_1056;
              goto LABEL_1062;
            }
          }
          else if ( (v760 & 1) == 0 )
          {
            goto LABEL_1055;
          }
          free(v761);
          if ( (v758 & 1) == 0 )
          {
LABEL_1056:
            if ( (v756 & 1) == 0 )
              goto LABEL_1057;
            goto LABEL_1063;
          }
LABEL_1062:
          free(v759);
          if ( (v756 & 1) == 0 )
          {
LABEL_1057:
            if ( (v754 & 1) == 0 )
              goto LABEL_1058;
            goto LABEL_1064;
          }
LABEL_1063:
          free(v757);
          if ( (v754 & 1) == 0 )
          {
LABEL_1058:
            if ( (v752 & 1) == 0 )
              goto LABEL_643;
            goto LABEL_1065;
          }
LABEL_1064:
          free(v755);
          if ( (v752 & 1) == 0 )
            goto LABEL_643;
LABEL_1065:
          free(p);
          if ( (v37 & 1) == 0 )
            return v22;
          goto LABEL_646;
        case 'p':
          if ( v5 < 3 || *a1 != 115 || a1[1] != 112 )
            return (__int64)v4;
          v13 = a1 + 2;
          v14 = sub_A20BC(a1 + 2, a2, a3);
          goto LABEL_597;
        case 'r':
          return sub_A9F34(a1, a2, a3);
        case 't':
          if ( v5 < 3 )
            return (__int64)v4;
          if ( *a1 != 115 )
            return (__int64)v4;
          if ( a1[1] != 116 )
            return (__int64)v4;
          v306 = a1 + 2;
          v22 = sub_925FC(a1 + 2, a2, a3);
          if ( (unsigned __int8 *)v22 == v306 )
            return (__int64)v4;
          v283 = *(_QWORD *)(a3 + 8);
          if ( *(_QWORD *)a3 == v283 )
            return (__int64)v4;
          v307 = *(unsigned __int8 *)(v283 - 24);
          v285 = (size_t *)(v283 - 48);
          v308 = (v307 & 1) == 0;
          v309 = v307 >> 1;
          if ( v308 )
            v288 = (void *)(v283 - 23);
          else
            v288 = *(void **)(v283 - 8);
          if ( v308 )
            v289 = v309;
          else
            v289 = *(_QWORD *)(v283 - 16);
          goto LABEL_407;
        case 'z':
          if ( v5 < 3 )
            return (__int64)v4;
          if ( *a1 != 115 )
            return (__int64)v4;
          if ( a1[1] != 122 )
            return (__int64)v4;
          v282 = a1 + 2;
          v22 = sub_A20BC(a1 + 2, a2, a3);
          if ( (unsigned __int8 *)v22 == v282 )
            return (__int64)v4;
          v283 = *(_QWORD *)(a3 + 8);
          if ( *(_QWORD *)a3 == v283 )
            return (__int64)v4;
          v284 = *(unsigned __int8 *)(v283 - 24);
          v285 = (size_t *)(v283 - 48);
          v286 = (v284 & 1) == 0;
          v287 = v284 >> 1;
          if ( v286 )
            v288 = (void *)(v283 - 23);
          else
            v288 = *(void **)(v283 - 8);
          if ( v286 )
            v289 = v287;
          else
            v289 = *(_QWORD *)(v283 - 16);
LABEL_407:
          sub_9CFD0(v285, v288, v289);
          v759 = *(char **)(v283 - 32);
          v758 = *(_OWORD *)(v283 - 48);
          *(_QWORD *)(v283 - 40) = 0LL;
          *(_QWORD *)(v283 - 32) = 0LL;
          *(_QWORD *)(v283 - 48) = 0LL;
          sub_9CDD8((size_t *)&v758, 0LL, "sizeof (", 8uLL);
          v310 = v759;
          v311 = v758;
          v759 = 0LL;
          v758 = 0uLL;
          v766 = v310;
          v765 = v311;
          sub_9CFD0((size_t *)&v765, ")", 1uLL);
          v312 = *(_QWORD *)((char *)&v765 + 1);
          v313 = *((_QWORD *)&v765 + 1);
          v314 = v766;
          v315 = v765;
          v766 = 0LL;
          v765 = 0uLL;
          *(_QWORD *)((char *)&v756 + 7) = v313;
          BYTE7(v756) = HIBYTE(v312);
          LOBYTE(v760) = v315;
          v316 = v312;
          v317 = *(_QWORD *)((char *)&v756 + 7);
          *(_QWORD *)&v756 = 0LL;
          *(_QWORD *)((char *)&v756 + 7) = 0LL;
          goto LABEL_609;
        default:
          return (__int64)v4;
      }
    case 't':
      switch ( v10[1] )
      {
        case 'e':
        case 'i':
          if ( v5 < 3 )
            return (__int64)v4;
          if ( *a1 != 116 )
            return (__int64)v4;
          v15 = a1[1];
          if ( v15 != 105 && v15 != 101 )
            return (__int64)v4;
          v16 = a1 + 2;
          v17 = a1 + 2;
          v18 = v15 == 101 ? sub_A20BC(v17, a2, a3) : sub_925FC(v17, a2, a3);
          v168 = v18;
          if ( (unsigned __int8 *)v18 == v16 )
            return (__int64)v4;
          v476 = *(_QWORD *)(a3 + 8);
          if ( *(_QWORD *)a3 == v476 )
            return (__int64)v4;
          v477 = *(unsigned __int8 *)(v476 - 24);
          v478 = (v477 & 1) == 0;
          v479 = v477 >> 1;
          if ( v478 )
            v480 = (void *)(v476 - 23);
          else
            v480 = *(void **)(v476 - 8);
          if ( v478 )
            v481 = v479;
          else
            v481 = *(_QWORD *)(v476 - 16);
          sub_9CFD0((size_t *)(v476 - 48), v480, v481);
          v759 = *(char **)(v476 - 32);
          v758 = *(_OWORD *)(v476 - 48);
          *(_QWORD *)(v476 - 40) = 0LL;
          *(_QWORD *)(v476 - 32) = 0LL;
          *(_QWORD *)(v476 - 48) = 0LL;
          sub_9CDD8((size_t *)&v758, 0LL, "typeid(", 7uLL);
          v482 = v759;
          v483 = v758;
          v759 = 0LL;
          v758 = 0uLL;
          v766 = v482;
          v765 = v483;
          sub_9CFD0((size_t *)&v765, ")", 1uLL);
          v484 = *(_QWORD *)((char *)&v765 + 1);
          v485 = *((_QWORD *)&v765 + 1);
          v486 = v766;
          v487 = v765;
          v766 = 0LL;
          v765 = 0uLL;
          *(_QWORD *)((char *)&v756 + 7) = v485;
          BYTE7(v756) = HIBYTE(v484);
          LOBYTE(v760) = v487;
          v488 = v484;
          v489 = *(_QWORD *)((char *)&v756 + 7);
          *(_QWORD *)&v756 = 0LL;
          *(_QWORD *)((char *)&v756 + 7) = 0LL;
          *(_QWORD *)((char *)&v760 + 1) = v488;
          *((_QWORD *)&v760 + 1) = v489;
          v761 = v486;
          v763 = 0LL;
          v764 = 0LL;
          v762 = 0LL;
          sub_A7174(*(_QWORD *)(a3 + 8) - 48LL, &v760);
          if ( (v762 & 1) != 0 )
          {
            free(v764);
            if ( (v760 & 1) == 0 )
            {
LABEL_663:
              if ( (v765 & 1) == 0 )
                goto LABEL_664;
              goto LABEL_732;
            }
          }
          else if ( (v760 & 1) == 0 )
          {
            goto LABEL_663;
          }
          free(v761);
          if ( (v765 & 1) == 0 )
          {
LABEL_664:
            if ( (v758 & 1) == 0 )
              return v168;
LABEL_733:
            v524 = v759;
            goto LABEL_758;
          }
LABEL_732:
          free(v766);
          if ( (v758 & 1) == 0 )
            return v168;
          goto LABEL_733;
        case 'r':
          *(_QWORD *)&v765 = 0LL;
          BYTE8(v765) = 0;
          *(_QWORD *)((char *)&v760 + 7) = 0LL;
          *(_QWORD *)&v760 = 0LL;
          qmemcpy(&v758, "throw", 5);
          v181 = *(_QWORD *)(a3 + 8);
          v182 = *(_QWORD *)(a3 + 16);
          if ( v181 >= v182 )
          {
            v389 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v181 - *(_QWORD *)a3) >> 4);
            if ( v389 + 1 > 0x555555555555555LL )
              abort();
            v390 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v182 - *(_QWORD *)a3) >> 4);
            if ( v390 >= 0x2AAAAAAAAAAAAAALL
              || ((v391 = 2 * v390, v391 >= v389 + 1) ? (v11 = v391) : (v11 = v389 + 1), v11) )
            {
              v392 = *(_QWORD *)(a3 + 24);
              v393 = *(char **)(v392 + 4096);
              if ( v392 + 4096 - (__int64)v393 >= (unsigned __int64)(48 * v11) )
                *(_QWORD *)(v392 + 4096) = &v393[48 * v11];
              else
                v393 = (char *)malloc(48 * v11);
            }
            else
            {
              v393 = 0LL;
            }
            v507 = &v393[48 * v389];
            *v507 = 10;
            *(_DWORD *)(v507 + 1) = v758;
            v508 = BYTE4(v758);
            v507[6] = 0;
            v507[5] = v508;
            *(_QWORD *)(v507 + 7) = v765;
            v509 = BYTE8(v765);
            *((_QWORD *)v507 + 2) = 0LL;
            v507[15] = v509;
            BYTE4(v758) = 0;
            LODWORD(v758) = 0;
            BYTE8(v765) = 0;
            *(_QWORD *)&v765 = 0LL;
            v507[24] = 0;
            *((_QWORD *)v507 + 4) = *(_QWORD *)((char *)&v760 + 7);
            *((_QWORD *)v507 + 5) = 0LL;
            *(_QWORD *)(v507 + 25) = v760;
            *(_QWORD *)((char *)&v760 + 7) = 0LL;
            *(_QWORD *)&v760 = 0LL;
            v511 = *(void ***)a3;
            v510 = *(void ***)(a3 + 8);
            v512 = v507 + 48;
            if ( v510 == *(void ***)a3 )
            {
              v514 = *(void ***)a3;
            }
            else
            {
              do
              {
                *((_QWORD *)v507 - 4) = *(v510 - 4);
                *((_OWORD *)v507 - 3) = *((_OWORD *)v510 - 3);
                v513 = (__int64)*(v510 - 1);
                *(v510 - 5) = 0LL;
                *(v510 - 4) = 0LL;
                *(v510 - 6) = 0LL;
                *((_QWORD *)v507 - 1) = v513;
                *(_OWORD *)(v507 - 24) = *(_OWORD *)(v510 - 3);
                *(v510 - 2) = 0LL;
                *(v510 - 1) = 0LL;
                *(v510 - 3) = 0LL;
                v510 -= 6;
                v507 -= 48;
              }
              while ( v511 != v510 );
              v514 = *(void ***)a3;
              v511 = *(void ***)(a3 + 8);
            }
            v515 = *(_QWORD *)(a3 + 16);
            *(_QWORD *)a3 = v507;
            *(_QWORD *)(a3 + 8) = v512;
            *(_QWORD *)(a3 + 16) = &v393[48 * v11];
            if ( v511 != v514 )
            {
              do
              {
                if ( (*(_BYTE *)(v511 - 3) & 1) != 0 )
                  free(*(v511 - 1));
                v516 = v511 - 6;
                if ( (*(_BYTE *)(v511 - 6) & 1) != 0 )
                  free(*(v511 - 4));
                v511 -= 6;
              }
              while ( v514 != v516 );
            }
            if ( v514 )
            {
              v517 = *(_QWORD *)(a3 + 24);
              if ( v517 + 4096 < (unsigned __int64)v514 || v517 > (unsigned __int64)v514 )
              {
                free(v514);
              }
              else if ( *(_QWORD *)(v517 + 4096) == v515 )
              {
                *(_QWORD *)(v517 + 4096) = v514;
              }
            }
          }
          else
          {
            *(_BYTE *)v181 = 10;
            *(_DWORD *)(v181 + 1) = v758;
            v183 = BYTE4(v758);
            *(_BYTE *)(v181 + 6) = 0;
            *(_BYTE *)(v181 + 5) = v183;
            *(_QWORD *)(v181 + 7) = v765;
            v184 = BYTE8(v765);
            *(_QWORD *)(v181 + 16) = 0LL;
            *(_BYTE *)(v181 + 15) = v184;
            BYTE4(v758) = 0;
            LODWORD(v758) = 0;
            BYTE8(v765) = 0;
            *(_QWORD *)&v765 = 0LL;
            *(_BYTE *)(v181 + 24) = 0;
            *(_QWORD *)(v181 + 32) = *(_QWORD *)((char *)&v760 + 7);
            *(_QWORD *)(v181 + 40) = 0LL;
            *(_QWORD *)(v181 + 25) = v760;
            *(_QWORD *)((char *)&v760 + 7) = 0LL;
            *(_QWORD *)&v760 = 0LL;
            *(_QWORD *)(a3 + 8) += 48LL;
          }
          v4 += 2;
          return (__int64)v4;
        case 'w':
          if ( v5 < 3 )
            return (__int64)v4;
          if ( *a1 != 116 )
            return (__int64)v4;
          if ( a1[1] != 119 )
            return (__int64)v4;
          v167 = a1 + 2;
          v168 = sub_A20BC(a1 + 2, a2, a3);
          if ( (unsigned __int8 *)v168 == v167 )
            return (__int64)v4;
          v169 = *(_QWORD *)(a3 + 8);
          if ( *(_QWORD *)a3 == v169 )
            return (__int64)v4;
          v170 = *(unsigned __int8 *)(v169 - 24);
          v171 = (v170 & 1) == 0;
          v172 = v170 >> 1;
          if ( v171 )
            v173 = (void *)(v169 - 23);
          else
            v173 = *(void **)(v169 - 8);
          if ( v171 )
            v174 = v172;
          else
            v174 = *(_QWORD *)(v169 - 16);
          sub_9CFD0((size_t *)(v169 - 48), v173, v174);
          v766 = *(char **)(v169 - 32);
          v765 = *(_OWORD *)(v169 - 48);
          *(_QWORD *)(v169 - 40) = 0LL;
          *(_QWORD *)(v169 - 32) = 0LL;
          *(_QWORD *)(v169 - 48) = 0LL;
          sub_9CDD8((size_t *)&v765, 0LL, "throw ", 6uLL);
          v175 = *(_QWORD *)((char *)&v765 + 1);
          v176 = *((_QWORD *)&v765 + 1);
          v177 = v766;
          v178 = v765;
          v766 = 0LL;
          v765 = 0uLL;
          *(_QWORD *)((char *)&v758 + 7) = v176;
          BYTE7(v758) = HIBYTE(v175);
          LOBYTE(v760) = v178;
          v179 = v175;
          v180 = *(_QWORD *)((char *)&v758 + 7);
          *(_QWORD *)&v758 = 0LL;
          *(_QWORD *)((char *)&v758 + 7) = 0LL;
          *(_QWORD *)((char *)&v760 + 1) = v179;
          *((_QWORD *)&v760 + 1) = v180;
          v761 = v177;
          v763 = 0LL;
          v764 = 0LL;
          v762 = 0LL;
          sub_A7174(*(_QWORD *)(a3 + 8) - 48LL, &v760);
          if ( (v762 & 1) != 0 )
          {
            free(v764);
            if ( (v760 & 1) == 0 )
            {
LABEL_231:
              if ( (v765 & 1) == 0 )
                return v168;
              goto LABEL_757;
            }
          }
          else if ( (v760 & 1) == 0 )
          {
            goto LABEL_231;
          }
          free(v761);
          if ( (v765 & 1) == 0 )
            return v168;
LABEL_757:
          v524 = v766;
LABEL_758:
          free(v524);
          return v168;
        default:
          return (__int64)v4;
      }
    default:
      return (__int64)v4;
  }
}
// 925FC: using guessed type __int64 __fastcall sub_925FC(_QWORD, _QWORD, _QWORD);
// A7174: using guessed type __int64 __fastcall sub_A7174(_QWORD, _QWORD);
// A743C: using guessed type __int64 __fastcall sub_A743C(_QWORD, _QWORD, _QWORD);
// A8CFC: using guessed type __int64 __fastcall sub_A8CFC(_QWORD, _QWORD, _QWORD);
// A9620: using guessed type __int64 __fastcall sub_A9620(_QWORD, _QWORD, _QWORD, _QWORD);
// A9B9C: using guessed type __int64 __fastcall sub_A9B9C(_QWORD, _QWORD, _QWORD, _QWORD);
// A9F34: using guessed type __int64 __fastcall sub_A9F34(_QWORD, _QWORD, _QWORD);

//----- (00000000000A7174) ----------------------------------------------------
long double __fastcall sub_A7174(unsigned __int64 *a1, __int64 a2)
{
  unsigned __int64 v4; // x24
  unsigned __int64 v5; // x22
  unsigned __int64 v6; // x23
  int v7; // w25
  unsigned __int64 v8; // x26
  _BYTE *v9; // x21
  _BYTE *v10; // x0
  _BYTE *v11; // x0
  bool v12; // cc
  _BYTE *v13; // x22
  _BYTE *v14; // x0
  long double *v15; // x22
  __int64 *v16; // x23
  __int64 v17; // x25
  unsigned __int64 v18; // x21
  unsigned __int64 v19; // x24
  int v20; // w26
  unsigned __int64 v21; // x27
  _BYTE *v22; // x19
  _BYTE *v23; // x0
  _BYTE *v24; // x0
  _BYTE *v25; // x21
  _BYTE *v26; // x0
  long double result; // q0

  if ( (*(_BYTE *)a1 & 1) == 0 )
  {
    *(_WORD *)a1 = 0;
    goto LABEL_23;
  }
  *(_BYTE *)a1[2] = 0;
  LOBYTE(v4) = *(_BYTE *)a1;
  a1[1] = 0LL;
  if ( (v4 & 1) != 0 )
  {
    v4 = *a1;
    v5 = (*a1 & 0xFFFFFFFFFFFFFFFELL) - 1;
    if ( (*a1 & 1) != 0 )
    {
      v6 = 0LL;
      v7 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    v5 = 22LL;
  }
  v6 = (unsigned __int64)((unsigned __int8)v4 & 0xFE) >> 1;
  if ( (unsigned __int8)v4 >= 0x2Eu )
  {
    v8 = ((unsigned __int8)(v6 + 16) & 0xF0) - 1LL;
    v7 = 1;
    if ( v8 == v5 )
      goto LABEL_23;
    goto LABEL_10;
  }
  v7 = 1;
LABEL_9:
  v8 = 22LL;
  if ( v5 == 22 )
    goto LABEL_23;
LABEL_10:
  if ( v8 == 22 )
  {
    v9 = (_BYTE *)a1[2];
    v10 = (char *)a1 + 1;
    if ( v7 )
      memcpy(v10, (const void *)a1[2], ((unsigned __int64)((unsigned __int8)v4 & 0xFE) >> 1) + 1);
    else
      *v10 = *v9;
    free(v9);
    *(_BYTE *)a1 = 2 * v6;
  }
  else
  {
    v11 = malloc(v8 + 1);
    v12 = v8 > v5;
    v13 = v11;
    if ( v12 || v11 )
    {
      if ( (v7 & 1) != 0 )
      {
        memcpy(v11, (char *)a1 + 1, ((unsigned __int64)((unsigned __int8)v4 & 0xFE) >> 1) + 1);
      }
      else
      {
        v14 = (_BYTE *)a1[2];
        *v13 = *v14;
        free(v14);
      }
      *a1 = (v8 + 1) | 1;
      a1[1] = v6;
      a1[2] = (unsigned __int64)v13;
    }
  }
LABEL_23:
  v15 = (long double *)(a2 + 24);
  a1[2] = *(_QWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_QWORD *)(a2 + 8) = 0LL;
  *(_QWORD *)(a2 + 16) = 0LL;
  *(_QWORD *)a2 = 0LL;
  v16 = (__int64 *)(a1 + 3);
  if ( (a1[3] & 1) == 0 )
  {
    *(_WORD *)v16 = 0;
    goto LABEL_45;
  }
  *(_BYTE *)a1[5] = 0;
  LOBYTE(v17) = *((_BYTE *)a1 + 24);
  a1[4] = 0LL;
  if ( (v17 & 1) != 0 )
  {
    v17 = *v16;
    v18 = (*v16 & 0xFFFFFFFFFFFFFFFELL) - 1;
    if ( (*v16 & 1) != 0 )
    {
      v19 = 0LL;
      v20 = 0;
      goto LABEL_31;
    }
  }
  else
  {
    v18 = 22LL;
  }
  v19 = (unsigned __int64)((unsigned __int8)v17 & 0xFE) >> 1;
  if ( (unsigned __int8)v17 < 0x2Eu )
  {
    v20 = 1;
LABEL_31:
    v21 = 22LL;
    if ( v18 == 22 )
      goto LABEL_45;
    goto LABEL_32;
  }
  v21 = ((unsigned __int8)(v19 + 16) & 0xF0) - 1LL;
  v20 = 1;
  if ( v21 == v18 )
    goto LABEL_45;
LABEL_32:
  if ( v21 == 22 )
  {
    v22 = (_BYTE *)a1[5];
    v23 = (char *)v16 + 1;
    if ( v20 )
      memcpy(v23, v22, ((unsigned __int64)((unsigned __int8)v17 & 0xFE) >> 1) + 1);
    else
      *v23 = *v22;
    free(v22);
    *(_BYTE *)v16 = 2 * v19;
  }
  else
  {
    v24 = malloc(v21 + 1);
    v12 = v21 > v18;
    v25 = v24;
    if ( v12 || v24 )
    {
      if ( (v20 & 1) != 0 )
      {
        memcpy(v24, (char *)a1 + 25, ((unsigned __int64)((unsigned __int8)v17 & 0xFE) >> 1) + 1);
      }
      else
      {
        v26 = (_BYTE *)a1[5];
        *v25 = *v26;
        free(v26);
      }
      a1[3] = (v21 + 1) | 1;
      a1[4] = v19;
      a1[5] = (unsigned __int64)v25;
    }
  }
LABEL_45:
  v16[2] = *(_QWORD *)(a2 + 40);
  result = *v15;
  *(long double *)v16 = *v15;
  *(_QWORD *)(a2 + 32) = 0LL;
  *(_QWORD *)(a2 + 40) = 0LL;
  *(_QWORD *)v15 = 0LL;
  return result;
}

//----- (00000000000A743C) ----------------------------------------------------
unsigned __int8 *__fastcall sub_A743C(unsigned __int8 *a1, unsigned __int8 *a2, __int64 *a3)
{
  unsigned __int8 *v4; // x19
  unsigned __int8 *v6; // x23
  __int64 v7; // x20
  unsigned __int8 *v8; // x22
  unsigned __int8 *v9; // x0
  unsigned __int8 *v10; // x0
  int v11; // t1
  _BYTE *v12; // x22
  __int64 v13; // x0
  int v14; // w21
  __int64 v15; // x28
  _BYTE *v16; // x23
  __int64 v17; // x22
  int v18; // w11
  char v19; // w8
  char v20; // w8
  char v21; // w12
  char v22; // w8
  char v23; // w10
  char *v24; // x8
  char *v25; // x9
  char v26; // w11
  bool v27; // cf
  int v28; // w0
  __int64 v29; // x20
  size_t v30; // x21
  char *v31; // x22
  unsigned __int8 *v32; // x0
  char *v33; // x22
  int v34; // w8
  int v35; // w21
  _BYTE *v36; // x23
  __int64 v37; // x22
  int v38; // w11
  char v39; // w8
  char v40; // w8
  char v41; // w12
  char v42; // w8
  char v43; // w10
  char *v44; // x8
  char *v45; // x9
  char v46; // w11
  int v47; // w0
  __int64 v48; // x20
  size_t v49; // x21
  char *v50; // x22
  int v51; // w21
  int v53; // w9
  char v54; // w8
  char v55; // w8
  char v56; // w10
  char v57; // w22
  int v58; // w21
  int v59; // w9
  char v60; // w8
  char v61; // w8
  char v62; // w10
  char v63; // w23
  int v64; // w21
  int v65; // w9
  char v66; // w8
  char v67; // w8
  char v68; // w10
  char v69; // w20
  int v70; // w21
  int v71; // w9
  char v72; // w8
  char v73; // w8
  char v74; // w10
  char v75; // w8
  int v76; // w0
  __int64 v77; // x8
  int v78; // w8
  unsigned __int64 v79; // x8
  unsigned __int64 v80; // x9
  char v81; // w9
  char v82; // w9
  unsigned __int8 *v84; // x23
  unsigned __int8 *v85; // x9
  int v86; // t1
  unsigned __int64 v87; // x21
  __int64 v88; // x20
  unsigned __int64 v89; // x8
  bool v90; // zf
  size_t v91; // x8
  void *v92; // x1
  size_t v93; // x2
  void *v94; // x8
  long double v95; // q0
  void *v96; // x8
  long double v97; // q0
  char *v98; // x0
  char *v99; // x8
  unsigned __int64 v100; // x9
  __int64 v101; // x9
  unsigned __int64 v102; // x21
  unsigned __int64 v103; // x9
  unsigned __int64 v104; // x9
  __int64 v105; // x9
  char *v106; // x0
  unsigned __int64 v107; // x22
  unsigned __int64 v108; // x9
  unsigned __int64 v109; // x9
  __int64 v110; // x9
  char *v111; // x0
  size_t v112; // x23
  __int64 v113; // x8
  void *v114; // x21
  __int64 v115; // x9
  char v116; // w22
  unsigned __int64 v117; // x8
  unsigned __int64 v118; // x9
  unsigned __int64 v119; // x23
  unsigned __int64 v120; // x9
  unsigned __int64 v121; // x9
  __int64 v122; // x9
  char *v123; // x0
  size_t v124; // x23
  __int64 v125; // x8
  void *v126; // x21
  __int64 v127; // x9
  char v128; // w22
  unsigned __int64 v129; // x8
  unsigned __int64 v130; // x9
  unsigned __int64 v131; // x23
  unsigned __int64 v132; // x9
  unsigned __int64 v133; // x9
  __int64 v134; // x9
  char *v135; // x0
  unsigned __int64 v136; // x9
  _OWORD *v137; // x11
  __int128 *v138; // x12
  unsigned __int64 v139; // x13
  __int128 v140; // q0
  __int128 v141; // q1
  size_t v142; // x21
  char *v143; // x22
  char *v144; // x8
  char v145; // w10
  char v146; // w10
  __int64 v147; // x11
  __int64 v148; // x22
  __int64 v149; // x10
  __int64 v150; // x12
  void *v151; // x21
  __int64 v152; // x23
  void *v153; // x20
  char *v154; // x8
  __int64 v155; // x10
  __int64 v156; // x11
  __int64 v157; // x22
  __int64 v158; // x10
  __int64 v159; // x12
  void *v160; // x20
  unsigned __int64 v161; // x8
  char v162; // t1
  char v163; // w22
  void *v164; // x21
  char *v165; // x1
  size_t v166; // x2
  __int64 v167; // x9
  __int64 v168; // x10
  void *v169; // x11
  char v170; // w8
  __int64 v171; // x8
  __int64 v172; // x9
  __int64 v173; // x8
  void *v174; // x21
  __int64 v175; // x9
  char v176; // w22
  unsigned __int64 v177; // x8
  unsigned __int64 v178; // x9
  unsigned __int64 v179; // x23
  __int64 v180; // x12
  unsigned __int64 v181; // x9
  unsigned __int64 v182; // x9
  __int64 v183; // x9
  __int64 v184; // x20
  char *v185; // x0
  char *v186; // x8
  __int64 v187; // x11
  __int64 v188; // x22
  __int64 v189; // x10
  __int64 v190; // x12
  void *v191; // x21
  __int64 v192; // x23
  void *v193; // x20
  unsigned __int64 v194; // x8
  void *v195; // x0
  char *v196; // x8
  __int64 v197; // x11
  __int64 v198; // x22
  __int64 v199; // x10
  __int64 v200; // x12
  void *v201; // x21
  __int64 v202; // x23
  void *v203; // x20
  unsigned __int64 v204; // x8
  char *v205; // x8
  char *v206; // x9
  __int64 v207; // x11
  __int64 v208; // x22
  __int64 v209; // x10
  __int64 v210; // x12
  void *v211; // x21
  __int64 v212; // x23
  void *v213; // x20
  unsigned __int64 v214; // x8
  long double v217; // [xsp+20h] [xbp-110h] BYREF
  void *p; // [xsp+30h] [xbp-100h]
  long double v219; // [xsp+40h] [xbp-F0h] BYREF
  void *v220; // [xsp+50h] [xbp-E0h]
  __int128 v221; // [xsp+58h] [xbp-D8h] BYREF
  char *v222; // [xsp+68h] [xbp-C8h]
  _BYTE v223[15]; // [xsp+70h] [xbp-C0h] BYREF
  char s[32]; // [xsp+80h] [xbp-B0h] BYREF
  __int64 v225; // [xsp+A0h] [xbp-90h]
  void *v226; // [xsp+A8h] [xbp-88h]
  _QWORD v227[2]; // [xsp+B0h] [xbp-80h]
  long double v228; // [xsp+C0h] [xbp-70h] BYREF
  void *v229; // [xsp+D0h] [xbp-60h]

  v4 = a1;
  _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  if ( a2 - a1 >= 4 && *a1 == 76 )
  {
    v6 = a1 + 1;
    v7 = 0x555555555555555LL;
    switch ( a1[1] )
    {
      case 'T':
        return v4;
      case '_':
        if ( a1[2] == 90 )
        {
          v8 = a1 + 3;
          v9 = sub_91038(a1 + 3, a2, a3);
          if ( v9 != v8 && v9 != a2 )
          {
            v11 = *v9;
            v10 = v9 + 1;
            if ( v11 == 69 )
              return v10;
          }
        }
        return v4;
      case 'a':
        v12 = a1 + 2;
        *(_DWORD *)&s[12] = 0;
        *(_QWORD *)&s[16] = 0LL;
        s[0] = 22;
        strcpy(&s[1], "signed char");
        v13 = sub_AA998(a1 + 2, a2, s, a3);
        goto LABEL_110;
      case 'b':
        if ( a1[3] != 69 )
          return v4;
        v78 = a1[2];
        if ( v78 == 49 )
        {
          WORD4(v228) = 0;
          *(_QWORD *)&v228 = 0LL;
          *(_QWORD *)&s[7] = 0LL;
          *(_QWORD *)s = 0LL;
          v79 = a3[1];
          v100 = a3[2];
          if ( v79 < v100 )
          {
            strcpy((char *)(v79 + 1), "true");
            *(_BYTE *)v79 = 8;
            v4 = a1 + 4;
            *(_WORD *)(v79 + 14) = WORD4(v228);
            v101 = *(_QWORD *)&v228;
            *(_QWORD *)(v79 + 16) = 0LL;
            *(_QWORD *)(v79 + 6) = v101;
            WORD4(v228) = 0;
            goto LABEL_133;
          }
          v107 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v79 - *a3) >> 4);
          if ( v107 + 1 > 0x555555555555555LL )
            abort();
          v108 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v100 - *a3) >> 4);
          if ( v108 >= 0x2AAAAAAAAAAAAAALL || ((v109 = 2 * v108, v109 >= v107 + 1) ? (v7 = v109) : (v7 = v107 + 1), v7) )
          {
            v110 = a3[3];
            v111 = *(char **)(v110 + 4096);
            if ( v110 + 4096 - (__int64)v111 >= (unsigned __int64)(48 * v7) )
              *(_QWORD *)(v110 + 4096) = &v111[48 * v7];
            else
              v111 = (char *)malloc(48 * v7);
          }
          else
          {
            v111 = 0LL;
          }
          v154 = &v111[48 * v107];
          *v154 = 8;
          strcpy(v154 + 1, "true");
          *((_WORD *)v154 + 7) = WORD4(v228);
          v155 = *(_QWORD *)&v228;
          *((_QWORD *)v154 + 2) = 0LL;
          *(_QWORD *)(v154 + 6) = v155;
          WORD4(v228) = 0;
          *(_QWORD *)&v228 = 0LL;
          v154[24] = 0;
          *((_QWORD *)v154 + 4) = *(_QWORD *)&s[7];
          *((_QWORD *)v154 + 5) = 0LL;
          *(_QWORD *)(v154 + 25) = *(_QWORD *)s;
          *(_QWORD *)&s[7] = 0LL;
          *(_QWORD *)s = 0LL;
          v157 = *a3;
          v156 = a3[1];
          v158 = (__int64)(v154 + 48);
          if ( v156 == *a3 )
          {
            v151 = (void *)*a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v154 - 4) = *(_QWORD *)(v156 - 32);
              *((_OWORD *)v154 - 3) = *(_OWORD *)(v156 - 48);
              v159 = *(_QWORD *)(v156 - 8);
              *(_QWORD *)(v156 - 40) = 0LL;
              *(_QWORD *)(v156 - 32) = 0LL;
              *(_QWORD *)(v156 - 48) = 0LL;
              *((_QWORD *)v154 - 1) = v159;
              *(_OWORD *)(v154 - 24) = *(_OWORD *)(v156 - 24);
              *(_QWORD *)(v156 - 16) = 0LL;
              *(_QWORD *)(v156 - 8) = 0LL;
              *(_QWORD *)(v156 - 24) = 0LL;
              v156 -= 48LL;
              v154 -= 48;
            }
            while ( v157 != v156 );
            v151 = (void *)*a3;
            v157 = a3[1];
          }
          v152 = a3[2];
          *a3 = (__int64)v154;
          a3[1] = v158;
          a3[2] = (__int64)&v111[48 * v7];
          if ( (void *)v157 != v151 )
          {
            do
            {
              if ( (*(_BYTE *)(v157 - 24) & 1) != 0 )
                free(*(void **)(v157 - 8));
              v160 = (void *)(v157 - 48);
              if ( (*(_BYTE *)(v157 - 48) & 1) != 0 )
                free(*(void **)(v157 - 32));
              v157 -= 48LL;
            }
            while ( v151 != v160 );
          }
        }
        else
        {
          if ( v78 != 48 )
            return v4;
          *(_QWORD *)&v228 = 0LL;
          BYTE8(v228) = 0;
          *(_QWORD *)&s[7] = 0LL;
          *(_QWORD *)s = 0LL;
          qmemcpy(&v219, "false", 5);
          v79 = a3[1];
          v80 = a3[2];
          if ( v79 < v80 )
          {
            *(_BYTE *)v79 = 10;
            v4 = a1 + 4;
            *(_DWORD *)(v79 + 1) = LODWORD(v219);
            v81 = BYTE4(v219);
            *(_BYTE *)(v79 + 6) = 0;
            *(_BYTE *)(v79 + 5) = v81;
            *(_QWORD *)(v79 + 7) = *(_QWORD *)&v228;
            v82 = BYTE8(v228);
            *(_QWORD *)(v79 + 16) = 0LL;
            *(_BYTE *)(v79 + 15) = v82;
            BYTE4(v219) = 0;
            LODWORD(v219) = 0;
            BYTE8(v228) = 0;
LABEL_133:
            *(_QWORD *)&v228 = 0LL;
            *(_BYTE *)(v79 + 24) = 0;
            *(_QWORD *)(v79 + 32) = *(_QWORD *)&s[7];
            *(_QWORD *)(v79 + 40) = 0LL;
            *(_QWORD *)(v79 + 25) = *(_QWORD *)s;
            *(_QWORD *)&s[7] = 0LL;
            *(_QWORD *)s = 0LL;
            a3[1] += 48LL;
            return v4;
          }
          v102 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v79 - *a3) >> 4);
          if ( v102 + 1 > 0x555555555555555LL )
            abort();
          v103 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v80 - *a3) >> 4);
          if ( v103 >= 0x2AAAAAAAAAAAAAALL || ((v104 = 2 * v103, v104 >= v102 + 1) ? (v7 = v104) : (v7 = v102 + 1), v7) )
          {
            v105 = a3[3];
            v106 = *(char **)(v105 + 4096);
            if ( v105 + 4096 - (__int64)v106 >= (unsigned __int64)(48 * v7) )
              *(_QWORD *)(v105 + 4096) = &v106[48 * v7];
            else
              v106 = (char *)malloc(48 * v7);
          }
          else
          {
            v106 = 0LL;
          }
          v144 = &v106[48 * v102];
          *v144 = 10;
          *(_DWORD *)(v144 + 1) = LODWORD(v219);
          v145 = BYTE4(v219);
          v144[6] = 0;
          v144[5] = v145;
          *(_QWORD *)(v144 + 7) = *(_QWORD *)&v228;
          v146 = BYTE8(v228);
          *((_QWORD *)v144 + 2) = 0LL;
          v144[15] = v146;
          BYTE4(v219) = 0;
          LODWORD(v219) = 0;
          BYTE8(v228) = 0;
          *(_QWORD *)&v228 = 0LL;
          v144[24] = 0;
          *((_QWORD *)v144 + 4) = *(_QWORD *)&s[7];
          *((_QWORD *)v144 + 5) = 0LL;
          *(_QWORD *)(v144 + 25) = *(_QWORD *)s;
          *(_QWORD *)&s[7] = 0LL;
          *(_QWORD *)s = 0LL;
          v148 = *a3;
          v147 = a3[1];
          v149 = (__int64)(v144 + 48);
          if ( v147 == *a3 )
          {
            v151 = (void *)*a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v144 - 4) = *(_QWORD *)(v147 - 32);
              *((_OWORD *)v144 - 3) = *(_OWORD *)(v147 - 48);
              v150 = *(_QWORD *)(v147 - 8);
              *(_QWORD *)(v147 - 40) = 0LL;
              *(_QWORD *)(v147 - 32) = 0LL;
              *(_QWORD *)(v147 - 48) = 0LL;
              *((_QWORD *)v144 - 1) = v150;
              *(_OWORD *)(v144 - 24) = *(_OWORD *)(v147 - 24);
              *(_QWORD *)(v147 - 16) = 0LL;
              *(_QWORD *)(v147 - 8) = 0LL;
              *(_QWORD *)(v147 - 24) = 0LL;
              v147 -= 48LL;
              v144 -= 48;
            }
            while ( v148 != v147 );
            v151 = (void *)*a3;
            v148 = a3[1];
          }
          v152 = a3[2];
          *a3 = (__int64)v144;
          a3[1] = v149;
          a3[2] = (__int64)&v106[48 * v7];
          if ( (void *)v148 != v151 )
          {
            do
            {
              if ( (*(_BYTE *)(v148 - 24) & 1) != 0 )
                free(*(void **)(v148 - 8));
              v153 = (void *)(v148 - 48);
              if ( (*(_BYTE *)(v148 - 48) & 1) != 0 )
                free(*(void **)(v148 - 32));
              v148 -= 48LL;
            }
            while ( v151 != v153 );
          }
        }
        if ( !v151 )
          goto LABEL_217;
        v161 = a3[3];
        if ( v161 + 4096 < (unsigned __int64)v151 || v161 > (unsigned __int64)v151 )
        {
          free(v151);
        }
        else if ( *(_QWORD *)(v161 + 4096) == v152 )
        {
          *(_QWORD *)(v161 + 4096) = v151;
          v4 += 4;
          return v4;
        }
LABEL_217:
        v4 += 4;
        return v4;
      case 'c':
        v12 = a1 + 2;
        *(_QWORD *)&s[8] = 0LL;
        *(_QWORD *)&s[16] = 0LL;
        *(_QWORD *)s = 0x7261686308LL;
        v13 = sub_AA998(a1 + 2, a2, s, a3);
        goto LABEL_110;
      case 'd':
        if ( (unsigned __int64)(a2 - (a1 + 2)) < 0x11 )
          goto LABEL_94;
        v14 = a1[2];
        v15 = 0LL;
        v16 = a1 + 3;
        v17 = -1LL;
        do
        {
          if ( !isxdigit(v14) )
            goto LABEL_94;
          v18 = (unsigned __int8)v16[v15];
          if ( (unsigned int)(v14 - 48) >= 0xA )
            v19 = 9;
          else
            v19 = 0;
          v20 = v19 + v14;
          if ( (unsigned int)(v18 - 48) >= 0xA )
            v21 = -87;
          else
            v21 = -48;
          v22 = v18 + 16 * v20 + v21;
          *((_BYTE *)&v228 + v17 + 1) = v22;
          v14 = (unsigned __int8)v16[v15 + 1];
          v15 += 2LL;
          ++v17;
        }
        while ( v15 != 16 );
        if ( v14 != 69 )
          goto LABEL_94;
        if ( (long double *)((char *)&v228 + v17) > &v228 && v17 != -1 )
        {
          v23 = LOBYTE(v228);
          LOBYTE(v228) = v22;
          *((_BYTE *)&v228 + v17) = v23;
          if ( v17 >= 3 )
          {
            v24 = (char *)&v228 + v17 - 1;
            v25 = (char *)&v228 + 2;
            do
            {
              v26 = *(v25 - 1);
              *(v25 - 1) = *v24;
              *v24-- = v26;
              v27 = v25++ >= v24;
            }
            while ( !v27 );
          }
        }
        memset(s, 0, sizeof(s));
        v28 = snprintf(s, 0x20uLL, "%a", *(double *)&v228);
        v29 = 0x555555555555555LL;
        if ( (unsigned int)v28 > 0x1F )
          goto LABEL_94;
        v30 = v28;
        v220 = 0LL;
        *(_OWORD *)&v219 = 0uLL;
        if ( (unsigned int)v28 >= 0x17 )
        {
          v112 = (v28 + 16LL) & 0xFFFFFFFFFFFFFFF0LL;
          v31 = (char *)malloc(v112);
          *((_QWORD *)&v219 + 1) = v30;
          v220 = v31;
          *(_QWORD *)&v219 = v112 | 1;
        }
        else
        {
          v31 = (char *)&v219 + 1;
          LOBYTE(v219) = 2 * v28;
          if ( !v28 )
          {
LABEL_154:
            v31[v30] = 0;
            v113 = *((_QWORD *)&v219 + 1);
            v114 = v220;
            v115 = *(_QWORD *)((char *)&v219 + 1);
            *(_QWORD *)((char *)v227 + 7) = 0LL;
            v227[0] = 0LL;
            v116 = LOBYTE(v219);
            *(_OWORD *)&v219 = 0uLL;
            *(_QWORD *)((char *)&v221 + 7) = v113;
            v220 = 0LL;
            *(_QWORD *)&v221 = v115;
            v117 = a3[1];
            v118 = a3[2];
            if ( v117 < v118 )
            {
              *(_BYTE *)v117 = v116;
              *(_QWORD *)(v117 + 8) = *(_QWORD *)((char *)&v221 + 7);
              *(_QWORD *)(v117 + 16) = v114;
              *(_QWORD *)(v117 + 1) = v221;
              *(_QWORD *)((char *)&v221 + 7) = 0LL;
              *(_QWORD *)&v221 = 0LL;
              *(_BYTE *)(v117 + 24) = 0;
              *(_QWORD *)(v117 + 32) = *(_QWORD *)((char *)v227 + 7);
              *(_QWORD *)(v117 + 40) = 0LL;
              *(_QWORD *)(v117 + 25) = v227[0];
              *(_QWORD *)((char *)v227 + 7) = 0LL;
              v227[0] = 0LL;
              a3[1] += 48LL;
              if ( (LOBYTE(v219) & 1) == 0 )
                goto LABEL_296;
LABEL_274:
              v195 = v220;
              goto LABEL_295;
            }
            v119 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v117 - *a3) >> 4);
            if ( v119 + 1 > 0x555555555555555LL )
              abort();
            v120 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v118 - *a3) >> 4);
            if ( v120 >= 0x2AAAAAAAAAAAAAALL
              || ((v121 = 2 * v120, v121 >= v119 + 1) ? (v29 = v121) : (v29 = v119 + 1), v29) )
            {
              v122 = a3[3];
              v123 = *(char **)(v122 + 4096);
              if ( v122 + 4096 - (__int64)v123 >= (unsigned __int64)(48 * v29) )
                *(_QWORD *)(v122 + 4096) = &v123[48 * v29];
              else
                v123 = (char *)malloc(48 * v29);
            }
            else
            {
              v123 = 0LL;
            }
            v186 = &v123[48 * v119];
            *v186 = v116;
            *((_QWORD *)v186 + 1) = *(_QWORD *)((char *)&v221 + 7);
            *((_QWORD *)v186 + 2) = v114;
            *(_QWORD *)(v186 + 1) = v221;
            *(_QWORD *)((char *)&v221 + 7) = 0LL;
            *(_QWORD *)&v221 = 0LL;
            v186[24] = 0;
            *((_QWORD *)v186 + 4) = *(_QWORD *)((char *)v227 + 7);
            *((_QWORD *)v186 + 5) = 0LL;
            *(_QWORD *)(v186 + 25) = v227[0];
            *(_QWORD *)((char *)v227 + 7) = 0LL;
            v227[0] = 0LL;
            v188 = *a3;
            v187 = a3[1];
            v189 = (__int64)(v186 + 48);
            if ( v187 == *a3 )
            {
              v191 = (void *)*a3;
            }
            else
            {
              do
              {
                *((_QWORD *)v186 - 4) = *(_QWORD *)(v187 - 32);
                *((_OWORD *)v186 - 3) = *(_OWORD *)(v187 - 48);
                v190 = *(_QWORD *)(v187 - 8);
                *(_QWORD *)(v187 - 40) = 0LL;
                *(_QWORD *)(v187 - 32) = 0LL;
                *(_QWORD *)(v187 - 48) = 0LL;
                *((_QWORD *)v186 - 1) = v190;
                *(_OWORD *)(v186 - 24) = *(_OWORD *)(v187 - 24);
                *(_QWORD *)(v187 - 16) = 0LL;
                *(_QWORD *)(v187 - 8) = 0LL;
                *(_QWORD *)(v187 - 24) = 0LL;
                v187 -= 48LL;
                v186 -= 48;
              }
              while ( v188 != v187 );
              v191 = (void *)*a3;
              v188 = a3[1];
            }
            v192 = a3[2];
            *a3 = (__int64)v186;
            a3[1] = v189;
            a3[2] = (__int64)&v123[48 * v29];
            if ( (void *)v188 != v191 )
            {
              do
              {
                if ( (*(_BYTE *)(v188 - 24) & 1) != 0 )
                  free(*(void **)(v188 - 8));
                v193 = (void *)(v188 - 48);
                if ( (*(_BYTE *)(v188 - 48) & 1) != 0 )
                  free(*(void **)(v188 - 32));
                v188 -= 48LL;
              }
              while ( v191 != v193 );
            }
            if ( v191 )
            {
              v194 = a3[3];
              if ( v194 + 4096 < (unsigned __int64)v191 || v194 > (unsigned __int64)v191 )
              {
                free(v191);
              }
              else if ( *(_QWORD *)(v194 + 4096) == v192 )
              {
                *(_QWORD *)(v194 + 4096) = v191;
                if ( (LOBYTE(v219) & 1) == 0 )
                  goto LABEL_296;
                goto LABEL_274;
              }
            }
            if ( (LOBYTE(v219) & 1) == 0 )
              goto LABEL_296;
            goto LABEL_274;
          }
        }
        memcpy(v31, s, v30);
        goto LABEL_154;
      case 'e':
        if ( (unsigned __int64)(a2 - (a1 + 2)) < 0x21 )
          goto LABEL_94;
        v35 = a1[2];
        v15 = 0LL;
        v36 = a1 + 3;
        v37 = -1LL;
        do
        {
          if ( !isxdigit(v35) )
            goto LABEL_94;
          v38 = (unsigned __int8)v36[v15];
          if ( (unsigned int)(v35 - 48) >= 0xA )
            v39 = 9;
          else
            v39 = 0;
          v40 = v39 + v35;
          if ( (unsigned int)(v38 - 48) >= 0xA )
            v41 = -87;
          else
            v41 = -48;
          v42 = v38 + 16 * v40 + v41;
          *((_BYTE *)&v219 + v37 + 1) = v42;
          v35 = (unsigned __int8)v36[v15 + 1];
          v15 += 2LL;
          ++v37;
        }
        while ( v15 != 32 );
        if ( v35 != 69 )
          goto LABEL_94;
        if ( (long double *)((char *)&v219 + v37) > &v219 && v37 != -1 )
        {
          v43 = LOBYTE(v219);
          LOBYTE(v219) = v42;
          *((_BYTE *)&v219 + v37) = v43;
          if ( v37 >= 3 )
          {
            v44 = (char *)&v219 + v37 - 1;
            v45 = (char *)&v219 + 2;
            do
            {
              v46 = *(v45 - 1);
              *(v45 - 1) = *v44;
              *v44-- = v46;
              v27 = v45++ >= v44;
            }
            while ( !v27 );
          }
        }
        memset(s, 0, sizeof(s));
        v225 = 0LL;
        v47 = snprintf(s, 0x28uLL, "%LaL", v219);
        v48 = 0x555555555555555LL;
        if ( (unsigned int)v47 > 0x27 )
        {
LABEL_94:
          v77 = 2LL;
          goto LABEL_95;
        }
        v49 = v47;
        v229 = 0LL;
        *(_OWORD *)&v228 = 0uLL;
        if ( (unsigned int)v47 >= 0x17 )
        {
          v124 = (v47 + 16LL) & 0xFFFFFFFFFFFFFFF0LL;
          v50 = (char *)malloc(v124);
          *((_QWORD *)&v228 + 1) = v49;
          v229 = v50;
          *(_QWORD *)&v228 = v124 | 1;
        }
        else
        {
          v50 = (char *)&v228 + 1;
          LOBYTE(v228) = 2 * v47;
          if ( !v47 )
            goto LABEL_167;
        }
        memcpy(v50, s, v49);
LABEL_167:
        v50[v49] = 0;
        v125 = *((_QWORD *)&v228 + 1);
        v126 = v229;
        v127 = *(_QWORD *)((char *)&v228 + 1);
        *(_QWORD *)((char *)v227 + 7) = 0LL;
        v227[0] = 0LL;
        v128 = LOBYTE(v228);
        *(_OWORD *)&v228 = 0uLL;
        v229 = 0LL;
        *(_QWORD *)((char *)&v221 + 7) = v125;
        *(_QWORD *)&v221 = v127;
        v129 = a3[1];
        v130 = a3[2];
        if ( v129 < v130 )
        {
          *(_BYTE *)v129 = v128;
          *(_QWORD *)(v129 + 8) = *(_QWORD *)((char *)&v221 + 7);
          *(_QWORD *)(v129 + 16) = v126;
          *(_QWORD *)(v129 + 1) = v221;
          *(_QWORD *)((char *)&v221 + 7) = 0LL;
          *(_QWORD *)&v221 = 0LL;
          *(_BYTE *)(v129 + 24) = 0;
          *(_QWORD *)(v129 + 32) = *(_QWORD *)((char *)v227 + 7);
          *(_QWORD *)(v129 + 40) = 0LL;
          *(_QWORD *)(v129 + 25) = v227[0];
          *(_QWORD *)((char *)v227 + 7) = 0LL;
          v227[0] = 0LL;
          a3[1] += 48LL;
          if ( (LOBYTE(v228) & 1) == 0 )
            goto LABEL_296;
          goto LABEL_294;
        }
        v131 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v129 - *a3) >> 4);
        if ( v131 + 1 > 0x555555555555555LL )
          abort();
        v132 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v130 - *a3) >> 4);
        if ( v132 >= 0x2AAAAAAAAAAAAAALL || ((v133 = 2 * v132, v133 >= v131 + 1) ? (v48 = v133) : (v48 = v131 + 1), v48) )
        {
          v134 = a3[3];
          v135 = *(char **)(v134 + 4096);
          if ( v134 + 4096 - (__int64)v135 >= (unsigned __int64)(48 * v48) )
            *(_QWORD *)(v134 + 4096) = &v135[48 * v48];
          else
            v135 = (char *)malloc(48 * v48);
        }
        else
        {
          v135 = 0LL;
        }
        v196 = &v135[48 * v131];
        *v196 = v128;
        *((_QWORD *)v196 + 1) = *(_QWORD *)((char *)&v221 + 7);
        *((_QWORD *)v196 + 2) = v126;
        *(_QWORD *)(v196 + 1) = v221;
        *(_QWORD *)((char *)&v221 + 7) = 0LL;
        *(_QWORD *)&v221 = 0LL;
        v196[24] = 0;
        *((_QWORD *)v196 + 4) = *(_QWORD *)((char *)v227 + 7);
        *((_QWORD *)v196 + 5) = 0LL;
        *(_QWORD *)(v196 + 25) = v227[0];
        *(_QWORD *)((char *)v227 + 7) = 0LL;
        v227[0] = 0LL;
        v198 = *a3;
        v197 = a3[1];
        v199 = (__int64)(v196 + 48);
        if ( v197 == *a3 )
        {
          v201 = (void *)*a3;
        }
        else
        {
          do
          {
            *((_QWORD *)v196 - 4) = *(_QWORD *)(v197 - 32);
            *((_OWORD *)v196 - 3) = *(_OWORD *)(v197 - 48);
            v200 = *(_QWORD *)(v197 - 8);
            *(_QWORD *)(v197 - 40) = 0LL;
            *(_QWORD *)(v197 - 32) = 0LL;
            *(_QWORD *)(v197 - 48) = 0LL;
            *((_QWORD *)v196 - 1) = v200;
            *(_OWORD *)(v196 - 24) = *(_OWORD *)(v197 - 24);
            *(_QWORD *)(v197 - 16) = 0LL;
            *(_QWORD *)(v197 - 8) = 0LL;
            *(_QWORD *)(v197 - 24) = 0LL;
            v197 -= 48LL;
            v196 -= 48;
          }
          while ( v198 != v197 );
          v201 = (void *)*a3;
          v198 = a3[1];
        }
        v202 = a3[2];
        *a3 = (__int64)v196;
        a3[1] = v199;
        a3[2] = (__int64)&v135[48 * v48];
        if ( (void *)v198 != v201 )
        {
          do
          {
            if ( (*(_BYTE *)(v198 - 24) & 1) != 0 )
              free(*(void **)(v198 - 8));
            v203 = (void *)(v198 - 48);
            if ( (*(_BYTE *)(v198 - 48) & 1) != 0 )
              free(*(void **)(v198 - 32));
            v198 -= 48LL;
          }
          while ( v201 != v203 );
        }
        if ( !v201 )
          goto LABEL_293;
        v204 = a3[3];
        if ( v204 + 4096 < (unsigned __int64)v201 || v204 > (unsigned __int64)v201 )
        {
          free(v201);
        }
        else if ( *(_QWORD *)(v204 + 4096) == v202 )
        {
          *(_QWORD *)(v204 + 4096) = v201;
          if ( (LOBYTE(v228) & 1) == 0 )
            goto LABEL_296;
          goto LABEL_294;
        }
LABEL_293:
        if ( (LOBYTE(v228) & 1) == 0 )
          goto LABEL_296;
LABEL_294:
        v195 = v229;
LABEL_295:
        free(v195);
LABEL_296:
        v77 = v15 + 3;
LABEL_95:
        if ( v77 != 2 )
          v4 += v77;
        return v4;
      case 'f':
        if ( (unsigned __int64)(a2 - (a1 + 2)) < 9 )
          goto LABEL_94;
        v51 = a1[2];
        if ( !isxdigit(v51) )
          goto LABEL_94;
        v53 = v4[3];
        v54 = (unsigned int)(v51 - 48) >= 0xA ? 9 : 0;
        v55 = v54 + v51;
        v56 = (unsigned int)(v53 - 48) >= 0xA ? -87 : -48;
        v57 = v53 + 16 * v55 + v56;
        LOBYTE(v228) = v57;
        v58 = v4[4];
        if ( !isxdigit(v58) )
          goto LABEL_94;
        v59 = v4[5];
        v60 = (unsigned int)(v58 - 48) >= 0xA ? 9 : 0;
        v61 = v60 + v58;
        v62 = (unsigned int)(v59 - 48) >= 0xA ? -87 : -48;
        v63 = v59 + 16 * v61 + v62;
        BYTE1(v228) = v63;
        v64 = v4[6];
        if ( !isxdigit(v64) )
          goto LABEL_94;
        v65 = v4[7];
        v66 = (unsigned int)(v64 - 48) >= 0xA ? 9 : 0;
        v67 = v66 + v64;
        v68 = (unsigned int)(v65 - 48) >= 0xA ? -87 : -48;
        v69 = v65 + 16 * v67 + v68;
        BYTE2(v228) = v69;
        v70 = v4[8];
        if ( !isxdigit(v70) )
          goto LABEL_94;
        v71 = v4[9];
        v72 = (unsigned int)(v70 - 48) >= 0xA ? 9 : 0;
        v73 = v72 + v70;
        v74 = (unsigned int)(v71 - 48) >= 0xA ? -87 : -48;
        v75 = v71 + 16 * v73 + v74;
        BYTE3(v228) = v75;
        if ( v4[10] != 69 )
          goto LABEL_94;
        LOBYTE(v228) = v75;
        BYTE3(v228) = v57;
        BYTE1(v228) = v69;
        BYTE2(v228) = v63;
        memset(s, 0, 24);
        v76 = snprintf(s, 0x18uLL, "%af", *(float *)&v228);
        if ( (unsigned int)v76 > 0x17 )
          goto LABEL_94;
        v142 = v76;
        p = 0LL;
        *(_OWORD *)&v217 = 0uLL;
        if ( v76 == 23 )
        {
          v143 = (char *)malloc(0x20uLL);
          *((_QWORD *)&v217 + 1) = v142;
          p = v143;
          *(_QWORD *)&v217 = 33LL;
        }
        else
        {
          v143 = (char *)&v217 + 1;
          LOBYTE(v217) = 2 * v76;
          if ( !v76 )
            goto LABEL_244;
        }
        memcpy(v143, s, v142);
LABEL_244:
        v143[v142] = 0;
        v173 = *((_QWORD *)&v217 + 1);
        v174 = p;
        v175 = *(_QWORD *)((char *)&v217 + 1);
        *(_QWORD *)((char *)v227 + 7) = 0LL;
        v227[0] = 0LL;
        v176 = LOBYTE(v217);
        *(_OWORD *)&v217 = 0uLL;
        p = 0LL;
        *(_QWORD *)((char *)&v221 + 7) = v173;
        *(_QWORD *)&v221 = v175;
        v177 = a3[1];
        v178 = a3[2];
        if ( v177 < v178 )
        {
          *(_BYTE *)v177 = v176;
          *(_QWORD *)(v177 + 8) = *(_QWORD *)((char *)&v221 + 7);
          *(_QWORD *)(v177 + 16) = v174;
          *(_QWORD *)(v177 + 1) = v221;
          *(_QWORD *)((char *)&v221 + 7) = 0LL;
          *(_QWORD *)&v221 = 0LL;
          *(_BYTE *)(v177 + 24) = 0;
          *(_QWORD *)(v177 + 32) = *(_QWORD *)((char *)v227 + 7);
          *(_QWORD *)(v177 + 40) = 0LL;
          *(_QWORD *)(v177 + 25) = v227[0];
          *(_QWORD *)((char *)v227 + 7) = 0LL;
          v227[0] = 0LL;
          a3[1] += 48LL;
          if ( (LOBYTE(v217) & 1) == 0 )
            goto LABEL_318;
          goto LABEL_317;
        }
        v179 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v177 - *a3) >> 4);
        v180 = 0x555555555555555LL;
        if ( v179 + 1 > 0x555555555555555LL )
          abort();
        v181 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v178 - *a3) >> 4);
        if ( v181 >= 0x2AAAAAAAAAAAAAALL
          || ((v182 = 2 * v181, v182 >= v179 + 1) ? (v180 = v182) : (v180 = v179 + 1), v180) )
        {
          v183 = a3[3];
          v184 = v180;
          v185 = *(char **)(v183 + 4096);
          if ( v183 + 4096 - (__int64)v185 >= (unsigned __int64)(48 * v180) )
            *(_QWORD *)(v183 + 4096) = &v185[48 * v180];
          else
            v185 = (char *)malloc(48 * v180);
          v180 = v184;
        }
        else
        {
          v185 = 0LL;
        }
        v205 = &v185[48 * v179];
        *v205 = v176;
        v206 = &v185[48 * v180];
        *((_QWORD *)v205 + 1) = *(_QWORD *)((char *)&v221 + 7);
        *((_QWORD *)v205 + 2) = v174;
        *(_QWORD *)(v205 + 1) = v221;
        *(_QWORD *)((char *)&v221 + 7) = 0LL;
        *(_QWORD *)&v221 = 0LL;
        v205[24] = 0;
        *((_QWORD *)v205 + 4) = *(_QWORD *)((char *)v227 + 7);
        *((_QWORD *)v205 + 5) = 0LL;
        *(_QWORD *)(v205 + 25) = v227[0];
        *(_QWORD *)((char *)v227 + 7) = 0LL;
        v227[0] = 0LL;
        v208 = *a3;
        v207 = a3[1];
        v209 = (__int64)(v205 + 48);
        if ( v207 == *a3 )
        {
          v211 = (void *)*a3;
        }
        else
        {
          do
          {
            *((_QWORD *)v205 - 4) = *(_QWORD *)(v207 - 32);
            *((_OWORD *)v205 - 3) = *(_OWORD *)(v207 - 48);
            v210 = *(_QWORD *)(v207 - 8);
            *(_QWORD *)(v207 - 40) = 0LL;
            *(_QWORD *)(v207 - 32) = 0LL;
            *(_QWORD *)(v207 - 48) = 0LL;
            *((_QWORD *)v205 - 1) = v210;
            *(_OWORD *)(v205 - 24) = *(_OWORD *)(v207 - 24);
            *(_QWORD *)(v207 - 16) = 0LL;
            *(_QWORD *)(v207 - 8) = 0LL;
            *(_QWORD *)(v207 - 24) = 0LL;
            v207 -= 48LL;
            v205 -= 48;
          }
          while ( v208 != v207 );
          v211 = (void *)*a3;
          v208 = a3[1];
        }
        v212 = a3[2];
        *a3 = (__int64)v205;
        a3[1] = v209;
        a3[2] = (__int64)v206;
        if ( (void *)v208 != v211 )
        {
          do
          {
            if ( (*(_BYTE *)(v208 - 24) & 1) != 0 )
              free(*(void **)(v208 - 8));
            v213 = (void *)(v208 - 48);
            if ( (*(_BYTE *)(v208 - 48) & 1) != 0 )
              free(*(void **)(v208 - 32));
            v208 -= 48LL;
          }
          while ( v211 != v213 );
        }
        if ( !v211 )
          goto LABEL_316;
        v214 = a3[3];
        if ( v214 + 4096 < (unsigned __int64)v211 || v214 > (unsigned __int64)v211 )
        {
          free(v211);
        }
        else if ( *(_QWORD *)(v214 + 4096) == v212 )
        {
          *(_QWORD *)(v214 + 4096) = v211;
          if ( (LOBYTE(v217) & 1) == 0 )
            goto LABEL_318;
          goto LABEL_317;
        }
LABEL_316:
        if ( (LOBYTE(v217) & 1) == 0 )
          goto LABEL_318;
LABEL_317:
        free(p);
LABEL_318:
        v77 = 11LL;
        goto LABEL_95;
      case 'h':
        v12 = a1 + 2;
        s[15] = 0;
        *(_QWORD *)&s[16] = 0LL;
        s[0] = 26;
        strcpy(&s[1], "unsigned char");
        v13 = sub_AA998(a1 + 2, a2, s, a3);
        goto LABEL_110;
      case 'i':
        v12 = a1 + 2;
        memset(s, 0, 24);
        v13 = sub_AA998(a1 + 2, a2, s, a3);
        goto LABEL_110;
      case 'j':
        v12 = a1 + 2;
        *(_QWORD *)&s[8] = 0LL;
        *(_QWORD *)&s[16] = 0LL;
        *(_QWORD *)s = 29954LL;
        v13 = sub_AA998(a1 + 2, a2, s, a3);
        goto LABEL_110;
      case 'l':
        v12 = a1 + 2;
        *(_QWORD *)&s[8] = 0LL;
        *(_QWORD *)&s[16] = 0LL;
        *(_QWORD *)s = 27650LL;
        v13 = sub_AA998(a1 + 2, a2, s, a3);
        goto LABEL_110;
      case 'm':
        v12 = a1 + 2;
        *(_QWORD *)&s[8] = 0LL;
        *(_QWORD *)&s[16] = 0LL;
        *(_QWORD *)s = 7107844LL;
        v13 = sub_AA998(a1 + 2, a2, s, a3);
        goto LABEL_110;
      case 'n':
        v12 = a1 + 2;
        s[9] = 0;
        *(_WORD *)&s[10] = 0;
        *(_DWORD *)&s[12] = 0;
        *(_QWORD *)&s[16] = 0LL;
        s[0] = 16;
        strcpy(&s[1], "__int12");
        v13 = sub_AA998(a1 + 2, a2, s, a3);
        goto LABEL_110;
      case 'o':
        v12 = a1 + 2;
        strcpy(&s[17], "8");
        s[19] = 0;
        *(_DWORD *)&s[20] = 0;
        strcpy(s, "\"unsigned __int1");
        v13 = sub_AA998(a1 + 2, a2, s, a3);
        goto LABEL_110;
      case 's':
        v12 = a1 + 2;
        *(_QWORD *)&s[8] = 0LL;
        *(_QWORD *)&s[16] = 0LL;
        *(_QWORD *)s = 0x74726F68730ALL;
        v13 = sub_AA998(a1 + 2, a2, s, a3);
        goto LABEL_110;
      case 't':
        v12 = a1 + 2;
        *(_QWORD *)&s[16] = 0LL;
        s[0] = 28;
        strcpy(&s[1], "unsigned short");
        v13 = sub_AA998(a1 + 2, a2, s, a3);
        goto LABEL_110;
      case 'w':
        v12 = a1 + 2;
        *(_QWORD *)&s[16] = 0LL;
        s[0] = 14;
        strcpy(&s[1], "wchar_t");
        s[9] = 0;
        *(_WORD *)&s[10] = 0;
        *(_DWORD *)&s[12] = 0;
        v13 = sub_AA998(a1 + 2, a2, s, a3);
        goto LABEL_110;
      case 'x':
        v12 = a1 + 2;
        *(_QWORD *)&s[8] = 0LL;
        *(_QWORD *)&s[16] = 0LL;
        *(_QWORD *)s = 7105540LL;
        v13 = sub_AA998(a1 + 2, a2, s, a3);
        goto LABEL_110;
      case 'y':
        v12 = a1 + 2;
        *(_QWORD *)&s[8] = 0LL;
        *(_QWORD *)&s[16] = 0LL;
        *(_QWORD *)s = 1819047174LL;
        v13 = sub_AA998(a1 + 2, a2, s, a3);
LABEL_110:
        if ( (_BYTE *)v13 != v12 )
          return (unsigned __int8 *)v13;
        return v4;
      default:
        v32 = (unsigned __int8 *)sub_925FC(a1 + 1, a2, a3);
        v33 = (char *)v32;
        if ( v32 == v6 || v32 == a2 )
          return v4;
        v34 = *v32;
        if ( v34 == 69 )
          return v32 + 1;
        v84 = v32;
        if ( (unsigned int)(v34 - 48) > 9 )
          goto LABEL_118;
        v85 = v32 + 1;
        do
        {
          if ( a2 == v85 )
            return v4;
          v86 = *v85++;
          v34 = v86;
        }
        while ( (unsigned int)(v86 - 48) < 0xA );
        v84 = v85 - 1;
LABEL_118:
        v87 = v84 - v32;
        if ( v84 == v32 )
          return v4;
        if ( v34 != 69 )
          return v4;
        v88 = a3[1];
        if ( *a3 == v88 )
          return v4;
        v89 = *(unsigned __int8 *)(v88 - 24);
        v90 = (v89 & 1) == 0;
        v91 = v89 >> 1;
        if ( v90 )
          v92 = (void *)(v88 - 23);
        else
          v92 = *(void **)(v88 - 8);
        if ( v90 )
          v93 = v91;
        else
          v93 = *(_QWORD *)(v88 - 16);
        sub_9CFD0((size_t *)(v88 - 48), v92, v93);
        p = *(void **)(v88 - 32);
        v217 = *(long double *)(v88 - 48);
        *(_QWORD *)(v88 - 40) = 0LL;
        *(_QWORD *)(v88 - 32) = 0LL;
        *(_QWORD *)(v88 - 48) = 0LL;
        sub_9CDD8((size_t *)&v217, 0LL, "(", 1uLL);
        v94 = p;
        v95 = v217;
        p = 0LL;
        *(_OWORD *)&v217 = 0uLL;
        v220 = v94;
        v219 = v95;
        sub_9CFD0((size_t *)&v219, ")", 1uLL);
        v96 = v220;
        v97 = v219;
        v220 = 0LL;
        *(_OWORD *)&v219 = 0uLL;
        v222 = 0LL;
        v229 = v96;
        v228 = v97;
        v221 = 0uLL;
        if ( v87 >= 0xFFFFFFFFFFFFFFF0LL )
          abort();
        if ( v87 > 0x16 )
        {
          v98 = (char *)malloc((v87 + 16) & 0xFFFFFFFFFFFFFFF0LL);
          *((_QWORD *)&v221 + 1) = v84 - (unsigned __int8 *)v33;
          v222 = v98;
          *(_QWORD *)&v221 = (v87 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
          if ( v87 >= 0x20 )
          {
            v136 = v87 & 0xFFFFFFFFFFFFFFE0LL;
            if ( (v87 & 0xFFFFFFFFFFFFFFE0LL) != 0 )
            {
              if ( v98 >= (char *)v84 || (v99 = v98, v33 >= &v98[v87]) )
              {
                v99 = &v98[v136];
                v137 = v98 + 16;
                v138 = (__int128 *)(v33 + 16);
                v139 = v87 & 0xFFFFFFFFFFFFFFE0LL;
                do
                {
                  v140 = *(v138 - 1);
                  v141 = *v138;
                  v139 -= 32LL;
                  v138 += 2;
                  *(v137 - 1) = v140;
                  *v137 = v141;
                  v137 += 2;
                }
                while ( v139 );
                v33 += v136;
                if ( v136 == v87 )
                {
LABEL_222:
                  v98[v87] = 0;
                  v163 = v221;
                  v164 = v222;
                  if ( (v221 & 1) != 0 )
                    v165 = v222;
                  else
                    v165 = (char *)&v221 + 1;
                  if ( (v221 & 1) != 0 )
                    v166 = *((_QWORD *)&v221 + 1);
                  else
                    v166 = (unsigned __int64)(unsigned __int8)v221 >> 1;
                  sub_9CFD0((size_t *)&v228, v165, v166);
                  v167 = *(_QWORD *)((char *)&v228 + 1);
                  v168 = *((_QWORD *)&v228 + 1);
                  v169 = v229;
                  v170 = LOBYTE(v228);
                  v229 = 0LL;
                  *(_OWORD *)&v228 = 0uLL;
                  *(_QWORD *)&v223[7] = v168;
                  v223[7] = HIBYTE(v167);
                  s[0] = v170;
                  v171 = v167;
                  v172 = *(_QWORD *)&v223[7];
                  memset(v223, 0, sizeof(v223));
                  *(_QWORD *)&s[1] = v171;
                  *(_QWORD *)&s[8] = v172;
                  *(_QWORD *)&s[16] = v169;
                  v225 = 0LL;
                  v226 = 0LL;
                  *(_QWORD *)&s[24] = 0LL;
                  sub_A7174((unsigned __int64 *)(a3[1] - 48), (__int64)s);
                  if ( (s[24] & 1) != 0 )
                  {
                    free(v226);
                    if ( (s[0] & 1) == 0 )
                    {
LABEL_230:
                      if ( (v163 & 1) == 0 )
                        goto LABEL_231;
                      goto LABEL_238;
                    }
                  }
                  else if ( (s[0] & 1) == 0 )
                  {
                    goto LABEL_230;
                  }
                  free(*(void **)&s[16]);
                  if ( (v163 & 1) == 0 )
                  {
LABEL_231:
                    if ( (LOBYTE(v228) & 1) == 0 )
                      goto LABEL_232;
                    goto LABEL_239;
                  }
LABEL_238:
                  free(v164);
                  if ( (LOBYTE(v228) & 1) == 0 )
                  {
LABEL_232:
                    if ( (LOBYTE(v219) & 1) == 0 )
                      goto LABEL_233;
                    goto LABEL_240;
                  }
LABEL_239:
                  free(v229);
                  if ( (LOBYTE(v219) & 1) == 0 )
                  {
LABEL_233:
                    if ( (LOBYTE(v217) & 1) == 0 )
                      return v84 + 1;
LABEL_234:
                    free(p);
                    return v84 + 1;
                  }
LABEL_240:
                  free(v220);
                  if ( (LOBYTE(v217) & 1) == 0 )
                    return v84 + 1;
                  goto LABEL_234;
                }
              }
            }
            else
            {
              v99 = v98;
            }
            do
            {
LABEL_221:
              v162 = *v33++;
              *v99++ = v162;
            }
            while ( v84 != (unsigned __int8 *)v33 );
            goto LABEL_222;
          }
        }
        else
        {
          LOBYTE(v221) = 2 * v87;
          v98 = (char *)&v221 + 1;
        }
        v99 = v98;
        goto LABEL_221;
    }
  }
  return v4;
}
// A7E8C: conditional instruction was optimized away because x21.8<17u
// 925FC: using guessed type __int64 __fastcall sub_925FC(_QWORD, _QWORD, _QWORD);
// AA998: using guessed type __int64 __fastcall sub_AA998(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000000A8CFC) ----------------------------------------------------
unsigned __int8 *__fastcall sub_A8CFC(unsigned __int8 *result, unsigned __int8 *a2, void **a3)
{
  int v4; // w8
  __int64 v5; // x22
  unsigned __int8 *v6; // x8
  int v7; // w9
  int v8; // t1
  unsigned __int8 *v9; // x25
  unsigned __int8 *v10; // x8
  unsigned __int8 *v11; // x24
  int v12; // w9
  unsigned __int8 *v13; // x8
  unsigned __int8 *v14; // x9
  int v15; // w10
  unsigned __int8 *v16; // x8
  int v17; // t1
  unsigned __int8 *v18; // x9
  int v19; // w10
  int v20; // t1
  unsigned __int8 *v21; // x25
  unsigned __int8 *v22; // x8
  int v23; // w9
  unsigned __int8 *v24; // x8
  int v25; // t1
  unsigned __int64 v26; // x26
  unsigned __int8 *v27; // x0
  unsigned __int8 *v28; // x8
  unsigned __int64 v29; // x9
  _OWORD *v30; // x11
  __int128 *v31; // x12
  unsigned __int64 v32; // x13
  __int128 v33; // q0
  __int128 v34; // q1
  unsigned __int8 *v35; // x8
  int v36; // t1
  unsigned __int64 v37; // x26
  unsigned __int8 *v38; // x0
  unsigned __int8 v39; // t1
  __int64 v40; // x8
  __int64 v41; // x9
  void *v42; // x20
  char v43; // w25
  __int64 v44; // x8
  __int64 v45; // x9
  _QWORD *v46; // x8
  _BYTE *v47; // x9
  __int64 v48; // x9
  __int64 v49; // x9
  unsigned __int64 v50; // x26
  unsigned __int64 v51; // x9
  unsigned __int64 v52; // x9
  _QWORD *v53; // x9
  char *v54; // x0
  char *v55; // x8
  char *v56; // x9
  void **v57; // x11
  void **v58; // x23
  char *v59; // x10
  __int64 v60; // x12
  void **v61; // x20
  void *v62; // x22
  void **v63; // x25
  unsigned __int64 v64; // x8
  unsigned __int8 *v65; // x8
  unsigned __int64 v66; // x9
  _OWORD *v67; // x11
  __int128 *v68; // x12
  unsigned __int64 v69; // x13
  __int128 v70; // q0
  __int128 v71; // q1
  unsigned __int8 v72; // t1
  __int64 v73; // x8
  __int64 v74; // x9
  __int64 v75; // x8
  __int64 v76; // x9
  _BYTE *v77; // x9
  unsigned __int64 v78; // x26
  unsigned __int64 v79; // x9
  unsigned __int64 v80; // x9
  _QWORD *v81; // x9
  char *v82; // x0
  char *v83; // x8
  char *v84; // x9
  void **v85; // x11
  void **v86; // x23
  char *v87; // x10
  __int64 v88; // x12
  void **v89; // x25
  __int128 v90; // [xsp+0h] [xbp-A0h] BYREF
  void *p; // [xsp+10h] [xbp-90h]
  _QWORD v92[4]; // [xsp+18h] [xbp-88h] BYREF
  _QWORD v93[2]; // [xsp+38h] [xbp-68h] BYREF
  _QWORD v94[3]; // [xsp+48h] [xbp-58h] BYREF

  v94[2] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a2 - result < 3 || *result != 102 )
    return result;
  v4 = result[1];
  v5 = 0x555555555555555LL;
  if ( v4 == 76 )
  {
    v13 = result + 2;
    if ( result + 2 == a2 )
      return result;
    if ( result[2] == 110 )
      v14 = result + 3;
    else
      v14 = result + 2;
    if ( v14 != a2 )
    {
      v15 = *v14;
      if ( v15 == 48 )
      {
        v13 = v14 + 1;
        if ( v14 + 1 == a2 )
          return result;
        goto LABEL_34;
      }
      if ( (unsigned int)(v15 - 49) <= 8 )
      {
        v16 = v14 + 1;
        do
        {
          if ( a2 == v16 )
            return result;
          v17 = *v16++;
        }
        while ( (unsigned int)(v17 - 48) < 0xA );
        v13 = v16 - 1;
      }
    }
    if ( v13 == a2 )
      return result;
LABEL_34:
    if ( *v13 != 112 )
      return result;
    v18 = v13 + 1;
    if ( v13 + 1 == a2 )
      return result;
    v19 = *v18;
    if ( v19 == 114 )
    {
      v19 = v13[2];
      v18 = v13 + 2;
    }
    if ( v19 == 86 )
    {
      v20 = *++v18;
      v19 = v20;
    }
    v21 = v19 == 75 ? v18 + 1 : v18;
    if ( v21 == a2 )
      return result;
    v22 = v21 + 1;
    v11 = v21;
    if ( *v21 != 110 )
      v22 = v21;
    if ( v22 != a2 )
    {
      v23 = *v22;
      if ( v23 == 48 )
      {
        v11 = v22 + 1;
        if ( v22 + 1 == a2 )
          return result;
        goto LABEL_77;
      }
      v11 = v21;
      if ( (unsigned int)(v23 - 49) <= 8 )
      {
        v35 = v22 + 1;
        do
        {
          if ( a2 == v35 )
            return result;
          v36 = *v35++;
        }
        while ( (unsigned int)(v36 - 48) < 0xA );
        v11 = v35 - 1;
      }
    }
    if ( v11 == a2 )
      return result;
LABEL_77:
    if ( *v11 != 95 )
      return result;
    v37 = v11 - v21;
    p = 0LL;
    v90 = 0uLL;
    if ( (unsigned __int64)(v11 - v21) >= 0xFFFFFFFFFFFFFFF0LL )
      goto LABEL_156;
    if ( v37 > 0x16 )
    {
      v38 = (unsigned __int8 *)malloc((v37 + 16) & 0xFFFFFFFFFFFFFFF0LL);
      *((_QWORD *)&v90 + 1) = v11 - v21;
      p = v38;
      *(_QWORD *)&v90 = (v37 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
      if ( v21 == v11 )
        goto LABEL_127;
    }
    else
    {
      LOBYTE(v90) = 2 * v37;
      v38 = (unsigned __int8 *)&v90 + 1;
      if ( v21 == v11 )
      {
LABEL_127:
        *v38 = 0;
        sub_9CDD8((size_t *)&v90, 0LL, "fp", 2uLL);
        v73 = *(_QWORD *)((char *)&v90 + 1);
        v74 = *((_QWORD *)&v90 + 1);
        v42 = p;
        v43 = v90;
        p = 0LL;
        v90 = 0uLL;
        *(_QWORD *)((char *)v92 + 7) = v74;
        v92[0] = v73;
        v75 = *(_QWORD *)((char *)v92 + 7);
        v76 = v92[0];
        memset(v93, 0, 15);
        memset(v92, 0, 15);
        *(_QWORD *)((char *)v94 + 7) = v75;
        v94[0] = v76;
        v46 = a3[1];
        v77 = a3[2];
        if ( v46 < (_QWORD *)v77 )
        {
LABEL_86:
          *(_BYTE *)v46 = v43;
          v46[1] = *(_QWORD *)((char *)v94 + 7);
          v48 = v94[0];
          v46[2] = v42;
          *(_QWORD *)((char *)v46 + 1) = v48;
          memset(v94, 0, 15);
          *((_BYTE *)v46 + 24) = 0;
          v46[4] = *(_QWORD *)((char *)v93 + 7);
          v49 = v93[0];
          v46[5] = 0LL;
          *(_QWORD *)((char *)v46 + 25) = v49;
          memset(v93, 0, 15);
          a3[1] = (char *)a3[1] + 48;
          if ( (v90 & 1) == 0 )
            return v11 + 1;
          goto LABEL_153;
        }
        v78 = 0xAAAAAAAAAAAAAAABLL * (((char *)v46 - (_BYTE *)*a3) >> 4);
        if ( v78 + 1 > 0x555555555555555LL )
          abort();
        v79 = 0xAAAAAAAAAAAAAAABLL * ((v77 - (_BYTE *)*a3) >> 4);
        if ( v79 >= 0x2AAAAAAAAAAAAAALL || ((v80 = 2 * v79, v80 >= v78 + 1) ? (v5 = v80) : (v5 = v78 + 1), v5) )
        {
          v81 = a3[3];
          v82 = (char *)v81[512];
          if ( (char *)(v81 + 512) - v82 >= (unsigned __int64)(48 * v5) )
            v81[512] = &v82[48 * v5];
          else
            v82 = (char *)malloc(48 * v5);
        }
        else
        {
          v82 = 0LL;
        }
        v83 = &v82[48 * v78];
        *v83 = v43;
        v84 = &v82[48 * v5];
        *((_QWORD *)v83 + 1) = *(_QWORD *)((char *)v94 + 7);
        *((_QWORD *)v83 + 2) = v42;
        *(_QWORD *)(v83 + 1) = v94[0];
        memset(v94, 0, 15);
        v83[24] = 0;
        *((_QWORD *)v83 + 4) = *(_QWORD *)((char *)v93 + 7);
        *((_QWORD *)v83 + 5) = 0LL;
        *(_QWORD *)(v83 + 25) = v93[0];
        memset(v93, 0, 15);
        v86 = (void **)*a3;
        v85 = (void **)a3[1];
        v87 = v83 + 48;
        if ( v85 == *a3 )
        {
          v61 = (void **)*a3;
        }
        else
        {
          do
          {
            *((_QWORD *)v83 - 4) = *(v85 - 4);
            *((_OWORD *)v83 - 3) = *((_OWORD *)v85 - 3);
            v88 = (__int64)*(v85 - 1);
            *(v85 - 5) = 0LL;
            *(v85 - 4) = 0LL;
            *(v85 - 6) = 0LL;
            *((_QWORD *)v83 - 1) = v88;
            *(_OWORD *)(v83 - 24) = *(_OWORD *)(v85 - 3);
            *(v85 - 2) = 0LL;
            *(v85 - 1) = 0LL;
            *(v85 - 3) = 0LL;
            v85 -= 6;
            v83 -= 48;
          }
          while ( v86 != v85 );
          v61 = (void **)*a3;
          v86 = (void **)a3[1];
        }
        v62 = a3[2];
        *a3 = v83;
        a3[1] = v87;
        a3[2] = v84;
        if ( v86 != v61 )
        {
          do
          {
            if ( (*(_BYTE *)(v86 - 3) & 1) != 0 )
              free(*(v86 - 1));
            v89 = v86 - 6;
            if ( (*(_BYTE *)(v86 - 6) & 1) != 0 )
              free(*(v86 - 4));
            v86 -= 6;
          }
          while ( v61 != v89 );
        }
        if ( !v61 )
          goto LABEL_152;
        v64 = (unsigned __int64)a3[3];
        if ( v64 + 4096 >= (unsigned __int64)v61 && v64 <= (unsigned __int64)v61 )
        {
LABEL_111:
          if ( *(void **)(v64 + 4096) == v62 )
          {
            *(_QWORD *)(v64 + 4096) = v61;
            if ( (v90 & 1) == 0 )
              return v11 + 1;
            goto LABEL_153;
          }
LABEL_152:
          if ( (v90 & 1) == 0 )
            return v11 + 1;
LABEL_153:
          free(p);
          return v11 + 1;
        }
LABEL_151:
        free(v61);
        goto LABEL_152;
      }
    }
    if ( v37 >= 0x20 )
    {
      v66 = v37 & 0xFFFFFFFFFFFFFFE0LL;
      if ( (v37 & 0xFFFFFFFFFFFFFFE0LL) != 0 )
      {
        if ( v38 >= v11 || (v65 = v38, v21 >= &v11[v38 - v21]) )
        {
          v65 = &v38[v66];
          v67 = v38 + 16;
          v68 = (__int128 *)(v21 + 16);
          v69 = v37 & 0xFFFFFFFFFFFFFFE0LL;
          do
          {
            v70 = *(v68 - 1);
            v71 = *v68;
            v69 -= 32LL;
            v68 += 2;
            *(v67 - 1) = v70;
            *v67 = v71;
            v67 += 2;
          }
          while ( v69 );
          v21 += v66;
          if ( v66 == v37 )
            goto LABEL_126;
        }
      }
      else
      {
        v65 = v38;
      }
    }
    else
    {
      v65 = v38;
    }
    do
    {
      v72 = *v21++;
      *v65++ = v72;
    }
    while ( v11 != v21 );
LABEL_126:
    v38 += v37;
    goto LABEL_127;
  }
  if ( v4 == 112 )
  {
    v6 = result + 2;
    if ( result + 2 != a2 )
    {
      v7 = *v6;
      if ( v7 == 114 )
      {
        v6 = result + 3;
        v7 = result[3];
      }
      if ( v7 == 86 )
      {
        v8 = *++v6;
        v7 = v8;
      }
      v9 = v7 == 75 ? v6 + 1 : v6;
      if ( v9 != a2 )
      {
        v10 = v9 + 1;
        v11 = v9;
        if ( *v9 != 110 )
          v10 = v9;
        if ( v10 != a2 )
        {
          v12 = *v10;
          if ( v12 == 48 )
          {
            v11 = v10 + 1;
            if ( v10 + 1 == a2 )
              return result;
            goto LABEL_56;
          }
          v11 = v9;
          if ( (unsigned int)(v12 - 49) <= 8 )
          {
            v24 = v10 + 1;
            do
            {
              if ( a2 == v24 )
                return result;
              v25 = *v24++;
            }
            while ( (unsigned int)(v25 - 48) < 0xA );
            v11 = v24 - 1;
          }
        }
        if ( v11 == a2 )
          return result;
LABEL_56:
        if ( *v11 != 95 )
          return result;
        v26 = v11 - v9;
        p = 0LL;
        v90 = 0uLL;
        if ( (unsigned __int64)(v11 - v9) < 0xFFFFFFFFFFFFFFF0LL )
        {
          if ( v26 > 0x16 )
          {
            v27 = (unsigned __int8 *)malloc((v26 + 16) & 0xFFFFFFFFFFFFFFF0LL);
            *((_QWORD *)&v90 + 1) = v11 - v9;
            p = v27;
            *(_QWORD *)&v90 = (v26 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
            if ( v9 == v11 )
              goto LABEL_85;
          }
          else
          {
            LOBYTE(v90) = 2 * v26;
            v27 = (unsigned __int8 *)&v90 + 1;
            if ( v9 == v11 )
            {
LABEL_85:
              *v27 = 0;
              sub_9CDD8((size_t *)&v90, 0LL, "fp", 2uLL);
              v40 = *(_QWORD *)((char *)&v90 + 1);
              v41 = *((_QWORD *)&v90 + 1);
              v42 = p;
              v43 = v90;
              p = 0LL;
              v90 = 0uLL;
              *(_QWORD *)((char *)&v92[2] + 7) = v41;
              v92[2] = v40;
              v44 = *(_QWORD *)((char *)&v92[2] + 7);
              v45 = v92[2];
              memset(v93, 0, 15);
              memset(&v92[2], 0, 15);
              *(_QWORD *)((char *)v94 + 7) = v44;
              v94[0] = v45;
              v46 = a3[1];
              v47 = a3[2];
              if ( v46 < (_QWORD *)v47 )
                goto LABEL_86;
              v50 = 0xAAAAAAAAAAAAAAABLL * (((char *)v46 - (_BYTE *)*a3) >> 4);
              if ( v50 + 1 > 0x555555555555555LL )
                abort();
              v51 = 0xAAAAAAAAAAAAAAABLL * ((v47 - (_BYTE *)*a3) >> 4);
              if ( v51 >= 0x2AAAAAAAAAAAAAALL || ((v52 = 2 * v51, v52 >= v50 + 1) ? (v5 = v52) : (v5 = v50 + 1), v5) )
              {
                v53 = a3[3];
                v54 = (char *)v53[512];
                if ( (char *)(v53 + 512) - v54 >= (unsigned __int64)(48 * v5) )
                  v53[512] = &v54[48 * v5];
                else
                  v54 = (char *)malloc(48 * v5);
              }
              else
              {
                v54 = 0LL;
              }
              v55 = &v54[48 * v50];
              *v55 = v43;
              v56 = &v54[48 * v5];
              *((_QWORD *)v55 + 1) = *(_QWORD *)((char *)v94 + 7);
              *((_QWORD *)v55 + 2) = v42;
              *(_QWORD *)(v55 + 1) = v94[0];
              memset(v94, 0, 15);
              v55[24] = 0;
              *((_QWORD *)v55 + 4) = *(_QWORD *)((char *)v93 + 7);
              *((_QWORD *)v55 + 5) = 0LL;
              *(_QWORD *)(v55 + 25) = v93[0];
              memset(v93, 0, 15);
              v58 = (void **)*a3;
              v57 = (void **)a3[1];
              v59 = v55 + 48;
              if ( v57 == *a3 )
              {
                v61 = (void **)*a3;
              }
              else
              {
                do
                {
                  *((_QWORD *)v55 - 4) = *(v57 - 4);
                  *((_OWORD *)v55 - 3) = *((_OWORD *)v57 - 3);
                  v60 = (__int64)*(v57 - 1);
                  *(v57 - 5) = 0LL;
                  *(v57 - 4) = 0LL;
                  *(v57 - 6) = 0LL;
                  *((_QWORD *)v55 - 1) = v60;
                  *(_OWORD *)(v55 - 24) = *(_OWORD *)(v57 - 3);
                  *(v57 - 2) = 0LL;
                  *(v57 - 1) = 0LL;
                  *(v57 - 3) = 0LL;
                  v57 -= 6;
                  v55 -= 48;
                }
                while ( v58 != v57 );
                v61 = (void **)*a3;
                v58 = (void **)a3[1];
              }
              v62 = a3[2];
              *a3 = v55;
              a3[1] = v59;
              a3[2] = v56;
              if ( v58 != v61 )
              {
                do
                {
                  if ( (*(_BYTE *)(v58 - 3) & 1) != 0 )
                    free(*(v58 - 1));
                  v63 = v58 - 6;
                  if ( (*(_BYTE *)(v58 - 6) & 1) != 0 )
                    free(*(v58 - 4));
                  v58 -= 6;
                }
                while ( v61 != v63 );
              }
              if ( !v61 )
                goto LABEL_152;
              v64 = (unsigned __int64)a3[3];
              if ( v64 + 4096 >= (unsigned __int64)v61 && v64 <= (unsigned __int64)v61 )
                goto LABEL_111;
              goto LABEL_151;
            }
          }
          if ( v26 >= 0x20 )
          {
            v29 = v26 & 0xFFFFFFFFFFFFFFE0LL;
            if ( (v26 & 0xFFFFFFFFFFFFFFE0LL) != 0 )
            {
              if ( v27 >= v11 || (v28 = v27, v9 >= &v11[v27 - v9]) )
              {
                v28 = &v27[v29];
                v30 = v27 + 16;
                v31 = (__int128 *)(v9 + 16);
                v32 = v26 & 0xFFFFFFFFFFFFFFE0LL;
                do
                {
                  v33 = *(v31 - 1);
                  v34 = *v31;
                  v32 -= 32LL;
                  v31 += 2;
                  *(v30 - 1) = v33;
                  *v30 = v34;
                  v30 += 2;
                }
                while ( v32 );
                v9 += v29;
                if ( v29 == v26 )
                  goto LABEL_84;
              }
            }
            else
            {
              v28 = v27;
            }
          }
          else
          {
            v28 = v27;
          }
          do
          {
            v39 = *v9++;
            *v28++ = v39;
          }
          while ( v11 != v9 );
LABEL_84:
          v27 += v26;
          goto LABEL_85;
        }
LABEL_156:
        abort();
      }
    }
  }
  return result;
}

//----- (00000000000A9620) ----------------------------------------------------
__int64 __fastcall sub_A9620(unsigned __int8 *a1, unsigned __int8 *a2, unsigned __int8 *a3, _QWORD *a4)
{
  unsigned __int8 *v7; // x22
  unsigned __int8 *v8; // x0
  unsigned __int8 *v9; // x23
  __int64 v10; // x19
  __int64 v11; // x25
  unsigned __int64 v12; // x8
  bool v13; // zf
  size_t v14; // x8
  void *v15; // x1
  size_t v16; // x2
  __int64 v17; // x22
  _BYTE *v18; // x25
  unsigned __int64 v19; // x8
  bool v20; // zf
  size_t v21; // x8
  void *v22; // x1
  size_t v23; // x2
  size_t *v24; // x0
  __int64 v25; // x8
  size_t *v26; // x21
  __int64 v27; // x19
  _BYTE *v28; // x20
  unsigned __int64 v29; // x8
  unsigned __int64 v30; // x9
  unsigned __int8 *v31; // x8
  void *v32; // x8
  __int128 v33; // q0
  unsigned __int64 v34; // x8
  bool v35; // zf
  size_t v36; // x8
  void *v37; // x1
  size_t v38; // x2
  void *v39; // x8
  __int128 v40; // q0
  char v41; // w25
  void *v42; // x8
  __int128 v43; // q0
  void *v44; // x22
  char *v45; // x1
  size_t v46; // x2
  void *v47; // x8
  __int128 v48; // q0
  char *v49; // x8
  __int128 v50; // q0
  char v51; // w26
  char *v52; // x23
  char *v53; // x1
  size_t v54; // x2
  unsigned __int64 v55; // x8
  unsigned __int64 v56; // x9
  unsigned __int8 *v57; // x8
  __int128 v59; // [xsp+8h] [xbp-148h] BYREF
  void *p; // [xsp+18h] [xbp-138h]
  __int128 v61; // [xsp+20h] [xbp-130h] BYREF
  void *v62; // [xsp+30h] [xbp-120h]
  __int128 v63; // [xsp+40h] [xbp-110h] BYREF
  void *v64; // [xsp+50h] [xbp-100h]
  __int128 v65; // [xsp+60h] [xbp-F0h] BYREF
  void *v66; // [xsp+70h] [xbp-E0h]
  __int128 v67; // [xsp+80h] [xbp-D0h] BYREF
  void *v68; // [xsp+90h] [xbp-C0h]
  __int128 v69; // [xsp+A0h] [xbp-B0h] BYREF
  char *v70; // [xsp+B0h] [xbp-A0h]
  __int128 v71; // [xsp+C0h] [xbp-90h] BYREF
  void *v72; // [xsp+D0h] [xbp-80h]
  __int128 v73; // [xsp+E0h] [xbp-70h] BYREF
  char *v74; // [xsp+F0h] [xbp-60h]

  v7 = a1;
  _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v8 = (unsigned __int8 *)sub_A20BC(a1, a2, (__int64)a4);
  v9 = v8;
  if ( v8 == v7 )
    return (__int64)v7;
  v10 = sub_A20BC(v8, a2, (__int64)a4);
  if ( (unsigned __int8 *)v10 != v9 )
  {
    v11 = a4[1];
    if ( 0xAAAAAAAAAAAAAAABLL * ((v11 - *a4) >> 4) < 2 )
      return (__int64)v7;
    v12 = *(unsigned __int8 *)(v11 - 24);
    v13 = (v12 & 1) == 0;
    v14 = v12 >> 1;
    if ( v13 )
      v15 = (void *)(v11 - 23);
    else
      v15 = *(void **)(v11 - 8);
    if ( v13 )
      v16 = v14;
    else
      v16 = *(_QWORD *)(v11 - 16);
    sub_9CFD0((size_t *)(v11 - 48), v15, v16);
    v74 = *(char **)(v11 - 32);
    v73 = *(_OWORD *)(v11 - 48);
    *(_QWORD *)(v11 - 40) = 0LL;
    *(_QWORD *)(v11 - 32) = 0LL;
    *(_QWORD *)(v11 - 48) = 0LL;
    v17 = a4[1];
    v18 = (_BYTE *)(v17 - 48);
    if ( (*(_BYTE *)(v17 - 24) & 1) != 0 )
      free(*(void **)(v17 - 8));
    if ( (*v18 & 1) != 0 )
      free(*(void **)(v17 - 32));
    a4[1] = v18;
    v19 = *(unsigned __int8 *)(v17 - 72);
    v20 = (v19 & 1) == 0;
    v21 = v19 >> 1;
    if ( v20 )
      v22 = (void *)(v17 - 71);
    else
      v22 = *(void **)(v17 - 56);
    if ( v20 )
      v23 = v21;
    else
      v23 = *(_QWORD *)(v17 - 64);
    v24 = sub_9CFD0((size_t *)(v17 - 96), v22, v23);
    v72 = (void *)v24[2];
    v71 = *(_OWORD *)v24;
    v24[1] = 0LL;
    v24[2] = 0LL;
    *v24 = 0LL;
    v25 = a4[1];
    v26 = (size_t *)(v25 - 48);
    if ( (*(_BYTE *)(v25 - 48) & 1) != 0 )
    {
      **(_BYTE **)(v25 - 32) = 0;
      *(_QWORD *)(v25 - 40) = 0LL;
    }
    else
    {
      *(_WORD *)v26 = 0;
    }
    v29 = *a3;
    v30 = *((_QWORD *)a3 + 1);
    if ( (v29 & 1) == 0 )
      v30 = v29 >> 1;
    if ( v30 == 1 )
    {
      v31 = (v29 & 1) != 0 ? (unsigned __int8 *)*((_QWORD *)a3 + 2) : a3 + 1;
      if ( *v31 == 62 )
        sub_B23DC(v26, 40LL);
    }
    sub_9F8F0("(", (unsigned __int8 *)&v71, (size_t *)&v59);
    sub_9CFD0((size_t *)&v59, ") ", 2uLL);
    v32 = p;
    v33 = v59;
    p = 0LL;
    v59 = 0uLL;
    v62 = v32;
    v61 = v33;
    v34 = *a3;
    v35 = (v34 & 1) == 0;
    v36 = v34 >> 1;
    if ( v35 )
      v37 = a3 + 1;
    else
      v37 = (void *)*((_QWORD *)a3 + 2);
    if ( v35 )
      v38 = v36;
    else
      v38 = *((_QWORD *)a3 + 1);
    sub_9CFD0((size_t *)&v61, v37, v38);
    v39 = v62;
    v40 = v61;
    v62 = 0LL;
    v61 = 0uLL;
    v64 = v39;
    v63 = v40;
    sub_9CFD0((size_t *)&v63, " (", 2uLL);
    v41 = v73;
    v42 = v64;
    v43 = v63;
    v64 = 0LL;
    v63 = 0uLL;
    v44 = v74;
    v66 = v42;
    if ( (v73 & 1) != 0 )
      v45 = v74;
    else
      v45 = (char *)&v73 + 1;
    v65 = v43;
    if ( (v73 & 1) != 0 )
      v46 = *((_QWORD *)&v73 + 1);
    else
      v46 = (unsigned __int64)(unsigned __int8)v73 >> 1;
    sub_9CFD0((size_t *)&v65, v45, v46);
    v47 = v66;
    v48 = v65;
    v66 = 0LL;
    v65 = 0uLL;
    v68 = v47;
    v67 = v48;
    sub_9CFD0((size_t *)&v67, ")", 1uLL);
    v49 = (char *)v68;
    v50 = v67;
    v68 = 0LL;
    v67 = 0uLL;
    v70 = v49;
    v69 = v50;
    v51 = v50;
    v52 = v49;
    if ( (v50 & 1) != 0 )
      v53 = v70;
    else
      v53 = (char *)&v69 + 1;
    if ( (v69 & 1) != 0 )
      v54 = *((_QWORD *)&v69 + 1);
    else
      v54 = (unsigned __int64)(unsigned __int8)v69 >> 1;
    sub_9CFD0(v26, v53, v54);
    if ( (v51 & 1) != 0 )
    {
      free(v52);
      if ( (v67 & 1) == 0 )
      {
LABEL_57:
        if ( (v65 & 1) == 0 )
          goto LABEL_58;
        goto LABEL_78;
      }
    }
    else if ( (v67 & 1) == 0 )
    {
      goto LABEL_57;
    }
    free(v68);
    if ( (v65 & 1) == 0 )
    {
LABEL_58:
      if ( (v63 & 1) == 0 )
        goto LABEL_59;
      goto LABEL_79;
    }
LABEL_78:
    free(v66);
    if ( (v63 & 1) == 0 )
    {
LABEL_59:
      if ( (v61 & 1) == 0 )
        goto LABEL_60;
      goto LABEL_80;
    }
LABEL_79:
    free(v64);
    if ( (v61 & 1) == 0 )
    {
LABEL_60:
      if ( (v59 & 1) == 0 )
      {
LABEL_62:
        v55 = *a3;
        v56 = *((_QWORD *)a3 + 1);
        if ( (v55 & 1) == 0 )
          v56 = v55 >> 1;
        if ( v56 == 1 )
        {
          v57 = (v55 & 1) != 0 ? (unsigned __int8 *)*((_QWORD *)a3 + 2) : a3 + 1;
          if ( *v57 == 62 )
            sub_B23DC(v26, 41LL);
        }
        if ( (v71 & 1) != 0 )
          free(v72);
        if ( (v41 & 1) != 0 )
          free(v44);
        return v10;
      }
LABEL_61:
      free(p);
      goto LABEL_62;
    }
LABEL_80:
    free(v62);
    if ( (v59 & 1) == 0 )
      goto LABEL_62;
    goto LABEL_61;
  }
  v27 = a4[1];
  if ( *a4 != v27 )
  {
    v28 = (_BYTE *)(v27 - 48);
    if ( (*(_BYTE *)(v27 - 24) & 1) != 0 )
      free(*(void **)(v27 - 8));
    if ( (*v28 & 1) != 0 )
      free(*(void **)(v27 - 32));
    a4[1] = v28;
  }
  return (__int64)v7;
}
// B23DC: using guessed type __int64 __fastcall sub_B23DC(_QWORD, _QWORD);

//----- (00000000000A9B9C) ----------------------------------------------------
__int64 __fastcall sub_A9B9C(unsigned __int8 *a1, unsigned __int8 *a2, int a3, _QWORD *a4)
{
  unsigned __int8 *v6; // x20
  __int64 v7; // x19
  __int64 v8; // x8
  unsigned __int64 v9; // x9
  size_t v10; // x10
  void *v11; // x11
  size_t *v12; // x0
  void *v13; // x8
  bool v14; // zf
  size_t v15; // x9
  void *v16; // x1
  size_t v17; // x2
  size_t *v18; // x0
  void *v19; // x25
  char *v20; // x1
  size_t v21; // x2
  void *v22; // x8
  __int128 v23; // q0
  void *v24; // x26
  char v25; // w10
  __int64 v26; // x27
  __int64 *v27; // x22
  const void **v28; // x28
  __int64 v29; // x20
  unsigned __int64 v30; // x21
  unsigned __int64 v31; // x9
  int v32; // w8
  unsigned __int64 v33; // x25
  _BYTE *v34; // x21
  _BYTE *v35; // x0
  _BYTE *v36; // x0
  bool v37; // cc
  _BYTE *v38; // x21
  void *v39; // x0
  unsigned __int64 v41; // [xsp+8h] [xbp-D8h]
  char v42; // [xsp+14h] [xbp-CCh]
  unsigned __int64 v43; // [xsp+18h] [xbp-C8h]
  char v44; // [xsp+24h] [xbp-BCh]
  void *v45; // [xsp+28h] [xbp-B8h]
  __int128 v46; // [xsp+30h] [xbp-B0h] BYREF
  char *v47; // [xsp+40h] [xbp-A0h]
  __int128 v48; // [xsp+48h] [xbp-98h] BYREF
  void *p; // [xsp+58h] [xbp-88h]
  __int128 v50; // [xsp+60h] [xbp-80h] BYREF
  void *v51; // [xsp+70h] [xbp-70h]
  _QWORD v52[3]; // [xsp+78h] [xbp-68h] BYREF

  v6 = a1;
  v52[2] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v7 = sub_A20BC(a1, a2, (__int64)a4);
  if ( (unsigned __int8 *)v7 != v6 && *a4 != a4[1] )
  {
    sub_AB28C((__int64 *)&v48, a3, "(");
    v8 = a4[1];
    v9 = *(unsigned __int8 *)(v8 - 24);
    v10 = *(_QWORD *)(v8 - 16);
    v11 = *(void **)(v8 - 8);
    v12 = (size_t *)(v8 - 48);
    v13 = (void *)(v8 - 23);
    v14 = (v9 & 1) == 0;
    v15 = v9 >> 1;
    if ( v14 )
      v16 = v13;
    else
      v16 = v11;
    if ( v14 )
      v17 = v15;
    else
      v17 = v10;
    v18 = sub_9CFD0(v12, v16, v17);
    v47 = (char *)v18[2];
    v46 = *(_OWORD *)v18;
    v18[1] = 0LL;
    v18[2] = 0LL;
    *v18 = 0LL;
    v19 = v47;
    if ( (v46 & 1) != 0 )
      v20 = v47;
    else
      v20 = (char *)&v46 + 1;
    if ( (v46 & 1) != 0 )
      v21 = *((_QWORD *)&v46 + 1);
    else
      v21 = (unsigned __int64)(unsigned __int8)v46 >> 1;
    sub_9CFD0((size_t *)&v48, v20, v21);
    v22 = p;
    v23 = v48;
    p = 0LL;
    v48 = 0uLL;
    v51 = v22;
    v50 = v23;
    sub_9CFD0((size_t *)&v50, ")", 1uLL);
    v24 = v51;
    v25 = v50;
    v51 = 0LL;
    *(_QWORD *)((char *)v52 + 7) = *((_QWORD *)&v50 + 1);
    v52[0] = *(_QWORD *)((char *)&v50 + 1);
    v50 = 0uLL;
    v26 = a4[1];
    v27 = (__int64 *)(v26 - 48);
    if ( (*(_BYTE *)(v26 - 48) & 1) == 0 )
    {
      *(_WORD *)(v26 - 48) = 0;
      v28 = (const void **)(v26 - 32);
      goto LABEL_39;
    }
    v28 = (const void **)(v26 - 32);
    **(_BYTE **)(v26 - 32) = 0;
    LOBYTE(v29) = *(_BYTE *)(v26 - 48);
    *(_QWORD *)(v26 - 40) = 0LL;
    if ( (v29 & 1) != 0 )
    {
      v29 = *v27;
      v30 = (*v27 & 0xFFFFFFFFFFFFFFFELL) - 1;
      v45 = v19;
      if ( (*v27 & 1) != 0 )
      {
        v31 = 0LL;
        v32 = 0;
        goto LABEL_23;
      }
    }
    else
    {
      v30 = 22LL;
      v45 = v19;
    }
    v31 = (unsigned __int64)((unsigned __int8)v29 & 0xFE) >> 1;
    if ( (unsigned __int8)v29 >= 0x2Eu )
    {
      v33 = ((unsigned __int8)(v31 + 16) & 0xF0) - 1LL;
      v32 = 1;
      if ( v33 == v30 )
        goto LABEL_24;
      goto LABEL_26;
    }
    v32 = 1;
LABEL_23:
    v33 = 22LL;
    if ( v30 == 22 )
    {
LABEL_24:
      v19 = v45;
      goto LABEL_39;
    }
LABEL_26:
    v44 = v25;
    v43 = v31;
    if ( v33 == 22 )
    {
      v34 = *v28;
      v35 = (_BYTE *)(v26 - 47);
      if ( v32 )
        memcpy(v35, *v28, ((unsigned __int64)((unsigned __int8)v29 & 0xFE) >> 1) + 1);
      else
        *v35 = *v34;
      free(v34);
      v19 = v45;
      *(_BYTE *)v27 = 2 * v43;
    }
    else
    {
      v42 = v32;
      v41 = v33 + 1;
      v36 = malloc(v33 + 1);
      v37 = v33 > v30;
      v38 = v36;
      if ( v37 || v36 )
      {
        v19 = v45;
        if ( (v42 & 1) != 0 )
        {
          memcpy(v36, (const void *)(v26 - 47), ((unsigned __int64)((unsigned __int8)v29 & 0xFE) >> 1) + 1);
        }
        else
        {
          v39 = (void *)*v28;
          *v38 = *(_BYTE *)*v28;
          free(v39);
        }
        *(_QWORD *)(v26 - 48) = v41 | 1;
        *(_QWORD *)(v26 - 40) = v43;
        *(_QWORD *)(v26 - 32) = v38;
      }
      else
      {
        v19 = v45;
      }
    }
    v25 = v44;
LABEL_39:
    *(_BYTE *)(v26 - 48) = v25;
    *(_QWORD *)(v26 - 47) = v52[0];
    *(_QWORD *)(v26 - 40) = *(_QWORD *)((char *)v52 + 7);
    *v28 = v24;
    memset(v52, 0, 15);
    if ( (v50 & 1) != 0 )
    {
      free(v51);
      if ( (v46 & 1) == 0 )
      {
LABEL_41:
        if ( (v48 & 1) == 0 )
          return v7;
LABEL_42:
        free(p);
        return v7;
      }
    }
    else if ( (v46 & 1) == 0 )
    {
      goto LABEL_41;
    }
    free(v19);
    if ( (v48 & 1) == 0 )
      return v7;
    goto LABEL_42;
  }
  return (__int64)v6;
}

//----- (00000000000A9F34) ----------------------------------------------------
__int64 __fastcall sub_A9F34(_BYTE *a1, _BYTE *a2, _QWORD *a3)
{
  _BYTE *v4; // x20
  int v6; // w8
  _BOOL4 v7; // w26
  _BYTE *v8; // x22
  __int64 v9; // x23
  __int64 v10; // x8
  _BYTE *v11; // x24
  _BYTE *v12; // x23
  _BYTE *v13; // x0
  _BYTE *v14; // x22
  _BYTE *v15; // x23
  __int64 v16; // x22
  unsigned __int64 v17; // x8
  bool v18; // zf
  size_t v19; // x8
  void *v20; // x1
  size_t v21; // x2
  __int64 v22; // x22
  _BYTE *v23; // x24
  char v24; // w24
  size_t *v25; // x0
  void *v26; // x22
  char *v27; // x1
  size_t v28; // x2
  int v29; // w26
  _BYTE *v30; // x22
  __int64 v31; // x21
  __int64 v32; // x22
  unsigned __int64 v33; // x8
  bool v34; // zf
  size_t v35; // x8
  void *v36; // x1
  size_t v37; // x2
  __int64 v38; // x22
  _BYTE *v39; // x20
  __int128 v40; // q0
  char *v41; // x8
  char v42; // w22
  void *v43; // x20
  size_t *v44; // x0
  char *v45; // x1
  size_t v46; // x2
  _BYTE *v47; // x0
  _BYTE *v48; // x23
  _BYTE *v49; // x22
  __int64 v50; // x23
  unsigned __int64 v51; // x8
  bool v52; // zf
  size_t v53; // x8
  void *v54; // x1
  size_t v55; // x2
  __int64 v56; // x23
  _BYTE *v57; // x24
  size_t *v58; // x0
  void *v59; // x23
  char *v60; // x1
  size_t v61; // x2
  __int64 v62; // x22
  unsigned __int64 v63; // x8
  bool v64; // zf
  size_t v65; // x8
  void *v66; // x1
  size_t v67; // x2
  __int64 v68; // x22
  _BYTE *v69; // x20
  __int128 v70; // q0
  char *v71; // x8
  __int64 v72; // x0
  _BYTE *v73; // x22
  __int64 v74; // x8
  _BYTE *v75; // x22
  __int64 v76; // x22
  unsigned __int64 v77; // x8
  bool v78; // zf
  size_t v79; // x8
  void *v80; // x1
  size_t v81; // x2
  __int64 v82; // x22
  _BYTE *v83; // x20
  __int128 v84; // q0
  char *v85; // x8
  __int64 v86; // x21
  _BYTE *v87; // x22
  _BYTE *v89; // x24
  __int64 v90; // x0
  __int64 v91; // x24
  unsigned __int64 v92; // x8
  bool v93; // zf
  size_t v94; // x8
  void *v95; // x1
  size_t v96; // x2
  __int64 v97; // x24
  _BYTE *v98; // x23
  __int128 v99; // q0
  char *v100; // x8
  char v101; // w23
  void *v102; // x24
  char *v103; // x1
  size_t v104; // x2
  _BYTE *v105; // x24
  __int64 v106; // x0
  __int64 v107; // x24
  unsigned __int64 v108; // x8
  bool v109; // zf
  size_t v110; // x8
  void *v111; // x1
  size_t v112; // x2
  __int64 v113; // x24
  _BYTE *v114; // x23
  __int128 v115; // q0
  char *v116; // x8
  char v117; // w23
  void *v118; // x24
  char *v119; // x1
  size_t v120; // x2
  __int64 v121; // x27
  _BYTE *v122; // x26
  __int128 v123; // [xsp+0h] [xbp-90h] BYREF
  char *v124; // [xsp+10h] [xbp-80h]
  __int128 v125; // [xsp+20h] [xbp-70h] BYREF
  void *p; // [xsp+30h] [xbp-60h]
  __int64 v127; // [xsp+38h] [xbp-58h]

  v4 = a1;
  v127 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a2 - a1 < 3 )
    return (__int64)v4;
  if ( *a1 == 103 )
  {
    v6 = (unsigned __int8)a1[1];
    v7 = v6 == 115;
    if ( v6 == 115 )
      v8 = a1 + 2;
    else
      v8 = a1;
  }
  else
  {
    v7 = 0;
    v8 = a1;
  }
  v9 = sub_AB388(v8, a2, a3);
  if ( (_BYTE *)v9 == v8 )
  {
    if ( a2 - v8 < 3 || *v8 != 115 || v8[1] != 114 )
      return (__int64)v4;
    v11 = v8 + 2;
    if ( v8[2] != 78 )
    {
      v47 = (_BYTE *)sub_AB6CC(v8 + 2, a2, a3);
      v48 = v47;
      if ( v47 == v11 )
      {
        v72 = sub_B1788(v8 + 2, a2, a3);
        v73 = (_BYTE *)v72;
        if ( (_BYTE *)v72 == v11 || (_BYTE *)v72 == a2 )
          return (__int64)v4;
        if ( v7 )
        {
          v74 = a3[1];
          if ( *a3 == v74 )
            return (__int64)v4;
          sub_9CDD8((size_t *)(v74 - 48), 0LL, "::", 2uLL);
        }
        while ( *v73 != 69 )
        {
          v105 = v73;
          v106 = sub_B1788(v73, a2, a3);
          v73 = (_BYTE *)v106;
          if ( (_BYTE *)v106 == v105 )
            return (__int64)v4;
          if ( (_BYTE *)v106 == a2 )
            return (__int64)v4;
          v107 = a3[1];
          if ( 0xAAAAAAAAAAAAAAABLL * ((v107 - *a3) >> 4) < 2 )
            return (__int64)v4;
          v108 = *(unsigned __int8 *)(v107 - 24);
          v109 = (v108 & 1) == 0;
          v110 = v108 >> 1;
          if ( v109 )
            v111 = (void *)(v107 - 23);
          else
            v111 = *(void **)(v107 - 8);
          if ( v109 )
            v112 = v110;
          else
            v112 = *(_QWORD *)(v107 - 16);
          sub_9CFD0((size_t *)(v107 - 48), v111, v112);
          p = *(void **)(v107 - 32);
          v125 = *(_OWORD *)(v107 - 48);
          *(_QWORD *)(v107 - 40) = 0LL;
          *(_QWORD *)(v107 - 32) = 0LL;
          *(_QWORD *)(v107 - 48) = 0LL;
          v113 = a3[1];
          v114 = (_BYTE *)(v113 - 48);
          if ( (*(_BYTE *)(v113 - 24) & 1) != 0 )
            free(*(void **)(v113 - 8));
          if ( (*v114 & 1) != 0 )
            free(*(void **)(v113 - 32));
          a3[1] = v114;
          sub_9CDD8((size_t *)&v125, 0LL, "::", 2uLL);
          v115 = v125;
          v116 = (char *)p;
          p = 0LL;
          v125 = 0uLL;
          v123 = v115;
          v124 = v116;
          v117 = v115;
          v118 = v116;
          if ( (v115 & 1) != 0 )
            v119 = v116;
          else
            v119 = (char *)&v123 + 1;
          if ( (v115 & 1) != 0 )
            v120 = *((_QWORD *)&v115 + 1);
          else
            v120 = (unsigned __int64)(unsigned __int8)v115 >> 1;
          sub_9CFD0((size_t *)(a3[1] - 48LL), v119, v120);
          if ( (v117 & 1) != 0 )
            free(v118);
          if ( (v125 & 1) != 0 )
            free(p);
        }
        v75 = v73 + 1;
        v31 = sub_AB388(v75, a2, a3);
        if ( (_BYTE *)v31 == v75 )
          goto LABEL_129;
        v76 = a3[1];
        if ( 0xAAAAAAAAAAAAAAABLL * ((v76 - *a3) >> 4) < 2 )
          return (__int64)v4;
        v77 = *(unsigned __int8 *)(v76 - 24);
        v78 = (v77 & 1) == 0;
        v79 = v77 >> 1;
        if ( v78 )
          v80 = (void *)(v76 - 23);
        else
          v80 = *(void **)(v76 - 8);
        if ( v78 )
          v81 = v79;
        else
          v81 = *(_QWORD *)(v76 - 16);
        sub_9CFD0((size_t *)(v76 - 48), v80, v81);
        p = *(void **)(v76 - 32);
        v125 = *(_OWORD *)(v76 - 48);
        *(_QWORD *)(v76 - 40) = 0LL;
        *(_QWORD *)(v76 - 32) = 0LL;
        *(_QWORD *)(v76 - 48) = 0LL;
        v82 = a3[1];
        v83 = (_BYTE *)(v82 - 48);
        if ( (*(_BYTE *)(v82 - 24) & 1) != 0 )
          free(*(void **)(v82 - 8));
        if ( (*v83 & 1) != 0 )
          free(*(void **)(v82 - 32));
        a3[1] = v83;
        sub_9CDD8((size_t *)&v125, 0LL, "::", 2uLL);
        v84 = v125;
        v85 = (char *)p;
        p = 0LL;
        v125 = 0uLL;
        v123 = v84;
        v124 = v85;
        v42 = v84;
        v43 = v85;
        v44 = (size_t *)(a3[1] - 48LL);
        if ( (v84 & 1) != 0 )
          v45 = v85;
        else
          v45 = (char *)&v123 + 1;
        if ( (v84 & 1) != 0 )
          v46 = *((_QWORD *)&v84 + 1);
        else
          v46 = (unsigned __int64)(unsigned __int8)v84 >> 1;
      }
      else
      {
        v49 = sub_9D3DC(v47, a2, (__int64)a3);
        if ( v49 != v48 )
        {
          v50 = a3[1];
          if ( 0xAAAAAAAAAAAAAAABLL * ((v50 - *a3) >> 4) < 2 )
            return (__int64)v4;
          v51 = *(unsigned __int8 *)(v50 - 24);
          v52 = (v51 & 1) == 0;
          v53 = v51 >> 1;
          if ( v52 )
            v54 = (void *)(v50 - 23);
          else
            v54 = *(void **)(v50 - 8);
          if ( v52 )
            v55 = v53;
          else
            v55 = *(_QWORD *)(v50 - 16);
          sub_9CFD0((size_t *)(v50 - 48), v54, v55);
          p = *(void **)(v50 - 32);
          v125 = *(_OWORD *)(v50 - 48);
          *(_QWORD *)(v50 - 40) = 0LL;
          *(_QWORD *)(v50 - 32) = 0LL;
          *(_QWORD *)(v50 - 48) = 0LL;
          v56 = a3[1];
          v57 = (_BYTE *)(v56 - 48);
          if ( (*(_BYTE *)(v56 - 24) & 1) != 0 )
            free(*(void **)(v56 - 8));
          if ( (*v57 & 1) != 0 )
            free(*(void **)(v56 - 32));
          a3[1] = v57;
          v58 = (size_t *)(v56 - 96);
          v59 = p;
          if ( (v125 & 1) != 0 )
            v60 = (char *)p;
          else
            v60 = (char *)&v125 + 1;
          if ( (v125 & 1) != 0 )
            v61 = *((_QWORD *)&v125 + 1);
          else
            v61 = (unsigned __int64)(unsigned __int8)v125 >> 1;
          sub_9CFD0(v58, v60, v61);
          if ( (v125 & 1) != 0 )
            free(v59);
          v48 = v49;
        }
        v31 = sub_AB388(v48, a2, a3);
        if ( (_BYTE *)v31 == v48 )
          goto LABEL_129;
        v62 = a3[1];
        if ( 0xAAAAAAAAAAAAAAABLL * ((v62 - *a3) >> 4) < 2 )
          return (__int64)v4;
        v63 = *(unsigned __int8 *)(v62 - 24);
        v64 = (v63 & 1) == 0;
        v65 = v63 >> 1;
        if ( v64 )
          v66 = (void *)(v62 - 23);
        else
          v66 = *(void **)(v62 - 8);
        if ( v64 )
          v67 = v65;
        else
          v67 = *(_QWORD *)(v62 - 16);
        sub_9CFD0((size_t *)(v62 - 48), v66, v67);
        p = *(void **)(v62 - 32);
        v125 = *(_OWORD *)(v62 - 48);
        *(_QWORD *)(v62 - 40) = 0LL;
        *(_QWORD *)(v62 - 32) = 0LL;
        *(_QWORD *)(v62 - 48) = 0LL;
        v68 = a3[1];
        v69 = (_BYTE *)(v68 - 48);
        if ( (*(_BYTE *)(v68 - 24) & 1) != 0 )
          free(*(void **)(v68 - 8));
        if ( (*v69 & 1) != 0 )
          free(*(void **)(v68 - 32));
        a3[1] = v69;
        sub_9CDD8((size_t *)&v125, 0LL, "::", 2uLL);
        v70 = v125;
        v71 = (char *)p;
        p = 0LL;
        v125 = 0uLL;
        v123 = v70;
        v124 = v71;
        v42 = v70;
        v43 = v71;
        v44 = (size_t *)(a3[1] - 48LL);
        if ( (v70 & 1) != 0 )
          v45 = v71;
        else
          v45 = (char *)&v123 + 1;
        if ( (v70 & 1) != 0 )
          v46 = *((_QWORD *)&v70 + 1);
        else
          v46 = (unsigned __int64)(unsigned __int8)v70 >> 1;
      }
LABEL_100:
      sub_9CFD0(v44, v45, v46);
      if ( (v42 & 1) != 0 )
        free(v43);
      if ( (v125 & 1) != 0 )
        free(p);
      return v31;
    }
    v12 = v8 + 3;
    v13 = (_BYTE *)sub_AB6CC(v8 + 3, a2, a3);
    v14 = v13;
    if ( v13 == v12 || v13 == a2 )
      return (__int64)v4;
    v15 = sub_9D3DC(v13, a2, (__int64)a3);
    if ( v15 == v14 )
    {
LABEL_41:
      while ( *v14 != 69 )
      {
        v89 = v14;
        v90 = sub_B1788(v14, a2, a3);
        v14 = (_BYTE *)v90;
        if ( (_BYTE *)v90 == v89 )
          return (__int64)v4;
        if ( (_BYTE *)v90 == a2 )
          return (__int64)v4;
        v91 = a3[1];
        if ( 0xAAAAAAAAAAAAAAABLL * ((v91 - *a3) >> 4) < 2 )
          return (__int64)v4;
        v92 = *(unsigned __int8 *)(v91 - 24);
        v93 = (v92 & 1) == 0;
        v94 = v92 >> 1;
        if ( v93 )
          v95 = (void *)(v91 - 23);
        else
          v95 = *(void **)(v91 - 8);
        if ( v93 )
          v96 = v94;
        else
          v96 = *(_QWORD *)(v91 - 16);
        sub_9CFD0((size_t *)(v91 - 48), v95, v96);
        p = *(void **)(v91 - 32);
        v125 = *(_OWORD *)(v91 - 48);
        *(_QWORD *)(v91 - 40) = 0LL;
        *(_QWORD *)(v91 - 32) = 0LL;
        *(_QWORD *)(v91 - 48) = 0LL;
        v97 = a3[1];
        v98 = (_BYTE *)(v97 - 48);
        if ( (*(_BYTE *)(v97 - 24) & 1) != 0 )
          free(*(void **)(v97 - 8));
        if ( (*v98 & 1) != 0 )
          free(*(void **)(v97 - 32));
        a3[1] = v98;
        sub_9CDD8((size_t *)&v125, 0LL, "::", 2uLL);
        v99 = v125;
        v100 = (char *)p;
        p = 0LL;
        v125 = 0uLL;
        v123 = v99;
        v124 = v100;
        v101 = v99;
        v102 = v100;
        if ( (v99 & 1) != 0 )
          v103 = v100;
        else
          v103 = (char *)&v123 + 1;
        if ( (v99 & 1) != 0 )
          v104 = *((_QWORD *)&v99 + 1);
        else
          v104 = (unsigned __int64)(unsigned __int8)v99 >> 1;
        sub_9CFD0((size_t *)(a3[1] - 48LL), v103, v104);
        if ( (v101 & 1) != 0 )
          free(v102);
        if ( (v125 & 1) != 0 )
          free(p);
      }
      v30 = v14 + 1;
      v31 = sub_AB388(v30, a2, a3);
      if ( (_BYTE *)v31 != v30 )
      {
        v32 = a3[1];
        if ( 0xAAAAAAAAAAAAAAABLL * ((v32 - *a3) >> 4) < 2 )
          return (__int64)v4;
        v33 = *(unsigned __int8 *)(v32 - 24);
        v34 = (v33 & 1) == 0;
        v35 = v33 >> 1;
        if ( v34 )
          v36 = (void *)(v32 - 23);
        else
          v36 = *(void **)(v32 - 8);
        if ( v34 )
          v37 = v35;
        else
          v37 = *(_QWORD *)(v32 - 16);
        sub_9CFD0((size_t *)(v32 - 48), v36, v37);
        p = *(void **)(v32 - 32);
        v125 = *(_OWORD *)(v32 - 48);
        *(_QWORD *)(v32 - 40) = 0LL;
        *(_QWORD *)(v32 - 32) = 0LL;
        *(_QWORD *)(v32 - 48) = 0LL;
        v38 = a3[1];
        v39 = (_BYTE *)(v38 - 48);
        if ( (*(_BYTE *)(v38 - 24) & 1) != 0 )
          free(*(void **)(v38 - 8));
        if ( (*v39 & 1) != 0 )
          free(*(void **)(v38 - 32));
        a3[1] = v39;
        sub_9CDD8((size_t *)&v125, 0LL, "::", 2uLL);
        v40 = v125;
        v41 = (char *)p;
        p = 0LL;
        v125 = 0uLL;
        v123 = v40;
        v124 = v41;
        v42 = v40;
        v43 = v41;
        v44 = (size_t *)(a3[1] - 48LL);
        if ( (v40 & 1) != 0 )
          v45 = v41;
        else
          v45 = (char *)&v123 + 1;
        if ( (v40 & 1) != 0 )
          v46 = *((_QWORD *)&v40 + 1);
        else
          v46 = (unsigned __int64)(unsigned __int8)v40 >> 1;
        goto LABEL_100;
      }
LABEL_129:
      v86 = a3[1];
      if ( *a3 != v86 )
      {
        v87 = (_BYTE *)(v86 - 48);
        if ( (*(_BYTE *)(v86 - 24) & 1) != 0 )
          free(*(void **)(v86 - 8));
        if ( (*v87 & 1) != 0 )
          free(*(void **)(v86 - 32));
        a3[1] = v87;
      }
      return (__int64)v4;
    }
    v16 = a3[1];
    if ( 0xAAAAAAAAAAAAAAABLL * ((v16 - *a3) >> 4) < 2 )
      return (__int64)v4;
    v17 = *(unsigned __int8 *)(v16 - 24);
    v18 = (v17 & 1) == 0;
    v19 = v17 >> 1;
    if ( v18 )
      v20 = (void *)(v16 - 23);
    else
      v20 = *(void **)(v16 - 8);
    if ( v18 )
      v21 = v19;
    else
      v21 = *(_QWORD *)(v16 - 16);
    sub_9CFD0((size_t *)(v16 - 48), v20, v21);
    p = *(void **)(v16 - 32);
    v125 = *(_OWORD *)(v16 - 48);
    *(_QWORD *)(v16 - 40) = 0LL;
    *(_QWORD *)(v16 - 32) = 0LL;
    *(_QWORD *)(v16 - 48) = 0LL;
    v22 = a3[1];
    v23 = (_BYTE *)(v22 - 48);
    if ( (*(_BYTE *)(v22 - 24) & 1) != 0 )
      free(*(void **)(v22 - 8));
    if ( (*v23 & 1) != 0 )
      free(*(void **)(v22 - 32));
    a3[1] = v23;
    v24 = v125;
    v25 = (size_t *)(v22 - 96);
    v26 = p;
    if ( (v125 & 1) != 0 )
      v27 = (char *)p;
    else
      v27 = (char *)&v125 + 1;
    if ( (v125 & 1) != 0 )
      v28 = *((_QWORD *)&v125 + 1);
    else
      v28 = (unsigned __int64)(unsigned __int8)v125 >> 1;
    sub_9CFD0(v25, v27, v28);
    if ( v15 == a2 )
    {
      v121 = a3[1];
      v122 = (_BYTE *)(v121 - 48);
      if ( (*(_BYTE *)(v121 - 24) & 1) != 0 )
        free(*(void **)(v121 - 8));
      if ( (*v122 & 1) != 0 )
        free(*(void **)(v121 - 32));
      a3[1] = v122;
      v29 = 1;
      if ( (v24 & 1) == 0 )
        goto LABEL_39;
    }
    else
    {
      v29 = 0;
      if ( (v125 & 1) == 0 )
      {
LABEL_39:
        if ( v29 )
          return (__int64)v4;
        v14 = v15;
        goto LABEL_41;
      }
    }
    free(v26);
    goto LABEL_39;
  }
  if ( !v7 )
    return v9;
  v10 = a3[1];
  if ( *a3 != v10 )
  {
    sub_9CDD8((size_t *)(v10 - 48), 0LL, "::", 2uLL);
    return v9;
  }
  return (__int64)v4;
}
// AB388: using guessed type __int64 __fastcall sub_AB388(_QWORD, _QWORD, _QWORD);
// AB6CC: using guessed type __int64 __fastcall sub_AB6CC(_QWORD, _QWORD, _QWORD);
// B1788: using guessed type __int64 __fastcall sub_B1788(_QWORD, _QWORD, _QWORD);

//----- (00000000000AA998) ----------------------------------------------------
unsigned __int8 *__fastcall sub_AA998(
        unsigned __int8 *a1,
        unsigned __int8 *a2,
        unsigned __int8 *a3,
        unsigned __int64 *a4)
{
  unsigned __int8 *v4; // x21
  unsigned __int8 *v7; // x8
  int v8; // w9
  unsigned __int8 *v9; // x28
  unsigned __int64 v10; // x8
  unsigned __int64 v11; // x8
  __int64 v12; // x24
  __int64 v13; // x8
  __int64 v14; // x9
  void *v15; // x22
  char v16; // w25
  __int64 v17; // x8
  __int64 v18; // x9
  unsigned __int64 v19; // x8
  unsigned __int64 v20; // x9
  unsigned __int8 *v21; // x8
  int v22; // t1
  unsigned __int64 v23; // x8
  _OWORD *v24; // x9
  unsigned __int64 v25; // x22
  unsigned __int64 v26; // x8
  unsigned __int64 v27; // x8
  unsigned __int64 v28; // x9
  char *v29; // x0
  unsigned __int64 v30; // x26
  unsigned __int64 v31; // x9
  unsigned __int64 v32; // x9
  unsigned __int64 v33; // x9
  char *v34; // x0
  char *v35; // x8
  unsigned __int64 v36; // x11
  unsigned __int64 v37; // x25
  char *v38; // x9
  _OWORD *v39; // x10
  __int64 v40; // x12
  unsigned __int64 v41; // x22
  unsigned __int64 v42; // x24
  unsigned __int64 v43; // x26
  unsigned __int64 v44; // x8
  void *v45; // x0
  char *v46; // x8
  char *v47; // x9
  void **v48; // x11
  void **v49; // x25
  char *v50; // x10
  __int64 v51; // x12
  void **v52; // x22
  unsigned __int64 v53; // x24
  void **v54; // x26
  unsigned __int64 v55; // x8
  unsigned __int64 v56; // x22
  unsigned __int64 v57; // x8
  size_t *v58; // x25
  size_t v59; // x23
  unsigned __int64 v60; // x26
  unsigned __int64 v61; // x24
  unsigned __int64 v62; // x9
  unsigned __int64 v63; // x10
  _BYTE *v64; // x0
  void *v65; // x8
  unsigned __int64 v66; // x10
  unsigned __int8 *v67; // x8
  _BYTE *v68; // x9
  _OWORD *v69; // x11
  __int128 *v70; // x12
  unsigned __int64 v71; // x13
  __int128 v72; // q0
  __int128 v73; // q1
  char v74; // t1
  char v75; // w22
  void *v76; // x21
  char *v77; // x1
  size_t v78; // x2
  unsigned __int64 v79; // x8
  size_t v80; // x8
  void *v81; // x0
  size_t v82; // x2
  void *v83; // x23
  size_t v84; // x26
  void *v85; // x23
  unsigned __int64 v86; // x8
  unsigned __int8 *v87; // x9
  size_t v88; // x10
  unsigned __int8 *v89; // x11
  unsigned __int64 v90; // x12
  __int128 *v91; // x13
  _OWORD *v92; // x14
  unsigned __int64 v93; // x15
  __int128 v94; // q0
  __int128 v95; // q1
  unsigned __int8 v96; // t1
  size_t v97; // x8
  unsigned __int64 v98; // x8
  size_t v99; // x2
  void *v100; // x1
  size_t n; // [xsp+8h] [xbp-B8h]
  size_t v103; // [xsp+10h] [xbp-B0h]
  void *src; // [xsp+18h] [xbp-A8h]
  __int128 v105; // [xsp+20h] [xbp-A0h] BYREF
  void *p; // [xsp+30h] [xbp-90h]
  _QWORD v107[2]; // [xsp+38h] [xbp-88h] BYREF
  _QWORD v108[2]; // [xsp+48h] [xbp-78h] BYREF
  _QWORD v109[3]; // [xsp+58h] [xbp-68h] BYREF

  v4 = a1;
  v109[2] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a1 == a2 )
    return v4;
  v7 = *a1 == 110 ? a1 + 1 : a1;
  if ( v7 == a2 )
    return v4;
  v8 = *v7;
  if ( v8 == 48 )
  {
    v9 = v7 + 1;
    if ( v7 + 1 == a1 )
      return v4;
LABEL_8:
    if ( v9 == a2 || *v9 != 69 )
      return v4;
    v10 = *a3;
    if ( (v10 & 1) != 0 )
      v11 = *((_QWORD *)a3 + 1);
    else
      v11 = v10 >> 1;
    v12 = 0x555555555555555LL;
    if ( v11 < 4 )
    {
      v24 = (_OWORD *)a4[1];
      v23 = a4[2];
      if ( (unsigned __int64)v24 < v23 )
      {
        v24[1] = 0u;
        v24[2] = 0u;
        *v24 = 0u;
        a4[1] += 48LL;
        goto LABEL_81;
      }
      v25 = 0xAAAAAAAAAAAAAAABLL * ((__int64)((__int64)v24 - *a4) >> 4);
      if ( v25 + 1 > 0x555555555555555LL )
        goto LABEL_160;
      v26 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v23 - *a4) >> 4);
      if ( v26 >= 0x2AAAAAAAAAAAAAALL || ((v27 = 2 * v26, v27 >= v25 + 1) ? (v12 = v27) : (v12 = v25 + 1), v12) )
      {
        v28 = a4[3];
        v29 = *(char **)(v28 + 4096);
        if ( v28 + 4096 - (unsigned __int64)v29 >= 48 * v12 )
          *(_QWORD *)(v28 + 4096) = &v29[48 * v12];
        else
          v29 = (char *)malloc(48 * v12);
      }
      else
      {
        v29 = 0LL;
      }
      v35 = &v29[48 * v25];
      *((_OWORD *)v35 + 1) = 0u;
      *((_OWORD *)v35 + 2) = 0u;
      *(_OWORD *)v35 = 0u;
      v37 = *a4;
      v36 = a4[1];
      v38 = &v29[48 * v12];
      v39 = v35 + 48;
      if ( v36 == *a4 )
      {
        v41 = *a4;
      }
      else
      {
        do
        {
          *((_QWORD *)v35 - 4) = *(_QWORD *)(v36 - 32);
          *((_OWORD *)v35 - 3) = *(_OWORD *)(v36 - 48);
          v40 = *(_QWORD *)(v36 - 8);
          *(_QWORD *)(v36 - 40) = 0LL;
          *(_QWORD *)(v36 - 32) = 0LL;
          *(_QWORD *)(v36 - 48) = 0LL;
          *((_QWORD *)v35 - 1) = v40;
          *(_OWORD *)(v35 - 24) = *(_OWORD *)(v36 - 24);
          *(_QWORD *)(v36 - 16) = 0LL;
          *(_QWORD *)(v36 - 8) = 0LL;
          *(_QWORD *)(v36 - 24) = 0LL;
          v36 -= 48LL;
          v35 -= 48;
        }
        while ( v37 != v36 );
        v41 = *a4;
        v37 = a4[1];
      }
      v42 = a4[2];
      *a4 = (unsigned __int64)v35;
      a4[1] = (unsigned __int64)v39;
      a4[2] = (unsigned __int64)v38;
      if ( v37 != v41 )
      {
        do
        {
          if ( (*(_BYTE *)(v37 - 24) & 1) != 0 )
            free(*(void **)(v37 - 8));
          v43 = v37 - 48;
          if ( (*(_BYTE *)(v37 - 48) & 1) != 0 )
            free(*(void **)(v37 - 32));
          v37 -= 48LL;
        }
        while ( v41 != v43 );
      }
      if ( v41 )
      {
        v44 = a4[3];
        if ( v44 + 4096 < v41 || v44 > v41 )
        {
          v45 = (void *)v41;
LABEL_80:
          free(v45);
          goto LABEL_81;
        }
        if ( *(_QWORD *)(v44 + 4096) == v42 )
          *(_QWORD *)(v44 + 4096) = v41;
      }
LABEL_81:
      if ( *v4 == 110 )
      {
        sub_B23DC(a4[1] - 48, 45LL);
        ++v4;
      }
      v56 = a4[1];
      v58 = (size_t *)(v56 - 48);
      v57 = *(unsigned __int8 *)(v56 - 48);
      if ( (*(_BYTE *)(v56 - 48) & 1) != 0 )
      {
        v57 = *(_QWORD *)(v56 - 48);
        v59 = *(_QWORD *)(v56 - 40);
        v60 = (v57 & 0xFFFFFFFFFFFFFFFELL) - 1;
        v61 = v9 - v4;
        if ( v9 == v4 )
          goto LABEL_150;
      }
      else
      {
        v59 = v57 >> 1;
        v60 = 22LL;
        v61 = v9 - v4;
        if ( v9 == v4 )
          goto LABEL_150;
      }
      if ( (v57 & 1) != 0 )
      {
        v63 = *(_QWORD *)(v56 - 40);
        v62 = *(_QWORD *)(v56 - 32);
        if ( v62 > (unsigned __int64)v4 )
          goto LABEL_96;
      }
      else
      {
        v62 = v56 - 47;
        v63 = (unsigned __int64)((unsigned __int8)v57 & 0xFE) >> 1;
        if ( v56 - 47 > (unsigned __int64)v4 )
          goto LABEL_96;
      }
      if ( v62 + v63 > (unsigned __int64)v4 )
      {
        p = 0LL;
        v105 = 0uLL;
        if ( v61 >= 0xFFFFFFFFFFFFFFF0LL )
          goto LABEL_160;
        if ( v61 > 0x16 )
        {
          v64 = malloc((v61 + 16) & 0xFFFFFFFFFFFFFFF0LL);
          *((_QWORD *)&v105 + 1) = v61;
          p = v64;
          *(_QWORD *)&v105 = (v61 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
          if ( v4 == v9 )
            goto LABEL_110;
        }
        else
        {
          LOBYTE(v105) = 2 * v61;
          v64 = (char *)&v105 + 1;
          if ( v4 == v9 )
          {
LABEL_110:
            *v64 = 0;
            v75 = v105;
            v76 = p;
            if ( (v105 & 1) != 0 )
              v77 = (char *)p;
            else
              v77 = (char *)&v105 + 1;
            if ( (v105 & 1) != 0 )
              v78 = *((_QWORD *)&v105 + 1);
            else
              v78 = (unsigned __int64)(unsigned __int8)v105 >> 1;
            sub_9CFD0(v58, v77, v78);
            if ( (v75 & 1) != 0 )
              free(v76);
            goto LABEL_150;
          }
        }
        if ( v61 >= 0x20 && (v66 = v61 & 0xFFFFFFFFFFFFFFE0LL, (v61 & 0xFFFFFFFFFFFFFFE0LL) != 0) )
        {
          v67 = &v4[v66];
          v68 = &v64[v66];
          v69 = v64 + 16;
          v70 = (__int128 *)(v4 + 16);
          v71 = v61 & 0xFFFFFFFFFFFFFFE0LL;
          do
          {
            v72 = *(v70 - 1);
            v73 = *v70;
            v71 -= 32LL;
            v70 += 2;
            *(v69 - 1) = v72;
            *v69 = v73;
            v69 += 2;
          }
          while ( v71 );
          if ( v66 == v61 )
            goto LABEL_109;
        }
        else
        {
          v67 = v4;
          v68 = v64;
        }
        do
        {
          v74 = *v67++;
          *v68++ = v74;
        }
        while ( v9 != v67 );
LABEL_109:
        v64 += v61;
        goto LABEL_110;
      }
LABEL_96:
      if ( v60 - v59 >= v61 )
        goto LABEL_131;
      if ( -17LL - v60 >= v59 + v61 - v60 )
      {
        if ( (v57 & 1) != 0 )
          v65 = *(void **)(v56 - 32);
        else
          v65 = (void *)(v56 - 47);
        src = v65;
        if ( v60 > 0x7FFFFFFFFFFFFFE6LL )
        {
          v80 = -17LL;
        }
        else
        {
          v79 = 2 * v60;
          if ( v59 + v61 >= 2 * v60 )
            v79 = v59 + v61;
          if ( v79 >= 0x17 )
            v80 = (v79 + 16) & 0xFFFFFFFFFFFFFFF0LL;
          else
            v80 = 23LL;
        }
        v103 = v80;
        v81 = malloc(v80);
        if ( v59 )
        {
          n = v59;
          v82 = v59;
          v83 = v81;
          memcpy(v81, src, v82);
          v81 = v83;
          v59 = n;
        }
        if ( v60 != 22 )
        {
          v84 = v59;
          v85 = v81;
          free(src);
          v81 = v85;
          v59 = v84;
        }
        *(_QWORD *)(v56 - 32) = v81;
        LOBYTE(v57) = v103 | 1;
        *(_QWORD *)(v56 - 48) = v103 | 1;
LABEL_131:
        if ( (v57 & 1) != 0 )
          v86 = *(_QWORD *)(v56 - 32);
        else
          v86 = v56 - 47;
        v87 = (unsigned __int8 *)(v86 + v59);
        if ( v4 == v9 )
          goto LABEL_147;
        v88 = v59 - (_QWORD)v4;
        if ( v61 >= 0x20 )
        {
          v90 = v61 & 0xFFFFFFFFFFFFFFE0LL;
          if ( (v61 & 0xFFFFFFFFFFFFFFE0LL) != 0 )
          {
            if ( v87 >= v9 || v4 >= &v9[v86 + v88] )
            {
              v87 += v90;
              v89 = &v4[v90];
              v91 = (__int128 *)(v4 + 16);
              v92 = (_OWORD *)(v86 + v59 + 16);
              v93 = v61 & 0xFFFFFFFFFFFFFFE0LL;
              do
              {
                v94 = *(v91 - 1);
                v95 = *v91;
                v91 += 2;
                v93 -= 32LL;
                *(v92 - 1) = v94;
                *v92 = v95;
                v92 += 2;
              }
              while ( v93 );
              if ( v90 == v61 )
                goto LABEL_146;
            }
            else
            {
              v89 = v4;
            }
          }
          else
          {
            v89 = v4;
          }
        }
        else
        {
          v89 = v4;
        }
        do
        {
          v96 = *v89++;
          *v87++ = v96;
        }
        while ( v9 != v89 );
LABEL_146:
        v87 = &v9[v88 + v86];
LABEL_147:
        *v87 = 0;
        v97 = v59 + v61;
        if ( (*(_BYTE *)v58 & 1) != 0 )
          *(_QWORD *)(v56 - 40) = v97;
        else
          *(_BYTE *)v58 = 2 * v97;
LABEL_150:
        v98 = *a3;
        if ( (v98 & 1) != 0 )
          v99 = *((_QWORD *)a3 + 1);
        else
          v99 = v98 >> 1;
        if ( v99 <= 3 )
        {
          if ( (v98 & 1) != 0 )
            v100 = (void *)*((_QWORD *)a3 + 2);
          else
            v100 = a3 + 1;
          sub_9CFD0((size_t *)(a4[1] - 48), v100, v99);
        }
        return v9 + 1;
      }
LABEL_160:
      abort();
    }
    sub_9F8F0("(", a3, (size_t *)&v105);
    sub_9CFD0((size_t *)&v105, ")", 1uLL);
    v13 = *(_QWORD *)((char *)&v105 + 1);
    v14 = *((_QWORD *)&v105 + 1);
    v15 = p;
    v16 = v105;
    p = 0LL;
    v105 = 0uLL;
    *(_QWORD *)((char *)v107 + 7) = v14;
    v107[0] = v13;
    v17 = *(_QWORD *)((char *)v107 + 7);
    v18 = v107[0];
    memset(v108, 0, 15);
    memset(v107, 0, 15);
    *(_QWORD *)((char *)v109 + 7) = v17;
    v109[0] = v18;
    v19 = a4[1];
    v20 = a4[2];
    if ( v19 < v20 )
    {
      *(_BYTE *)v19 = v16;
      *(_QWORD *)(v19 + 8) = *(_QWORD *)((char *)v109 + 7);
      *(_QWORD *)(v19 + 16) = v15;
      *(_QWORD *)(v19 + 1) = v109[0];
      memset(v109, 0, 15);
      *(_BYTE *)(v19 + 24) = 0;
      *(_QWORD *)(v19 + 32) = *(_QWORD *)((char *)v108 + 7);
      *(_QWORD *)(v19 + 40) = 0LL;
      *(_QWORD *)(v19 + 25) = v108[0];
      memset(v108, 0, 15);
      a4[1] += 48LL;
      if ( (v105 & 1) == 0 )
        goto LABEL_81;
      goto LABEL_79;
    }
    v30 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v19 - *a4) >> 4);
    if ( v30 + 1 > 0x555555555555555LL )
      abort();
    v31 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v20 - *a4) >> 4);
    if ( v31 >= 0x2AAAAAAAAAAAAAALL || ((v32 = 2 * v31, v32 >= v30 + 1) ? (v12 = v32) : (v12 = v30 + 1), v12) )
    {
      v33 = a4[3];
      v34 = *(char **)(v33 + 4096);
      if ( v33 + 4096 - (unsigned __int64)v34 >= 48 * v12 )
        *(_QWORD *)(v33 + 4096) = &v34[48 * v12];
      else
        v34 = (char *)malloc(48 * v12);
    }
    else
    {
      v34 = 0LL;
    }
    v46 = &v34[48 * v30];
    *v46 = v16;
    v47 = &v34[48 * v12];
    *((_QWORD *)v46 + 1) = *(_QWORD *)((char *)v109 + 7);
    *((_QWORD *)v46 + 2) = v15;
    *(_QWORD *)(v46 + 1) = v109[0];
    memset(v109, 0, 15);
    v46[24] = 0;
    *((_QWORD *)v46 + 4) = *(_QWORD *)((char *)v108 + 7);
    *((_QWORD *)v46 + 5) = 0LL;
    *(_QWORD *)(v46 + 25) = v108[0];
    memset(v108, 0, 15);
    v49 = (void **)*a4;
    v48 = (void **)a4[1];
    v50 = v46 + 48;
    if ( v48 == (void **)*a4 )
    {
      v52 = (void **)*a4;
    }
    else
    {
      do
      {
        *((_QWORD *)v46 - 4) = *(v48 - 4);
        *((_OWORD *)v46 - 3) = *((_OWORD *)v48 - 3);
        v51 = (__int64)*(v48 - 1);
        *(v48 - 5) = 0LL;
        *(v48 - 4) = 0LL;
        *(v48 - 6) = 0LL;
        *((_QWORD *)v46 - 1) = v51;
        *(_OWORD *)(v46 - 24) = *(_OWORD *)(v48 - 3);
        *(v48 - 2) = 0LL;
        *(v48 - 1) = 0LL;
        *(v48 - 3) = 0LL;
        v48 -= 6;
        v46 -= 48;
      }
      while ( v49 != v48 );
      v52 = (void **)*a4;
      v49 = (void **)a4[1];
    }
    v53 = a4[2];
    *a4 = (unsigned __int64)v46;
    a4[1] = (unsigned __int64)v50;
    a4[2] = (unsigned __int64)v47;
    if ( v49 != v52 )
    {
      do
      {
        if ( (*(_BYTE *)(v49 - 3) & 1) != 0 )
          free(*(v49 - 1));
        v54 = v49 - 6;
        if ( (*(_BYTE *)(v49 - 6) & 1) != 0 )
          free(*(v49 - 4));
        v49 -= 6;
      }
      while ( v52 != v54 );
    }
    if ( v52 )
    {
      v55 = a4[3];
      if ( v55 + 4096 < (unsigned __int64)v52 || v55 > (unsigned __int64)v52 )
      {
        free(v52);
      }
      else if ( *(_QWORD *)(v55 + 4096) == v53 )
      {
        *(_QWORD *)(v55 + 4096) = v52;
        if ( (v105 & 1) == 0 )
          goto LABEL_81;
LABEL_79:
        v45 = p;
        goto LABEL_80;
      }
    }
    if ( (v105 & 1) == 0 )
      goto LABEL_81;
    goto LABEL_79;
  }
  if ( (unsigned int)(v8 - 49) <= 8 )
  {
    v21 = v7 + 1;
    do
    {
      if ( a2 == v21 )
        return v4;
      v22 = *v21++;
    }
    while ( (unsigned int)(v22 - 48) < 0xA );
    v9 = v21 - 1;
    if ( v21 - 1 != a1 )
      goto LABEL_8;
  }
  return v4;
}
// B23DC: using guessed type __int64 __fastcall sub_B23DC(_QWORD, _QWORD);

//----- (00000000000AB28C) ----------------------------------------------------
size_t *__usercall sub_AB28C@<X0>(size_t *__return_ptr a1@<X8>, char *s@<X1>, unsigned __int8 *a3@<X0>)
{
  unsigned __int64 v5; // x22
  size_t v6; // x24
  size_t v8; // x0
  bool v9; // zf
  size_t v10; // x21
  size_t v11; // x22
  unsigned __int64 v12; // x8
  const void *v13; // x23
  char *v14; // x24
  size_t v15; // x25

  a1[1] = 0LL;
  a1[2] = 0LL;
  *a1 = 0LL;
  v5 = *a3;
  v6 = *((_QWORD *)a3 + 1);
  v8 = strlen(s);
  v9 = (v5 & 1) == 0;
  v10 = v8;
  if ( (v5 & 1) != 0 )
    v11 = v6;
  else
    v11 = v5 >> 1;
  v12 = v11 + v8;
  if ( v9 )
    v13 = a3 + 1;
  else
    v13 = (const void *)*((_QWORD *)a3 + 2);
  if ( v12 >= 0xFFFFFFFFFFFFFFF0LL )
    abort();
  if ( v12 <= 0x16 )
  {
    *(_BYTE *)a1 = 2 * v11;
    v14 = (char *)a1 + 1;
    if ( !v11 )
      goto LABEL_13;
    goto LABEL_12;
  }
  v15 = (v12 + 16) & 0xFFFFFFFFFFFFFFF0LL;
  v14 = (char *)malloc(v15);
  a1[1] = v11;
  a1[2] = (size_t)v14;
  *a1 = v15 | 1;
  if ( v11 )
LABEL_12:
    memcpy(v14, v13, v11);
LABEL_13:
  v14[v11] = 0;
  return sub_9CFD0(a1, s, v10);
}

//----- (00000000000AB388) ----------------------------------------------------
__int64 __fastcall sub_AB388(unsigned __int8 *a1, unsigned __int8 *a2, _QWORD *a3)
{
  unsigned __int8 *v3; // x21
  unsigned __int8 *v4; // x20
  int v6; // w8
  unsigned __int8 *v7; // x22
  unsigned __int8 *v8; // x23
  __int64 result; // x0
  __int64 v10; // x21
  unsigned __int64 v11; // x8
  bool v12; // zf
  size_t v13; // x8
  void *v14; // x1
  size_t v15; // x2
  __int64 v16; // x21
  _BYTE *v17; // x22
  size_t *v18; // x0
  char v19; // w21
  void *v20; // x19
  char *v21; // x1
  size_t v22; // x2
  unsigned __int8 *v23; // x22
  __int64 v24; // x21
  unsigned __int64 v25; // x8
  bool v26; // zf
  size_t v27; // x8
  void *v28; // x1
  size_t v29; // x2
  __int64 v30; // x21
  _BYTE *v31; // x22
  __int64 v32; // x23
  __int64 v33; // x8
  __int128 v34; // [xsp+0h] [xbp-50h] BYREF
  char *v35; // [xsp+10h] [xbp-40h]
  __int64 v36; // [xsp+18h] [xbp-38h]

  v3 = a2;
  v4 = a1;
  v36 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a2 - a1 < 2 )
    return (__int64)v4;
  v6 = *a1;
  if ( (v6 == 111 || v6 == 100) && a1[1] == 110 )
  {
    v7 = a1 + 2;
    if ( v6 == 111 )
    {
      v8 = (unsigned __int8 *)sub_AC0B0(a1 + 2, a2, a3);
      result = (__int64)v4;
      if ( v8 != v7 )
      {
        v4 = sub_9D3DC(v8, v3, (__int64)a3);
        result = (__int64)v8;
        if ( v4 != v8 )
        {
          v10 = a3[1];
          if ( 0xAAAAAAAAAAAAAAABLL * ((v10 - *a3) >> 4) >= 2 )
          {
            v11 = *(unsigned __int8 *)(v10 - 24);
            v12 = (v11 & 1) == 0;
            v13 = v11 >> 1;
            if ( v12 )
              v14 = (void *)(v10 - 23);
            else
              v14 = *(void **)(v10 - 8);
            if ( v12 )
              v15 = v13;
            else
              v15 = *(_QWORD *)(v10 - 16);
            sub_9CFD0((size_t *)(v10 - 48), v14, v15);
            v35 = *(char **)(v10 - 32);
            v34 = *(_OWORD *)(v10 - 48);
            *(_QWORD *)(v10 - 40) = 0LL;
            *(_QWORD *)(v10 - 32) = 0LL;
            *(_QWORD *)(v10 - 48) = 0LL;
            v16 = a3[1];
            v17 = (_BYTE *)(v16 - 48);
            if ( (*(_BYTE *)(v16 - 24) & 1) != 0 )
              free(*(void **)(v16 - 8));
            if ( (*v17 & 1) != 0 )
              free(*(void **)(v16 - 32));
            a3[1] = v17;
            v18 = (size_t *)(v16 - 96);
            v19 = v34;
            v20 = v35;
            if ( (v34 & 1) != 0 )
              v21 = v35;
            else
              v21 = (char *)&v34 + 1;
            if ( (v34 & 1) != 0 )
              v22 = *((_QWORD *)&v34 + 1);
            else
              v22 = (unsigned __int64)(unsigned __int8)v34 >> 1;
LABEL_45:
            sub_9CFD0(v18, v21, v22);
            if ( (v19 & 1) != 0 )
              free(v20);
            return (__int64)v4;
          }
          return (__int64)v4;
        }
      }
    }
    else
    {
      if ( v7 != a2 )
      {
        v32 = sub_AB6CC(a1 + 2, a2, a3);
        if ( (unsigned __int8 *)v32 == v7 )
          v32 = sub_B1788(v4 + 2, v3, a3);
        if ( (unsigned __int8 *)v32 == v7 )
        {
          v3 = v4 + 2;
        }
        else
        {
          v33 = a3[1];
          v3 = v4 + 2;
          if ( *a3 != v33 )
          {
            sub_9CDD8((size_t *)(v33 - 48), 0LL, "~", 1uLL);
            v3 = (unsigned __int8 *)v32;
          }
        }
      }
      if ( v3 == v7 )
        return (__int64)v4;
      else
        return (__int64)v3;
    }
  }
  else
  {
    result = sub_B1788(a1, a2, a3);
    if ( (unsigned __int8 *)result == v4 )
    {
      v23 = (unsigned __int8 *)sub_AC0B0(v4, v3, a3);
      result = (__int64)v4;
      if ( v23 != v4 )
      {
        v4 = sub_9D3DC(v23, v3, (__int64)a3);
        result = (__int64)v23;
        if ( v4 != v23 )
        {
          v24 = a3[1];
          if ( 0xAAAAAAAAAAAAAAABLL * ((v24 - *a3) >> 4) >= 2 )
          {
            v25 = *(unsigned __int8 *)(v24 - 24);
            v26 = (v25 & 1) == 0;
            v27 = v25 >> 1;
            if ( v26 )
              v28 = (void *)(v24 - 23);
            else
              v28 = *(void **)(v24 - 8);
            if ( v26 )
              v29 = v27;
            else
              v29 = *(_QWORD *)(v24 - 16);
            sub_9CFD0((size_t *)(v24 - 48), v28, v29);
            v35 = *(char **)(v24 - 32);
            v34 = *(_OWORD *)(v24 - 48);
            *(_QWORD *)(v24 - 40) = 0LL;
            *(_QWORD *)(v24 - 32) = 0LL;
            *(_QWORD *)(v24 - 48) = 0LL;
            v30 = a3[1];
            v31 = (_BYTE *)(v30 - 48);
            if ( (*(_BYTE *)(v30 - 24) & 1) != 0 )
              free(*(void **)(v30 - 8));
            if ( (*v31 & 1) != 0 )
              free(*(void **)(v30 - 32));
            a3[1] = v31;
            v18 = (size_t *)(v30 - 96);
            v19 = v34;
            v20 = v35;
            if ( (v34 & 1) != 0 )
              v21 = v35;
            else
              v21 = (char *)&v34 + 1;
            if ( (v34 & 1) != 0 )
              v22 = *((_QWORD *)&v34 + 1);
            else
              v22 = (unsigned __int64)(unsigned __int8)v34 >> 1;
            goto LABEL_45;
          }
          return (__int64)v4;
        }
      }
    }
  }
  return result;
}
// AB6CC: using guessed type __int64 __fastcall sub_AB6CC(_QWORD, _QWORD, _QWORD);
// AC0B0: using guessed type __int64 __fastcall sub_AC0B0(_QWORD, _QWORD, _QWORD);
// B1788: using guessed type __int64 __fastcall sub_B1788(_QWORD, _QWORD, _QWORD);

//----- (00000000000AB6CC) ----------------------------------------------------
unsigned __int8 *__fastcall sub_AB6CC(unsigned __int8 *a1, unsigned __int8 *a2, void **a3)
{
  int v6; // w8
  unsigned __int64 v7; // x24
  __int64 v8; // x0
  _BYTE *v9; // x8
  unsigned __int8 *v10; // x20
  unsigned __int64 v11; // x9
  char *v12; // x8
  char *v13; // x9
  void **v14; // x19
  __int64 v15; // x21
  size_t *v16; // x8
  __int64 v17; // x1
  char *v18; // x8
  char *v19; // x9
  void **v20; // x19
  void *v21; // x8
  char *v22; // x8
  char *v23; // x9
  void **v24; // x20
  unsigned __int64 v25; // x21
  _BYTE *v27; // x10
  __int64 v28; // x21
  __int64 v29; // x9
  unsigned __int64 v30; // x9
  __int64 v31; // x22
  char *v32; // x0
  _BYTE *v33; // x10
  __int64 v34; // x20
  __int64 v35; // x9
  unsigned __int64 v36; // x9
  __int64 v37; // x22
  char *v38; // x0
  _QWORD *v39; // x9
  char *v40; // x8
  char *v41; // x10
  void **v42; // x11
  void **v43; // x21
  char *v44; // x9
  __int128 v45; // t1
  void **v46; // x22
  _QWORD *v47; // x9
  void *v48; // x24
  unsigned __int64 v49; // x8
  char *v50; // x8
  char *v51; // x10
  void **v52; // x11
  void **v53; // x20
  char *v54; // x9
  __int128 v55; // t1
  void **v56; // x22
  void **v57; // x21
  void **v58; // x22
  void *v59; // x24
  unsigned __int64 v60; // x8
  void **v61; // x20
  void **v62; // x22
  _BYTE *v63; // x10
  __int64 v64; // x20
  __int64 v65; // x9
  unsigned __int64 v66; // x9
  __int64 v67; // x22
  char *v68; // x0
  _QWORD *v69; // x9
  char *v70; // x8
  char *v71; // x10
  void **v72; // x11
  void **v73; // x20
  char *v74; // x9
  __int128 v75; // t1
  void **v76; // x22
  void *v77; // x24
  unsigned __int64 v78; // x8
  void **v79; // x20
  void **v80; // x22
  void *v81; // [xsp+8h] [xbp-78h] BYREF
  void *p[2]; // [xsp+10h] [xbp-70h] BYREF
  __int64 v83; // [xsp+20h] [xbp-60h]
  unsigned __int64 v84; // [xsp+28h] [xbp-58h]
  __int64 v85; // [xsp+38h] [xbp-48h]

  v85 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a1 == a2 )
    return a1;
  v6 = *a1;
  if ( v6 == 68 )
  {
    v15 = (__int64)sub_A0A48(a1, a2, a3);
    if ( (unsigned __int8 *)v15 == a1 )
      return a1;
    v21 = a3[1];
    v10 = a1;
    if ( *a3 == v21 )
      return v10;
    v81 = a3[3];
    sub_9D15C((size_t **)p, (__int64)v21 - 48, (__int64 *)&v81);
    v22 = (char *)a3[5];
    v23 = (char *)a3[6];
    if ( v22 < v23 )
    {
      *((_QWORD *)v22 + 3) = v84;
      *(_OWORD *)v22 = *(_OWORD *)p;
      *((_QWORD *)v22 + 2) = v83;
      p[1] = 0LL;
      v83 = 0LL;
      p[0] = 0LL;
      a3[5] = (char *)a3[5] + 32;
      v20 = (void **)p[0];
      if ( !p[0] )
        return (unsigned __int8 *)v15;
      goto LABEL_93;
    }
    v33 = a3[4];
    v34 = (v22 - v33) >> 5;
    if ( (unsigned __int64)(v34 + 1) >> 59 )
      abort();
    v35 = v23 - v33;
    if ( (unsigned __int64)(v35 >> 5) > 0x3FFFFFFFFFFFFFELL )
    {
      v37 = 0x7FFFFFFFFFFFFFFLL;
    }
    else
    {
      v36 = v35 >> 4;
      if ( v36 >= v34 + 1 )
        v37 = v36;
      else
        v37 = v34 + 1;
      if ( !v37 )
      {
        v38 = 0LL;
        goto LABEL_66;
      }
    }
    v47 = a3[7];
    v38 = (char *)v47[512];
    if ( (char *)(v47 + 512) - v38 >= (unsigned __int64)(32 * v37) )
      v47[512] = &v38[32 * v37];
    else
      v38 = (char *)malloc(32 * v37);
LABEL_66:
    v50 = &v38[32 * v34];
    *((_QWORD *)v50 + 1) = 0LL;
    *((_QWORD *)v50 + 2) = 0LL;
    v51 = v50 + 32;
    *((_QWORD *)v50 + 3) = v84;
    *(_OWORD *)v50 = *(_OWORD *)p;
    *((_QWORD *)v50 + 2) = v83;
    p[1] = 0LL;
    v83 = 0LL;
    p[0] = 0LL;
    v53 = (void **)a3[4];
    v52 = (void **)a3[5];
    v54 = &v38[32 * v37];
    if ( v52 == v53 )
    {
      v56 = (void **)a3[4];
    }
    else
    {
      do
      {
        *((_QWORD *)v50 - 3) = 0LL;
        *((_QWORD *)v50 - 2) = 0LL;
        *((_QWORD *)v50 - 4) = 0LL;
        *((_QWORD *)v50 - 1) = *(v52 - 1);
        v55 = *((_OWORD *)v52 - 2);
        v52 -= 4;
        *((_OWORD *)v50 - 2) = v55;
        *((_QWORD *)v50 - 2) = v52[2];
        v50 -= 32;
        v52[1] = 0LL;
        v52[2] = 0LL;
        *v52 = 0LL;
      }
      while ( v53 != v52 );
      v56 = (void **)a3[4];
      v53 = (void **)a3[5];
    }
    v59 = a3[6];
    a3[4] = v50;
    a3[5] = v51;
    a3[6] = v54;
    while ( v56 != v53 )
    {
      v53 -= 4;
      sub_9D32C(v53);
    }
    if ( v56 )
    {
      v60 = (unsigned __int64)a3[7];
      if ( v60 + 4096 < (unsigned __int64)v56 || v60 > (unsigned __int64)v56 )
      {
        free(v56);
      }
      else if ( *(void **)(v60 + 4096) == v59 )
      {
        *(_QWORD *)(v60 + 4096) = v56;
        v20 = (void **)p[0];
        if ( !p[0] )
          return (unsigned __int8 *)v15;
        goto LABEL_93;
      }
    }
    v20 = (void **)p[0];
    if ( !p[0] )
      return (unsigned __int8 *)v15;
LABEL_93:
    v61 = (void **)p[1];
    if ( p[1] != v20 )
    {
      do
      {
        if ( (*(_BYTE *)(v61 - 3) & 1) != 0 )
          free(*(v61 - 1));
        v62 = v61 - 6;
        if ( (*(_BYTE *)(v61 - 6) & 1) != 0 )
          free(*(v61 - 4));
        v61 -= 6;
      }
      while ( v20 != v62 );
    }
    goto LABEL_99;
  }
  if ( v6 == 83 )
  {
    v10 = sub_9E1F8(a1, a2, a3);
    if ( v10 != a1 )
      return v10;
    if ( a2 - a1 < 3 )
      return a1;
    if ( a1[1] != 116 )
      return a1;
    v15 = sub_A0C94(a1 + 2, a2, (char **)a3);
    if ( (unsigned __int8 *)v15 == a1 + 2 )
      return a1;
    v16 = (size_t *)a3[1];
    v10 = a1;
    if ( *a3 == v16 )
      return v10;
    sub_9CDD8(v16 - 6, 0LL, "std::", 5uLL);
    v17 = (__int64)a3[1] - 48;
    v81 = a3[3];
    sub_9D15C((size_t **)p, v17, (__int64 *)&v81);
    v18 = (char *)a3[5];
    v19 = (char *)a3[6];
    if ( v18 < v19 )
    {
      *((_QWORD *)v18 + 3) = v84;
      *(_OWORD *)v18 = *(_OWORD *)p;
      *((_QWORD *)v18 + 2) = v83;
      p[1] = 0LL;
      v83 = 0LL;
      p[0] = 0LL;
      a3[5] = (char *)a3[5] + 32;
      v20 = (void **)p[0];
      if ( !p[0] )
        return (unsigned __int8 *)v15;
      goto LABEL_130;
    }
    v63 = a3[4];
    v64 = (v18 - v63) >> 5;
    if ( (unsigned __int64)(v64 + 1) >> 59 )
      abort();
    v65 = v19 - v63;
    if ( (unsigned __int64)(v65 >> 5) > 0x3FFFFFFFFFFFFFELL )
    {
      v67 = 0x7FFFFFFFFFFFFFFLL;
    }
    else
    {
      v66 = v65 >> 4;
      if ( v66 >= v64 + 1 )
        v67 = v66;
      else
        v67 = v64 + 1;
      if ( !v67 )
      {
        v68 = 0LL;
LABEL_116:
        v70 = &v68[32 * v64];
        *((_QWORD *)v70 + 1) = 0LL;
        *((_QWORD *)v70 + 2) = 0LL;
        v71 = v70 + 32;
        *((_QWORD *)v70 + 3) = v84;
        *(_OWORD *)v70 = *(_OWORD *)p;
        *((_QWORD *)v70 + 2) = v83;
        p[1] = 0LL;
        v83 = 0LL;
        p[0] = 0LL;
        v73 = (void **)a3[4];
        v72 = (void **)a3[5];
        v74 = &v68[32 * v67];
        if ( v72 == v73 )
        {
          v76 = (void **)a3[4];
        }
        else
        {
          do
          {
            *((_QWORD *)v70 - 3) = 0LL;
            *((_QWORD *)v70 - 2) = 0LL;
            *((_QWORD *)v70 - 4) = 0LL;
            *((_QWORD *)v70 - 1) = *(v72 - 1);
            v75 = *((_OWORD *)v72 - 2);
            v72 -= 4;
            *((_OWORD *)v70 - 2) = v75;
            *((_QWORD *)v70 - 2) = v72[2];
            v70 -= 32;
            v72[1] = 0LL;
            v72[2] = 0LL;
            *v72 = 0LL;
          }
          while ( v73 != v72 );
          v76 = (void **)a3[4];
          v73 = (void **)a3[5];
        }
        v77 = a3[6];
        a3[4] = v70;
        a3[5] = v71;
        a3[6] = v74;
        while ( v76 != v73 )
        {
          v73 -= 4;
          sub_9D32C(v73);
        }
        if ( v76 )
        {
          v78 = (unsigned __int64)a3[7];
          if ( v78 + 4096 < (unsigned __int64)v76 || v78 > (unsigned __int64)v76 )
          {
            free(v76);
          }
          else if ( *(void **)(v78 + 4096) == v77 )
          {
            *(_QWORD *)(v78 + 4096) = v76;
            v20 = (void **)p[0];
            if ( !p[0] )
              return (unsigned __int8 *)v15;
            goto LABEL_130;
          }
        }
        v20 = (void **)p[0];
        if ( p[0] )
        {
LABEL_130:
          v79 = (void **)p[1];
          if ( p[1] != v20 )
          {
            do
            {
              if ( (*(_BYTE *)(v79 - 3) & 1) != 0 )
                free(*(v79 - 1));
              v80 = v79 - 6;
              if ( (*(_BYTE *)(v79 - 6) & 1) != 0 )
                free(*(v79 - 4));
              v79 -= 6;
            }
            while ( v20 != v80 );
          }
LABEL_99:
          p[1] = v20;
          if ( v84 + 4096 < (unsigned __int64)v20 || v84 > (unsigned __int64)v20 )
          {
            free(v20);
          }
          else if ( *(_QWORD *)(v84 + 4096) == v83 )
          {
            *(_QWORD *)(v84 + 4096) = v20;
          }
        }
        return (unsigned __int8 *)v15;
      }
    }
    v69 = a3[7];
    v68 = (char *)v69[512];
    if ( (char *)(v69 + 512) - v68 >= (unsigned __int64)(32 * v67) )
      v69[512] = &v68[32 * v67];
    else
      v68 = (char *)malloc(32 * v67);
    goto LABEL_116;
  }
  if ( v6 != 84 )
    return a1;
  v7 = 0xAAAAAAAAAAAAAAABLL * (((_BYTE *)a3[1] - (_BYTE *)*a3) >> 4);
  v8 = sub_9F9E8(a1, a2, (__int64)a3);
  v9 = a3[1];
  v10 = (unsigned __int8 *)v8;
  v11 = 0xAAAAAAAAAAAAAAABLL * ((v9 - (_BYTE *)*a3) >> 4);
  if ( (unsigned __int8 *)v8 == a1 || v11 != v7 + 1 )
  {
    if ( v11 != v7 )
    {
      v24 = (void **)(v9 - 48);
      v25 = v7 - v11;
      do
      {
        if ( ((_BYTE)v24[3] & 1) != 0 )
          free(v24[5]);
        if ( (*(_BYTE *)v24 & 1) != 0 )
          free(v24[2]);
        a3[1] = v24;
        ++v25;
        v24 -= 6;
      }
      while ( v25 );
    }
    return a1;
  }
  v81 = a3[3];
  sub_9D15C((size_t **)p, (__int64)(v9 - 48), (__int64 *)&v81);
  v12 = (char *)a3[5];
  v13 = (char *)a3[6];
  if ( v12 < v13 )
  {
    *((_QWORD *)v12 + 3) = v84;
    *(_OWORD *)v12 = *(_OWORD *)p;
    *((_QWORD *)v12 + 2) = v83;
    p[1] = 0LL;
    v83 = 0LL;
    p[0] = 0LL;
    a3[5] = (char *)a3[5] + 32;
    v14 = (void **)p[0];
    if ( !p[0] )
      return v10;
    goto LABEL_71;
  }
  v27 = a3[4];
  v28 = (v12 - v27) >> 5;
  if ( (unsigned __int64)(v28 + 1) >> 59 )
    abort();
  v29 = v13 - v27;
  if ( (unsigned __int64)(v29 >> 5) > 0x3FFFFFFFFFFFFFELL )
  {
    v31 = 0x7FFFFFFFFFFFFFFLL;
  }
  else
  {
    v30 = v29 >> 4;
    if ( v30 >= v28 + 1 )
      v31 = v30;
    else
      v31 = v28 + 1;
    if ( !v31 )
    {
      v32 = 0LL;
      goto LABEL_50;
    }
  }
  v39 = a3[7];
  v32 = (char *)v39[512];
  if ( (char *)(v39 + 512) - v32 >= (unsigned __int64)(32 * v31) )
    v39[512] = &v32[32 * v31];
  else
    v32 = (char *)malloc(32 * v31);
LABEL_50:
  v40 = &v32[32 * v28];
  *((_QWORD *)v40 + 1) = 0LL;
  *((_QWORD *)v40 + 2) = 0LL;
  v41 = v40 + 32;
  *((_QWORD *)v40 + 3) = v84;
  *(_OWORD *)v40 = *(_OWORD *)p;
  *((_QWORD *)v40 + 2) = v83;
  p[1] = 0LL;
  v83 = 0LL;
  p[0] = 0LL;
  v43 = (void **)a3[4];
  v42 = (void **)a3[5];
  v44 = &v32[32 * v31];
  if ( v42 == v43 )
  {
    v46 = (void **)a3[4];
  }
  else
  {
    do
    {
      *((_QWORD *)v40 - 3) = 0LL;
      *((_QWORD *)v40 - 2) = 0LL;
      *((_QWORD *)v40 - 4) = 0LL;
      *((_QWORD *)v40 - 1) = *(v42 - 1);
      v45 = *((_OWORD *)v42 - 2);
      v42 -= 4;
      *((_OWORD *)v40 - 2) = v45;
      *((_QWORD *)v40 - 2) = v42[2];
      v40 -= 32;
      v42[1] = 0LL;
      v42[2] = 0LL;
      *v42 = 0LL;
    }
    while ( v43 != v42 );
    v46 = (void **)a3[4];
    v43 = (void **)a3[5];
  }
  v48 = a3[6];
  a3[4] = v40;
  a3[5] = v41;
  a3[6] = v44;
  while ( v46 != v43 )
  {
    v43 -= 4;
    sub_9D32C(v43);
  }
  if ( !v46 )
  {
LABEL_70:
    v14 = (void **)p[0];
    if ( !p[0] )
      return v10;
    goto LABEL_71;
  }
  v49 = (unsigned __int64)a3[7];
  if ( v49 + 4096 < (unsigned __int64)v46 || v49 > (unsigned __int64)v46 )
  {
    free(v46);
    goto LABEL_70;
  }
  if ( *(void **)(v49 + 4096) != v48 )
    goto LABEL_70;
  *(_QWORD *)(v49 + 4096) = v46;
  v14 = (void **)p[0];
  if ( !p[0] )
    return v10;
LABEL_71:
  v57 = (void **)p[1];
  if ( p[1] != v14 )
  {
    do
    {
      if ( (*(_BYTE *)(v57 - 3) & 1) != 0 )
        free(*(v57 - 1));
      v58 = v57 - 6;
      if ( (*(_BYTE *)(v57 - 6) & 1) != 0 )
        free(*(v57 - 4));
      v57 -= 6;
    }
    while ( v14 != v58 );
  }
  p[1] = v14;
  if ( v84 + 4096 < (unsigned __int64)v14 || v84 > (unsigned __int64)v14 )
  {
    free(v14);
  }
  else if ( *(_QWORD *)(v84 + 4096) == v83 )
  {
    *(_QWORD *)(v84 + 4096) = v14;
  }
  return v10;
}

//----- (00000000000AC0B0) ----------------------------------------------------
__int64 __fastcall sub_AC0B0(_BYTE *a1, __int64 a2, __int64 a3)
{
  _BYTE *v3; // x19
  __int64 v5; // x21
  unsigned __int64 v6; // x9
  unsigned __int64 v7; // x10
  unsigned __int64 v8; // x22
  unsigned __int64 v9; // x10
  __int64 v10; // x9
  char *v11; // x0
  _BYTE *v12; // x22
  __int64 v13; // x21
  __int64 v14; // x8
  size_t *v15; // x0
  char *v16; // x2
  size_t v17; // x3
  unsigned __int64 v18; // x10
  unsigned __int64 v19; // x22
  unsigned __int64 v20; // x10
  __int64 v21; // x9
  char *v22; // x0
  int v23; // w9
  unsigned __int64 v24; // x10
  unsigned __int64 v25; // x22
  unsigned __int64 v26; // x10
  __int64 v27; // x9
  char *v28; // x0
  unsigned __int64 v29; // x10
  unsigned __int64 v30; // x22
  unsigned __int64 v31; // x10
  __int64 v32; // x9
  char *v33; // x0
  unsigned __int64 v34; // x10
  unsigned __int64 v35; // x22
  unsigned __int64 v36; // x10
  __int64 v37; // x9
  char *v38; // x0
  unsigned __int64 v39; // x10
  unsigned __int64 v40; // x22
  unsigned __int64 v41; // x10
  __int64 v42; // x9
  char *v43; // x0
  int v44; // w9
  unsigned __int64 v45; // x10
  unsigned __int64 v46; // x22
  unsigned __int64 v47; // x10
  __int64 v48; // x9
  char *v49; // x0
  unsigned __int64 v50; // x10
  unsigned __int64 v51; // x22
  unsigned __int64 v52; // x10
  __int64 v53; // x9
  char *v54; // x0
  unsigned __int64 v55; // x10
  unsigned __int64 v56; // x22
  unsigned __int64 v57; // x10
  __int64 v58; // x9
  char *v59; // x0
  unsigned __int64 v60; // x10
  unsigned __int64 v61; // x22
  unsigned __int64 v62; // x10
  __int64 v63; // x9
  char *v64; // x0
  unsigned __int64 v65; // x10
  unsigned __int64 v66; // x22
  unsigned __int64 v67; // x10
  __int64 v68; // x9
  char *v69; // x0
  int v70; // w9
  unsigned __int64 v71; // x10
  unsigned __int64 v72; // x22
  unsigned __int64 v73; // x10
  __int64 v74; // x9
  char *v75; // x0
  unsigned __int64 v76; // x10
  unsigned __int64 v77; // x10
  unsigned __int64 v78; // x22
  unsigned __int64 v79; // x10
  __int64 v80; // x9
  char *v81; // x0
  unsigned __int64 v82; // x10
  unsigned __int64 v83; // x22
  unsigned __int64 v84; // x10
  __int64 v85; // x9
  char *v86; // x0
  unsigned __int64 v87; // x10
  unsigned __int64 v88; // x22
  unsigned __int64 v89; // x10
  __int64 v90; // x9
  char *v91; // x0
  unsigned __int64 v92; // x10
  unsigned __int64 v93; // x22
  unsigned __int64 v94; // x10
  __int64 v95; // x9
  char *v96; // x0
  unsigned __int64 v97; // x10
  unsigned __int64 v98; // x22
  unsigned __int64 v99; // x10
  __int64 v100; // x9
  char *v101; // x0
  unsigned __int64 v102; // x10
  unsigned __int64 v103; // x10
  unsigned __int64 v104; // x10
  unsigned __int64 v105; // x22
  unsigned __int64 v106; // x10
  __int64 v107; // x9
  char *v108; // x0
  unsigned __int64 v109; // x10
  unsigned __int64 v110; // x22
  unsigned __int64 v111; // x10
  __int64 v112; // x9
  char *v113; // x0
  unsigned __int64 v114; // x10
  unsigned __int64 v115; // x22
  unsigned __int64 v116; // x10
  __int64 v117; // x9
  char *v118; // x0
  char v119; // w24
  _BYTE *v120; // x22
  __int64 v121; // x8
  unsigned __int64 v122; // x10
  unsigned __int64 v123; // x22
  unsigned __int64 v124; // x10
  __int64 v125; // x9
  char *v126; // x0
  _BYTE *v127; // x22
  __int64 v128; // x8
  unsigned __int64 v129; // x10
  unsigned __int64 v130; // x22
  unsigned __int64 v131; // x10
  __int64 v132; // x9
  char *v133; // x0
  unsigned __int64 v134; // x10
  unsigned __int64 v135; // x22
  unsigned __int64 v136; // x10
  __int64 v137; // x9
  char *v138; // x0
  unsigned __int64 v139; // x9
  unsigned __int64 v140; // x10
  __int64 v141; // x8
  unsigned __int64 v142; // x10
  unsigned __int64 v143; // x22
  unsigned __int64 v144; // x10
  __int64 v145; // x9
  char *v146; // x0
  unsigned __int64 v147; // x10
  unsigned __int64 v148; // x22
  unsigned __int64 v149; // x10
  __int64 v150; // x9
  char *v151; // x0
  unsigned __int64 v152; // x10
  unsigned __int64 v153; // x22
  unsigned __int64 v154; // x10
  __int64 v155; // x9
  char *v156; // x0
  unsigned __int64 v157; // x10
  unsigned __int64 v158; // x22
  unsigned __int64 v159; // x10
  __int64 v160; // x9
  char *v161; // x0
  unsigned __int64 v162; // x10
  unsigned __int64 v163; // x22
  unsigned __int64 v164; // x10
  __int64 v165; // x9
  char *v166; // x0
  unsigned __int64 v167; // x10
  unsigned __int64 v168; // x10
  unsigned __int64 v169; // x22
  unsigned __int64 v170; // x10
  __int64 v171; // x9
  char *v172; // x0
  unsigned __int64 v173; // x10
  unsigned __int64 v174; // x22
  unsigned __int64 v175; // x10
  __int64 v176; // x9
  char *v177; // x0
  unsigned __int64 v178; // x10
  unsigned __int64 v179; // x22
  unsigned __int64 v180; // x10
  __int64 v181; // x9
  char *v182; // x0
  unsigned __int64 v183; // x10
  unsigned __int64 v184; // x22
  unsigned __int64 v185; // x10
  __int64 v186; // x9
  char *v187; // x0
  unsigned __int64 v188; // x10
  unsigned __int64 v189; // x22
  unsigned __int64 v190; // x10
  __int64 v191; // x9
  char *v192; // x0
  unsigned __int64 v193; // x10
  unsigned __int64 v194; // x22
  unsigned __int64 v195; // x10
  __int64 v196; // x9
  char *v197; // x0
  unsigned __int64 v198; // x10
  unsigned __int64 v199; // x22
  unsigned __int64 v200; // x10
  __int64 v201; // x9
  char *v202; // x0
  unsigned __int64 v203; // x10
  unsigned __int64 v204; // x10
  unsigned __int64 v205; // x10
  unsigned __int64 v206; // x10
  unsigned __int64 v207; // x22
  unsigned __int64 v208; // x10
  __int64 v209; // x9
  char *v210; // x0
  unsigned __int64 v211; // x10
  unsigned __int64 v212; // x10
  unsigned __int64 v213; // x22
  unsigned __int64 v214; // x10
  __int64 v215; // x9
  char *v216; // x0
  unsigned __int64 v217; // x22
  unsigned __int64 v218; // x10
  __int64 v219; // x9
  char *v220; // x0
  unsigned __int64 v221; // x22
  unsigned __int64 v222; // x10
  __int64 v223; // x9
  char *v224; // x0
  unsigned __int64 v225; // x22
  unsigned __int64 v226; // x10
  __int64 v227; // x9
  char *v228; // x0
  unsigned __int64 v229; // x22
  unsigned __int64 v230; // x10
  __int64 v231; // x9
  char *v232; // x0
  unsigned __int64 v233; // x22
  unsigned __int64 v234; // x10
  __int64 v235; // x9
  char *v236; // x0
  unsigned __int64 v237; // x22
  unsigned __int64 v238; // x10
  __int64 v239; // x9
  char *v240; // x0
  unsigned __int64 v241; // x22
  unsigned __int64 v242; // x10
  __int64 v243; // x9
  char *v244; // x0
  unsigned __int64 v245; // x22
  unsigned __int64 v246; // x10
  __int64 v247; // x9
  char *v248; // x0
  unsigned __int64 v249; // x22
  unsigned __int64 v250; // x10
  __int64 v251; // x9
  char *v252; // x0
  char *v253; // x8
  char *v254; // x9
  void **v255; // x11
  void **v256; // x22
  char *v257; // x10
  __int64 v258; // x12
  void **v259; // x21
  __int64 v260; // x24
  void **v261; // x25
  char *v262; // x8
  char *v263; // x9
  void **v264; // x11
  void **v265; // x22
  char *v266; // x10
  __int64 v267; // x12
  __int64 v268; // x24
  void **v269; // x25
  char *v270; // x8
  char *v271; // x9
  void **v272; // x11
  void **v273; // x22
  char *v274; // x10
  __int64 v275; // x12
  void **v276; // x25
  char *v277; // x8
  char *v278; // x9
  void **v279; // x11
  void **v280; // x22
  char *v281; // x10
  __int64 v282; // x12
  void **v283; // x25
  char *v284; // x8
  char *v285; // x9
  void **v286; // x11
  void **v287; // x22
  char *v288; // x10
  __int64 v289; // x12
  void **v290; // x25
  char *v291; // x8
  char *v292; // x9
  void **v293; // x11
  void **v294; // x22
  char *v295; // x10
  __int64 v296; // x12
  void **v297; // x25
  char *v298; // x8
  char *v299; // x9
  void **v300; // x11
  void **v301; // x22
  char *v302; // x10
  __int64 v303; // x12
  void **v304; // x25
  char *v305; // x8
  char *v306; // x9
  void **v307; // x11
  void **v308; // x22
  char *v309; // x10
  __int64 v310; // x12
  void **v311; // x25
  char *v312; // x8
  char *v313; // x9
  void **v314; // x11
  void **v315; // x22
  char *v316; // x10
  __int64 v317; // x12
  void **v318; // x25
  char *v319; // x8
  char *v320; // x9
  void **v321; // x11
  void **v322; // x22
  char *v323; // x10
  __int64 v324; // x12
  void **v325; // x25
  char *v326; // x8
  char *v327; // x9
  void **v328; // x11
  void **v329; // x22
  char *v330; // x10
  __int64 v331; // x12
  void **v332; // x25
  char *v333; // x8
  char *v334; // x9
  void **v335; // x11
  void **v336; // x22
  char *v337; // x10
  __int64 v338; // x12
  void **v339; // x25
  char *v340; // x8
  char *v341; // x9
  void **v342; // x11
  void **v343; // x22
  char *v344; // x10
  __int64 v345; // x12
  void **v346; // x25
  char *v347; // x8
  char *v348; // x9
  void **v349; // x11
  void **v350; // x22
  char *v351; // x10
  __int64 v352; // x12
  void **v353; // x25
  char *v354; // x8
  char *v355; // x9
  void **v356; // x11
  void **v357; // x22
  char *v358; // x10
  __int64 v359; // x12
  void **v360; // x25
  char *v361; // x8
  char *v362; // x9
  void **v363; // x11
  void **v364; // x22
  char *v365; // x10
  __int64 v366; // x12
  void **v367; // x25
  unsigned __int64 v368; // x8
  char *v369; // x8
  char *v370; // x9
  void **v371; // x11
  void **v372; // x22
  char *v373; // x10
  __int64 v374; // x12
  void **v375; // x25
  char *v376; // x8
  char *v377; // x9
  void **v378; // x11
  void **v379; // x22
  char *v380; // x10
  __int64 v381; // x12
  void **v382; // x25
  char *v383; // x8
  char *v384; // x9
  void **v385; // x11
  void **v386; // x22
  char *v387; // x10
  __int64 v388; // x12
  void **v389; // x25
  char *v390; // x8
  char *v391; // x9
  void **v392; // x11
  void **v393; // x22
  char *v394; // x10
  __int64 v395; // x12
  void **v396; // x25
  char *v397; // x8
  char *v398; // x9
  void **v399; // x11
  void **v400; // x22
  char *v401; // x10
  __int64 v402; // x12
  void **v403; // x25
  char *v404; // x8
  char *v405; // x9
  void **v406; // x11
  void **v407; // x22
  char *v408; // x10
  __int64 v409; // x12
  void **v410; // x25
  char *v411; // x8
  char *v412; // x9
  void **v413; // x11
  void **v414; // x22
  char *v415; // x10
  __int64 v416; // x12
  void **v417; // x25
  char *v418; // x8
  char *v419; // x9
  void **v420; // x11
  void **v421; // x22
  char *v422; // x10
  __int64 v423; // x12
  void **v424; // x25
  char *v425; // x8
  char *v426; // x9
  void **v427; // x11
  void **v428; // x22
  char *v429; // x10
  __int64 v430; // x12
  void **v431; // x25
  char *v432; // x8
  char *v433; // x9
  void **v434; // x11
  void **v435; // x22
  char *v436; // x10
  __int64 v437; // x12
  void **v438; // x25
  char *v439; // x8
  char *v440; // x9
  void **v441; // x11
  void **v442; // x22
  char *v443; // x10
  __int64 v444; // x12
  void **v445; // x25
  char *v446; // x8
  char *v447; // x9
  void **v448; // x11
  void **v449; // x22
  char *v450; // x10
  __int64 v451; // x12
  void **v452; // x25
  char *v453; // x8
  char *v454; // x9
  void **v455; // x11
  void **v456; // x22
  char *v457; // x10
  __int64 v458; // x12
  void **v459; // x25
  char *v460; // x8
  char *v461; // x9
  void **v462; // x11
  void **v463; // x22
  char *v464; // x10
  __int64 v465; // x12
  void **v466; // x25
  char *v467; // x8
  char *v468; // x9
  void **v469; // x11
  void **v470; // x22
  char *v471; // x10
  __int64 v472; // x12
  void **v473; // x25
  char *v474; // x8
  char *v475; // x9
  void **v476; // x11
  void **v477; // x22
  char *v478; // x10
  __int64 v479; // x12
  void **v480; // x25
  char *v481; // x8
  char *v482; // x9
  void **v483; // x11
  void **v484; // x22
  char *v485; // x10
  __int64 v486; // x12
  void **v487; // x25
  char *v488; // x8
  char *v489; // x9
  void **v490; // x11
  void **v491; // x22
  char *v492; // x10
  __int64 v493; // x12
  void **v494; // x25
  char *v495; // x8
  char *v496; // x9
  void **v497; // x11
  void **v498; // x22
  char *v499; // x10
  __int64 v500; // x12
  void **v501; // x25
  char *v502; // x8
  char *v503; // x9
  void **v504; // x11
  void **v505; // x22
  char *v506; // x10
  __int64 v507; // x12
  void **v508; // x25
  char *v509; // x8
  char *v510; // x9
  void **v511; // x11
  void **v512; // x22
  char *v513; // x10
  __int64 v514; // x12
  void **v515; // x25
  char *v516; // x8
  char *v517; // x9
  void **v518; // x11
  void **v519; // x22
  char *v520; // x10
  __int64 v521; // x12
  void **v522; // x25
  char *v523; // x8
  char *v524; // x9
  void **v525; // x11
  void **v526; // x22
  char *v527; // x10
  __int64 v528; // x12
  void **v529; // x25
  char *v530; // x8
  char *v531; // x9
  void **v532; // x11
  void **v533; // x22
  char *v534; // x10
  __int64 v535; // x12
  void **v536; // x25
  char *v537; // x8
  char *v538; // x9
  void **v539; // x11
  void **v540; // x22
  char *v541; // x10
  __int64 v542; // x12
  void **v543; // x25
  char *v544; // x8
  char *v545; // x9
  void **v546; // x11
  void **v547; // x22
  char *v548; // x10
  __int64 v549; // x12
  void **v550; // x25
  char *v551; // x8
  char *v552; // x9
  void **v553; // x11
  void **v554; // x22
  char *v555; // x10
  __int64 v556; // x12
  void **v557; // x25
  char *v558; // x8
  char *v559; // x9
  void **v560; // x11
  void **v561; // x22
  char *v562; // x10
  __int64 v563; // x12
  void **v564; // x25
  char *v565; // x8
  char *v566; // x9
  void **v567; // x11
  void **v568; // x22
  char *v569; // x10
  __int64 v570; // x12
  void **v571; // x25
  char *v572; // x8
  char *v573; // x9
  void **v574; // x11
  void **v575; // x22
  char *v576; // x10
  __int64 v577; // x12
  void **v578; // x25
  unsigned __int64 v579; // x8
  _QWORD v581[2]; // [xsp+8h] [xbp-68h] BYREF
  _QWORD v582[3]; // [xsp+18h] [xbp-58h] BYREF

  v3 = a1;
  v582[2] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a2 - (__int64)a1 < 2 )
    return (__int64)v3;
  v5 = 0x555555555555555LL;
  switch ( *a1 )
  {
    case 'a':
      switch ( a1[1] )
      {
        case 'N':
          *(_QWORD *)((char *)v582 + 7) = 0LL;
          v582[0] = 0LL;
          qmemcpy(v581, "operator&=", 10);
          v6 = *(_QWORD *)(a3 + 8);
          v157 = *(_QWORD *)(a3 + 16);
          if ( v6 < v157 )
            goto LABEL_365;
          v158 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v6 - *(_QWORD *)a3) >> 4);
          if ( v158 + 1 > 0x555555555555555LL )
            abort();
          v159 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v157 - *(_QWORD *)a3) >> 4);
          if ( v159 >= 0x2AAAAAAAAAAAAAALL || (2 * v159 >= v158 + 1 ? (v5 = 2 * v159) : (v5 = v158 + 1), v5) )
          {
            v160 = *(_QWORD *)(a3 + 24);
            v161 = *(char **)(v160 + 4096);
            if ( v160 + 4096 - (__int64)v161 >= (unsigned __int64)(48 * v5) )
              *(_QWORD *)(v160 + 4096) = &v161[48 * v5];
            else
              v161 = (char *)malloc(48 * v5);
          }
          else
          {
            v161 = 0LL;
          }
          v453 = &v161[48 * v158];
          *v453 = 20;
          v454 = &v161[48 * v5];
          *(_QWORD *)(v453 + 1) = v581[0];
          v453[11] = 0;
          *((_DWORD *)v453 + 3) = 0;
          *((_QWORD *)v453 + 2) = 0LL;
          *(_WORD *)(v453 + 9) = v581[1];
          v581[0] = 0LL;
          LOWORD(v581[1]) = 0;
          v453[24] = 0;
          *((_QWORD *)v453 + 4) = *(_QWORD *)((char *)v582 + 7);
          *((_QWORD *)v453 + 5) = 0LL;
          *(_QWORD *)(v453 + 25) = v582[0];
          *(_QWORD *)((char *)v582 + 7) = 0LL;
          v582[0] = 0LL;
          v456 = *(void ***)a3;
          v455 = *(void ***)(a3 + 8);
          v457 = v453 + 48;
          if ( v455 == *(void ***)a3 )
          {
            v259 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v453 - 4) = *(v455 - 4);
              *((_OWORD *)v453 - 3) = *((_OWORD *)v455 - 3);
              v458 = (__int64)*(v455 - 1);
              *(v455 - 5) = 0LL;
              *(v455 - 4) = 0LL;
              *(v455 - 6) = 0LL;
              *((_QWORD *)v453 - 1) = v458;
              *(_OWORD *)(v453 - 24) = *(_OWORD *)(v455 - 3);
              *(v455 - 2) = 0LL;
              *(v455 - 1) = 0LL;
              *(v455 - 3) = 0LL;
              v455 -= 6;
              v453 -= 48;
            }
            while ( v456 != v455 );
            v259 = *(void ***)a3;
            v456 = *(void ***)(a3 + 8);
          }
          v260 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v453;
          *(_QWORD *)(a3 + 8) = v457;
          *(_QWORD *)(a3 + 16) = v454;
          if ( v456 != v259 )
          {
            do
            {
              if ( (*(_BYTE *)(v456 - 3) & 1) != 0 )
                free(*(v456 - 1));
              v459 = v456 - 6;
              if ( (*(_BYTE *)(v456 - 6) & 1) != 0 )
                free(*(v456 - 4));
              v456 -= 6;
            }
            while ( v259 != v459 );
          }
          goto LABEL_1062;
        case 'S':
          *(_QWORD *)((char *)v582 + 7) = 0LL;
          v582[0] = 0LL;
          qmemcpy(v581, "operator=", 9);
          v6 = *(_QWORD *)(a3 + 8);
          v162 = *(_QWORD *)(a3 + 16);
          if ( v6 < v162 )
            goto LABEL_378;
          v163 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v6 - *(_QWORD *)a3) >> 4);
          if ( v163 + 1 > 0x555555555555555LL )
            abort();
          v164 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v162 - *(_QWORD *)a3) >> 4);
          if ( v164 >= 0x2AAAAAAAAAAAAAALL || (2 * v164 >= v163 + 1 ? (v5 = 2 * v164) : (v5 = v163 + 1), v5) )
          {
            v165 = *(_QWORD *)(a3 + 24);
            v166 = *(char **)(v165 + 4096);
            if ( v165 + 4096 - (__int64)v166 >= (unsigned __int64)(48 * v5) )
              *(_QWORD *)(v165 + 4096) = &v166[48 * v5];
            else
              v166 = (char *)malloc(48 * v5);
          }
          else
          {
            v166 = 0LL;
          }
          v460 = &v166[48 * v163];
          *v460 = 18;
          v461 = &v166[48 * v5];
          *(_QWORD *)(v460 + 1) = v581[0];
          v460[10] = 0;
          v460[9] = v581[1];
          *(_DWORD *)(v460 + 11) = 0;
          *((_QWORD *)v460 + 2) = 0LL;
          v460[15] = 0;
          v581[0] = 0LL;
          LOBYTE(v581[1]) = 0;
          v460[24] = 0;
          *((_QWORD *)v460 + 4) = *(_QWORD *)((char *)v582 + 7);
          *((_QWORD *)v460 + 5) = 0LL;
          *(_QWORD *)(v460 + 25) = v582[0];
          *(_QWORD *)((char *)v582 + 7) = 0LL;
          v582[0] = 0LL;
          v463 = *(void ***)a3;
          v462 = *(void ***)(a3 + 8);
          v464 = v460 + 48;
          if ( v462 == *(void ***)a3 )
          {
            v259 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v460 - 4) = *(v462 - 4);
              *((_OWORD *)v460 - 3) = *((_OWORD *)v462 - 3);
              v465 = (__int64)*(v462 - 1);
              *(v462 - 5) = 0LL;
              *(v462 - 4) = 0LL;
              *(v462 - 6) = 0LL;
              *((_QWORD *)v460 - 1) = v465;
              *(_OWORD *)(v460 - 24) = *(_OWORD *)(v462 - 3);
              *(v462 - 2) = 0LL;
              *(v462 - 1) = 0LL;
              *(v462 - 3) = 0LL;
              v462 -= 6;
              v460 -= 48;
            }
            while ( v463 != v462 );
            v259 = *(void ***)a3;
            v463 = *(void ***)(a3 + 8);
          }
          v260 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v460;
          *(_QWORD *)(a3 + 8) = v464;
          *(_QWORD *)(a3 + 16) = v461;
          if ( v463 != v259 )
          {
            do
            {
              if ( (*(_BYTE *)(v463 - 3) & 1) != 0 )
                free(*(v463 - 1));
              v466 = v463 - 6;
              if ( (*(_BYTE *)(v463 - 6) & 1) != 0 )
                free(*(v463 - 4));
              v463 -= 6;
            }
            while ( v259 != v466 );
          }
          goto LABEL_1062;
        case 'a':
          *(_QWORD *)((char *)v582 + 7) = 0LL;
          v582[0] = 0LL;
          qmemcpy(v581, "operator&&", 10);
          v6 = *(_QWORD *)(a3 + 8);
          v134 = *(_QWORD *)(a3 + 16);
          if ( v6 < v134 )
            goto LABEL_365;
          v135 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v6 - *(_QWORD *)a3) >> 4);
          if ( v135 + 1 > 0x555555555555555LL )
            abort();
          v136 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v134 - *(_QWORD *)a3) >> 4);
          if ( v136 >= 0x2AAAAAAAAAAAAAALL || (2 * v136 >= v135 + 1 ? (v5 = 2 * v136) : (v5 = v135 + 1), v5) )
          {
            v137 = *(_QWORD *)(a3 + 24);
            v138 = *(char **)(v137 + 4096);
            if ( v137 + 4096 - (__int64)v138 >= (unsigned __int64)(48 * v5) )
              *(_QWORD *)(v137 + 4096) = &v138[48 * v5];
            else
              v138 = (char *)malloc(48 * v5);
          }
          else
          {
            v138 = 0LL;
          }
          v397 = &v138[48 * v135];
          *v397 = 20;
          v398 = &v138[48 * v5];
          *(_QWORD *)(v397 + 1) = v581[0];
          v397[11] = 0;
          *((_DWORD *)v397 + 3) = 0;
          *((_QWORD *)v397 + 2) = 0LL;
          *(_WORD *)(v397 + 9) = v581[1];
          v581[0] = 0LL;
          LOWORD(v581[1]) = 0;
          v397[24] = 0;
          *((_QWORD *)v397 + 4) = *(_QWORD *)((char *)v582 + 7);
          *((_QWORD *)v397 + 5) = 0LL;
          *(_QWORD *)(v397 + 25) = v582[0];
          *(_QWORD *)((char *)v582 + 7) = 0LL;
          v582[0] = 0LL;
          v400 = *(void ***)a3;
          v399 = *(void ***)(a3 + 8);
          v401 = v397 + 48;
          if ( v399 == *(void ***)a3 )
          {
            v259 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v397 - 4) = *(v399 - 4);
              *((_OWORD *)v397 - 3) = *((_OWORD *)v399 - 3);
              v402 = (__int64)*(v399 - 1);
              *(v399 - 5) = 0LL;
              *(v399 - 4) = 0LL;
              *(v399 - 6) = 0LL;
              *((_QWORD *)v397 - 1) = v402;
              *(_OWORD *)(v397 - 24) = *(_OWORD *)(v399 - 3);
              *(v399 - 2) = 0LL;
              *(v399 - 1) = 0LL;
              *(v399 - 3) = 0LL;
              v399 -= 6;
              v397 -= 48;
            }
            while ( v400 != v399 );
            v259 = *(void ***)a3;
            v400 = *(void ***)(a3 + 8);
          }
          v260 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v397;
          *(_QWORD *)(a3 + 8) = v401;
          *(_QWORD *)(a3 + 16) = v398;
          if ( v400 != v259 )
          {
            do
            {
              if ( (*(_BYTE *)(v400 - 3) & 1) != 0 )
                free(*(v400 - 1));
              v403 = v400 - 6;
              if ( (*(_BYTE *)(v400 - 6) & 1) != 0 )
                free(*(v400 - 4));
              v400 -= 6;
            }
            while ( v259 != v403 );
          }
          goto LABEL_1062;
        case 'd':
        case 'n':
          *(_QWORD *)((char *)v582 + 7) = 0LL;
          v582[0] = 0LL;
          qmemcpy(v581, "operator&", 9);
          v6 = *(_QWORD *)(a3 + 8);
          v7 = *(_QWORD *)(a3 + 16);
          if ( v6 < v7 )
            goto LABEL_378;
          v8 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v6 - *(_QWORD *)a3) >> 4);
          if ( v8 + 1 > 0x555555555555555LL )
            abort();
          v9 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v7 - *(_QWORD *)a3) >> 4);
          if ( v9 >= 0x2AAAAAAAAAAAAAALL || (2 * v9 >= v8 + 1 ? (v5 = 2 * v9) : (v5 = v8 + 1), v5) )
          {
            v10 = *(_QWORD *)(a3 + 24);
            v11 = *(char **)(v10 + 4096);
            if ( v10 + 4096 - (__int64)v11 >= (unsigned __int64)(48 * v5) )
              *(_QWORD *)(v10 + 4096) = &v11[48 * v5];
            else
              v11 = (char *)malloc(48 * v5);
          }
          else
          {
            v11 = 0LL;
          }
          v270 = &v11[48 * v8];
          *v270 = 18;
          v271 = &v11[48 * v5];
          *(_QWORD *)(v270 + 1) = v581[0];
          v270[10] = 0;
          v270[9] = v581[1];
          *(_DWORD *)(v270 + 11) = 0;
          *((_QWORD *)v270 + 2) = 0LL;
          v270[15] = 0;
          v581[0] = 0LL;
          LOBYTE(v581[1]) = 0;
          v270[24] = 0;
          *((_QWORD *)v270 + 4) = *(_QWORD *)((char *)v582 + 7);
          *((_QWORD *)v270 + 5) = 0LL;
          *(_QWORD *)(v270 + 25) = v582[0];
          *(_QWORD *)((char *)v582 + 7) = 0LL;
          v582[0] = 0LL;
          v273 = *(void ***)a3;
          v272 = *(void ***)(a3 + 8);
          v274 = v270 + 48;
          if ( v272 == *(void ***)a3 )
          {
            v259 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v270 - 4) = *(v272 - 4);
              *((_OWORD *)v270 - 3) = *((_OWORD *)v272 - 3);
              v275 = (__int64)*(v272 - 1);
              *(v272 - 5) = 0LL;
              *(v272 - 4) = 0LL;
              *(v272 - 6) = 0LL;
              *((_QWORD *)v270 - 1) = v275;
              *(_OWORD *)(v270 - 24) = *(_OWORD *)(v272 - 3);
              *(v272 - 2) = 0LL;
              *(v272 - 1) = 0LL;
              *(v272 - 3) = 0LL;
              v272 -= 6;
              v270 -= 48;
            }
            while ( v273 != v272 );
            v259 = *(void ***)a3;
            v273 = *(void ***)(a3 + 8);
          }
          v260 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v270;
          *(_QWORD *)(a3 + 8) = v274;
          *(_QWORD *)(a3 + 16) = v271;
          if ( v273 != v259 )
          {
            do
            {
              if ( (*(_BYTE *)(v273 - 3) & 1) != 0 )
                free(*(v273 - 1));
              v276 = v273 - 6;
              if ( (*(_BYTE *)(v273 - 6) & 1) != 0 )
                free(*(v273 - 4));
              v273 -= 6;
            }
            while ( v259 != v276 );
          }
          goto LABEL_1062;
        default:
          return (__int64)v3;
      }
      return (__int64)v3;
    case 'c':
      switch ( a1[1] )
      {
        case 'l':
          *(_QWORD *)((char *)v582 + 7) = 0LL;
          v582[0] = 0LL;
          qmemcpy(v581, "operator()", 10);
          v6 = *(_QWORD *)(a3 + 8);
          v55 = *(_QWORD *)(a3 + 16);
          if ( v6 < v55 )
            goto LABEL_365;
          v56 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v6 - *(_QWORD *)a3) >> 4);
          if ( v56 + 1 > 0x555555555555555LL )
            abort();
          v57 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v55 - *(_QWORD *)a3) >> 4);
          if ( v57 >= 0x2AAAAAAAAAAAAAALL || (2 * v57 >= v56 + 1 ? (v5 = 2 * v57) : (v5 = v56 + 1), v5) )
          {
            v58 = *(_QWORD *)(a3 + 24);
            v59 = *(char **)(v58 + 4096);
            if ( v58 + 4096 - (__int64)v59 >= (unsigned __int64)(48 * v5) )
              *(_QWORD *)(v58 + 4096) = &v59[48 * v5];
            else
              v59 = (char *)malloc(48 * v5);
          }
          else
          {
            v59 = 0LL;
          }
          v369 = &v59[48 * v56];
          *v369 = 20;
          v370 = &v59[48 * v5];
          *(_QWORD *)(v369 + 1) = v581[0];
          v369[11] = 0;
          *((_DWORD *)v369 + 3) = 0;
          *((_QWORD *)v369 + 2) = 0LL;
          *(_WORD *)(v369 + 9) = v581[1];
          v581[0] = 0LL;
          LOWORD(v581[1]) = 0;
          v369[24] = 0;
          *((_QWORD *)v369 + 4) = *(_QWORD *)((char *)v582 + 7);
          *((_QWORD *)v369 + 5) = 0LL;
          *(_QWORD *)(v369 + 25) = v582[0];
          *(_QWORD *)((char *)v582 + 7) = 0LL;
          v582[0] = 0LL;
          v372 = *(void ***)a3;
          v371 = *(void ***)(a3 + 8);
          v373 = v369 + 48;
          if ( v371 == *(void ***)a3 )
          {
            v259 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v369 - 4) = *(v371 - 4);
              *((_OWORD *)v369 - 3) = *((_OWORD *)v371 - 3);
              v374 = (__int64)*(v371 - 1);
              *(v371 - 5) = 0LL;
              *(v371 - 4) = 0LL;
              *(v371 - 6) = 0LL;
              *((_QWORD *)v369 - 1) = v374;
              *(_OWORD *)(v369 - 24) = *(_OWORD *)(v371 - 3);
              *(v371 - 2) = 0LL;
              *(v371 - 1) = 0LL;
              *(v371 - 3) = 0LL;
              v371 -= 6;
              v369 -= 48;
            }
            while ( v372 != v371 );
            v259 = *(void ***)a3;
            v372 = *(void ***)(a3 + 8);
          }
          v260 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v369;
          *(_QWORD *)(a3 + 8) = v373;
          *(_QWORD *)(a3 + 16) = v370;
          if ( v372 != v259 )
          {
            do
            {
              if ( (*(_BYTE *)(v372 - 3) & 1) != 0 )
                free(*(v372 - 1));
              v375 = v372 - 6;
              if ( (*(_BYTE *)(v372 - 6) & 1) != 0 )
                free(*(v372 - 4));
              v372 -= 6;
            }
            while ( v259 != v375 );
          }
          goto LABEL_1062;
        case 'm':
          *(_QWORD *)((char *)v582 + 7) = 0LL;
          v582[0] = 0LL;
          qmemcpy(v581, "operator,", 9);
          v6 = *(_QWORD *)(a3 + 8);
          v114 = *(_QWORD *)(a3 + 16);
          if ( v6 < v114 )
            goto LABEL_378;
          v115 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v6 - *(_QWORD *)a3) >> 4);
          if ( v115 + 1 > 0x555555555555555LL )
            abort();
          v116 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v114 - *(_QWORD *)a3) >> 4);
          if ( v116 >= 0x2AAAAAAAAAAAAAALL || (2 * v116 >= v115 + 1 ? (v5 = 2 * v116) : (v5 = v115 + 1), v5) )
          {
            v117 = *(_QWORD *)(a3 + 24);
            v118 = *(char **)(v117 + 4096);
            if ( v117 + 4096 - (__int64)v118 >= (unsigned __int64)(48 * v5) )
              *(_QWORD *)(v117 + 4096) = &v118[48 * v5];
            else
              v118 = (char *)malloc(48 * v5);
          }
          else
          {
            v118 = 0LL;
          }
          v376 = &v118[48 * v115];
          *v376 = 18;
          v377 = &v118[48 * v5];
          *(_QWORD *)(v376 + 1) = v581[0];
          v376[10] = 0;
          v376[9] = v581[1];
          *(_DWORD *)(v376 + 11) = 0;
          *((_QWORD *)v376 + 2) = 0LL;
          v376[15] = 0;
          v581[0] = 0LL;
          LOBYTE(v581[1]) = 0;
          v376[24] = 0;
          *((_QWORD *)v376 + 4) = *(_QWORD *)((char *)v582 + 7);
          *((_QWORD *)v376 + 5) = 0LL;
          *(_QWORD *)(v376 + 25) = v582[0];
          *(_QWORD *)((char *)v582 + 7) = 0LL;
          v582[0] = 0LL;
          v379 = *(void ***)a3;
          v378 = *(void ***)(a3 + 8);
          v380 = v376 + 48;
          if ( v378 == *(void ***)a3 )
          {
            v259 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v376 - 4) = *(v378 - 4);
              *((_OWORD *)v376 - 3) = *((_OWORD *)v378 - 3);
              v381 = (__int64)*(v378 - 1);
              *(v378 - 5) = 0LL;
              *(v378 - 4) = 0LL;
              *(v378 - 6) = 0LL;
              *((_QWORD *)v376 - 1) = v381;
              *(_OWORD *)(v376 - 24) = *(_OWORD *)(v378 - 3);
              *(v378 - 2) = 0LL;
              *(v378 - 1) = 0LL;
              *(v378 - 3) = 0LL;
              v378 -= 6;
              v376 -= 48;
            }
            while ( v379 != v378 );
            v259 = *(void ***)a3;
            v379 = *(void ***)(a3 + 8);
          }
          v260 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v376;
          *(_QWORD *)(a3 + 8) = v380;
          *(_QWORD *)(a3 + 16) = v377;
          if ( v379 != v259 )
          {
            do
            {
              if ( (*(_BYTE *)(v379 - 3) & 1) != 0 )
                free(*(v379 - 1));
              v382 = v379 - 6;
              if ( (*(_BYTE *)(v379 - 6) & 1) != 0 )
                free(*(v379 - 4));
              v379 -= 6;
            }
            while ( v259 != v382 );
          }
          goto LABEL_1062;
        case 'o':
          *(_QWORD *)((char *)v582 + 7) = 0LL;
          v582[0] = 0LL;
          qmemcpy(v581, "operator~", 9);
          v6 = *(_QWORD *)(a3 + 8);
          v104 = *(_QWORD *)(a3 + 16);
          if ( v6 < v104 )
            goto LABEL_378;
          v105 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v6 - *(_QWORD *)a3) >> 4);
          if ( v105 + 1 > 0x555555555555555LL )
            abort();
          v106 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v104 - *(_QWORD *)a3) >> 4);
          if ( v106 >= 0x2AAAAAAAAAAAAAALL || (2 * v106 >= v105 + 1 ? (v5 = 2 * v106) : (v5 = v105 + 1), v5) )
          {
            v107 = *(_QWORD *)(a3 + 24);
            v108 = *(char **)(v107 + 4096);
            if ( v107 + 4096 - (__int64)v108 >= (unsigned __int64)(48 * v5) )
              *(_QWORD *)(v107 + 4096) = &v108[48 * v5];
            else
              v108 = (char *)malloc(48 * v5);
          }
          else
          {
            v108 = 0LL;
          }
          v354 = &v108[48 * v105];
          *v354 = 18;
          v355 = &v108[48 * v5];
          *(_QWORD *)(v354 + 1) = v581[0];
          v354[10] = 0;
          v354[9] = v581[1];
          *(_DWORD *)(v354 + 11) = 0;
          *((_QWORD *)v354 + 2) = 0LL;
          v354[15] = 0;
          v581[0] = 0LL;
          LOBYTE(v581[1]) = 0;
          v354[24] = 0;
          *((_QWORD *)v354 + 4) = *(_QWORD *)((char *)v582 + 7);
          *((_QWORD *)v354 + 5) = 0LL;
          *(_QWORD *)(v354 + 25) = v582[0];
          *(_QWORD *)((char *)v582 + 7) = 0LL;
          v582[0] = 0LL;
          v357 = *(void ***)a3;
          v356 = *(void ***)(a3 + 8);
          v358 = v354 + 48;
          if ( v356 == *(void ***)a3 )
          {
            v259 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v354 - 4) = *(v356 - 4);
              *((_OWORD *)v354 - 3) = *((_OWORD *)v356 - 3);
              v359 = (__int64)*(v356 - 1);
              *(v356 - 5) = 0LL;
              *(v356 - 4) = 0LL;
              *(v356 - 6) = 0LL;
              *((_QWORD *)v354 - 1) = v359;
              *(_OWORD *)(v354 - 24) = *(_OWORD *)(v356 - 3);
              *(v356 - 2) = 0LL;
              *(v356 - 1) = 0LL;
              *(v356 - 3) = 0LL;
              v356 -= 6;
              v354 -= 48;
            }
            while ( v357 != v356 );
            v259 = *(void ***)a3;
            v357 = *(void ***)(a3 + 8);
          }
          v260 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v354;
          *(_QWORD *)(a3 + 8) = v358;
          *(_QWORD *)(a3 + 16) = v355;
          if ( v357 != v259 )
          {
            do
            {
              if ( (*(_BYTE *)(v357 - 3) & 1) != 0 )
                free(*(v357 - 1));
              v360 = v357 - 6;
              if ( (*(_BYTE *)(v357 - 6) & 1) != 0 )
                free(*(v357 - 4));
              v357 -= 6;
            }
            while ( v259 != v360 );
          }
          goto LABEL_1062;
        case 'v':
          v119 = *(_BYTE *)(a3 + 111);
          v120 = a1 + 2;
          *(_BYTE *)(a3 + 111) = 0;
          v13 = sub_925FC(a1 + 2, a2, a3);
          *(_BYTE *)(a3 + 111) = v119;
          if ( (_BYTE *)v13 == v120 )
            return (__int64)v3;
          v121 = *(_QWORD *)(a3 + 8);
          if ( *(_QWORD *)a3 == v121 )
            return (__int64)v3;
          sub_9CDD8((size_t *)(v121 - 48), 0LL, "operator ", 9uLL);
          *(_BYTE *)(a3 + 108) = 1;
          break;
        default:
          return (__int64)v3;
      }
      return v13;
    case 'd':
      switch ( a1[1] )
      {
        case 'V':
          *(_QWORD *)((char *)v582 + 7) = 0LL;
          v582[0] = 0LL;
          qmemcpy(v581, "operator/=", 10);
          v6 = *(_QWORD *)(a3 + 8);
          v50 = *(_QWORD *)(a3 + 16);
          if ( v6 < v50 )
            goto LABEL_365;
          v51 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v6 - *(_QWORD *)a3) >> 4);
          if ( v51 + 1 > 0x555555555555555LL )
            abort();
          v52 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v50 - *(_QWORD *)a3) >> 4);
          if ( v52 >= 0x2AAAAAAAAAAAAAALL || (2 * v52 >= v51 + 1 ? (v5 = 2 * v52) : (v5 = v51 + 1), v5) )
          {
            v53 = *(_QWORD *)(a3 + 24);
            v54 = *(char **)(v53 + 4096);
            if ( v53 + 4096 - (__int64)v54 >= (unsigned __int64)(48 * v5) )
              *(_QWORD *)(v53 + 4096) = &v54[48 * v5];
            else
              v54 = (char *)malloc(48 * v5);
          }
          else
          {
            v54 = 0LL;
          }
          v404 = &v54[48 * v51];
          *v404 = 20;
          v405 = &v54[48 * v5];
          *(_QWORD *)(v404 + 1) = v581[0];
          v404[11] = 0;
          *((_DWORD *)v404 + 3) = 0;
          *((_QWORD *)v404 + 2) = 0LL;
          *(_WORD *)(v404 + 9) = v581[1];
          v581[0] = 0LL;
          LOWORD(v581[1]) = 0;
          v404[24] = 0;
          *((_QWORD *)v404 + 4) = *(_QWORD *)((char *)v582 + 7);
          *((_QWORD *)v404 + 5) = 0LL;
          *(_QWORD *)(v404 + 25) = v582[0];
          *(_QWORD *)((char *)v582 + 7) = 0LL;
          v582[0] = 0LL;
          v407 = *(void ***)a3;
          v406 = *(void ***)(a3 + 8);
          v408 = v404 + 48;
          if ( v406 == *(void ***)a3 )
          {
            v259 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v404 - 4) = *(v406 - 4);
              *((_OWORD *)v404 - 3) = *((_OWORD *)v406 - 3);
              v409 = (__int64)*(v406 - 1);
              *(v406 - 5) = 0LL;
              *(v406 - 4) = 0LL;
              *(v406 - 6) = 0LL;
              *((_QWORD *)v404 - 1) = v409;
              *(_OWORD *)(v404 - 24) = *(_OWORD *)(v406 - 3);
              *(v406 - 2) = 0LL;
              *(v406 - 1) = 0LL;
              *(v406 - 3) = 0LL;
              v406 -= 6;
              v404 -= 48;
            }
            while ( v407 != v406 );
            v259 = *(void ***)a3;
            v407 = *(void ***)(a3 + 8);
          }
          v260 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v404;
          *(_QWORD *)(a3 + 8) = v408;
          *(_QWORD *)(a3 + 16) = v405;
          if ( v407 != v259 )
          {
            do
            {
              if ( (*(_BYTE *)(v407 - 3) & 1) != 0 )
                free(*(v407 - 1));
              v410 = v407 - 6;
              if ( (*(_BYTE *)(v407 - 6) & 1) != 0 )
                free(*(v407 - 4));
              v407 -= 6;
            }
            while ( v259 != v410 );
          }
          goto LABEL_1062;
        case 'a':
          memset(v581, 0, 15);
          qmemcpy(v582, "operator delete", 15);
          v139 = *(_QWORD *)(a3 + 8);
          v140 = *(_QWORD *)(a3 + 16);
          if ( v139 < v140 )
          {
            *(_BYTE *)v139 = 34;
            v3 = a1 + 2;
            *(_QWORD *)(v139 + 8) = *(_QWORD *)((char *)v582 + 7);
            v141 = v582[0];
            *(_QWORD *)(v139 + 16) = 23899LL;
            goto LABEL_295;
          }
          v221 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v139 - *(_QWORD *)a3) >> 4);
          if ( v221 + 1 > 0x555555555555555LL )
            abort();
          v222 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v140 - *(_QWORD *)a3) >> 4);
          if ( v222 >= 0x2AAAAAAAAAAAAAALL || (2 * v222 >= v221 + 1 ? (v5 = 2 * v222) : (v5 = v221 + 1), v5) )
          {
            v223 = *(_QWORD *)(a3 + 24);
            v224 = *(char **)(v223 + 4096);
            if ( v223 + 4096 - (__int64)v224 >= (unsigned __int64)(48 * v5) )
              *(_QWORD *)(v223 + 4096) = &v224[48 * v5];
            else
              v224 = (char *)malloc(48 * v5);
          }
          else
          {
            v224 = 0LL;
          }
          v425 = &v224[48 * v221];
          *v425 = 34;
          v426 = &v224[48 * v5];
          *((_QWORD *)v425 + 1) = *(_QWORD *)((char *)v582 + 7);
          *((_QWORD *)v425 + 2) = 23899LL;
          *(_QWORD *)(v425 + 1) = v582[0];
          *(_QWORD *)((char *)v582 + 7) = 0LL;
          v582[0] = 0LL;
          v425[24] = 0;
          *((_QWORD *)v425 + 4) = *(_QWORD *)((char *)v581 + 7);
          *((_QWORD *)v425 + 5) = 0LL;
          *(_QWORD *)(v425 + 25) = v581[0];
          memset(v581, 0, 15);
          v428 = *(void ***)a3;
          v427 = *(void ***)(a3 + 8);
          v429 = v425 + 48;
          if ( v427 == *(void ***)a3 )
          {
            v259 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v425 - 4) = *(v427 - 4);
              *((_OWORD *)v425 - 3) = *((_OWORD *)v427 - 3);
              v430 = (__int64)*(v427 - 1);
              *(v427 - 5) = 0LL;
              *(v427 - 4) = 0LL;
              *(v427 - 6) = 0LL;
              *((_QWORD *)v425 - 1) = v430;
              *(_OWORD *)(v425 - 24) = *(_OWORD *)(v427 - 3);
              *(v427 - 2) = 0LL;
              *(v427 - 1) = 0LL;
              *(v427 - 3) = 0LL;
              v427 -= 6;
              v425 -= 48;
            }
            while ( v428 != v427 );
            v259 = *(void ***)a3;
            v428 = *(void ***)(a3 + 8);
          }
          v260 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v425;
          *(_QWORD *)(a3 + 8) = v429;
          *(_QWORD *)(a3 + 16) = v426;
          if ( v428 != v259 )
          {
            do
            {
              if ( (*(_BYTE *)(v428 - 3) & 1) != 0 )
                free(*(v428 - 1));
              v431 = v428 - 6;
              if ( (*(_BYTE *)(v428 - 6) & 1) != 0 )
                free(*(v428 - 4));
              v428 -= 6;
            }
            while ( v259 != v431 );
          }
          goto LABEL_1062;
        case 'e':
          *(_QWORD *)((char *)v582 + 7) = 0LL;
          v582[0] = 0LL;
          qmemcpy(v581, "operator*", 9);
          v6 = *(_QWORD *)(a3 + 8);
          v122 = *(_QWORD *)(a3 + 16);
          if ( v6 < v122 )
            goto LABEL_378;
          v123 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v6 - *(_QWORD *)a3) >> 4);
          if ( v123 + 1 > 0x555555555555555LL )
            abort();
          v124 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v122 - *(_QWORD *)a3) >> 4);
          if ( v124 >= 0x2AAAAAAAAAAAAAALL || (2 * v124 >= v123 + 1 ? (v5 = 2 * v124) : (v5 = v123 + 1), v5) )
          {
            v125 = *(_QWORD *)(a3 + 24);
            v126 = *(char **)(v125 + 4096);
            if ( v125 + 4096 - (__int64)v126 >= (unsigned __int64)(48 * v5) )
              *(_QWORD *)(v125 + 4096) = &v126[48 * v5];
            else
              v126 = (char *)malloc(48 * v5);
          }
          else
          {
            v126 = 0LL;
          }
          v383 = &v126[48 * v123];
          *v383 = 18;
          v384 = &v126[48 * v5];
          *(_QWORD *)(v383 + 1) = v581[0];
          v383[10] = 0;
          v383[9] = v581[1];
          *(_DWORD *)(v383 + 11) = 0;
          *((_QWORD *)v383 + 2) = 0LL;
          v383[15] = 0;
          v581[0] = 0LL;
          LOBYTE(v581[1]) = 0;
          v383[24] = 0;
          *((_QWORD *)v383 + 4) = *(_QWORD *)((char *)v582 + 7);
          *((_QWORD *)v383 + 5) = 0LL;
          *(_QWORD *)(v383 + 25) = v582[0];
          *(_QWORD *)((char *)v582 + 7) = 0LL;
          v582[0] = 0LL;
          v386 = *(void ***)a3;
          v385 = *(void ***)(a3 + 8);
          v387 = v383 + 48;
          if ( v385 == *(void ***)a3 )
          {
            v259 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v383 - 4) = *(v385 - 4);
              *((_OWORD *)v383 - 3) = *((_OWORD *)v385 - 3);
              v388 = (__int64)*(v385 - 1);
              *(v385 - 5) = 0LL;
              *(v385 - 4) = 0LL;
              *(v385 - 6) = 0LL;
              *((_QWORD *)v383 - 1) = v388;
              *(_OWORD *)(v383 - 24) = *(_OWORD *)(v385 - 3);
              *(v385 - 2) = 0LL;
              *(v385 - 1) = 0LL;
              *(v385 - 3) = 0LL;
              v385 -= 6;
              v383 -= 48;
            }
            while ( v386 != v385 );
            v259 = *(void ***)a3;
            v386 = *(void ***)(a3 + 8);
          }
          v260 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v383;
          *(_QWORD *)(a3 + 8) = v387;
          *(_QWORD *)(a3 + 16) = v384;
          if ( v386 != v259 )
          {
            do
            {
              if ( (*(_BYTE *)(v386 - 3) & 1) != 0 )
                free(*(v386 - 1));
              v389 = v386 - 6;
              if ( (*(_BYTE *)(v386 - 6) & 1) != 0 )
                free(*(v386 - 4));
              v386 -= 6;
            }
            while ( v259 != v389 );
          }
          goto LABEL_1062;
        case 'l':
          memset(v581, 0, 15);
          qmemcpy(v582, "operator delete", 15);
          v139 = *(_QWORD *)(a3 + 8);
          v167 = *(_QWORD *)(a3 + 16);
          if ( v139 >= v167 )
          {
            v225 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v139 - *(_QWORD *)a3) >> 4);
            if ( v225 + 1 > 0x555555555555555LL )
              abort();
            v226 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v167 - *(_QWORD *)a3) >> 4);
            if ( v226 >= 0x2AAAAAAAAAAAAAALL || (2 * v226 >= v225 + 1 ? (v5 = 2 * v226) : (v5 = v225 + 1), v5) )
            {
              v227 = *(_QWORD *)(a3 + 24);
              v228 = *(char **)(v227 + 4096);
              if ( v227 + 4096 - (__int64)v228 >= (unsigned __int64)(48 * v5) )
                *(_QWORD *)(v227 + 4096) = &v228[48 * v5];
              else
                v228 = (char *)malloc(48 * v5);
            }
            else
            {
              v228 = 0LL;
            }
            v467 = &v228[48 * v225];
            *v467 = 30;
            v468 = &v228[48 * v5];
            *((_QWORD *)v467 + 1) = *(_QWORD *)((char *)v582 + 7);
            *((_QWORD *)v467 + 2) = 0LL;
            *(_QWORD *)(v467 + 1) = v582[0];
            *(_QWORD *)((char *)v582 + 7) = 0LL;
            v582[0] = 0LL;
            v467[24] = 0;
            *((_QWORD *)v467 + 4) = *(_QWORD *)((char *)v581 + 7);
            *((_QWORD *)v467 + 5) = 0LL;
            *(_QWORD *)(v467 + 25) = v581[0];
            memset(v581, 0, 15);
            v470 = *(void ***)a3;
            v469 = *(void ***)(a3 + 8);
            v471 = v467 + 48;
            if ( v469 == *(void ***)a3 )
            {
              v259 = *(void ***)a3;
            }
            else
            {
              do
              {
                *((_QWORD *)v467 - 4) = *(v469 - 4);
                *((_OWORD *)v467 - 3) = *((_OWORD *)v469 - 3);
                v472 = (__int64)*(v469 - 1);
                *(v469 - 5) = 0LL;
                *(v469 - 4) = 0LL;
                *(v469 - 6) = 0LL;
                *((_QWORD *)v467 - 1) = v472;
                *(_OWORD *)(v467 - 24) = *(_OWORD *)(v469 - 3);
                *(v469 - 2) = 0LL;
                *(v469 - 1) = 0LL;
                *(v469 - 3) = 0LL;
                v469 -= 6;
                v467 -= 48;
              }
              while ( v470 != v469 );
              v259 = *(void ***)a3;
              v470 = *(void ***)(a3 + 8);
            }
            v260 = *(_QWORD *)(a3 + 16);
            *(_QWORD *)a3 = v467;
            *(_QWORD *)(a3 + 8) = v471;
            *(_QWORD *)(a3 + 16) = v468;
            if ( v470 != v259 )
            {
              do
              {
                if ( (*(_BYTE *)(v470 - 3) & 1) != 0 )
                  free(*(v470 - 1));
                v473 = v470 - 6;
                if ( (*(_BYTE *)(v470 - 6) & 1) != 0 )
                  free(*(v470 - 4));
                v470 -= 6;
              }
              while ( v259 != v473 );
            }
            goto LABEL_1062;
          }
          *(_BYTE *)v139 = 30;
          v3 = a1 + 2;
          *(_QWORD *)(v139 + 8) = *(_QWORD *)((char *)v582 + 7);
          *(_QWORD *)(v139 + 16) = 0LL;
          v141 = v582[0];
LABEL_295:
          *(_QWORD *)(v139 + 1) = v141;
          *(_QWORD *)((char *)v582 + 7) = 0LL;
          v582[0] = 0LL;
          *(_BYTE *)(v139 + 24) = 0;
          *(_QWORD *)(v139 + 32) = *(_QWORD *)((char *)v581 + 7);
          *(_QWORD *)(v139 + 40) = 0LL;
          *(_QWORD *)(v139 + 25) = v581[0];
          memset(v581, 0, 15);
          break;
        case 'v':
          *(_QWORD *)((char *)v582 + 7) = 0LL;
          v582[0] = 0LL;
          qmemcpy(v581, "operator/", 9);
          v6 = *(_QWORD *)(a3 + 8);
          v178 = *(_QWORD *)(a3 + 16);
          if ( v6 < v178 )
            goto LABEL_378;
          v179 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v6 - *(_QWORD *)a3) >> 4);
          if ( v179 + 1 > 0x555555555555555LL )
            abort();
          v180 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v178 - *(_QWORD *)a3) >> 4);
          if ( v180 >= 0x2AAAAAAAAAAAAAALL || (2 * v180 >= v179 + 1 ? (v5 = 2 * v180) : (v5 = v179 + 1), v5) )
          {
            v181 = *(_QWORD *)(a3 + 24);
            v182 = *(char **)(v181 + 4096);
            if ( v181 + 4096 - (__int64)v182 >= (unsigned __int64)(48 * v5) )
              *(_QWORD *)(v181 + 4096) = &v182[48 * v5];
            else
              v182 = (char *)malloc(48 * v5);
          }
          else
          {
            v182 = 0LL;
          }
          v488 = &v182[48 * v179];
          *v488 = 18;
          v489 = &v182[48 * v5];
          *(_QWORD *)(v488 + 1) = v581[0];
          v488[10] = 0;
          v488[9] = v581[1];
          *(_DWORD *)(v488 + 11) = 0;
          *((_QWORD *)v488 + 2) = 0LL;
          v488[15] = 0;
          v581[0] = 0LL;
          LOBYTE(v581[1]) = 0;
          v488[24] = 0;
          *((_QWORD *)v488 + 4) = *(_QWORD *)((char *)v582 + 7);
          *((_QWORD *)v488 + 5) = 0LL;
          *(_QWORD *)(v488 + 25) = v582[0];
          *(_QWORD *)((char *)v582 + 7) = 0LL;
          v582[0] = 0LL;
          v491 = *(void ***)a3;
          v490 = *(void ***)(a3 + 8);
          v492 = v488 + 48;
          if ( v490 == *(void ***)a3 )
          {
            v259 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v488 - 4) = *(v490 - 4);
              *((_OWORD *)v488 - 3) = *((_OWORD *)v490 - 3);
              v493 = (__int64)*(v490 - 1);
              *(v490 - 5) = 0LL;
              *(v490 - 4) = 0LL;
              *(v490 - 6) = 0LL;
              *((_QWORD *)v488 - 1) = v493;
              *(_OWORD *)(v488 - 24) = *(_OWORD *)(v490 - 3);
              *(v490 - 2) = 0LL;
              *(v490 - 1) = 0LL;
              *(v490 - 3) = 0LL;
              v490 -= 6;
              v488 -= 48;
            }
            while ( v491 != v490 );
            v259 = *(void ***)a3;
            v491 = *(void ***)(a3 + 8);
          }
          v260 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v488;
          *(_QWORD *)(a3 + 8) = v492;
          *(_QWORD *)(a3 + 16) = v489;
          if ( v491 != v259 )
          {
            do
            {
              if ( (*(_BYTE *)(v491 - 3) & 1) != 0 )
                free(*(v491 - 1));
              v494 = v491 - 6;
              if ( (*(_BYTE *)(v491 - 6) & 1) != 0 )
                free(*(v491 - 4));
              v491 -= 6;
            }
            while ( v259 != v494 );
          }
          goto LABEL_1062;
        default:
          return (__int64)v3;
      }
      goto LABEL_380;
    case 'e':
      v44 = (unsigned __int8)a1[1];
      if ( v44 == 79 )
      {
        *(_QWORD *)((char *)v582 + 7) = 0LL;
        v582[0] = 0LL;
        qmemcpy(v581, "operator^=", 10);
        v6 = *(_QWORD *)(a3 + 8);
        v87 = *(_QWORD *)(a3 + 16);
        if ( v6 < v87 )
          goto LABEL_365;
        v88 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v6 - *(_QWORD *)a3) >> 4);
        if ( v88 + 1 > 0x555555555555555LL )
          abort();
        v89 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v87 - *(_QWORD *)a3) >> 4);
        if ( v89 >= 0x2AAAAAAAAAAAAAALL || (2 * v89 >= v88 + 1 ? (v5 = 2 * v89) : (v5 = v88 + 1), v5) )
        {
          v90 = *(_QWORD *)(a3 + 24);
          v91 = *(char **)(v90 + 4096);
          if ( v90 + 4096 - (__int64)v91 >= (unsigned __int64)(48 * v5) )
            *(_QWORD *)(v90 + 4096) = &v91[48 * v5];
          else
            v91 = (char *)malloc(48 * v5);
        }
        else
        {
          v91 = 0LL;
        }
        v298 = &v91[48 * v88];
        *v298 = 20;
        v299 = &v91[48 * v5];
        *(_QWORD *)(v298 + 1) = v581[0];
        v298[11] = 0;
        *((_DWORD *)v298 + 3) = 0;
        *((_QWORD *)v298 + 2) = 0LL;
        *(_WORD *)(v298 + 9) = v581[1];
        v581[0] = 0LL;
        LOWORD(v581[1]) = 0;
        v298[24] = 0;
        *((_QWORD *)v298 + 4) = *(_QWORD *)((char *)v582 + 7);
        *((_QWORD *)v298 + 5) = 0LL;
        *(_QWORD *)(v298 + 25) = v582[0];
        *(_QWORD *)((char *)v582 + 7) = 0LL;
        v582[0] = 0LL;
        v301 = *(void ***)a3;
        v300 = *(void ***)(a3 + 8);
        v302 = v298 + 48;
        if ( v300 == *(void ***)a3 )
        {
          v259 = *(void ***)a3;
        }
        else
        {
          do
          {
            *((_QWORD *)v298 - 4) = *(v300 - 4);
            *((_OWORD *)v298 - 3) = *((_OWORD *)v300 - 3);
            v303 = (__int64)*(v300 - 1);
            *(v300 - 5) = 0LL;
            *(v300 - 4) = 0LL;
            *(v300 - 6) = 0LL;
            *((_QWORD *)v298 - 1) = v303;
            *(_OWORD *)(v298 - 24) = *(_OWORD *)(v300 - 3);
            *(v300 - 2) = 0LL;
            *(v300 - 1) = 0LL;
            *(v300 - 3) = 0LL;
            v300 -= 6;
            v298 -= 48;
          }
          while ( v301 != v300 );
          v259 = *(void ***)a3;
          v301 = *(void ***)(a3 + 8);
        }
        v260 = *(_QWORD *)(a3 + 16);
        *(_QWORD *)a3 = v298;
        *(_QWORD *)(a3 + 8) = v302;
        *(_QWORD *)(a3 + 16) = v299;
        if ( v301 != v259 )
        {
          do
          {
            if ( (*(_BYTE *)(v301 - 3) & 1) != 0 )
              free(*(v301 - 1));
            v304 = v301 - 6;
            if ( (*(_BYTE *)(v301 - 6) & 1) != 0 )
              free(*(v301 - 4));
            v301 -= 6;
          }
          while ( v259 != v304 );
        }
        goto LABEL_1062;
      }
      if ( v44 == 113 )
      {
        *(_QWORD *)((char *)v582 + 7) = 0LL;
        v582[0] = 0LL;
        qmemcpy(v581, "operator==", 10);
        v6 = *(_QWORD *)(a3 + 8);
        v82 = *(_QWORD *)(a3 + 16);
        if ( v6 < v82 )
          goto LABEL_365;
        v83 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v6 - *(_QWORD *)a3) >> 4);
        if ( v83 + 1 > 0x555555555555555LL )
          abort();
        v84 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v82 - *(_QWORD *)a3) >> 4);
        if ( v84 >= 0x2AAAAAAAAAAAAAALL || (2 * v84 >= v83 + 1 ? (v5 = 2 * v84) : (v5 = v83 + 1), v5) )
        {
          v85 = *(_QWORD *)(a3 + 24);
          v86 = *(char **)(v85 + 4096);
          if ( v85 + 4096 - (__int64)v86 >= (unsigned __int64)(48 * v5) )
            *(_QWORD *)(v85 + 4096) = &v86[48 * v5];
          else
            v86 = (char *)malloc(48 * v5);
        }
        else
        {
          v86 = 0LL;
        }
        v291 = &v86[48 * v83];
        *v291 = 20;
        v292 = &v86[48 * v5];
        *(_QWORD *)(v291 + 1) = v581[0];
        v291[11] = 0;
        *((_DWORD *)v291 + 3) = 0;
        *((_QWORD *)v291 + 2) = 0LL;
        *(_WORD *)(v291 + 9) = v581[1];
        v581[0] = 0LL;
        LOWORD(v581[1]) = 0;
        v291[24] = 0;
        *((_QWORD *)v291 + 4) = *(_QWORD *)((char *)v582 + 7);
        *((_QWORD *)v291 + 5) = 0LL;
        *(_QWORD *)(v291 + 25) = v582[0];
        *(_QWORD *)((char *)v582 + 7) = 0LL;
        v582[0] = 0LL;
        v294 = *(void ***)a3;
        v293 = *(void ***)(a3 + 8);
        v295 = v291 + 48;
        if ( v293 == *(void ***)a3 )
        {
          v259 = *(void ***)a3;
        }
        else
        {
          do
          {
            *((_QWORD *)v291 - 4) = *(v293 - 4);
            *((_OWORD *)v291 - 3) = *((_OWORD *)v293 - 3);
            v296 = (__int64)*(v293 - 1);
            *(v293 - 5) = 0LL;
            *(v293 - 4) = 0LL;
            *(v293 - 6) = 0LL;
            *((_QWORD *)v291 - 1) = v296;
            *(_OWORD *)(v291 - 24) = *(_OWORD *)(v293 - 3);
            *(v293 - 2) = 0LL;
            *(v293 - 1) = 0LL;
            *(v293 - 3) = 0LL;
            v293 -= 6;
            v291 -= 48;
          }
          while ( v294 != v293 );
          v259 = *(void ***)a3;
          v294 = *(void ***)(a3 + 8);
        }
        v260 = *(_QWORD *)(a3 + 16);
        *(_QWORD *)a3 = v291;
        *(_QWORD *)(a3 + 8) = v295;
        *(_QWORD *)(a3 + 16) = v292;
        if ( v294 != v259 )
        {
          do
          {
            if ( (*(_BYTE *)(v294 - 3) & 1) != 0 )
              free(*(v294 - 1));
            v297 = v294 - 6;
            if ( (*(_BYTE *)(v294 - 6) & 1) != 0 )
              free(*(v294 - 4));
            v294 -= 6;
          }
          while ( v259 != v297 );
        }
        goto LABEL_1062;
      }
      if ( v44 != 111 )
        return (__int64)v3;
      *(_QWORD *)((char *)v582 + 7) = 0LL;
      v582[0] = 0LL;
      qmemcpy(v581, "operator^", 9);
      v6 = *(_QWORD *)(a3 + 8);
      v45 = *(_QWORD *)(a3 + 16);
      if ( v6 >= v45 )
      {
        v46 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v6 - *(_QWORD *)a3) >> 4);
        if ( v46 + 1 > 0x555555555555555LL )
          abort();
        v47 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v45 - *(_QWORD *)a3) >> 4);
        if ( v47 >= 0x2AAAAAAAAAAAAAALL || (2 * v47 >= v46 + 1 ? (v5 = 2 * v47) : (v5 = v46 + 1), v5) )
        {
          v48 = *(_QWORD *)(a3 + 24);
          v49 = *(char **)(v48 + 4096);
          if ( v48 + 4096 - (__int64)v49 >= (unsigned __int64)(48 * v5) )
            *(_QWORD *)(v48 + 4096) = &v49[48 * v5];
          else
            v49 = (char *)malloc(48 * v5);
        }
        else
        {
          v49 = 0LL;
        }
        v305 = &v49[48 * v46];
        *v305 = 18;
        v306 = &v49[48 * v5];
        *(_QWORD *)(v305 + 1) = v581[0];
        v305[10] = 0;
        v305[9] = v581[1];
        *(_DWORD *)(v305 + 11) = 0;
        *((_QWORD *)v305 + 2) = 0LL;
        v305[15] = 0;
        v581[0] = 0LL;
        LOBYTE(v581[1]) = 0;
        v305[24] = 0;
        *((_QWORD *)v305 + 4) = *(_QWORD *)((char *)v582 + 7);
        *((_QWORD *)v305 + 5) = 0LL;
        *(_QWORD *)(v305 + 25) = v582[0];
        *(_QWORD *)((char *)v582 + 7) = 0LL;
        v582[0] = 0LL;
        v308 = *(void ***)a3;
        v307 = *(void ***)(a3 + 8);
        v309 = v305 + 48;
        if ( v307 == *(void ***)a3 )
        {
          v259 = *(void ***)a3;
        }
        else
        {
          do
          {
            *((_QWORD *)v305 - 4) = *(v307 - 4);
            *((_OWORD *)v305 - 3) = *((_OWORD *)v307 - 3);
            v310 = (__int64)*(v307 - 1);
            *(v307 - 5) = 0LL;
            *(v307 - 4) = 0LL;
            *(v307 - 6) = 0LL;
            *((_QWORD *)v305 - 1) = v310;
            *(_OWORD *)(v305 - 24) = *(_OWORD *)(v307 - 3);
            *(v307 - 2) = 0LL;
            *(v307 - 1) = 0LL;
            *(v307 - 3) = 0LL;
            v307 -= 6;
            v305 -= 48;
          }
          while ( v308 != v307 );
          v259 = *(void ***)a3;
          v308 = *(void ***)(a3 + 8);
        }
        v260 = *(_QWORD *)(a3 + 16);
        *(_QWORD *)a3 = v305;
        *(_QWORD *)(a3 + 8) = v309;
        *(_QWORD *)(a3 + 16) = v306;
        if ( v308 != v259 )
        {
          do
          {
            if ( (*(_BYTE *)(v308 - 3) & 1) != 0 )
              free(*(v308 - 1));
            v311 = v308 - 6;
            if ( (*(_BYTE *)(v308 - 6) & 1) != 0 )
              free(*(v308 - 4));
            v308 -= 6;
          }
          while ( v259 != v311 );
        }
        goto LABEL_1062;
      }
      goto LABEL_378;
    case 'g':
      v23 = (unsigned __int8)a1[1];
      if ( v23 == 116 )
      {
        *(_QWORD *)((char *)v582 + 7) = 0LL;
        v582[0] = 0LL;
        qmemcpy(v581, "operator>", 9);
        v6 = *(_QWORD *)(a3 + 8);
        v77 = *(_QWORD *)(a3 + 16);
        if ( v6 < v77 )
          goto LABEL_378;
        v78 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v6 - *(_QWORD *)a3) >> 4);
        if ( v78 + 1 > 0x555555555555555LL )
          abort();
        v79 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v77 - *(_QWORD *)a3) >> 4);
        if ( v79 >= 0x2AAAAAAAAAAAAAALL || (2 * v79 >= v78 + 1 ? (v5 = 2 * v79) : (v5 = v78 + 1), v5) )
        {
          v80 = *(_QWORD *)(a3 + 24);
          v81 = *(char **)(v80 + 4096);
          if ( v80 + 4096 - (__int64)v81 >= (unsigned __int64)(48 * v5) )
            *(_QWORD *)(v80 + 4096) = &v81[48 * v5];
          else
            v81 = (char *)malloc(48 * v5);
        }
        else
        {
          v81 = 0LL;
        }
        v284 = &v81[48 * v78];
        *v284 = 18;
        v285 = &v81[48 * v5];
        *(_QWORD *)(v284 + 1) = v581[0];
        v284[10] = 0;
        v284[9] = v581[1];
        *(_DWORD *)(v284 + 11) = 0;
        *((_QWORD *)v284 + 2) = 0LL;
        v284[15] = 0;
        v581[0] = 0LL;
        LOBYTE(v581[1]) = 0;
        v284[24] = 0;
        *((_QWORD *)v284 + 4) = *(_QWORD *)((char *)v582 + 7);
        *((_QWORD *)v284 + 5) = 0LL;
        *(_QWORD *)(v284 + 25) = v582[0];
        *(_QWORD *)((char *)v582 + 7) = 0LL;
        v582[0] = 0LL;
        v287 = *(void ***)a3;
        v286 = *(void ***)(a3 + 8);
        v288 = v284 + 48;
        if ( v286 == *(void ***)a3 )
        {
          v259 = *(void ***)a3;
        }
        else
        {
          do
          {
            *((_QWORD *)v284 - 4) = *(v286 - 4);
            *((_OWORD *)v284 - 3) = *((_OWORD *)v286 - 3);
            v289 = (__int64)*(v286 - 1);
            *(v286 - 5) = 0LL;
            *(v286 - 4) = 0LL;
            *(v286 - 6) = 0LL;
            *((_QWORD *)v284 - 1) = v289;
            *(_OWORD *)(v284 - 24) = *(_OWORD *)(v286 - 3);
            *(v286 - 2) = 0LL;
            *(v286 - 1) = 0LL;
            *(v286 - 3) = 0LL;
            v286 -= 6;
            v284 -= 48;
          }
          while ( v287 != v286 );
          v259 = *(void ***)a3;
          v287 = *(void ***)(a3 + 8);
        }
        v260 = *(_QWORD *)(a3 + 16);
        *(_QWORD *)a3 = v284;
        *(_QWORD *)(a3 + 8) = v288;
        *(_QWORD *)(a3 + 16) = v285;
        if ( v287 != v259 )
        {
          do
          {
            if ( (*(_BYTE *)(v287 - 3) & 1) != 0 )
              free(*(v287 - 1));
            v290 = v287 - 6;
            if ( (*(_BYTE *)(v287 - 6) & 1) != 0 )
              free(*(v287 - 4));
            v287 -= 6;
          }
          while ( v259 != v290 );
        }
        goto LABEL_1062;
      }
      if ( v23 != 101 )
        return (__int64)v3;
      *(_QWORD *)((char *)v582 + 7) = 0LL;
      v582[0] = 0LL;
      qmemcpy(v581, "operator>=", 10);
      v6 = *(_QWORD *)(a3 + 8);
      v24 = *(_QWORD *)(a3 + 16);
      if ( v6 >= v24 )
      {
        v25 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v6 - *(_QWORD *)a3) >> 4);
        if ( v25 + 1 > 0x555555555555555LL )
          abort();
        v26 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v24 - *(_QWORD *)a3) >> 4);
        if ( v26 >= 0x2AAAAAAAAAAAAAALL || (2 * v26 >= v25 + 1 ? (v5 = 2 * v26) : (v5 = v25 + 1), v5) )
        {
          v27 = *(_QWORD *)(a3 + 24);
          v28 = *(char **)(v27 + 4096);
          if ( v27 + 4096 - (__int64)v28 >= (unsigned __int64)(48 * v5) )
            *(_QWORD *)(v27 + 4096) = &v28[48 * v5];
          else
            v28 = (char *)malloc(48 * v5);
        }
        else
        {
          v28 = 0LL;
        }
        v277 = &v28[48 * v25];
        *v277 = 20;
        v278 = &v28[48 * v5];
        *(_QWORD *)(v277 + 1) = v581[0];
        v277[11] = 0;
        *((_DWORD *)v277 + 3) = 0;
        *((_QWORD *)v277 + 2) = 0LL;
        *(_WORD *)(v277 + 9) = v581[1];
        v581[0] = 0LL;
        LOWORD(v581[1]) = 0;
        v277[24] = 0;
        *((_QWORD *)v277 + 4) = *(_QWORD *)((char *)v582 + 7);
        *((_QWORD *)v277 + 5) = 0LL;
        *(_QWORD *)(v277 + 25) = v582[0];
        *(_QWORD *)((char *)v582 + 7) = 0LL;
        v582[0] = 0LL;
        v280 = *(void ***)a3;
        v279 = *(void ***)(a3 + 8);
        v281 = v277 + 48;
        if ( v279 == *(void ***)a3 )
        {
          v259 = *(void ***)a3;
        }
        else
        {
          do
          {
            *((_QWORD *)v277 - 4) = *(v279 - 4);
            *((_OWORD *)v277 - 3) = *((_OWORD *)v279 - 3);
            v282 = (__int64)*(v279 - 1);
            *(v279 - 5) = 0LL;
            *(v279 - 4) = 0LL;
            *(v279 - 6) = 0LL;
            *((_QWORD *)v277 - 1) = v282;
            *(_OWORD *)(v277 - 24) = *(_OWORD *)(v279 - 3);
            *(v279 - 2) = 0LL;
            *(v279 - 1) = 0LL;
            *(v279 - 3) = 0LL;
            v279 -= 6;
            v277 -= 48;
          }
          while ( v280 != v279 );
          v259 = *(void ***)a3;
          v280 = *(void ***)(a3 + 8);
        }
        v260 = *(_QWORD *)(a3 + 16);
        *(_QWORD *)a3 = v277;
        *(_QWORD *)(a3 + 8) = v281;
        *(_QWORD *)(a3 + 16) = v278;
        if ( v280 != v259 )
        {
          do
          {
            if ( (*(_BYTE *)(v280 - 3) & 1) != 0 )
              free(*(v280 - 1));
            v283 = v280 - 6;
            if ( (*(_BYTE *)(v280 - 6) & 1) != 0 )
              free(*(v280 - 4));
            v280 -= 6;
          }
          while ( v259 != v283 );
        }
        goto LABEL_1062;
      }
      goto LABEL_365;
    case 'i':
      if ( a1[1] != 120 )
        return (__int64)v3;
      *(_QWORD *)((char *)v582 + 7) = 0LL;
      v582[0] = 0LL;
      qmemcpy(v581, "operator[]", 10);
      v6 = *(_QWORD *)(a3 + 8);
      v34 = *(_QWORD *)(a3 + 16);
      if ( v6 < v34 )
        goto LABEL_365;
      v35 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v6 - *(_QWORD *)a3) >> 4);
      if ( v35 + 1 > 0x555555555555555LL )
        abort();
      v36 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v34 - *(_QWORD *)a3) >> 4);
      if ( v36 >= 0x2AAAAAAAAAAAAAALL || (2 * v36 >= v35 + 1 ? (v5 = 2 * v36) : (v5 = v35 + 1), v5) )
      {
        v37 = *(_QWORD *)(a3 + 24);
        v38 = *(char **)(v37 + 4096);
        if ( v37 + 4096 - (__int64)v38 >= (unsigned __int64)(48 * v5) )
          *(_QWORD *)(v37 + 4096) = &v38[48 * v5];
        else
          v38 = (char *)malloc(48 * v5);
      }
      else
      {
        v38 = 0LL;
      }
      v253 = &v38[48 * v35];
      *v253 = 20;
      v254 = &v38[48 * v5];
      *(_QWORD *)(v253 + 1) = v581[0];
      v253[11] = 0;
      *((_DWORD *)v253 + 3) = 0;
      *((_QWORD *)v253 + 2) = 0LL;
      *(_WORD *)(v253 + 9) = v581[1];
      v581[0] = 0LL;
      LOWORD(v581[1]) = 0;
      v253[24] = 0;
      *((_QWORD *)v253 + 4) = *(_QWORD *)((char *)v582 + 7);
      *((_QWORD *)v253 + 5) = 0LL;
      *(_QWORD *)(v253 + 25) = v582[0];
      *(_QWORD *)((char *)v582 + 7) = 0LL;
      v582[0] = 0LL;
      v256 = *(void ***)a3;
      v255 = *(void ***)(a3 + 8);
      v257 = v253 + 48;
      if ( v255 == *(void ***)a3 )
      {
        v259 = *(void ***)a3;
      }
      else
      {
        do
        {
          *((_QWORD *)v253 - 4) = *(v255 - 4);
          *((_OWORD *)v253 - 3) = *((_OWORD *)v255 - 3);
          v258 = (__int64)*(v255 - 1);
          *(v255 - 5) = 0LL;
          *(v255 - 4) = 0LL;
          *(v255 - 6) = 0LL;
          *((_QWORD *)v253 - 1) = v258;
          *(_OWORD *)(v253 - 24) = *(_OWORD *)(v255 - 3);
          *(v255 - 2) = 0LL;
          *(v255 - 1) = 0LL;
          *(v255 - 3) = 0LL;
          v255 -= 6;
          v253 -= 48;
        }
        while ( v256 != v255 );
        v259 = *(void ***)a3;
        v256 = *(void ***)(a3 + 8);
      }
      v260 = *(_QWORD *)(a3 + 16);
      *(_QWORD *)a3 = v253;
      *(_QWORD *)(a3 + 8) = v257;
      *(_QWORD *)(a3 + 16) = v254;
      if ( v256 != v259 )
      {
        do
        {
          if ( (*(_BYTE *)(v256 - 3) & 1) != 0 )
            free(*(v256 - 1));
          v261 = v256 - 6;
          if ( (*(_BYTE *)(v256 - 6) & 1) != 0 )
            free(*(v256 - 4));
          v256 -= 6;
        }
        while ( v259 != v261 );
      }
      goto LABEL_1062;
    case 'l':
      switch ( a1[1] )
      {
        case 'S':
          *(_QWORD *)((char *)v582 + 7) = 0LL;
          v582[0] = 0LL;
          qmemcpy(v581, "operator<<=", 11);
          v6 = *(_QWORD *)(a3 + 8);
          v60 = *(_QWORD *)(a3 + 16);
          if ( v6 < v60 )
            goto LABEL_183;
          v61 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v6 - *(_QWORD *)a3) >> 4);
          if ( v61 + 1 > 0x555555555555555LL )
            abort();
          v62 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v60 - *(_QWORD *)a3) >> 4);
          if ( v62 >= 0x2AAAAAAAAAAAAAALL || (2 * v62 >= v61 + 1 ? (v5 = 2 * v62) : (v5 = v61 + 1), v5) )
          {
            v63 = *(_QWORD *)(a3 + 24);
            v64 = *(char **)(v63 + 4096);
            if ( v63 + 4096 - (__int64)v64 >= (unsigned __int64)(48 * v5) )
              *(_QWORD *)(v63 + 4096) = &v64[48 * v5];
            else
              v64 = (char *)malloc(48 * v5);
          }
          else
          {
            v64 = 0LL;
          }
          v411 = &v64[48 * v61];
          *v411 = 22;
          v412 = &v64[48 * v5];
          *(_QWORD *)(v411 + 1) = v581[0];
          v411[11] = BYTE2(v581[1]);
          v411[12] = 0;
          *(_WORD *)(v411 + 9) = v581[1];
          *(_WORD *)(v411 + 13) = 0;
          *((_QWORD *)v411 + 2) = 0LL;
          v411[15] = 0;
          v581[0] = 0LL;
          LOWORD(v581[1]) = 0;
          BYTE2(v581[1]) = 0;
          v411[24] = 0;
          *((_QWORD *)v411 + 4) = *(_QWORD *)((char *)v582 + 7);
          *((_QWORD *)v411 + 5) = 0LL;
          *(_QWORD *)(v411 + 25) = v582[0];
          *(_QWORD *)((char *)v582 + 7) = 0LL;
          v582[0] = 0LL;
          v414 = *(void ***)a3;
          v413 = *(void ***)(a3 + 8);
          v415 = v411 + 48;
          if ( v413 == *(void ***)a3 )
          {
            v259 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v411 - 4) = *(v413 - 4);
              *((_OWORD *)v411 - 3) = *((_OWORD *)v413 - 3);
              v416 = (__int64)*(v413 - 1);
              *(v413 - 5) = 0LL;
              *(v413 - 4) = 0LL;
              *(v413 - 6) = 0LL;
              *((_QWORD *)v411 - 1) = v416;
              *(_OWORD *)(v411 - 24) = *(_OWORD *)(v413 - 3);
              *(v413 - 2) = 0LL;
              *(v413 - 1) = 0LL;
              *(v413 - 3) = 0LL;
              v413 -= 6;
              v411 -= 48;
            }
            while ( v414 != v413 );
            v259 = *(void ***)a3;
            v414 = *(void ***)(a3 + 8);
          }
          v260 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v411;
          *(_QWORD *)(a3 + 8) = v415;
          *(_QWORD *)(a3 + 16) = v412;
          if ( v414 != v259 )
          {
            do
            {
              if ( (*(_BYTE *)(v414 - 3) & 1) != 0 )
                free(*(v414 - 1));
              v417 = v414 - 6;
              if ( (*(_BYTE *)(v414 - 6) & 1) != 0 )
                free(*(v414 - 4));
              v414 -= 6;
            }
            while ( v259 != v417 );
          }
          goto LABEL_1062;
        case 'e':
          *(_QWORD *)((char *)v582 + 7) = 0LL;
          v582[0] = 0LL;
          qmemcpy(v581, "operator<=", 10);
          v6 = *(_QWORD *)(a3 + 8);
          v142 = *(_QWORD *)(a3 + 16);
          if ( v6 < v142 )
            goto LABEL_365;
          v143 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v6 - *(_QWORD *)a3) >> 4);
          if ( v143 + 1 > 0x555555555555555LL )
            abort();
          v144 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v142 - *(_QWORD *)a3) >> 4);
          if ( v144 >= 0x2AAAAAAAAAAAAAALL || (2 * v144 >= v143 + 1 ? (v5 = 2 * v144) : (v5 = v143 + 1), v5) )
          {
            v145 = *(_QWORD *)(a3 + 24);
            v146 = *(char **)(v145 + 4096);
            if ( v145 + 4096 - (__int64)v146 >= (unsigned __int64)(48 * v5) )
              *(_QWORD *)(v145 + 4096) = &v146[48 * v5];
            else
              v146 = (char *)malloc(48 * v5);
          }
          else
          {
            v146 = 0LL;
          }
          v432 = &v146[48 * v143];
          *v432 = 20;
          v433 = &v146[48 * v5];
          *(_QWORD *)(v432 + 1) = v581[0];
          v432[11] = 0;
          *((_DWORD *)v432 + 3) = 0;
          *((_QWORD *)v432 + 2) = 0LL;
          *(_WORD *)(v432 + 9) = v581[1];
          v581[0] = 0LL;
          LOWORD(v581[1]) = 0;
          v432[24] = 0;
          *((_QWORD *)v432 + 4) = *(_QWORD *)((char *)v582 + 7);
          *((_QWORD *)v432 + 5) = 0LL;
          *(_QWORD *)(v432 + 25) = v582[0];
          *(_QWORD *)((char *)v582 + 7) = 0LL;
          v582[0] = 0LL;
          v435 = *(void ***)a3;
          v434 = *(void ***)(a3 + 8);
          v436 = v432 + 48;
          if ( v434 == *(void ***)a3 )
          {
            v259 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v432 - 4) = *(v434 - 4);
              *((_OWORD *)v432 - 3) = *((_OWORD *)v434 - 3);
              v437 = (__int64)*(v434 - 1);
              *(v434 - 5) = 0LL;
              *(v434 - 4) = 0LL;
              *(v434 - 6) = 0LL;
              *((_QWORD *)v432 - 1) = v437;
              *(_OWORD *)(v432 - 24) = *(_OWORD *)(v434 - 3);
              *(v434 - 2) = 0LL;
              *(v434 - 1) = 0LL;
              *(v434 - 3) = 0LL;
              v434 -= 6;
              v432 -= 48;
            }
            while ( v435 != v434 );
            v259 = *(void ***)a3;
            v435 = *(void ***)(a3 + 8);
          }
          v260 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v432;
          *(_QWORD *)(a3 + 8) = v436;
          *(_QWORD *)(a3 + 16) = v433;
          if ( v435 != v259 )
          {
            do
            {
              if ( (*(_BYTE *)(v435 - 3) & 1) != 0 )
                free(*(v435 - 1));
              v438 = v435 - 6;
              if ( (*(_BYTE *)(v435 - 6) & 1) != 0 )
                free(*(v435 - 4));
              v435 -= 6;
            }
            while ( v259 != v438 );
          }
          goto LABEL_1062;
        case 'i':
          v127 = a1 + 2;
          v13 = sub_B190C(a1 + 2, a2, a3);
          if ( (_BYTE *)v13 == v127 )
            return (__int64)v3;
          v128 = *(_QWORD *)(a3 + 8);
          if ( *(_QWORD *)a3 == v128 )
            return (__int64)v3;
          v15 = (size_t *)(v128 - 48);
          v16 = "operator\"\" ";
          v17 = 11LL;
          break;
        case 's':
          *(_QWORD *)((char *)v582 + 7) = 0LL;
          v582[0] = 0LL;
          qmemcpy(v581, "operator<<", 10);
          v6 = *(_QWORD *)(a3 + 8);
          v168 = *(_QWORD *)(a3 + 16);
          if ( v6 < v168 )
            goto LABEL_365;
          v169 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v6 - *(_QWORD *)a3) >> 4);
          if ( v169 + 1 > 0x555555555555555LL )
            abort();
          v170 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v168 - *(_QWORD *)a3) >> 4);
          if ( v170 >= 0x2AAAAAAAAAAAAAALL || (2 * v170 >= v169 + 1 ? (v5 = 2 * v170) : (v5 = v169 + 1), v5) )
          {
            v171 = *(_QWORD *)(a3 + 24);
            v172 = *(char **)(v171 + 4096);
            if ( v171 + 4096 - (__int64)v172 >= (unsigned __int64)(48 * v5) )
              *(_QWORD *)(v171 + 4096) = &v172[48 * v5];
            else
              v172 = (char *)malloc(48 * v5);
          }
          else
          {
            v172 = 0LL;
          }
          v474 = &v172[48 * v169];
          *v474 = 20;
          v475 = &v172[48 * v5];
          *(_QWORD *)(v474 + 1) = v581[0];
          v474[11] = 0;
          *((_DWORD *)v474 + 3) = 0;
          *((_QWORD *)v474 + 2) = 0LL;
          *(_WORD *)(v474 + 9) = v581[1];
          v581[0] = 0LL;
          LOWORD(v581[1]) = 0;
          v474[24] = 0;
          *((_QWORD *)v474 + 4) = *(_QWORD *)((char *)v582 + 7);
          *((_QWORD *)v474 + 5) = 0LL;
          *(_QWORD *)(v474 + 25) = v582[0];
          *(_QWORD *)((char *)v582 + 7) = 0LL;
          v582[0] = 0LL;
          v477 = *(void ***)a3;
          v476 = *(void ***)(a3 + 8);
          v478 = v474 + 48;
          if ( v476 == *(void ***)a3 )
          {
            v259 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v474 - 4) = *(v476 - 4);
              *((_OWORD *)v474 - 3) = *((_OWORD *)v476 - 3);
              v479 = (__int64)*(v476 - 1);
              *(v476 - 5) = 0LL;
              *(v476 - 4) = 0LL;
              *(v476 - 6) = 0LL;
              *((_QWORD *)v474 - 1) = v479;
              *(_OWORD *)(v474 - 24) = *(_OWORD *)(v476 - 3);
              *(v476 - 2) = 0LL;
              *(v476 - 1) = 0LL;
              *(v476 - 3) = 0LL;
              v476 -= 6;
              v474 -= 48;
            }
            while ( v477 != v476 );
            v259 = *(void ***)a3;
            v477 = *(void ***)(a3 + 8);
          }
          v260 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v474;
          *(_QWORD *)(a3 + 8) = v478;
          *(_QWORD *)(a3 + 16) = v475;
          if ( v477 != v259 )
          {
            do
            {
              if ( (*(_BYTE *)(v477 - 3) & 1) != 0 )
                free(*(v477 - 1));
              v480 = v477 - 6;
              if ( (*(_BYTE *)(v477 - 6) & 1) != 0 )
                free(*(v477 - 4));
              v477 -= 6;
            }
            while ( v259 != v480 );
          }
          goto LABEL_1062;
        case 't':
          *(_QWORD *)((char *)v582 + 7) = 0LL;
          v582[0] = 0LL;
          qmemcpy(v581, "operator<", 9);
          v6 = *(_QWORD *)(a3 + 8);
          v183 = *(_QWORD *)(a3 + 16);
          if ( v6 < v183 )
            goto LABEL_378;
          v184 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v6 - *(_QWORD *)a3) >> 4);
          if ( v184 + 1 > 0x555555555555555LL )
            abort();
          v185 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v183 - *(_QWORD *)a3) >> 4);
          if ( v185 >= 0x2AAAAAAAAAAAAAALL || (2 * v185 >= v184 + 1 ? (v5 = 2 * v185) : (v5 = v184 + 1), v5) )
          {
            v186 = *(_QWORD *)(a3 + 24);
            v187 = *(char **)(v186 + 4096);
            if ( v186 + 4096 - (__int64)v187 >= (unsigned __int64)(48 * v5) )
              *(_QWORD *)(v186 + 4096) = &v187[48 * v5];
            else
              v187 = (char *)malloc(48 * v5);
          }
          else
          {
            v187 = 0LL;
          }
          v495 = &v187[48 * v184];
          *v495 = 18;
          v496 = &v187[48 * v5];
          *(_QWORD *)(v495 + 1) = v581[0];
          v495[10] = 0;
          v495[9] = v581[1];
          *(_DWORD *)(v495 + 11) = 0;
          *((_QWORD *)v495 + 2) = 0LL;
          v495[15] = 0;
          v581[0] = 0LL;
          LOBYTE(v581[1]) = 0;
          v495[24] = 0;
          *((_QWORD *)v495 + 4) = *(_QWORD *)((char *)v582 + 7);
          *((_QWORD *)v495 + 5) = 0LL;
          *(_QWORD *)(v495 + 25) = v582[0];
          *(_QWORD *)((char *)v582 + 7) = 0LL;
          v582[0] = 0LL;
          v498 = *(void ***)a3;
          v497 = *(void ***)(a3 + 8);
          v499 = v495 + 48;
          if ( v497 == *(void ***)a3 )
          {
            v259 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v495 - 4) = *(v497 - 4);
              *((_OWORD *)v495 - 3) = *((_OWORD *)v497 - 3);
              v500 = (__int64)*(v497 - 1);
              *(v497 - 5) = 0LL;
              *(v497 - 4) = 0LL;
              *(v497 - 6) = 0LL;
              *((_QWORD *)v495 - 1) = v500;
              *(_OWORD *)(v495 - 24) = *(_OWORD *)(v497 - 3);
              *(v497 - 2) = 0LL;
              *(v497 - 1) = 0LL;
              *(v497 - 3) = 0LL;
              v497 -= 6;
              v495 -= 48;
            }
            while ( v498 != v497 );
            v259 = *(void ***)a3;
            v498 = *(void ***)(a3 + 8);
          }
          v260 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v495;
          *(_QWORD *)(a3 + 8) = v499;
          *(_QWORD *)(a3 + 16) = v496;
          if ( v498 != v259 )
          {
            do
            {
              if ( (*(_BYTE *)(v498 - 3) & 1) != 0 )
                free(*(v498 - 1));
              v501 = v498 - 6;
              if ( (*(_BYTE *)(v498 - 6) & 1) != 0 )
                free(*(v498 - 4));
              v498 -= 6;
            }
            while ( v259 != v501 );
          }
          goto LABEL_1062;
        default:
          return (__int64)v3;
      }
      goto LABEL_226;
    case 'm':
      switch ( a1[1] )
      {
        case 'I':
          *(_QWORD *)((char *)v582 + 7) = 0LL;
          v582[0] = 0LL;
          qmemcpy(v581, "operator-=", 10);
          v6 = *(_QWORD *)(a3 + 8);
          v65 = *(_QWORD *)(a3 + 16);
          if ( v6 < v65 )
            goto LABEL_365;
          v66 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v6 - *(_QWORD *)a3) >> 4);
          if ( v66 + 1 > 0x555555555555555LL )
            abort();
          v67 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v65 - *(_QWORD *)a3) >> 4);
          if ( v67 >= 0x2AAAAAAAAAAAAAALL || (2 * v67 >= v66 + 1 ? (v5 = 2 * v67) : (v5 = v66 + 1), v5) )
          {
            v68 = *(_QWORD *)(a3 + 24);
            v69 = *(char **)(v68 + 4096);
            if ( v68 + 4096 - (__int64)v69 >= (unsigned __int64)(48 * v5) )
              *(_QWORD *)(v68 + 4096) = &v69[48 * v5];
            else
              v69 = (char *)malloc(48 * v5);
          }
          else
          {
            v69 = 0LL;
          }
          v418 = &v69[48 * v66];
          *v418 = 20;
          v419 = &v69[48 * v5];
          *(_QWORD *)(v418 + 1) = v581[0];
          v418[11] = 0;
          *((_DWORD *)v418 + 3) = 0;
          *((_QWORD *)v418 + 2) = 0LL;
          *(_WORD *)(v418 + 9) = v581[1];
          v581[0] = 0LL;
          LOWORD(v581[1]) = 0;
          v418[24] = 0;
          *((_QWORD *)v418 + 4) = *(_QWORD *)((char *)v582 + 7);
          *((_QWORD *)v418 + 5) = 0LL;
          *(_QWORD *)(v418 + 25) = v582[0];
          *(_QWORD *)((char *)v582 + 7) = 0LL;
          v582[0] = 0LL;
          v421 = *(void ***)a3;
          v420 = *(void ***)(a3 + 8);
          v422 = v418 + 48;
          if ( v420 == *(void ***)a3 )
          {
            v259 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v418 - 4) = *(v420 - 4);
              *((_OWORD *)v418 - 3) = *((_OWORD *)v420 - 3);
              v423 = (__int64)*(v420 - 1);
              *(v420 - 5) = 0LL;
              *(v420 - 4) = 0LL;
              *(v420 - 6) = 0LL;
              *((_QWORD *)v418 - 1) = v423;
              *(_OWORD *)(v418 - 24) = *(_OWORD *)(v420 - 3);
              *(v420 - 2) = 0LL;
              *(v420 - 1) = 0LL;
              *(v420 - 3) = 0LL;
              v420 -= 6;
              v418 -= 48;
            }
            while ( v421 != v420 );
            v259 = *(void ***)a3;
            v421 = *(void ***)(a3 + 8);
          }
          v260 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v418;
          *(_QWORD *)(a3 + 8) = v422;
          *(_QWORD *)(a3 + 16) = v419;
          if ( v421 != v259 )
          {
            do
            {
              if ( (*(_BYTE *)(v421 - 3) & 1) != 0 )
                free(*(v421 - 1));
              v424 = v421 - 6;
              if ( (*(_BYTE *)(v421 - 6) & 1) != 0 )
                free(*(v421 - 4));
              v421 -= 6;
            }
            while ( v259 != v424 );
          }
          goto LABEL_1062;
        case 'L':
          *(_QWORD *)((char *)v582 + 7) = 0LL;
          v582[0] = 0LL;
          qmemcpy(v581, "operator*=", 10);
          v6 = *(_QWORD *)(a3 + 8);
          v147 = *(_QWORD *)(a3 + 16);
          if ( v6 < v147 )
            goto LABEL_365;
          v148 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v6 - *(_QWORD *)a3) >> 4);
          if ( v148 + 1 > 0x555555555555555LL )
            abort();
          v149 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v147 - *(_QWORD *)a3) >> 4);
          if ( v149 >= 0x2AAAAAAAAAAAAAALL || (2 * v149 >= v148 + 1 ? (v5 = 2 * v149) : (v5 = v148 + 1), v5) )
          {
            v150 = *(_QWORD *)(a3 + 24);
            v151 = *(char **)(v150 + 4096);
            if ( v150 + 4096 - (__int64)v151 >= (unsigned __int64)(48 * v5) )
              *(_QWORD *)(v150 + 4096) = &v151[48 * v5];
            else
              v151 = (char *)malloc(48 * v5);
          }
          else
          {
            v151 = 0LL;
          }
          v439 = &v151[48 * v148];
          *v439 = 20;
          v440 = &v151[48 * v5];
          *(_QWORD *)(v439 + 1) = v581[0];
          v439[11] = 0;
          *((_DWORD *)v439 + 3) = 0;
          *((_QWORD *)v439 + 2) = 0LL;
          *(_WORD *)(v439 + 9) = v581[1];
          v581[0] = 0LL;
          LOWORD(v581[1]) = 0;
          v439[24] = 0;
          *((_QWORD *)v439 + 4) = *(_QWORD *)((char *)v582 + 7);
          *((_QWORD *)v439 + 5) = 0LL;
          *(_QWORD *)(v439 + 25) = v582[0];
          *(_QWORD *)((char *)v582 + 7) = 0LL;
          v582[0] = 0LL;
          v442 = *(void ***)a3;
          v441 = *(void ***)(a3 + 8);
          v443 = v439 + 48;
          if ( v441 == *(void ***)a3 )
          {
            v259 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v439 - 4) = *(v441 - 4);
              *((_OWORD *)v439 - 3) = *((_OWORD *)v441 - 3);
              v444 = (__int64)*(v441 - 1);
              *(v441 - 5) = 0LL;
              *(v441 - 4) = 0LL;
              *(v441 - 6) = 0LL;
              *((_QWORD *)v439 - 1) = v444;
              *(_OWORD *)(v439 - 24) = *(_OWORD *)(v441 - 3);
              *(v441 - 2) = 0LL;
              *(v441 - 1) = 0LL;
              *(v441 - 3) = 0LL;
              v441 -= 6;
              v439 -= 48;
            }
            while ( v442 != v441 );
            v259 = *(void ***)a3;
            v442 = *(void ***)(a3 + 8);
          }
          v260 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v439;
          *(_QWORD *)(a3 + 8) = v443;
          *(_QWORD *)(a3 + 16) = v440;
          if ( v442 != v259 )
          {
            do
            {
              if ( (*(_BYTE *)(v442 - 3) & 1) != 0 )
                free(*(v442 - 1));
              v445 = v442 - 6;
              if ( (*(_BYTE *)(v442 - 6) & 1) != 0 )
                free(*(v442 - 4));
              v442 -= 6;
            }
            while ( v259 != v445 );
          }
          goto LABEL_1062;
        case 'i':
          *(_QWORD *)((char *)v582 + 7) = 0LL;
          v582[0] = 0LL;
          qmemcpy(v581, "operator-", 9);
          v6 = *(_QWORD *)(a3 + 8);
          v129 = *(_QWORD *)(a3 + 16);
          if ( v6 < v129 )
            goto LABEL_378;
          v130 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v6 - *(_QWORD *)a3) >> 4);
          if ( v130 + 1 > 0x555555555555555LL )
            abort();
          v131 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v129 - *(_QWORD *)a3) >> 4);
          if ( v131 >= 0x2AAAAAAAAAAAAAALL || (2 * v131 >= v130 + 1 ? (v5 = 2 * v131) : (v5 = v130 + 1), v5) )
          {
            v132 = *(_QWORD *)(a3 + 24);
            v133 = *(char **)(v132 + 4096);
            if ( v132 + 4096 - (__int64)v133 >= (unsigned __int64)(48 * v5) )
              *(_QWORD *)(v132 + 4096) = &v133[48 * v5];
            else
              v133 = (char *)malloc(48 * v5);
          }
          else
          {
            v133 = 0LL;
          }
          v390 = &v133[48 * v130];
          *v390 = 18;
          v391 = &v133[48 * v5];
          *(_QWORD *)(v390 + 1) = v581[0];
          v390[10] = 0;
          v390[9] = v581[1];
          *(_DWORD *)(v390 + 11) = 0;
          *((_QWORD *)v390 + 2) = 0LL;
          v390[15] = 0;
          v581[0] = 0LL;
          LOBYTE(v581[1]) = 0;
          v390[24] = 0;
          *((_QWORD *)v390 + 4) = *(_QWORD *)((char *)v582 + 7);
          *((_QWORD *)v390 + 5) = 0LL;
          *(_QWORD *)(v390 + 25) = v582[0];
          *(_QWORD *)((char *)v582 + 7) = 0LL;
          v582[0] = 0LL;
          v393 = *(void ***)a3;
          v392 = *(void ***)(a3 + 8);
          v394 = v390 + 48;
          if ( v392 == *(void ***)a3 )
          {
            v259 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v390 - 4) = *(v392 - 4);
              *((_OWORD *)v390 - 3) = *((_OWORD *)v392 - 3);
              v395 = (__int64)*(v392 - 1);
              *(v392 - 5) = 0LL;
              *(v392 - 4) = 0LL;
              *(v392 - 6) = 0LL;
              *((_QWORD *)v390 - 1) = v395;
              *(_OWORD *)(v390 - 24) = *(_OWORD *)(v392 - 3);
              *(v392 - 2) = 0LL;
              *(v392 - 1) = 0LL;
              *(v392 - 3) = 0LL;
              v392 -= 6;
              v390 -= 48;
            }
            while ( v393 != v392 );
            v259 = *(void ***)a3;
            v393 = *(void ***)(a3 + 8);
          }
          v260 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v390;
          *(_QWORD *)(a3 + 8) = v394;
          *(_QWORD *)(a3 + 16) = v391;
          if ( v393 != v259 )
          {
            do
            {
              if ( (*(_BYTE *)(v393 - 3) & 1) != 0 )
                free(*(v393 - 1));
              v396 = v393 - 6;
              if ( (*(_BYTE *)(v393 - 6) & 1) != 0 )
                free(*(v393 - 4));
              v393 -= 6;
            }
            while ( v259 != v396 );
          }
          goto LABEL_1062;
        case 'l':
          *(_QWORD *)((char *)v582 + 7) = 0LL;
          v582[0] = 0LL;
          qmemcpy(v581, "operator*", 9);
          v6 = *(_QWORD *)(a3 + 8);
          v173 = *(_QWORD *)(a3 + 16);
          if ( v6 < v173 )
            goto LABEL_378;
          v174 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v6 - *(_QWORD *)a3) >> 4);
          if ( v174 + 1 > 0x555555555555555LL )
            abort();
          v175 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v173 - *(_QWORD *)a3) >> 4);
          if ( v175 >= 0x2AAAAAAAAAAAAAALL || (2 * v175 >= v174 + 1 ? (v5 = 2 * v175) : (v5 = v174 + 1), v5) )
          {
            v176 = *(_QWORD *)(a3 + 24);
            v177 = *(char **)(v176 + 4096);
            if ( v176 + 4096 - (__int64)v177 >= (unsigned __int64)(48 * v5) )
              *(_QWORD *)(v176 + 4096) = &v177[48 * v5];
            else
              v177 = (char *)malloc(48 * v5);
          }
          else
          {
            v177 = 0LL;
          }
          v481 = &v177[48 * v174];
          *v481 = 18;
          v482 = &v177[48 * v5];
          *(_QWORD *)(v481 + 1) = v581[0];
          v481[10] = 0;
          v481[9] = v581[1];
          *(_DWORD *)(v481 + 11) = 0;
          *((_QWORD *)v481 + 2) = 0LL;
          v481[15] = 0;
          v581[0] = 0LL;
          LOBYTE(v581[1]) = 0;
          v481[24] = 0;
          *((_QWORD *)v481 + 4) = *(_QWORD *)((char *)v582 + 7);
          *((_QWORD *)v481 + 5) = 0LL;
          *(_QWORD *)(v481 + 25) = v582[0];
          *(_QWORD *)((char *)v582 + 7) = 0LL;
          v582[0] = 0LL;
          v484 = *(void ***)a3;
          v483 = *(void ***)(a3 + 8);
          v485 = v481 + 48;
          if ( v483 == *(void ***)a3 )
          {
            v259 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v481 - 4) = *(v483 - 4);
              *((_OWORD *)v481 - 3) = *((_OWORD *)v483 - 3);
              v486 = (__int64)*(v483 - 1);
              *(v483 - 5) = 0LL;
              *(v483 - 4) = 0LL;
              *(v483 - 6) = 0LL;
              *((_QWORD *)v481 - 1) = v486;
              *(_OWORD *)(v481 - 24) = *(_OWORD *)(v483 - 3);
              *(v483 - 2) = 0LL;
              *(v483 - 1) = 0LL;
              *(v483 - 3) = 0LL;
              v483 -= 6;
              v481 -= 48;
            }
            while ( v484 != v483 );
            v259 = *(void ***)a3;
            v484 = *(void ***)(a3 + 8);
          }
          v260 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v481;
          *(_QWORD *)(a3 + 8) = v485;
          *(_QWORD *)(a3 + 16) = v482;
          if ( v484 != v259 )
          {
            do
            {
              if ( (*(_BYTE *)(v484 - 3) & 1) != 0 )
                free(*(v484 - 1));
              v487 = v484 - 6;
              if ( (*(_BYTE *)(v484 - 6) & 1) != 0 )
                free(*(v484 - 4));
              v484 -= 6;
            }
            while ( v259 != v487 );
          }
          goto LABEL_1062;
        case 'm':
          *(_QWORD *)((char *)v582 + 7) = 0LL;
          v582[0] = 0LL;
          qmemcpy(v581, "operator--", 10);
          v6 = *(_QWORD *)(a3 + 8);
          v188 = *(_QWORD *)(a3 + 16);
          if ( v6 < v188 )
            goto LABEL_365;
          v189 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v6 - *(_QWORD *)a3) >> 4);
          if ( v189 + 1 > 0x555555555555555LL )
            abort();
          v190 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v188 - *(_QWORD *)a3) >> 4);
          if ( v190 >= 0x2AAAAAAAAAAAAAALL || (2 * v190 >= v189 + 1 ? (v5 = 2 * v190) : (v5 = v189 + 1), v5) )
          {
            v191 = *(_QWORD *)(a3 + 24);
            v192 = *(char **)(v191 + 4096);
            if ( v191 + 4096 - (__int64)v192 >= (unsigned __int64)(48 * v5) )
              *(_QWORD *)(v191 + 4096) = &v192[48 * v5];
            else
              v192 = (char *)malloc(48 * v5);
          }
          else
          {
            v192 = 0LL;
          }
          v502 = &v192[48 * v189];
          *v502 = 20;
          v503 = &v192[48 * v5];
          *(_QWORD *)(v502 + 1) = v581[0];
          v502[11] = 0;
          *((_DWORD *)v502 + 3) = 0;
          *((_QWORD *)v502 + 2) = 0LL;
          *(_WORD *)(v502 + 9) = v581[1];
          v581[0] = 0LL;
          LOWORD(v581[1]) = 0;
          v502[24] = 0;
          *((_QWORD *)v502 + 4) = *(_QWORD *)((char *)v582 + 7);
          *((_QWORD *)v502 + 5) = 0LL;
          *(_QWORD *)(v502 + 25) = v582[0];
          *(_QWORD *)((char *)v582 + 7) = 0LL;
          v582[0] = 0LL;
          v505 = *(void ***)a3;
          v504 = *(void ***)(a3 + 8);
          v506 = v502 + 48;
          if ( v504 == *(void ***)a3 )
          {
            v259 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v502 - 4) = *(v504 - 4);
              *((_OWORD *)v502 - 3) = *((_OWORD *)v504 - 3);
              v507 = (__int64)*(v504 - 1);
              *(v504 - 5) = 0LL;
              *(v504 - 4) = 0LL;
              *(v504 - 6) = 0LL;
              *((_QWORD *)v502 - 1) = v507;
              *(_OWORD *)(v502 - 24) = *(_OWORD *)(v504 - 3);
              *(v504 - 2) = 0LL;
              *(v504 - 1) = 0LL;
              *(v504 - 3) = 0LL;
              v504 -= 6;
              v502 -= 48;
            }
            while ( v505 != v504 );
            v259 = *(void ***)a3;
            v505 = *(void ***)(a3 + 8);
          }
          v260 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v502;
          *(_QWORD *)(a3 + 8) = v506;
          *(_QWORD *)(a3 + 16) = v503;
          if ( v505 != v259 )
          {
            do
            {
              if ( (*(_BYTE *)(v505 - 3) & 1) != 0 )
                free(*(v505 - 1));
              v508 = v505 - 6;
              if ( (*(_BYTE *)(v505 - 6) & 1) != 0 )
                free(*(v505 - 4));
              v505 -= 6;
            }
            while ( v259 != v508 );
          }
          goto LABEL_1062;
        default:
          return (__int64)v3;
      }
      return (__int64)v3;
    case 'n':
      switch ( a1[1] )
      {
        case 'a':
          *(_QWORD *)((char *)v582 + 7) = 0LL;
          v582[0] = 0LL;
          qmemcpy(v581, "operator new[]", 14);
          v6 = *(_QWORD *)(a3 + 8);
          v76 = *(_QWORD *)(a3 + 16);
          if ( v6 < v76 )
          {
            *(_BYTE *)v6 = 28;
            v3 = a1 + 2;
            *(_QWORD *)(v6 + 7) = *(_QWORD *)((char *)v581 + 6);
            *(_BYTE *)(v6 + 15) = 0;
            *(_QWORD *)(v6 + 16) = 0LL;
            *(_QWORD *)(v6 + 1) = v581[0];
            *(_QWORD *)((char *)v581 + 6) = 0LL;
            goto LABEL_361;
          }
          v229 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v6 - *(_QWORD *)a3) >> 4);
          if ( v229 + 1 > 0x555555555555555LL )
            abort();
          v230 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v76 - *(_QWORD *)a3) >> 4);
          if ( v230 >= 0x2AAAAAAAAAAAAAALL || (2 * v230 >= v229 + 1 ? (v5 = 2 * v230) : (v5 = v229 + 1), v5) )
          {
            v231 = *(_QWORD *)(a3 + 24);
            v232 = *(char **)(v231 + 4096);
            if ( v231 + 4096 - (__int64)v232 >= (unsigned __int64)(48 * v5) )
              *(_QWORD *)(v231 + 4096) = &v232[48 * v5];
            else
              v232 = (char *)malloc(48 * v5);
          }
          else
          {
            v232 = 0LL;
          }
          v509 = &v232[48 * v229];
          *v509 = 28;
          v510 = &v232[48 * v5];
          *(_QWORD *)(v509 + 7) = *(_QWORD *)((char *)v581 + 6);
          v509[15] = 0;
          *((_QWORD *)v509 + 2) = 0LL;
          *(_QWORD *)(v509 + 1) = v581[0];
          *(_QWORD *)((char *)v581 + 6) = 0LL;
          v581[0] = 0LL;
          v509[24] = 0;
          *((_QWORD *)v509 + 4) = *(_QWORD *)((char *)v582 + 7);
          *((_QWORD *)v509 + 5) = 0LL;
          *(_QWORD *)(v509 + 25) = v582[0];
          *(_QWORD *)((char *)v582 + 7) = 0LL;
          v582[0] = 0LL;
          v512 = *(void ***)a3;
          v511 = *(void ***)(a3 + 8);
          v513 = v509 + 48;
          if ( v511 == *(void ***)a3 )
          {
            v259 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v509 - 4) = *(v511 - 4);
              *((_OWORD *)v509 - 3) = *((_OWORD *)v511 - 3);
              v514 = (__int64)*(v511 - 1);
              *(v511 - 5) = 0LL;
              *(v511 - 4) = 0LL;
              *(v511 - 6) = 0LL;
              *((_QWORD *)v509 - 1) = v514;
              *(_OWORD *)(v509 - 24) = *(_OWORD *)(v511 - 3);
              *(v511 - 2) = 0LL;
              *(v511 - 1) = 0LL;
              *(v511 - 3) = 0LL;
              v511 -= 6;
              v509 -= 48;
            }
            while ( v512 != v511 );
            v259 = *(void ***)a3;
            v512 = *(void ***)(a3 + 8);
          }
          v260 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v509;
          *(_QWORD *)(a3 + 8) = v513;
          *(_QWORD *)(a3 + 16) = v510;
          if ( v512 != v259 )
          {
            do
            {
              if ( (*(_BYTE *)(v512 - 3) & 1) != 0 )
                free(*(v512 - 1));
              v515 = v512 - 6;
              if ( (*(_BYTE *)(v512 - 6) & 1) != 0 )
                free(*(v512 - 4));
              v512 -= 6;
            }
            while ( v259 != v515 );
          }
          goto LABEL_1062;
        case 'e':
          *(_QWORD *)((char *)v582 + 7) = 0LL;
          v582[0] = 0LL;
          qmemcpy(v581, "operator!=", 10);
          v6 = *(_QWORD *)(a3 + 8);
          v193 = *(_QWORD *)(a3 + 16);
          if ( v6 < v193 )
            goto LABEL_365;
          v194 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v6 - *(_QWORD *)a3) >> 4);
          if ( v194 + 1 > 0x555555555555555LL )
            abort();
          v195 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v193 - *(_QWORD *)a3) >> 4);
          if ( v195 >= 0x2AAAAAAAAAAAAAALL || (2 * v195 >= v194 + 1 ? (v5 = 2 * v195) : (v5 = v194 + 1), v5) )
          {
            v196 = *(_QWORD *)(a3 + 24);
            v197 = *(char **)(v196 + 4096);
            if ( v196 + 4096 - (__int64)v197 >= (unsigned __int64)(48 * v5) )
              *(_QWORD *)(v196 + 4096) = &v197[48 * v5];
            else
              v197 = (char *)malloc(48 * v5);
          }
          else
          {
            v197 = 0LL;
          }
          v516 = &v197[48 * v194];
          *v516 = 20;
          v517 = &v197[48 * v5];
          *(_QWORD *)(v516 + 1) = v581[0];
          v516[11] = 0;
          *((_DWORD *)v516 + 3) = 0;
          *((_QWORD *)v516 + 2) = 0LL;
          *(_WORD *)(v516 + 9) = v581[1];
          v581[0] = 0LL;
          LOWORD(v581[1]) = 0;
          v516[24] = 0;
          *((_QWORD *)v516 + 4) = *(_QWORD *)((char *)v582 + 7);
          *((_QWORD *)v516 + 5) = 0LL;
          *(_QWORD *)(v516 + 25) = v582[0];
          *(_QWORD *)((char *)v582 + 7) = 0LL;
          v582[0] = 0LL;
          v519 = *(void ***)a3;
          v518 = *(void ***)(a3 + 8);
          v520 = v516 + 48;
          if ( v518 == *(void ***)a3 )
          {
            v259 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v516 - 4) = *(v518 - 4);
              *((_OWORD *)v516 - 3) = *((_OWORD *)v518 - 3);
              v521 = (__int64)*(v518 - 1);
              *(v518 - 5) = 0LL;
              *(v518 - 4) = 0LL;
              *(v518 - 6) = 0LL;
              *((_QWORD *)v516 - 1) = v521;
              *(_OWORD *)(v516 - 24) = *(_OWORD *)(v518 - 3);
              *(v518 - 2) = 0LL;
              *(v518 - 1) = 0LL;
              *(v518 - 3) = 0LL;
              v518 -= 6;
              v516 -= 48;
            }
            while ( v519 != v518 );
            v259 = *(void ***)a3;
            v519 = *(void ***)(a3 + 8);
          }
          v260 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v516;
          *(_QWORD *)(a3 + 8) = v520;
          *(_QWORD *)(a3 + 16) = v517;
          if ( v519 != v259 )
          {
            do
            {
              if ( (*(_BYTE *)(v519 - 3) & 1) != 0 )
                free(*(v519 - 1));
              v522 = v519 - 6;
              if ( (*(_BYTE *)(v519 - 6) & 1) != 0 )
                free(*(v519 - 4));
              v519 -= 6;
            }
            while ( v259 != v522 );
          }
          goto LABEL_1062;
        case 'g':
          *(_QWORD *)((char *)v582 + 7) = 0LL;
          v582[0] = 0LL;
          qmemcpy(v581, "operator-", 9);
          v6 = *(_QWORD *)(a3 + 8);
          v152 = *(_QWORD *)(a3 + 16);
          if ( v6 < v152 )
            goto LABEL_378;
          v153 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v6 - *(_QWORD *)a3) >> 4);
          if ( v153 + 1 > 0x555555555555555LL )
            abort();
          v154 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v152 - *(_QWORD *)a3) >> 4);
          if ( v154 >= 0x2AAAAAAAAAAAAAALL || (2 * v154 >= v153 + 1 ? (v5 = 2 * v154) : (v5 = v153 + 1), v5) )
          {
            v155 = *(_QWORD *)(a3 + 24);
            v156 = *(char **)(v155 + 4096);
            if ( v155 + 4096 - (__int64)v156 >= (unsigned __int64)(48 * v5) )
              *(_QWORD *)(v155 + 4096) = &v156[48 * v5];
            else
              v156 = (char *)malloc(48 * v5);
          }
          else
          {
            v156 = 0LL;
          }
          v446 = &v156[48 * v153];
          *v446 = 18;
          v447 = &v156[48 * v5];
          *(_QWORD *)(v446 + 1) = v581[0];
          v446[10] = 0;
          v446[9] = v581[1];
          *(_DWORD *)(v446 + 11) = 0;
          *((_QWORD *)v446 + 2) = 0LL;
          v446[15] = 0;
          v581[0] = 0LL;
          LOBYTE(v581[1]) = 0;
          v446[24] = 0;
          *((_QWORD *)v446 + 4) = *(_QWORD *)((char *)v582 + 7);
          *((_QWORD *)v446 + 5) = 0LL;
          *(_QWORD *)(v446 + 25) = v582[0];
          *(_QWORD *)((char *)v582 + 7) = 0LL;
          v582[0] = 0LL;
          v449 = *(void ***)a3;
          v448 = *(void ***)(a3 + 8);
          v450 = v446 + 48;
          if ( v448 == *(void ***)a3 )
          {
            v259 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v446 - 4) = *(v448 - 4);
              *((_OWORD *)v446 - 3) = *((_OWORD *)v448 - 3);
              v451 = (__int64)*(v448 - 1);
              *(v448 - 5) = 0LL;
              *(v448 - 4) = 0LL;
              *(v448 - 6) = 0LL;
              *((_QWORD *)v446 - 1) = v451;
              *(_OWORD *)(v446 - 24) = *(_OWORD *)(v448 - 3);
              *(v448 - 2) = 0LL;
              *(v448 - 1) = 0LL;
              *(v448 - 3) = 0LL;
              v448 -= 6;
              v446 -= 48;
            }
            while ( v449 != v448 );
            v259 = *(void ***)a3;
            v449 = *(void ***)(a3 + 8);
          }
          v260 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v446;
          *(_QWORD *)(a3 + 8) = v450;
          *(_QWORD *)(a3 + 16) = v447;
          if ( v449 != v259 )
          {
            do
            {
              if ( (*(_BYTE *)(v449 - 3) & 1) != 0 )
                free(*(v449 - 1));
              v452 = v449 - 6;
              if ( (*(_BYTE *)(v449 - 6) & 1) != 0 )
                free(*(v449 - 4));
              v449 -= 6;
            }
            while ( v259 != v452 );
          }
          goto LABEL_1062;
        case 't':
          *(_QWORD *)((char *)v582 + 7) = 0LL;
          v582[0] = 0LL;
          qmemcpy(v581, "operator!", 9);
          v6 = *(_QWORD *)(a3 + 8);
          v198 = *(_QWORD *)(a3 + 16);
          if ( v6 < v198 )
            goto LABEL_378;
          v199 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v6 - *(_QWORD *)a3) >> 4);
          if ( v199 + 1 > 0x555555555555555LL )
            abort();
          v200 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v198 - *(_QWORD *)a3) >> 4);
          if ( v200 >= 0x2AAAAAAAAAAAAAALL || (2 * v200 >= v199 + 1 ? (v5 = 2 * v200) : (v5 = v199 + 1), v5) )
          {
            v201 = *(_QWORD *)(a3 + 24);
            v202 = *(char **)(v201 + 4096);
            if ( v201 + 4096 - (__int64)v202 >= (unsigned __int64)(48 * v5) )
              *(_QWORD *)(v201 + 4096) = &v202[48 * v5];
            else
              v202 = (char *)malloc(48 * v5);
          }
          else
          {
            v202 = 0LL;
          }
          v523 = &v202[48 * v199];
          *v523 = 18;
          v524 = &v202[48 * v5];
          *(_QWORD *)(v523 + 1) = v581[0];
          v523[10] = 0;
          v523[9] = v581[1];
          *(_DWORD *)(v523 + 11) = 0;
          *((_QWORD *)v523 + 2) = 0LL;
          v523[15] = 0;
          v581[0] = 0LL;
          LOBYTE(v581[1]) = 0;
          v523[24] = 0;
          *((_QWORD *)v523 + 4) = *(_QWORD *)((char *)v582 + 7);
          *((_QWORD *)v523 + 5) = 0LL;
          *(_QWORD *)(v523 + 25) = v582[0];
          *(_QWORD *)((char *)v582 + 7) = 0LL;
          v582[0] = 0LL;
          v526 = *(void ***)a3;
          v525 = *(void ***)(a3 + 8);
          v527 = v523 + 48;
          if ( v525 == *(void ***)a3 )
          {
            v259 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v523 - 4) = *(v525 - 4);
              *((_OWORD *)v523 - 3) = *((_OWORD *)v525 - 3);
              v528 = (__int64)*(v525 - 1);
              *(v525 - 5) = 0LL;
              *(v525 - 4) = 0LL;
              *(v525 - 6) = 0LL;
              *((_QWORD *)v523 - 1) = v528;
              *(_OWORD *)(v523 - 24) = *(_OWORD *)(v525 - 3);
              *(v525 - 2) = 0LL;
              *(v525 - 1) = 0LL;
              *(v525 - 3) = 0LL;
              v525 -= 6;
              v523 -= 48;
            }
            while ( v526 != v525 );
            v259 = *(void ***)a3;
            v526 = *(void ***)(a3 + 8);
          }
          v260 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v523;
          *(_QWORD *)(a3 + 8) = v527;
          *(_QWORD *)(a3 + 16) = v524;
          if ( v526 != v259 )
          {
            do
            {
              if ( (*(_BYTE *)(v526 - 3) & 1) != 0 )
                free(*(v526 - 1));
              v529 = v526 - 6;
              if ( (*(_BYTE *)(v526 - 6) & 1) != 0 )
                free(*(v526 - 4));
              v526 -= 6;
            }
            while ( v259 != v529 );
          }
          goto LABEL_1062;
        case 'w':
          *(_QWORD *)((char *)v582 + 7) = 0LL;
          v582[0] = 0LL;
          qmemcpy(v581, "operator new", 12);
          v6 = *(_QWORD *)(a3 + 8);
          v203 = *(_QWORD *)(a3 + 16);
          if ( v6 >= v203 )
          {
            v233 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v6 - *(_QWORD *)a3) >> 4);
            if ( v233 + 1 > 0x555555555555555LL )
              abort();
            v234 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v203 - *(_QWORD *)a3) >> 4);
            if ( v234 >= 0x2AAAAAAAAAAAAAALL || (2 * v234 >= v233 + 1 ? (v5 = 2 * v234) : (v5 = v233 + 1), v5) )
            {
              v235 = *(_QWORD *)(a3 + 24);
              v236 = *(char **)(v235 + 4096);
              if ( v235 + 4096 - (__int64)v236 >= (unsigned __int64)(48 * v5) )
                *(_QWORD *)(v235 + 4096) = &v236[48 * v5];
              else
                v236 = (char *)malloc(48 * v5);
            }
            else
            {
              v236 = 0LL;
            }
            v530 = &v236[48 * v233];
            *v530 = 24;
            v531 = &v236[48 * v5];
            *(_DWORD *)(v530 + 9) = v581[1];
            v530[13] = 0;
            *((_WORD *)v530 + 7) = 0;
            *((_QWORD *)v530 + 2) = 0LL;
            *(_QWORD *)(v530 + 1) = v581[0];
            LODWORD(v581[1]) = 0;
            v581[0] = 0LL;
            v530[24] = 0;
            *((_QWORD *)v530 + 4) = *(_QWORD *)((char *)v582 + 7);
            *((_QWORD *)v530 + 5) = 0LL;
            *(_QWORD *)(v530 + 25) = v582[0];
            *(_QWORD *)((char *)v582 + 7) = 0LL;
            v582[0] = 0LL;
            v533 = *(void ***)a3;
            v532 = *(void ***)(a3 + 8);
            v534 = v530 + 48;
            if ( v532 == *(void ***)a3 )
            {
              v259 = *(void ***)a3;
            }
            else
            {
              do
              {
                *((_QWORD *)v530 - 4) = *(v532 - 4);
                *((_OWORD *)v530 - 3) = *((_OWORD *)v532 - 3);
                v535 = (__int64)*(v532 - 1);
                *(v532 - 5) = 0LL;
                *(v532 - 4) = 0LL;
                *(v532 - 6) = 0LL;
                *((_QWORD *)v530 - 1) = v535;
                *(_OWORD *)(v530 - 24) = *(_OWORD *)(v532 - 3);
                *(v532 - 2) = 0LL;
                *(v532 - 1) = 0LL;
                *(v532 - 3) = 0LL;
                v532 -= 6;
                v530 -= 48;
              }
              while ( v533 != v532 );
              v259 = *(void ***)a3;
              v533 = *(void ***)(a3 + 8);
            }
            v260 = *(_QWORD *)(a3 + 16);
            *(_QWORD *)a3 = v530;
            *(_QWORD *)(a3 + 8) = v534;
            *(_QWORD *)(a3 + 16) = v531;
            if ( v533 != v259 )
            {
              do
              {
                if ( (*(_BYTE *)(v533 - 3) & 1) != 0 )
                  free(*(v533 - 1));
                v536 = v533 - 6;
                if ( (*(_BYTE *)(v533 - 6) & 1) != 0 )
                  free(*(v533 - 4));
                v533 -= 6;
              }
              while ( v259 != v536 );
            }
            goto LABEL_1062;
          }
          *(_BYTE *)v6 = 24;
          v3 = a1 + 2;
          *(_DWORD *)(v6 + 9) = v581[1];
          *(_BYTE *)(v6 + 13) = 0;
          *(_WORD *)(v6 + 14) = 0;
          *(_QWORD *)(v6 + 16) = 0LL;
          *(_QWORD *)(v6 + 1) = v581[0];
          LODWORD(v581[1]) = 0;
LABEL_361:
          v581[0] = 0LL;
          break;
        default:
          return (__int64)v3;
      }
      goto LABEL_379;
    case 'o':
      v70 = (unsigned __int8)a1[1];
      if ( v70 == 82 )
      {
        *(_QWORD *)((char *)v582 + 7) = 0LL;
        v582[0] = 0LL;
        qmemcpy(v581, "operator|=", 10);
        v6 = *(_QWORD *)(a3 + 8);
        v97 = *(_QWORD *)(a3 + 16);
        if ( v6 >= v97 )
        {
          v98 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v6 - *(_QWORD *)a3) >> 4);
          if ( v98 + 1 > 0x555555555555555LL )
            abort();
          v99 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v97 - *(_QWORD *)a3) >> 4);
          if ( v99 >= 0x2AAAAAAAAAAAAAALL || (2 * v99 >= v98 + 1 ? (v5 = 2 * v99) : (v5 = v98 + 1), v5) )
          {
            v100 = *(_QWORD *)(a3 + 24);
            v101 = *(char **)(v100 + 4096);
            if ( v100 + 4096 - (__int64)v101 >= (unsigned __int64)(48 * v5) )
              *(_QWORD *)(v100 + 4096) = &v101[48 * v5];
            else
              v101 = (char *)malloc(48 * v5);
          }
          else
          {
            v101 = 0LL;
          }
          v319 = &v101[48 * v98];
          *v319 = 20;
          v320 = &v101[48 * v5];
          *(_QWORD *)(v319 + 1) = v581[0];
          v319[11] = 0;
          *((_DWORD *)v319 + 3) = 0;
          *((_QWORD *)v319 + 2) = 0LL;
          *(_WORD *)(v319 + 9) = v581[1];
          v581[0] = 0LL;
          LOWORD(v581[1]) = 0;
          v319[24] = 0;
          *((_QWORD *)v319 + 4) = *(_QWORD *)((char *)v582 + 7);
          *((_QWORD *)v319 + 5) = 0LL;
          *(_QWORD *)(v319 + 25) = v582[0];
          *(_QWORD *)((char *)v582 + 7) = 0LL;
          v582[0] = 0LL;
          v322 = *(void ***)a3;
          v321 = *(void ***)(a3 + 8);
          v323 = v319 + 48;
          if ( v321 == *(void ***)a3 )
          {
            v259 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v319 - 4) = *(v321 - 4);
              *((_OWORD *)v319 - 3) = *((_OWORD *)v321 - 3);
              v324 = (__int64)*(v321 - 1);
              *(v321 - 5) = 0LL;
              *(v321 - 4) = 0LL;
              *(v321 - 6) = 0LL;
              *((_QWORD *)v319 - 1) = v324;
              *(_OWORD *)(v319 - 24) = *(_OWORD *)(v321 - 3);
              *(v321 - 2) = 0LL;
              *(v321 - 1) = 0LL;
              *(v321 - 3) = 0LL;
              v321 -= 6;
              v319 -= 48;
            }
            while ( v322 != v321 );
            v259 = *(void ***)a3;
            v322 = *(void ***)(a3 + 8);
          }
          v260 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v319;
          *(_QWORD *)(a3 + 8) = v323;
          *(_QWORD *)(a3 + 16) = v320;
          if ( v322 != v259 )
          {
            do
            {
              if ( (*(_BYTE *)(v322 - 3) & 1) != 0 )
                free(*(v322 - 1));
              v325 = v322 - 6;
              if ( (*(_BYTE *)(v322 - 6) & 1) != 0 )
                free(*(v322 - 4));
              v322 -= 6;
            }
            while ( v259 != v325 );
          }
          goto LABEL_1062;
        }
        goto LABEL_365;
      }
      if ( v70 == 114 )
      {
        *(_QWORD *)((char *)v582 + 7) = 0LL;
        v582[0] = 0LL;
        qmemcpy(v581, "operator|", 9);
        v6 = *(_QWORD *)(a3 + 8);
        v92 = *(_QWORD *)(a3 + 16);
        if ( v6 >= v92 )
        {
          v93 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v6 - *(_QWORD *)a3) >> 4);
          if ( v93 + 1 > 0x555555555555555LL )
            abort();
          v94 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v92 - *(_QWORD *)a3) >> 4);
          if ( v94 >= 0x2AAAAAAAAAAAAAALL || (2 * v94 >= v93 + 1 ? (v5 = 2 * v94) : (v5 = v93 + 1), v5) )
          {
            v95 = *(_QWORD *)(a3 + 24);
            v96 = *(char **)(v95 + 4096);
            if ( v95 + 4096 - (__int64)v96 >= (unsigned __int64)(48 * v5) )
              *(_QWORD *)(v95 + 4096) = &v96[48 * v5];
            else
              v96 = (char *)malloc(48 * v5);
          }
          else
          {
            v96 = 0LL;
          }
          v312 = &v96[48 * v93];
          *v312 = 18;
          v313 = &v96[48 * v5];
          *(_QWORD *)(v312 + 1) = v581[0];
          v312[10] = 0;
          v312[9] = v581[1];
          *(_DWORD *)(v312 + 11) = 0;
          *((_QWORD *)v312 + 2) = 0LL;
          v312[15] = 0;
          v581[0] = 0LL;
          LOBYTE(v581[1]) = 0;
          v312[24] = 0;
          *((_QWORD *)v312 + 4) = *(_QWORD *)((char *)v582 + 7);
          *((_QWORD *)v312 + 5) = 0LL;
          *(_QWORD *)(v312 + 25) = v582[0];
          *(_QWORD *)((char *)v582 + 7) = 0LL;
          v582[0] = 0LL;
          v315 = *(void ***)a3;
          v314 = *(void ***)(a3 + 8);
          v316 = v312 + 48;
          if ( v314 == *(void ***)a3 )
          {
            v259 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v312 - 4) = *(v314 - 4);
              *((_OWORD *)v312 - 3) = *((_OWORD *)v314 - 3);
              v317 = (__int64)*(v314 - 1);
              *(v314 - 5) = 0LL;
              *(v314 - 4) = 0LL;
              *(v314 - 6) = 0LL;
              *((_QWORD *)v312 - 1) = v317;
              *(_OWORD *)(v312 - 24) = *(_OWORD *)(v314 - 3);
              *(v314 - 2) = 0LL;
              *(v314 - 1) = 0LL;
              *(v314 - 3) = 0LL;
              v314 -= 6;
              v312 -= 48;
            }
            while ( v315 != v314 );
            v259 = *(void ***)a3;
            v315 = *(void ***)(a3 + 8);
          }
          v260 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v312;
          *(_QWORD *)(a3 + 8) = v316;
          *(_QWORD *)(a3 + 16) = v313;
          if ( v315 != v259 )
          {
            do
            {
              if ( (*(_BYTE *)(v315 - 3) & 1) != 0 )
                free(*(v315 - 1));
              v318 = v315 - 6;
              if ( (*(_BYTE *)(v315 - 6) & 1) != 0 )
                free(*(v315 - 4));
              v315 -= 6;
            }
            while ( v259 != v318 );
          }
          goto LABEL_1062;
        }
LABEL_378:
        *(_BYTE *)v6 = 18;
        v3 = a1 + 2;
        *(_QWORD *)(v6 + 1) = v581[0];
        *(_BYTE *)(v6 + 10) = 0;
        *(_BYTE *)(v6 + 9) = v581[1];
        *(_DWORD *)(v6 + 11) = 0;
        *(_QWORD *)(v6 + 16) = 0LL;
        *(_BYTE *)(v6 + 15) = 0;
        v581[0] = 0LL;
        LOBYTE(v581[1]) = 0;
LABEL_379:
        *(_BYTE *)(v6 + 24) = 0;
        *(_QWORD *)(v6 + 32) = *(_QWORD *)((char *)v582 + 7);
        *(_QWORD *)(v6 + 40) = 0LL;
        *(_QWORD *)(v6 + 25) = v582[0];
        *(_QWORD *)((char *)v582 + 7) = 0LL;
        v582[0] = 0LL;
LABEL_380:
        *(_QWORD *)(a3 + 8) += 48LL;
        return (__int64)v3;
      }
      if ( v70 != 111 )
        return (__int64)v3;
      *(_QWORD *)((char *)v582 + 7) = 0LL;
      v582[0] = 0LL;
      qmemcpy(v581, "operator||", 10);
      v6 = *(_QWORD *)(a3 + 8);
      v71 = *(_QWORD *)(a3 + 16);
      if ( v6 < v71 )
      {
LABEL_365:
        *(_BYTE *)v6 = 20;
        v3 = a1 + 2;
        *(_QWORD *)(v6 + 1) = v581[0];
        *(_BYTE *)(v6 + 11) = 0;
        *(_DWORD *)(v6 + 12) = 0;
        *(_QWORD *)(v6 + 16) = 0LL;
        *(_WORD *)(v6 + 9) = v581[1];
        v581[0] = 0LL;
        LOWORD(v581[1]) = 0;
        goto LABEL_379;
      }
      v72 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v6 - *(_QWORD *)a3) >> 4);
      if ( v72 + 1 > 0x555555555555555LL )
        abort();
      v73 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v71 - *(_QWORD *)a3) >> 4);
      if ( v73 >= 0x2AAAAAAAAAAAAAALL || (2 * v73 >= v72 + 1 ? (v5 = 2 * v73) : (v5 = v72 + 1), v5) )
      {
        v74 = *(_QWORD *)(a3 + 24);
        v75 = *(char **)(v74 + 4096);
        if ( v74 + 4096 - (__int64)v75 >= (unsigned __int64)(48 * v5) )
          *(_QWORD *)(v74 + 4096) = &v75[48 * v5];
        else
          v75 = (char *)malloc(48 * v5);
      }
      else
      {
        v75 = 0LL;
      }
      v326 = &v75[48 * v72];
      *v326 = 20;
      v327 = &v75[48 * v5];
      *(_QWORD *)(v326 + 1) = v581[0];
      v326[11] = 0;
      *((_DWORD *)v326 + 3) = 0;
      *((_QWORD *)v326 + 2) = 0LL;
      *(_WORD *)(v326 + 9) = v581[1];
      v581[0] = 0LL;
      LOWORD(v581[1]) = 0;
      v326[24] = 0;
      *((_QWORD *)v326 + 4) = *(_QWORD *)((char *)v582 + 7);
      *((_QWORD *)v326 + 5) = 0LL;
      *(_QWORD *)(v326 + 25) = v582[0];
      *(_QWORD *)((char *)v582 + 7) = 0LL;
      v582[0] = 0LL;
      v329 = *(void ***)a3;
      v328 = *(void ***)(a3 + 8);
      v330 = v326 + 48;
      if ( v328 == *(void ***)a3 )
      {
        v259 = *(void ***)a3;
      }
      else
      {
        do
        {
          *((_QWORD *)v326 - 4) = *(v328 - 4);
          *((_OWORD *)v326 - 3) = *((_OWORD *)v328 - 3);
          v331 = (__int64)*(v328 - 1);
          *(v328 - 5) = 0LL;
          *(v328 - 4) = 0LL;
          *(v328 - 6) = 0LL;
          *((_QWORD *)v326 - 1) = v331;
          *(_OWORD *)(v326 - 24) = *(_OWORD *)(v328 - 3);
          *(v328 - 2) = 0LL;
          *(v328 - 1) = 0LL;
          *(v328 - 3) = 0LL;
          v328 -= 6;
          v326 -= 48;
        }
        while ( v329 != v328 );
        v259 = *(void ***)a3;
        v329 = *(void ***)(a3 + 8);
      }
      v260 = *(_QWORD *)(a3 + 16);
      *(_QWORD *)a3 = v326;
      *(_QWORD *)(a3 + 8) = v330;
      *(_QWORD *)(a3 + 16) = v327;
      if ( v329 != v259 )
      {
        do
        {
          if ( (*(_BYTE *)(v329 - 3) & 1) != 0 )
            free(*(v329 - 1));
          v332 = v329 - 6;
          if ( (*(_BYTE *)(v329 - 6) & 1) != 0 )
            free(*(v329 - 4));
          v329 -= 6;
        }
        while ( v259 != v332 );
      }
LABEL_1062:
      if ( v259 )
      {
        v579 = *(_QWORD *)(a3 + 24);
        if ( v579 + 4096 < (unsigned __int64)v259 || v579 > (unsigned __int64)v259 )
        {
LABEL_1067:
          free(v259);
        }
        else if ( *(_QWORD *)(v579 + 4096) == v260 )
        {
          *(_QWORD *)(v579 + 4096) = v259;
        }
      }
LABEL_1068:
      v3 += 2;
      return (__int64)v3;
    case 'p':
      switch ( a1[1] )
      {
        case 'L':
          *(_QWORD *)((char *)v582 + 7) = 0LL;
          v582[0] = 0LL;
          qmemcpy(v581, "operator+=", 10);
          v6 = *(_QWORD *)(a3 + 8);
          v18 = *(_QWORD *)(a3 + 16);
          if ( v6 < v18 )
            goto LABEL_365;
          v19 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v6 - *(_QWORD *)a3) >> 4);
          if ( v19 + 1 > 0x555555555555555LL )
            abort();
          v20 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v18 - *(_QWORD *)a3) >> 4);
          if ( v20 >= 0x2AAAAAAAAAAAAAALL || (2 * v20 >= v19 + 1 ? (v5 = 2 * v20) : (v5 = v19 + 1), v5) )
          {
            v21 = *(_QWORD *)(a3 + 24);
            v22 = *(char **)(v21 + 4096);
            if ( v21 + 4096 - (__int64)v22 >= (unsigned __int64)(48 * v5) )
              *(_QWORD *)(v21 + 4096) = &v22[48 * v5];
            else
              v22 = (char *)malloc(48 * v5);
          }
          else
          {
            v22 = 0LL;
          }
          v551 = &v22[48 * v19];
          *v551 = 20;
          v552 = &v22[48 * v5];
          *(_QWORD *)(v551 + 1) = v581[0];
          v551[11] = 0;
          *((_DWORD *)v551 + 3) = 0;
          *((_QWORD *)v551 + 2) = 0LL;
          *(_WORD *)(v551 + 9) = v581[1];
          v581[0] = 0LL;
          LOWORD(v581[1]) = 0;
          v551[24] = 0;
          *((_QWORD *)v551 + 4) = *(_QWORD *)((char *)v582 + 7);
          *((_QWORD *)v551 + 5) = 0LL;
          *(_QWORD *)(v551 + 25) = v582[0];
          *(_QWORD *)((char *)v582 + 7) = 0LL;
          v582[0] = 0LL;
          v554 = *(void ***)a3;
          v553 = *(void ***)(a3 + 8);
          v555 = v551 + 48;
          if ( v553 == *(void ***)a3 )
          {
            v259 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v551 - 4) = *(v553 - 4);
              *((_OWORD *)v551 - 3) = *((_OWORD *)v553 - 3);
              v556 = (__int64)*(v553 - 1);
              *(v553 - 5) = 0LL;
              *(v553 - 4) = 0LL;
              *(v553 - 6) = 0LL;
              *((_QWORD *)v551 - 1) = v556;
              *(_OWORD *)(v551 - 24) = *(_OWORD *)(v553 - 3);
              *(v553 - 2) = 0LL;
              *(v553 - 1) = 0LL;
              *(v553 - 3) = 0LL;
              v553 -= 6;
              v551 -= 48;
            }
            while ( v554 != v553 );
            v259 = *(void ***)a3;
            v554 = *(void ***)(a3 + 8);
          }
          v260 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v551;
          *(_QWORD *)(a3 + 8) = v555;
          *(_QWORD *)(a3 + 16) = v552;
          if ( v554 != v259 )
          {
            do
            {
              if ( (*(_BYTE *)(v554 - 3) & 1) != 0 )
                free(*(v554 - 1));
              v557 = v554 - 6;
              if ( (*(_BYTE *)(v554 - 6) & 1) != 0 )
                free(*(v554 - 4));
              v554 -= 6;
            }
            while ( v259 != v557 );
          }
          goto LABEL_1062;
        case 'l':
          *(_QWORD *)((char *)v582 + 7) = 0LL;
          v582[0] = 0LL;
          qmemcpy(v581, "operator+", 9);
          v6 = *(_QWORD *)(a3 + 8);
          v206 = *(_QWORD *)(a3 + 16);
          if ( v6 < v206 )
            goto LABEL_378;
          v207 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v6 - *(_QWORD *)a3) >> 4);
          if ( v207 + 1 > 0x555555555555555LL )
            abort();
          v208 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v206 - *(_QWORD *)a3) >> 4);
          if ( v208 >= 0x2AAAAAAAAAAAAAALL || (2 * v208 >= v207 + 1 ? (v5 = 2 * v208) : (v5 = v207 + 1), v5) )
          {
            v209 = *(_QWORD *)(a3 + 24);
            v210 = *(char **)(v209 + 4096);
            if ( v209 + 4096 - (__int64)v210 >= (unsigned __int64)(48 * v5) )
              *(_QWORD *)(v209 + 4096) = &v210[48 * v5];
            else
              v210 = (char *)malloc(48 * v5);
          }
          else
          {
            v210 = 0LL;
          }
          v558 = &v210[48 * v207];
          *v558 = 18;
          v559 = &v210[48 * v5];
          *(_QWORD *)(v558 + 1) = v581[0];
          v558[10] = 0;
          v558[9] = v581[1];
          *(_DWORD *)(v558 + 11) = 0;
          *((_QWORD *)v558 + 2) = 0LL;
          v558[15] = 0;
          v581[0] = 0LL;
          LOBYTE(v581[1]) = 0;
          v558[24] = 0;
          *((_QWORD *)v558 + 4) = *(_QWORD *)((char *)v582 + 7);
          *((_QWORD *)v558 + 5) = 0LL;
          *(_QWORD *)(v558 + 25) = v582[0];
          *(_QWORD *)((char *)v582 + 7) = 0LL;
          v582[0] = 0LL;
          v561 = *(void ***)a3;
          v560 = *(void ***)(a3 + 8);
          v562 = v558 + 48;
          if ( v560 == *(void ***)a3 )
          {
            v259 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v558 - 4) = *(v560 - 4);
              *((_OWORD *)v558 - 3) = *((_OWORD *)v560 - 3);
              v563 = (__int64)*(v560 - 1);
              *(v560 - 5) = 0LL;
              *(v560 - 4) = 0LL;
              *(v560 - 6) = 0LL;
              *((_QWORD *)v558 - 1) = v563;
              *(_OWORD *)(v558 - 24) = *(_OWORD *)(v560 - 3);
              *(v560 - 2) = 0LL;
              *(v560 - 1) = 0LL;
              *(v560 - 3) = 0LL;
              v560 -= 6;
              v558 -= 48;
            }
            while ( v561 != v560 );
            v259 = *(void ***)a3;
            v561 = *(void ***)(a3 + 8);
          }
          v260 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v558;
          *(_QWORD *)(a3 + 8) = v562;
          *(_QWORD *)(a3 + 16) = v559;
          if ( v561 != v259 )
          {
            do
            {
              if ( (*(_BYTE *)(v561 - 3) & 1) != 0 )
                free(*(v561 - 1));
              v564 = v561 - 6;
              if ( (*(_BYTE *)(v561 - 6) & 1) != 0 )
                free(*(v561 - 4));
              v561 -= 6;
            }
            while ( v259 != v564 );
          }
          goto LABEL_1062;
        case 'm':
          *(_QWORD *)((char *)v582 + 7) = 0LL;
          v582[0] = 0LL;
          qmemcpy(v581, "operator->*", 11);
          v6 = *(_QWORD *)(a3 + 8);
          v204 = *(_QWORD *)(a3 + 16);
          if ( v6 < v204 )
            goto LABEL_183;
          v237 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v6 - *(_QWORD *)a3) >> 4);
          if ( v237 + 1 > 0x555555555555555LL )
            abort();
          v238 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v204 - *(_QWORD *)a3) >> 4);
          if ( v238 >= 0x2AAAAAAAAAAAAAALL || (2 * v238 >= v237 + 1 ? (v5 = 2 * v238) : (v5 = v237 + 1), v5) )
          {
            v239 = *(_QWORD *)(a3 + 24);
            v240 = *(char **)(v239 + 4096);
            if ( v239 + 4096 - (__int64)v240 >= (unsigned __int64)(48 * v5) )
              *(_QWORD *)(v239 + 4096) = &v240[48 * v5];
            else
              v240 = (char *)malloc(48 * v5);
          }
          else
          {
            v240 = 0LL;
          }
          v537 = &v240[48 * v237];
          *v537 = 22;
          v538 = &v240[48 * v5];
          *(_QWORD *)(v537 + 1) = v581[0];
          v537[11] = BYTE2(v581[1]);
          v537[12] = 0;
          *(_WORD *)(v537 + 9) = v581[1];
          *(_WORD *)(v537 + 13) = 0;
          *((_QWORD *)v537 + 2) = 0LL;
          v537[15] = 0;
          v581[0] = 0LL;
          LOWORD(v581[1]) = 0;
          BYTE2(v581[1]) = 0;
          v537[24] = 0;
          *((_QWORD *)v537 + 4) = *(_QWORD *)((char *)v582 + 7);
          *((_QWORD *)v537 + 5) = 0LL;
          *(_QWORD *)(v537 + 25) = v582[0];
          *(_QWORD *)((char *)v582 + 7) = 0LL;
          v582[0] = 0LL;
          v540 = *(void ***)a3;
          v539 = *(void ***)(a3 + 8);
          v541 = v537 + 48;
          if ( v539 == *(void ***)a3 )
          {
            v259 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v537 - 4) = *(v539 - 4);
              *((_OWORD *)v537 - 3) = *((_OWORD *)v539 - 3);
              v542 = (__int64)*(v539 - 1);
              *(v539 - 5) = 0LL;
              *(v539 - 4) = 0LL;
              *(v539 - 6) = 0LL;
              *((_QWORD *)v537 - 1) = v542;
              *(_OWORD *)(v537 - 24) = *(_OWORD *)(v539 - 3);
              *(v539 - 2) = 0LL;
              *(v539 - 1) = 0LL;
              *(v539 - 3) = 0LL;
              v539 -= 6;
              v537 -= 48;
            }
            while ( v540 != v539 );
            v259 = *(void ***)a3;
            v540 = *(void ***)(a3 + 8);
          }
          v260 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v537;
          *(_QWORD *)(a3 + 8) = v541;
          *(_QWORD *)(a3 + 16) = v538;
          if ( v540 != v259 )
          {
            do
            {
              if ( (*(_BYTE *)(v540 - 3) & 1) != 0 )
                free(*(v540 - 1));
              v543 = v540 - 6;
              if ( (*(_BYTE *)(v540 - 6) & 1) != 0 )
                free(*(v540 - 4));
              v540 -= 6;
            }
            while ( v259 != v543 );
          }
          goto LABEL_1062;
        case 'p':
          *(_QWORD *)((char *)v582 + 7) = 0LL;
          v582[0] = 0LL;
          qmemcpy(v581, "operator++", 10);
          v6 = *(_QWORD *)(a3 + 8);
          v211 = *(_QWORD *)(a3 + 16);
          if ( v6 < v211 )
            goto LABEL_365;
          v245 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v6 - *(_QWORD *)a3) >> 4);
          if ( v245 + 1 > 0x555555555555555LL )
            abort();
          v246 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v211 - *(_QWORD *)a3) >> 4);
          if ( v246 >= 0x2AAAAAAAAAAAAAALL || (2 * v246 >= v245 + 1 ? (v5 = 2 * v246) : (v5 = v245 + 1), v5) )
          {
            v247 = *(_QWORD *)(a3 + 24);
            v248 = *(char **)(v247 + 4096);
            if ( v247 + 4096 - (__int64)v248 >= (unsigned __int64)(48 * v5) )
              *(_QWORD *)(v247 + 4096) = &v248[48 * v5];
            else
              v248 = (char *)malloc(48 * v5);
          }
          else
          {
            v248 = 0LL;
          }
          v565 = &v248[48 * v245];
          *v565 = 20;
          v566 = &v248[48 * v5];
          *(_QWORD *)(v565 + 1) = v581[0];
          v565[11] = 0;
          *((_DWORD *)v565 + 3) = 0;
          *((_QWORD *)v565 + 2) = 0LL;
          *(_WORD *)(v565 + 9) = v581[1];
          v581[0] = 0LL;
          LOWORD(v581[1]) = 0;
          v565[24] = 0;
          *((_QWORD *)v565 + 4) = *(_QWORD *)((char *)v582 + 7);
          *((_QWORD *)v565 + 5) = 0LL;
          *(_QWORD *)(v565 + 25) = v582[0];
          *(_QWORD *)((char *)v582 + 7) = 0LL;
          v582[0] = 0LL;
          v568 = *(void ***)a3;
          v567 = *(void ***)(a3 + 8);
          v569 = v565 + 48;
          if ( v567 == *(void ***)a3 )
          {
            v259 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v565 - 4) = *(v567 - 4);
              *((_OWORD *)v565 - 3) = *((_OWORD *)v567 - 3);
              v570 = (__int64)*(v567 - 1);
              *(v567 - 5) = 0LL;
              *(v567 - 4) = 0LL;
              *(v567 - 6) = 0LL;
              *((_QWORD *)v565 - 1) = v570;
              *(_OWORD *)(v565 - 24) = *(_OWORD *)(v567 - 3);
              *(v567 - 2) = 0LL;
              *(v567 - 1) = 0LL;
              *(v567 - 3) = 0LL;
              v567 -= 6;
              v565 -= 48;
            }
            while ( v568 != v567 );
            v259 = *(void ***)a3;
            v568 = *(void ***)(a3 + 8);
          }
          v260 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v565;
          *(_QWORD *)(a3 + 8) = v569;
          *(_QWORD *)(a3 + 16) = v566;
          if ( v568 != v259 )
          {
            do
            {
              if ( (*(_BYTE *)(v568 - 3) & 1) != 0 )
                free(*(v568 - 1));
              v571 = v568 - 6;
              if ( (*(_BYTE *)(v568 - 6) & 1) != 0 )
                free(*(v568 - 4));
              v568 -= 6;
            }
            while ( v259 != v571 );
          }
          goto LABEL_1062;
        case 's':
          *(_QWORD *)((char *)v582 + 7) = 0LL;
          v582[0] = 0LL;
          qmemcpy(v581, "operator+", 9);
          v6 = *(_QWORD *)(a3 + 8);
          v212 = *(_QWORD *)(a3 + 16);
          if ( v6 < v212 )
            goto LABEL_378;
          v249 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v6 - *(_QWORD *)a3) >> 4);
          if ( v249 + 1 > 0x555555555555555LL )
            abort();
          v250 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v212 - *(_QWORD *)a3) >> 4);
          if ( v250 >= 0x2AAAAAAAAAAAAAALL || (2 * v250 >= v249 + 1 ? (v5 = 2 * v250) : (v5 = v249 + 1), v5) )
          {
            v251 = *(_QWORD *)(a3 + 24);
            v252 = *(char **)(v251 + 4096);
            if ( v251 + 4096 - (__int64)v252 >= (unsigned __int64)(48 * v5) )
              *(_QWORD *)(v251 + 4096) = &v252[48 * v5];
            else
              v252 = (char *)malloc(48 * v5);
          }
          else
          {
            v252 = 0LL;
          }
          v572 = &v252[48 * v249];
          *v572 = 18;
          v573 = &v252[48 * v5];
          *(_QWORD *)(v572 + 1) = v581[0];
          v572[10] = 0;
          v572[9] = v581[1];
          *(_DWORD *)(v572 + 11) = 0;
          *((_QWORD *)v572 + 2) = 0LL;
          v572[15] = 0;
          v581[0] = 0LL;
          LOBYTE(v581[1]) = 0;
          v572[24] = 0;
          *((_QWORD *)v572 + 4) = *(_QWORD *)((char *)v582 + 7);
          *((_QWORD *)v572 + 5) = 0LL;
          *(_QWORD *)(v572 + 25) = v582[0];
          *(_QWORD *)((char *)v582 + 7) = 0LL;
          v582[0] = 0LL;
          v575 = *(void ***)a3;
          v574 = *(void ***)(a3 + 8);
          v576 = v572 + 48;
          if ( v574 == *(void ***)a3 )
          {
            v259 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v572 - 4) = *(v574 - 4);
              *((_OWORD *)v572 - 3) = *((_OWORD *)v574 - 3);
              v577 = (__int64)*(v574 - 1);
              *(v574 - 5) = 0LL;
              *(v574 - 4) = 0LL;
              *(v574 - 6) = 0LL;
              *((_QWORD *)v572 - 1) = v577;
              *(_OWORD *)(v572 - 24) = *(_OWORD *)(v574 - 3);
              *(v574 - 2) = 0LL;
              *(v574 - 1) = 0LL;
              *(v574 - 3) = 0LL;
              v574 -= 6;
              v572 -= 48;
            }
            while ( v575 != v574 );
            v259 = *(void ***)a3;
            v575 = *(void ***)(a3 + 8);
          }
          v260 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v572;
          *(_QWORD *)(a3 + 8) = v576;
          *(_QWORD *)(a3 + 16) = v573;
          if ( v575 != v259 )
          {
            do
            {
              if ( (*(_BYTE *)(v575 - 3) & 1) != 0 )
                free(*(v575 - 1));
              v578 = v575 - 6;
              if ( (*(_BYTE *)(v575 - 6) & 1) != 0 )
                free(*(v575 - 4));
              v575 -= 6;
            }
            while ( v259 != v578 );
          }
          goto LABEL_1062;
        case 't':
          *(_QWORD *)((char *)v582 + 7) = 0LL;
          v582[0] = 0LL;
          qmemcpy(v581, "operator->", 10);
          v6 = *(_QWORD *)(a3 + 8);
          v205 = *(_QWORD *)(a3 + 16);
          if ( v6 < v205 )
            goto LABEL_365;
          v241 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v6 - *(_QWORD *)a3) >> 4);
          if ( v241 + 1 > 0x555555555555555LL )
            abort();
          v242 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v205 - *(_QWORD *)a3) >> 4);
          if ( v242 >= 0x2AAAAAAAAAAAAAALL || (2 * v242 >= v241 + 1 ? (v5 = 2 * v242) : (v5 = v241 + 1), v5) )
          {
            v243 = *(_QWORD *)(a3 + 24);
            v244 = *(char **)(v243 + 4096);
            if ( v243 + 4096 - (__int64)v244 >= (unsigned __int64)(48 * v5) )
              *(_QWORD *)(v243 + 4096) = &v244[48 * v5];
            else
              v244 = (char *)malloc(48 * v5);
          }
          else
          {
            v244 = 0LL;
          }
          v544 = &v244[48 * v241];
          *v544 = 20;
          v545 = &v244[48 * v5];
          *(_QWORD *)(v544 + 1) = v581[0];
          v544[11] = 0;
          *((_DWORD *)v544 + 3) = 0;
          *((_QWORD *)v544 + 2) = 0LL;
          *(_WORD *)(v544 + 9) = v581[1];
          v581[0] = 0LL;
          LOWORD(v581[1]) = 0;
          v544[24] = 0;
          *((_QWORD *)v544 + 4) = *(_QWORD *)((char *)v582 + 7);
          *((_QWORD *)v544 + 5) = 0LL;
          *(_QWORD *)(v544 + 25) = v582[0];
          *(_QWORD *)((char *)v582 + 7) = 0LL;
          v582[0] = 0LL;
          v547 = *(void ***)a3;
          v546 = *(void ***)(a3 + 8);
          v548 = v544 + 48;
          if ( v546 == *(void ***)a3 )
          {
            v259 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v544 - 4) = *(v546 - 4);
              *((_OWORD *)v544 - 3) = *((_OWORD *)v546 - 3);
              v549 = (__int64)*(v546 - 1);
              *(v546 - 5) = 0LL;
              *(v546 - 4) = 0LL;
              *(v546 - 6) = 0LL;
              *((_QWORD *)v544 - 1) = v549;
              *(_OWORD *)(v544 - 24) = *(_OWORD *)(v546 - 3);
              *(v546 - 2) = 0LL;
              *(v546 - 1) = 0LL;
              *(v546 - 3) = 0LL;
              v546 -= 6;
              v544 -= 48;
            }
            while ( v547 != v546 );
            v259 = *(void ***)a3;
            v547 = *(void ***)(a3 + 8);
          }
          v260 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v544;
          *(_QWORD *)(a3 + 8) = v548;
          *(_QWORD *)(a3 + 16) = v545;
          if ( v547 != v259 )
          {
            do
            {
              if ( (*(_BYTE *)(v547 - 3) & 1) != 0 )
                free(*(v547 - 1));
              v550 = v547 - 6;
              if ( (*(_BYTE *)(v547 - 6) & 1) != 0 )
                free(*(v547 - 4));
              v547 -= 6;
            }
            while ( v259 != v550 );
          }
          goto LABEL_1062;
        default:
          return (__int64)v3;
      }
      return (__int64)v3;
    case 'q':
      if ( a1[1] != 117 )
        return (__int64)v3;
      *(_QWORD *)((char *)v582 + 7) = 0LL;
      v582[0] = 0LL;
      qmemcpy(v581, "operator?", 9);
      v6 = *(_QWORD *)(a3 + 8);
      v39 = *(_QWORD *)(a3 + 16);
      if ( v6 < v39 )
        goto LABEL_378;
      v40 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v6 - *(_QWORD *)a3) >> 4);
      if ( v40 + 1 > 0x555555555555555LL )
        abort();
      v41 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v39 - *(_QWORD *)a3) >> 4);
      if ( v41 >= 0x2AAAAAAAAAAAAAALL || (2 * v41 >= v40 + 1 ? (v5 = 2 * v41) : (v5 = v40 + 1), v5) )
      {
        v42 = *(_QWORD *)(a3 + 24);
        v43 = *(char **)(v42 + 4096);
        if ( v42 + 4096 - (__int64)v43 >= (unsigned __int64)(48 * v5) )
          *(_QWORD *)(v42 + 4096) = &v43[48 * v5];
        else
          v43 = (char *)malloc(48 * v5);
      }
      else
      {
        v43 = 0LL;
      }
      v262 = &v43[48 * v40];
      *v262 = 18;
      v263 = &v43[48 * v5];
      *(_QWORD *)(v262 + 1) = v581[0];
      v262[10] = 0;
      v262[9] = v581[1];
      *(_DWORD *)(v262 + 11) = 0;
      *((_QWORD *)v262 + 2) = 0LL;
      v262[15] = 0;
      v581[0] = 0LL;
      LOBYTE(v581[1]) = 0;
      v262[24] = 0;
      *((_QWORD *)v262 + 4) = *(_QWORD *)((char *)v582 + 7);
      *((_QWORD *)v262 + 5) = 0LL;
      *(_QWORD *)(v262 + 25) = v582[0];
      *(_QWORD *)((char *)v582 + 7) = 0LL;
      v582[0] = 0LL;
      v265 = *(void ***)a3;
      v264 = *(void ***)(a3 + 8);
      v266 = v262 + 48;
      if ( v264 == *(void ***)a3 )
      {
        v259 = *(void ***)a3;
      }
      else
      {
        do
        {
          *((_QWORD *)v262 - 4) = *(v264 - 4);
          *((_OWORD *)v262 - 3) = *((_OWORD *)v264 - 3);
          v267 = (__int64)*(v264 - 1);
          *(v264 - 5) = 0LL;
          *(v264 - 4) = 0LL;
          *(v264 - 6) = 0LL;
          *((_QWORD *)v262 - 1) = v267;
          *(_OWORD *)(v262 - 24) = *(_OWORD *)(v264 - 3);
          *(v264 - 2) = 0LL;
          *(v264 - 1) = 0LL;
          *(v264 - 3) = 0LL;
          v264 -= 6;
          v262 -= 48;
        }
        while ( v265 != v264 );
        v259 = *(void ***)a3;
        v265 = *(void ***)(a3 + 8);
      }
      v268 = *(_QWORD *)(a3 + 16);
      *(_QWORD *)a3 = v262;
      *(_QWORD *)(a3 + 8) = v266;
      *(_QWORD *)(a3 + 16) = v263;
      if ( v265 != v259 )
      {
        do
        {
          if ( (*(_BYTE *)(v265 - 3) & 1) != 0 )
            free(*(v265 - 1));
          v269 = v265 - 6;
          if ( (*(_BYTE *)(v265 - 6) & 1) != 0 )
            free(*(v265 - 4));
          v265 -= 6;
        }
        while ( v259 != v269 );
      }
LABEL_698:
      if ( !v259 )
        goto LABEL_1068;
      v368 = *(_QWORD *)(a3 + 24);
      if ( v368 + 4096 < (unsigned __int64)v259 || v368 > (unsigned __int64)v259 )
        goto LABEL_1067;
      if ( *(_QWORD *)(v368 + 4096) != v268 )
        goto LABEL_1068;
      *(_QWORD *)(v368 + 4096) = v259;
      v3 += 2;
      return (__int64)v3;
    case 'r':
      switch ( a1[1] )
      {
        case 'M':
          *(_QWORD *)((char *)v582 + 7) = 0LL;
          v582[0] = 0LL;
          qmemcpy(v581, "operator%=", 10);
          v6 = *(_QWORD *)(a3 + 8);
          v29 = *(_QWORD *)(a3 + 16);
          if ( v6 < v29 )
            goto LABEL_365;
          v30 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v6 - *(_QWORD *)a3) >> 4);
          if ( v30 + 1 > 0x555555555555555LL )
            abort();
          v31 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v29 - *(_QWORD *)a3) >> 4);
          if ( v31 >= 0x2AAAAAAAAAAAAAALL || (2 * v31 >= v30 + 1 ? (v5 = 2 * v31) : (v5 = v30 + 1), v5) )
          {
            v32 = *(_QWORD *)(a3 + 24);
            v33 = *(char **)(v32 + 4096);
            if ( v32 + 4096 - (__int64)v33 >= (unsigned __int64)(48 * v5) )
              *(_QWORD *)(v32 + 4096) = &v33[48 * v5];
            else
              v33 = (char *)malloc(48 * v5);
          }
          else
          {
            v33 = 0LL;
          }
          v340 = &v33[48 * v30];
          *v340 = 20;
          v341 = &v33[48 * v5];
          *(_QWORD *)(v340 + 1) = v581[0];
          v340[11] = 0;
          *((_DWORD *)v340 + 3) = 0;
          *((_QWORD *)v340 + 2) = 0LL;
          *(_WORD *)(v340 + 9) = v581[1];
          v581[0] = 0LL;
          LOWORD(v581[1]) = 0;
          v340[24] = 0;
          *((_QWORD *)v340 + 4) = *(_QWORD *)((char *)v582 + 7);
          *((_QWORD *)v340 + 5) = 0LL;
          *(_QWORD *)(v340 + 25) = v582[0];
          *(_QWORD *)((char *)v582 + 7) = 0LL;
          v582[0] = 0LL;
          v343 = *(void ***)a3;
          v342 = *(void ***)(a3 + 8);
          v344 = v340 + 48;
          if ( v342 == *(void ***)a3 )
          {
            v259 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v340 - 4) = *(v342 - 4);
              *((_OWORD *)v340 - 3) = *((_OWORD *)v342 - 3);
              v345 = (__int64)*(v342 - 1);
              *(v342 - 5) = 0LL;
              *(v342 - 4) = 0LL;
              *(v342 - 6) = 0LL;
              *((_QWORD *)v340 - 1) = v345;
              *(_OWORD *)(v340 - 24) = *(_OWORD *)(v342 - 3);
              *(v342 - 2) = 0LL;
              *(v342 - 1) = 0LL;
              *(v342 - 3) = 0LL;
              v342 -= 6;
              v340 -= 48;
            }
            while ( v343 != v342 );
            v259 = *(void ***)a3;
            v343 = *(void ***)(a3 + 8);
          }
          v268 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v340;
          *(_QWORD *)(a3 + 8) = v344;
          *(_QWORD *)(a3 + 16) = v341;
          if ( v343 != v259 )
          {
            do
            {
              if ( (*(_BYTE *)(v343 - 3) & 1) != 0 )
                free(*(v343 - 1));
              v346 = v343 - 6;
              if ( (*(_BYTE *)(v343 - 6) & 1) != 0 )
                free(*(v343 - 4));
              v343 -= 6;
            }
            while ( v259 != v346 );
          }
          goto LABEL_698;
        case 'S':
          *(_QWORD *)((char *)v582 + 7) = 0LL;
          v582[0] = 0LL;
          qmemcpy(v581, "operator>>=", 11);
          v6 = *(_QWORD *)(a3 + 8);
          v103 = *(_QWORD *)(a3 + 16);
          if ( v6 < v103 )
          {
LABEL_183:
            *(_BYTE *)v6 = 22;
            v3 = a1 + 2;
            *(_QWORD *)(v6 + 1) = v581[0];
            *(_BYTE *)(v6 + 11) = BYTE2(v581[1]);
            *(_BYTE *)(v6 + 12) = 0;
            *(_WORD *)(v6 + 9) = v581[1];
            *(_WORD *)(v6 + 13) = 0;
            *(_QWORD *)(v6 + 16) = 0LL;
            *(_BYTE *)(v6 + 15) = 0;
            v581[0] = 0LL;
            LOWORD(v581[1]) = 0;
            BYTE2(v581[1]) = 0;
            goto LABEL_379;
          }
          v217 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v6 - *(_QWORD *)a3) >> 4);
          if ( v217 + 1 > 0x555555555555555LL )
            abort();
          v218 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v103 - *(_QWORD *)a3) >> 4);
          if ( v218 >= 0x2AAAAAAAAAAAAAALL || (2 * v218 >= v217 + 1 ? (v5 = 2 * v218) : (v5 = v217 + 1), v5) )
          {
            v219 = *(_QWORD *)(a3 + 24);
            v220 = *(char **)(v219 + 4096);
            if ( v219 + 4096 - (__int64)v220 >= (unsigned __int64)(48 * v5) )
              *(_QWORD *)(v219 + 4096) = &v220[48 * v5];
            else
              v220 = (char *)malloc(48 * v5);
          }
          else
          {
            v220 = 0LL;
          }
          v347 = &v220[48 * v217];
          *v347 = 22;
          v348 = &v220[48 * v5];
          *(_QWORD *)(v347 + 1) = v581[0];
          v347[11] = BYTE2(v581[1]);
          v347[12] = 0;
          *(_WORD *)(v347 + 9) = v581[1];
          *(_WORD *)(v347 + 13) = 0;
          *((_QWORD *)v347 + 2) = 0LL;
          v347[15] = 0;
          v581[0] = 0LL;
          LOWORD(v581[1]) = 0;
          BYTE2(v581[1]) = 0;
          v347[24] = 0;
          *((_QWORD *)v347 + 4) = *(_QWORD *)((char *)v582 + 7);
          *((_QWORD *)v347 + 5) = 0LL;
          *(_QWORD *)(v347 + 25) = v582[0];
          *(_QWORD *)((char *)v582 + 7) = 0LL;
          v582[0] = 0LL;
          v350 = *(void ***)a3;
          v349 = *(void ***)(a3 + 8);
          v351 = v347 + 48;
          if ( v349 == *(void ***)a3 )
          {
            v259 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v347 - 4) = *(v349 - 4);
              *((_OWORD *)v347 - 3) = *((_OWORD *)v349 - 3);
              v352 = (__int64)*(v349 - 1);
              *(v349 - 5) = 0LL;
              *(v349 - 4) = 0LL;
              *(v349 - 6) = 0LL;
              *((_QWORD *)v347 - 1) = v352;
              *(_OWORD *)(v347 - 24) = *(_OWORD *)(v349 - 3);
              *(v349 - 2) = 0LL;
              *(v349 - 1) = 0LL;
              *(v349 - 3) = 0LL;
              v349 -= 6;
              v347 -= 48;
            }
            while ( v350 != v349 );
            v259 = *(void ***)a3;
            v350 = *(void ***)(a3 + 8);
          }
          v268 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v347;
          *(_QWORD *)(a3 + 8) = v351;
          *(_QWORD *)(a3 + 16) = v348;
          if ( v350 != v259 )
          {
            do
            {
              if ( (*(_BYTE *)(v350 - 3) & 1) != 0 )
                free(*(v350 - 1));
              v353 = v350 - 6;
              if ( (*(_BYTE *)(v350 - 6) & 1) != 0 )
                free(*(v350 - 4));
              v350 -= 6;
            }
            while ( v259 != v353 );
          }
          break;
        case 'm':
          *(_QWORD *)((char *)v582 + 7) = 0LL;
          v582[0] = 0LL;
          qmemcpy(v581, "operator%", 9);
          v6 = *(_QWORD *)(a3 + 8);
          v102 = *(_QWORD *)(a3 + 16);
          if ( v6 < v102 )
            goto LABEL_378;
          v213 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v6 - *(_QWORD *)a3) >> 4);
          if ( v213 + 1 > 0x555555555555555LL )
            abort();
          v214 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v102 - *(_QWORD *)a3) >> 4);
          if ( v214 >= 0x2AAAAAAAAAAAAAALL || (2 * v214 >= v213 + 1 ? (v5 = 2 * v214) : (v5 = v213 + 1), v5) )
          {
            v215 = *(_QWORD *)(a3 + 24);
            v216 = *(char **)(v215 + 4096);
            if ( v215 + 4096 - (__int64)v216 >= (unsigned __int64)(48 * v5) )
              *(_QWORD *)(v215 + 4096) = &v216[48 * v5];
            else
              v216 = (char *)malloc(48 * v5);
          }
          else
          {
            v216 = 0LL;
          }
          v333 = &v216[48 * v213];
          *v333 = 18;
          v334 = &v216[48 * v5];
          *(_QWORD *)(v333 + 1) = v581[0];
          v333[10] = 0;
          v333[9] = v581[1];
          *(_DWORD *)(v333 + 11) = 0;
          *((_QWORD *)v333 + 2) = 0LL;
          v333[15] = 0;
          v581[0] = 0LL;
          LOBYTE(v581[1]) = 0;
          v333[24] = 0;
          *((_QWORD *)v333 + 4) = *(_QWORD *)((char *)v582 + 7);
          *((_QWORD *)v333 + 5) = 0LL;
          *(_QWORD *)(v333 + 25) = v582[0];
          *(_QWORD *)((char *)v582 + 7) = 0LL;
          v582[0] = 0LL;
          v336 = *(void ***)a3;
          v335 = *(void ***)(a3 + 8);
          v337 = v333 + 48;
          if ( v335 == *(void ***)a3 )
          {
            v259 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v333 - 4) = *(v335 - 4);
              *((_OWORD *)v333 - 3) = *((_OWORD *)v335 - 3);
              v338 = (__int64)*(v335 - 1);
              *(v335 - 5) = 0LL;
              *(v335 - 4) = 0LL;
              *(v335 - 6) = 0LL;
              *((_QWORD *)v333 - 1) = v338;
              *(_OWORD *)(v333 - 24) = *(_OWORD *)(v335 - 3);
              *(v335 - 2) = 0LL;
              *(v335 - 1) = 0LL;
              *(v335 - 3) = 0LL;
              v335 -= 6;
              v333 -= 48;
            }
            while ( v336 != v335 );
            v259 = *(void ***)a3;
            v336 = *(void ***)(a3 + 8);
          }
          v268 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v333;
          *(_QWORD *)(a3 + 8) = v337;
          *(_QWORD *)(a3 + 16) = v334;
          if ( v336 != v259 )
          {
            do
            {
              if ( (*(_BYTE *)(v336 - 3) & 1) != 0 )
                free(*(v336 - 1));
              v339 = v336 - 6;
              if ( (*(_BYTE *)(v336 - 6) & 1) != 0 )
                free(*(v336 - 4));
              v336 -= 6;
            }
            while ( v259 != v339 );
          }
          goto LABEL_698;
        case 's':
          *(_QWORD *)((char *)v582 + 7) = 0LL;
          v582[0] = 0LL;
          qmemcpy(v581, "operator>>", 10);
          v6 = *(_QWORD *)(a3 + 8);
          v109 = *(_QWORD *)(a3 + 16);
          if ( v6 < v109 )
            goto LABEL_365;
          v110 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v6 - *(_QWORD *)a3) >> 4);
          if ( v110 + 1 > 0x555555555555555LL )
            abort();
          v111 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v109 - *(_QWORD *)a3) >> 4);
          if ( v111 >= 0x2AAAAAAAAAAAAAALL || (2 * v111 >= v110 + 1 ? (v5 = 2 * v111) : (v5 = v110 + 1), v5) )
          {
            v112 = *(_QWORD *)(a3 + 24);
            v113 = *(char **)(v112 + 4096);
            if ( v112 + 4096 - (__int64)v113 >= (unsigned __int64)(48 * v5) )
              *(_QWORD *)(v112 + 4096) = &v113[48 * v5];
            else
              v113 = (char *)malloc(48 * v5);
          }
          else
          {
            v113 = 0LL;
          }
          v361 = &v113[48 * v110];
          *v361 = 20;
          v362 = &v113[48 * v5];
          *(_QWORD *)(v361 + 1) = v581[0];
          v361[11] = 0;
          *((_DWORD *)v361 + 3) = 0;
          *((_QWORD *)v361 + 2) = 0LL;
          *(_WORD *)(v361 + 9) = v581[1];
          v581[0] = 0LL;
          LOWORD(v581[1]) = 0;
          v361[24] = 0;
          *((_QWORD *)v361 + 4) = *(_QWORD *)((char *)v582 + 7);
          *((_QWORD *)v361 + 5) = 0LL;
          *(_QWORD *)(v361 + 25) = v582[0];
          *(_QWORD *)((char *)v582 + 7) = 0LL;
          v582[0] = 0LL;
          v364 = *(void ***)a3;
          v363 = *(void ***)(a3 + 8);
          v365 = v361 + 48;
          if ( v363 == *(void ***)a3 )
          {
            v259 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v361 - 4) = *(v363 - 4);
              *((_OWORD *)v361 - 3) = *((_OWORD *)v363 - 3);
              v366 = (__int64)*(v363 - 1);
              *(v363 - 5) = 0LL;
              *(v363 - 4) = 0LL;
              *(v363 - 6) = 0LL;
              *((_QWORD *)v361 - 1) = v366;
              *(_OWORD *)(v361 - 24) = *(_OWORD *)(v363 - 3);
              *(v363 - 2) = 0LL;
              *(v363 - 1) = 0LL;
              *(v363 - 3) = 0LL;
              v363 -= 6;
              v361 -= 48;
            }
            while ( v364 != v363 );
            v259 = *(void ***)a3;
            v364 = *(void ***)(a3 + 8);
          }
          v268 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v361;
          *(_QWORD *)(a3 + 8) = v365;
          *(_QWORD *)(a3 + 16) = v362;
          if ( v364 != v259 )
          {
            do
            {
              if ( (*(_BYTE *)(v364 - 3) & 1) != 0 )
                free(*(v364 - 1));
              v367 = v364 - 6;
              if ( (*(_BYTE *)(v364 - 6) & 1) != 0 )
                free(*(v364 - 4));
              v364 -= 6;
            }
            while ( v259 != v367 );
          }
          goto LABEL_698;
        default:
          return (__int64)v3;
      }
      goto LABEL_698;
    case 'v':
      if ( (unsigned int)(unsigned __int8)a1[1] - 48 > 9 )
        return (__int64)v3;
      v12 = a1 + 2;
      v13 = sub_B190C(a1 + 2, a2, a3);
      if ( (_BYTE *)v13 == v12 )
        return (__int64)v3;
      v14 = *(_QWORD *)(a3 + 8);
      if ( *(_QWORD *)a3 == v14 )
        return (__int64)v3;
      v15 = (size_t *)(v14 - 48);
      v16 = "operator ";
      v17 = 9LL;
LABEL_226:
      sub_9CDD8(v15, 0LL, v16, v17);
      return v13;
    default:
      return (__int64)v3;
  }
}
// 925FC: using guessed type __int64 __fastcall sub_925FC(_QWORD, _QWORD, _QWORD);
// B190C: using guessed type __int64 __fastcall sub_B190C(_QWORD, _QWORD, _QWORD);

//----- (00000000000B1788) ----------------------------------------------------
_BYTE *__fastcall sub_B1788(_BYTE *a1, _BYTE *a2, _QWORD *a3)
{
  _BYTE *v6; // x0
  _BYTE *v7; // x22
  _BYTE *v8; // x19
  __int64 v9; // x24
  unsigned __int64 v10; // x8
  bool v11; // zf
  size_t v12; // x8
  void *v13; // x1
  size_t v14; // x2
  __int64 v15; // x21
  _BYTE *v16; // x22
  void *v17; // x20
  char *v18; // x1
  size_t v19; // x2
  __int128 v21; // [xsp+0h] [xbp-50h] BYREF
  char *v22; // [xsp+10h] [xbp-40h]
  __int64 v23; // [xsp+18h] [xbp-38h]

  v23 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a1 == a2 )
    return a1;
  v6 = (_BYTE *)sub_B190C(a1, a2, a3);
  v7 = v6;
  if ( v6 == a1 )
    return a1;
  v8 = sub_9D3DC(v6, a2, (__int64)a3);
  if ( v8 != v7 )
  {
    v9 = a3[1];
    v7 = a1;
    if ( 0xAAAAAAAAAAAAAAABLL * ((v9 - *a3) >> 4) >= 2 )
    {
      v10 = *(unsigned __int8 *)(v9 - 24);
      v11 = (v10 & 1) == 0;
      v12 = v10 >> 1;
      if ( v11 )
        v13 = (void *)(v9 - 23);
      else
        v13 = *(void **)(v9 - 8);
      if ( v11 )
        v14 = v12;
      else
        v14 = *(_QWORD *)(v9 - 16);
      sub_9CFD0((size_t *)(v9 - 48), v13, v14);
      v22 = *(char **)(v9 - 32);
      v21 = *(_OWORD *)(v9 - 48);
      *(_QWORD *)(v9 - 40) = 0LL;
      *(_QWORD *)(v9 - 32) = 0LL;
      *(_QWORD *)(v9 - 48) = 0LL;
      v15 = a3[1];
      v16 = (_BYTE *)(v15 - 48);
      if ( (*(_BYTE *)(v15 - 24) & 1) != 0 )
        free(*(void **)(v15 - 8));
      if ( (*v16 & 1) != 0 )
        free(*(void **)(v15 - 32));
      a3[1] = v16;
      v17 = v22;
      if ( (v21 & 1) != 0 )
        v18 = v22;
      else
        v18 = (char *)&v21 + 1;
      if ( (v21 & 1) != 0 )
        v19 = *((_QWORD *)&v21 + 1);
      else
        v19 = (unsigned __int64)(unsigned __int8)v21 >> 1;
      sub_9CFD0((size_t *)(v15 - 96), v18, v19);
      if ( (v21 & 1) != 0 )
        free(v17);
      return v8;
    }
  }
  return v7;
}
// B190C: using guessed type __int64 __fastcall sub_B190C(_QWORD, _QWORD, _QWORD);

//----- (00000000000B190C) ----------------------------------------------------
unsigned __int8 *__fastcall sub_B190C(unsigned __int8 *a1, unsigned __int8 *a2, void **a3)
{
  unsigned __int8 *v3; // x22
  __int64 v5; // x8
  size_t v6; // x19
  unsigned __int8 *v7; // x20
  int v8; // w8
  unsigned __int8 *v9; // x9
  int v10; // t1
  char *v11; // x23
  char *v12; // x22
  unsigned __int64 v13; // x8
  size_t v14; // x22
  char v15; // w22
  unsigned __int64 v16; // x8
  _BOOL4 v17; // w24
  char *v18; // x0
  __int64 v19; // x23
  char *v20; // x9
  char *v21; // x10
  __int64 v22; // x9
  void *v23; // x22
  __int64 v24; // x10
  char v25; // w24
  __int64 v26; // x9
  char *v27; // x9
  char *v28; // x10
  unsigned __int64 v29; // x24
  unsigned __int64 v30; // x10
  _QWORD *v31; // x9
  char *v32; // x0
  unsigned __int64 v33; // x26
  unsigned __int64 v34; // x10
  _QWORD *v35; // x9
  char *v36; // x0
  char *v37; // x8
  char *v38; // x9
  void **v39; // x11
  void **v40; // x24
  char *v41; // x10
  __int64 v42; // x12
  void **v43; // x22
  void *v44; // x23
  void **v45; // x26
  unsigned __int64 v46; // x8
  char *v47; // x8
  char *v48; // x9
  void **v49; // x11
  void **v50; // x24
  char *v51; // x10
  __int64 v52; // x12
  void **v53; // x22
  void *v54; // x23
  void **v55; // x26
  unsigned __int64 v56; // x8
  __int128 v58; // [xsp+8h] [xbp-98h] BYREF
  void *v59; // [xsp+18h] [xbp-88h]
  _BYTE v60[15]; // [xsp+20h] [xbp-80h] BYREF
  _QWORD v61[2]; // [xsp+30h] [xbp-70h] BYREF
  __int128 v62; // [xsp+40h] [xbp-60h] BYREF
  void *p; // [xsp+50h] [xbp-50h]
  __int64 v64; // [xsp+58h] [xbp-48h]

  v3 = a1;
  v64 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a1 == a2 )
    return v3;
  v5 = *a1;
  v6 = v5 - 48;
  if ( (unsigned int)(v5 - 48) > 9 )
    return v3;
  v7 = a1 + 1;
  if ( a1 + 1 == a2 )
    return v3;
  v8 = *v7 - 48;
  if ( (unsigned int)v8 > 9 )
  {
LABEL_9:
    if ( a2 - v7 < v6 )
      return v3;
    v59 = 0LL;
    v58 = 0uLL;
    if ( v6 >= 0xFFFFFFFFFFFFFFF0LL )
      abort();
    if ( v6 >= 0x17 )
    {
      v12 = (char *)malloc((v6 + 16) & 0xFFFFFFFFFFFFFFF0LL);
      *((_QWORD *)&v58 + 1) = v6;
      v59 = v12;
      *(_QWORD *)&v58 = (v6 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
      v11 = (char *)&v58 + 1;
    }
    else
    {
      v11 = (char *)&v58 + 1;
      v12 = (char *)&v58 + 1;
      LOBYTE(v58) = 2 * v6;
      if ( !v6 )
        goto LABEL_16;
    }
    memcpy(v12, v7, v6);
LABEL_16:
    v12[v6] = 0;
    v13 = *((_QWORD *)&v58 + 1);
    p = 0LL;
    v62 = 0uLL;
    if ( (v58 & 1) != 0 )
      v11 = (char *)v59;
    else
      v13 = (unsigned __int64)(unsigned __int8)v58 >> 1;
    if ( v13 >= 0xA )
      v14 = 10LL;
    else
      v14 = v13;
    LOBYTE(v62) = 2 * v14;
    if ( v14 )
      memcpy((char *)&v62 + 1, v11, v14);
    *((_BYTE *)&v62 + v14 + 1) = 0;
    v15 = v62;
    v16 = *((_QWORD *)&v62 + 1);
    v17 = 0;
    if ( (v62 & 1) == 0 )
      v16 = (unsigned __int64)(unsigned __int8)v62 >> 1;
    if ( v16 == 10 )
    {
      if ( (v62 & 1) != 0 )
        v18 = (char *)p;
      else
        v18 = (char *)&v62 + 1;
      v17 = memcmp(v18, "_GLOBAL__N", 0xAuLL) == 0;
    }
    if ( (v15 & 1) != 0 )
      free(p);
    v19 = 0x555555555555555LL;
    if ( v17 )
    {
      memset(v61, 0, 15);
      qmemcpy(&v62, "(anonymous name", 15);
      v20 = (char *)a3[1];
      v21 = (char *)a3[2];
      if ( v20 >= v21 )
      {
        v29 = 0xAAAAAAAAAAAAAAABLL * ((v20 - (_BYTE *)*a3) >> 4);
        if ( v29 + 1 > 0x555555555555555LL )
          abort();
        v30 = 0xAAAAAAAAAAAAAAABLL * ((v21 - (_BYTE *)*a3) >> 4);
        if ( v30 >= 0x2AAAAAAAAAAAAAALL || (2 * v30 >= v29 + 1 ? (v19 = 2 * v30) : (v19 = v29 + 1), v19) )
        {
          v31 = a3[3];
          v32 = (char *)v31[512];
          if ( (char *)(v31 + 512) - v32 >= (unsigned __int64)(48 * v19) )
            v31[512] = &v32[48 * v19];
          else
            v32 = (char *)malloc(48 * v19);
        }
        else
        {
          v32 = 0LL;
        }
        v37 = &v32[48 * v29];
        *v37 = 42;
        v38 = &v32[48 * v19];
        *((_QWORD *)v37 + 1) = *(_QWORD *)((char *)&v62 + 7);
        *((_QWORD *)v37 + 2) = 0x296563617073LL;
        *(_QWORD *)(v37 + 1) = v62;
        *(_QWORD *)((char *)&v62 + 7) = 0LL;
        *(_QWORD *)&v62 = 0LL;
        v37[24] = 0;
        *((_QWORD *)v37 + 4) = *(_QWORD *)((char *)v61 + 7);
        *((_QWORD *)v37 + 5) = 0LL;
        *(_QWORD *)(v37 + 25) = v61[0];
        memset(v61, 0, 15);
        v40 = (void **)*a3;
        v39 = (void **)a3[1];
        v41 = v37 + 48;
        if ( v39 == *a3 )
        {
          v43 = (void **)*a3;
        }
        else
        {
          do
          {
            *((_QWORD *)v37 - 4) = *(v39 - 4);
            *((_OWORD *)v37 - 3) = *((_OWORD *)v39 - 3);
            v42 = (__int64)*(v39 - 1);
            *(v39 - 5) = 0LL;
            *(v39 - 4) = 0LL;
            *(v39 - 6) = 0LL;
            *((_QWORD *)v37 - 1) = v42;
            *(_OWORD *)(v37 - 24) = *(_OWORD *)(v39 - 3);
            *(v39 - 2) = 0LL;
            *(v39 - 1) = 0LL;
            *(v39 - 3) = 0LL;
            v39 -= 6;
            v37 -= 48;
          }
          while ( v40 != v39 );
          v43 = (void **)*a3;
          v40 = (void **)a3[1];
        }
        v44 = a3[2];
        *a3 = v37;
        a3[1] = v41;
        a3[2] = v38;
        if ( v40 != v43 )
        {
          do
          {
            if ( (*(_BYTE *)(v40 - 3) & 1) != 0 )
              free(*(v40 - 1));
            v45 = v40 - 6;
            if ( (*(_BYTE *)(v40 - 6) & 1) != 0 )
              free(*(v40 - 4));
            v40 -= 6;
          }
          while ( v43 != v45 );
        }
        if ( v43 )
        {
          v46 = (unsigned __int64)a3[3];
          if ( v46 + 4096 < (unsigned __int64)v43 || v46 > (unsigned __int64)v43 )
          {
            free(v43);
          }
          else if ( *(void **)(v46 + 4096) == v44 )
          {
            *(_QWORD *)(v46 + 4096) = v43;
          }
        }
      }
      else
      {
        *v20 = 42;
        *((_QWORD *)v20 + 1) = *(_QWORD *)((char *)&v62 + 7);
        *((_QWORD *)v20 + 2) = 0x296563617073LL;
        *(_QWORD *)(v20 + 1) = v62;
        *(_QWORD *)((char *)&v62 + 7) = 0LL;
        *(_QWORD *)&v62 = 0LL;
        v20[24] = 0;
        *((_QWORD *)v20 + 4) = *(_QWORD *)((char *)v61 + 7);
        *((_QWORD *)v20 + 5) = 0LL;
        *(_QWORD *)(v20 + 25) = v61[0];
        memset(v61, 0, 15);
        a3[1] = (char *)a3[1] + 48;
      }
      v3 = &v7[v6];
      if ( (v58 & 1) != 0 )
        free(v59);
    }
    else
    {
      v22 = *((_QWORD *)&v58 + 1);
      v23 = v59;
      v24 = *(_QWORD *)((char *)&v58 + 1);
      v25 = v58;
      v58 = 0uLL;
      *(_QWORD *)&v60[7] = v22;
      v59 = 0LL;
      v60[7] = HIBYTE(v24);
      v26 = *(_QWORD *)&v60[7];
      memset(v61, 0, 15);
      memset(v60, 0, sizeof(v60));
      *(_QWORD *)((char *)&v62 + 7) = v26;
      *(_QWORD *)&v62 = v24;
      v27 = (char *)a3[1];
      v28 = (char *)a3[2];
      if ( v27 >= v28 )
      {
        v33 = 0xAAAAAAAAAAAAAAABLL * ((v27 - (_BYTE *)*a3) >> 4);
        if ( v33 + 1 > 0x555555555555555LL )
          abort();
        v34 = 0xAAAAAAAAAAAAAAABLL * ((v28 - (_BYTE *)*a3) >> 4);
        if ( v34 >= 0x2AAAAAAAAAAAAAALL || (2 * v34 >= v33 + 1 ? (v19 = 2 * v34) : (v19 = v33 + 1), v19) )
        {
          v35 = a3[3];
          v36 = (char *)v35[512];
          if ( (char *)(v35 + 512) - v36 >= (unsigned __int64)(48 * v19) )
            v35[512] = &v36[48 * v19];
          else
            v36 = (char *)malloc(48 * v19);
        }
        else
        {
          v36 = 0LL;
        }
        v47 = &v36[48 * v33];
        *v47 = v25;
        v48 = &v36[48 * v19];
        *((_QWORD *)v47 + 1) = *(_QWORD *)((char *)&v62 + 7);
        *((_QWORD *)v47 + 2) = v23;
        *(_QWORD *)(v47 + 1) = v62;
        *(_QWORD *)((char *)&v62 + 7) = 0LL;
        *(_QWORD *)&v62 = 0LL;
        v47[24] = 0;
        *((_QWORD *)v47 + 4) = *(_QWORD *)((char *)v61 + 7);
        *((_QWORD *)v47 + 5) = 0LL;
        *(_QWORD *)(v47 + 25) = v61[0];
        memset(v61, 0, 15);
        v50 = (void **)*a3;
        v49 = (void **)a3[1];
        v51 = v47 + 48;
        if ( v49 == *a3 )
        {
          v53 = (void **)*a3;
        }
        else
        {
          do
          {
            *((_QWORD *)v47 - 4) = *(v49 - 4);
            *((_OWORD *)v47 - 3) = *((_OWORD *)v49 - 3);
            v52 = (__int64)*(v49 - 1);
            *(v49 - 5) = 0LL;
            *(v49 - 4) = 0LL;
            *(v49 - 6) = 0LL;
            *((_QWORD *)v47 - 1) = v52;
            *(_OWORD *)(v47 - 24) = *(_OWORD *)(v49 - 3);
            *(v49 - 2) = 0LL;
            *(v49 - 1) = 0LL;
            *(v49 - 3) = 0LL;
            v49 -= 6;
            v47 -= 48;
          }
          while ( v50 != v49 );
          v53 = (void **)*a3;
          v50 = (void **)a3[1];
        }
        v54 = a3[2];
        *a3 = v47;
        a3[1] = v51;
        a3[2] = v48;
        if ( v50 != v53 )
        {
          do
          {
            if ( (*(_BYTE *)(v50 - 3) & 1) != 0 )
              free(*(v50 - 1));
            v55 = v50 - 6;
            if ( (*(_BYTE *)(v50 - 6) & 1) != 0 )
              free(*(v50 - 4));
            v50 -= 6;
          }
          while ( v53 != v55 );
        }
        if ( v53 )
        {
          v56 = (unsigned __int64)a3[3];
          if ( v56 + 4096 < (unsigned __int64)v53 || v56 > (unsigned __int64)v53 )
          {
            free(v53);
          }
          else if ( *(void **)(v56 + 4096) == v54 )
          {
            *(_QWORD *)(v56 + 4096) = v53;
          }
        }
      }
      else
      {
        *v27 = v25;
        *((_QWORD *)v27 + 1) = *(_QWORD *)((char *)&v62 + 7);
        *((_QWORD *)v27 + 2) = v23;
        *(_QWORD *)(v27 + 1) = v62;
        *(_QWORD *)((char *)&v62 + 7) = 0LL;
        *(_QWORD *)&v62 = 0LL;
        v27[24] = 0;
        *((_QWORD *)v27 + 4) = *(_QWORD *)((char *)v61 + 7);
        *((_QWORD *)v27 + 5) = 0LL;
        *(_QWORD *)(v27 + 25) = v61[0];
        memset(v61, 0, 15);
        a3[1] = (char *)a3[1] + 48;
      }
      return &v7[v6];
    }
    return v3;
  }
  v9 = a1 + 2;
  while ( a2 != v9 )
  {
    v10 = *v9++;
    v6 = 10 * v6 + v8;
    v8 = v10 - 48;
    if ( (unsigned int)(v10 - 48) >= 0xA )
    {
      v7 = v9 - 1;
      goto LABEL_9;
    }
  }
  return v3;
}
// B1A48: conditional instruction was optimized away because x22.8<Bu
// B1A50: conditional instruction was optimized away because x22.8<Bu

//----- (00000000000B1FF4) ----------------------------------------------------
void __usercall sub_B1FF4(size_t *a1@<X0>, __int64 a2@<X8>)
{
  unsigned __int64 v3; // x22
  size_t v4; // x21
  size_t v6; // x23
  const void *v7; // x0
  const void *v8; // x0
  const void *v9; // x0
  size_t v10; // x21
  const void *v11; // x0
  unsigned __int8 *v12; // x22
  unsigned __int8 *v13; // x21
  int v14; // w8
  int v15; // w9
  int v16; // t1
  unsigned __int8 *v17; // x23
  int v18; // w20
  int v19; // w0
  const void *v20; // x20
  void *v21; // x19
  const char *v22; // x8
  void *v23; // x0
  __int64 v24; // x9
  __int64 v25; // x8
  unsigned __int64 v26; // x23
  unsigned __int8 *v27; // x19
  unsigned __int8 *v28; // x0
  unsigned __int64 v29; // x10
  unsigned __int8 *v30; // x8
  unsigned __int8 *v31; // x9
  unsigned __int8 v32; // t1
  _OWORD *v33; // x11
  __int128 *v34; // x12
  unsigned __int64 v35; // x13
  __int128 v36; // q0
  __int128 v37; // q1

  v3 = *(unsigned __int8 *)a1;
  v4 = a1[1];
  if ( (v3 & 1) != 0 )
    v6 = a1[1];
  else
    v6 = v3 >> 1;
  switch ( v6 )
  {
    case 0uLL:
      *(_QWORD *)(a2 + 8) = 0LL;
      *(_QWORD *)(a2 + 16) = 0LL;
      *(_QWORD *)a2 = 0LL;
      if ( (v3 & 1) == 0 )
      {
        *(_QWORD *)(a2 + 16) = a1[2];
        *(_OWORD *)a2 = *(_OWORD *)a1;
        return;
      }
      if ( v4 >= 0xFFFFFFFFFFFFFFF0LL )
        goto LABEL_75;
      v20 = (const void *)a1[2];
      if ( v4 >= 0x17 )
      {
        v23 = malloc((v4 + 16) & 0xFFFFFFFFFFFFFFF0LL);
        *(_QWORD *)(a2 + 8) = v4;
        *(_QWORD *)(a2 + 16) = v23;
        *(_QWORD *)a2 = (v4 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
        v21 = v23;
      }
      else
      {
        *(_BYTE *)a2 = 2 * v4;
        v21 = (void *)(a2 + 1);
        if ( !v4 )
          goto LABEL_54;
      }
      memcpy(v21, v20, v4);
LABEL_54:
      *((_BYTE *)v21 + v4) = 0;
      return;
    case 0xBuLL:
      if ( (v3 & 1) != 0 )
        v7 = (const void *)a1[2];
      else
        v7 = (char *)a1 + 1;
      if ( memcmp(v7, "std::string", 0xBuLL) )
        goto LABEL_20;
      sub_A1F74(a1, "std::basic_string<char, std::char_traits<char>, std::allocator<char> >", 0x46uLL);
      *(_QWORD *)(a2 + 8) = 0LL;
      *(_QWORD *)(a2 + 16) = 0LL;
      *(_QWORD *)a2 = 0LL;
      *(_BYTE *)a2 = 24;
      strcpy((char *)(a2 + 1), "basic_string");
      return;
    case 0xCuLL:
      if ( (v3 & 1) != 0 )
        v8 = (const void *)a1[2];
      else
        v8 = (char *)a1 + 1;
      if ( !memcmp(v8, "std::istream", 0xCuLL) )
      {
        sub_A1F74(a1, "std::basic_istream<char, std::char_traits<char> >", 0x31uLL);
        v22 = "basic_istream";
        *(_QWORD *)(a2 + 8) = 0LL;
        *(_QWORD *)(a2 + 16) = 0LL;
        *(_QWORD *)a2 = 0LL;
LABEL_56:
        v24 = *(_QWORD *)v22;
        v25 = *(_QWORD *)(v22 + 5);
        *(_BYTE *)a2 = 26;
        *(_QWORD *)(a2 + 1) = v24;
        *(_QWORD *)(a2 + 6) = v25;
        *(_BYTE *)(a2 + 14) = 0;
        return;
      }
      if ( (v3 & 1) != 0 )
        v9 = (const void *)a1[2];
      else
        v9 = (char *)a1 + 1;
      if ( !memcmp(v9, "std::ostream", 0xCuLL) )
      {
        sub_A1F74(a1, "std::basic_ostream<char, std::char_traits<char> >", 0x31uLL);
        *(_QWORD *)(a2 + 8) = 0LL;
        *(_QWORD *)(a2 + 16) = 0LL;
        *(_QWORD *)a2 = 0LL;
        v22 = "basic_ostream";
        goto LABEL_56;
      }
LABEL_20:
      v10 = a1[2];
LABEL_25:
      if ( (v3 & 1) != 0 )
        v12 = (unsigned __int8 *)v10;
      else
        v12 = (unsigned __int8 *)a1 + 1;
      v13 = &v12[v6];
      if ( v12[v6 - 1] == 62 )
      {
        v14 = 1;
LABEL_33:
        while ( 2 )
        {
          --v13;
          do
          {
            if ( v12 == v13 )
              goto LABEL_45;
            v16 = *--v13;
            v15 = v16;
            if ( v16 == 62 )
            {
              ++v14;
              ++v13;
              goto LABEL_33;
            }
          }
          while ( v15 != 60 );
          if ( --v14 )
          {
            ++v13;
            continue;
          }
          break;
        }
      }
      if ( v13 - v12 < 2 )
      {
LABEL_45:
        *(_QWORD *)(a2 + 8) = 0LL;
        *(_QWORD *)(a2 + 16) = 0LL;
        *(_QWORD *)a2 = 0LL;
        return;
      }
      v17 = v13 - 1;
      while ( v12 != v17 )
      {
        v18 = *v17;
        if ( v18 == 58 )
        {
          v12 = v17 + 1;
          break;
        }
        v19 = isalpha(v18);
        --v17;
        if ( v18 != 95 && (unsigned int)(v18 - 48) >= 0xA && !v19 )
          goto LABEL_45;
      }
      v26 = v13 - v12;
      *(_QWORD *)(a2 + 8) = 0LL;
      *(_QWORD *)(a2 + 16) = 0LL;
      *(_QWORD *)a2 = 0LL;
      if ( (unsigned __int64)(v13 - v12) >= 0xFFFFFFFFFFFFFFF0LL )
LABEL_75:
        abort();
      if ( v26 <= 0x16 )
      {
        *(_BYTE *)a2 = 2 * v26;
        v27 = (unsigned __int8 *)(a2 + 1);
        if ( v12 == v13 )
          goto LABEL_70;
LABEL_63:
        if ( v26 >= 0x20
          && (v29 = v26 & 0xFFFFFFFFFFFFFFE0LL, (v26 & 0xFFFFFFFFFFFFFFE0LL) != 0)
          && (v27 >= v13 || v12 >= &v27[v26]) )
        {
          v30 = &v12[v29];
          v31 = &v27[v29];
          v33 = v27 + 16;
          v34 = (__int128 *)(v12 + 16);
          v35 = v26 & 0xFFFFFFFFFFFFFFE0LL;
          do
          {
            v36 = *(v34 - 1);
            v37 = *v34;
            v35 -= 32LL;
            v34 += 2;
            *(v33 - 1) = v36;
            *v33 = v37;
            v33 += 2;
          }
          while ( v35 );
          if ( v29 == v26 )
            goto LABEL_69;
        }
        else
        {
          v30 = v12;
          v31 = v27;
        }
        do
        {
          v32 = *v30++;
          *v31++ = v32;
        }
        while ( v13 != v30 );
LABEL_69:
        v27 += v26;
        goto LABEL_70;
      }
      v28 = (unsigned __int8 *)malloc((v26 + 16) & 0xFFFFFFFFFFFFFFF0LL);
      *(_QWORD *)(a2 + 8) = v26;
      *(_QWORD *)(a2 + 16) = v28;
      *(_QWORD *)a2 = (v26 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
      v27 = v28;
      if ( v12 != v13 )
        goto LABEL_63;
LABEL_70:
      *v27 = 0;
      return;
    case 0xDuLL:
      v10 = a1[2];
      if ( (v3 & 1) != 0 )
        v11 = (const void *)a1[2];
      else
        v11 = (char *)a1 + 1;
      if ( memcmp(v11, "std::iostream", 0xDuLL) )
        goto LABEL_25;
      sub_A1F74(a1, "std::basic_iostream<char, std::char_traits<char> >", 0x32uLL);
      *(_QWORD *)(a2 + 16) = 0LL;
      *(_BYTE *)a2 = 28;
      strcpy((char *)(a2 + 1), "basic_iostream");
      return;
    default:
      goto LABEL_20;
  }
}

//----- (00000000000B23DC) ----------------------------------------------------
void __fastcall sub_B23DC(size_t *a1, char a2)
{
  unsigned __int64 v3; // x8
  size_t v5; // x9
  size_t v6; // x25
  size_t v7; // x21
  char *v8; // x23
  void *v9; // x22
  unsigned __int64 v10; // x8
  size_t v11; // x24
  char *v12; // x8

  v3 = *(unsigned __int8 *)a1;
  if ( (v3 & 1) != 0 )
  {
    v5 = *a1;
    v6 = a1[1];
    v7 = (*a1 & 0xFFFFFFFFFFFFFFFELL) - 1;
    if ( v6 != v7 )
      goto LABEL_3;
LABEL_6:
    if ( v7 == -17LL )
      abort();
    if ( (v5 & 1) != 0 )
      v9 = (void *)a1[2];
    else
      v9 = (char *)a1 + 1;
    if ( v7 > 0x7FFFFFFFFFFFFFE6LL )
    {
      v11 = -17LL;
    }
    else
    {
      if ( v7 + 1 >= 2 * v7 )
        v10 = v7 + 1;
      else
        v10 = 2 * v7;
      if ( v10 >= 0x17 )
        v11 = (v10 + 16) & 0xFFFFFFFFFFFFFFF0LL;
      else
        v11 = 23LL;
    }
    v8 = (char *)malloc(v11);
    memcpy(v8, v9, v7);
    if ( v7 != 22 )
      free(v9);
    a1[2] = (size_t)v8;
    *a1 = v11 | 1;
    goto LABEL_22;
  }
  v6 = v3 >> 1;
  v7 = 22LL;
  LOBYTE(v5) = *(_BYTE *)a1;
  if ( v3 >> 1 == 22 )
    goto LABEL_6;
LABEL_3:
  if ( (v3 & 1) != 0 )
  {
    v8 = (char *)a1[2];
LABEL_22:
    a1[1] = v6 + 1;
    goto LABEL_23;
  }
  *(_BYTE *)a1 = 2 * v6 + 2;
  v8 = (char *)a1 + 1;
LABEL_23:
  v12 = &v8[v6];
  *v12 = a2;
  v12[1] = 0;
}

//----- (00000000000B2508) ----------------------------------------------------
__int64 __fastcall sub_B2508(size_t *a1, __int64 a2, unsigned __int64 a3, char *a4)
{
  size_t v7; // x8
  char *v9; // x25
  unsigned __int64 v10; // x28
  size_t v11; // x23
  char *v12; // x9
  size_t v13; // x10
  _BYTE *v14; // x0
  unsigned __int64 v15; // x10
  char *v16; // x8
  _BYTE *v17; // x9
  _OWORD *v18; // x11
  __int128 *v19; // x12
  unsigned __int64 v20; // x13
  __int128 v21; // q0
  __int128 v22; // q1
  size_t v23; // x27
  unsigned __int64 v24; // x21
  char *v25; // x8
  size_t v26; // x24
  char v27; // t1
  char *v28; // x2
  unsigned __int64 v29; // x8
  __int64 v30; // x19
  __int64 v31; // x21
  size_t v32; // x9
  unsigned __int64 v33; // x8
  size_t v34; // x26
  char *v35; // x0
  char *v36; // x8
  char *v37; // x9
  unsigned __int64 v38; // x10
  __int128 *v39; // x11
  char *v40; // x12
  unsigned __int64 v41; // x13
  __int128 v42; // q0
  __int128 v43; // q1
  char v44; // t1
  char *v45; // x8
  char *src; // [xsp+10h] [xbp-80h]
  unsigned __int64 v49; // [xsp+20h] [xbp-70h] BYREF
  unsigned __int64 v50; // [xsp+28h] [xbp-68h]
  void *p; // [xsp+30h] [xbp-60h]
  __int64 v52; // [xsp+38h] [xbp-58h]

  v52 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v7 = *(unsigned __int8 *)a1;
  if ( (v7 & 1) != 0 )
    v9 = (char *)a1[2];
  else
    v9 = (char *)a1 + 1;
  v10 = (unsigned __int64)&a4[-a3];
  v11 = a2 - (_QWORD)v9;
  if ( a4 == (char *)a3 )
    goto LABEL_74;
  if ( (v7 & 1) != 0 )
  {
    v13 = a1[1];
    v12 = (char *)a1[2];
    if ( (unsigned __int64)v12 > a3 )
    {
LABEL_19:
      if ( (v7 & 1) != 0 )
      {
        v7 = *a1;
        v23 = a1[1];
        v24 = (*a1 & 0xFFFFFFFFFFFFFFFELL) - 1;
      }
      else
      {
        v23 = v7 >> 1;
        v24 = 22LL;
      }
      if ( v24 - v23 >= v10 )
      {
        if ( (v7 & 1) != 0 )
          v26 = a1[2];
        else
          v26 = (size_t)a1 + 1;
        v31 = a2;
        if ( v23 != v11 )
        {
          memmove((void *)(v26 + v11 + v10), (const void *)(v26 + v11), v23 - v11);
          LOBYTE(v7) = *(_BYTE *)a1;
        }
        v32 = v23 + v10;
        if ( (v7 & 1) == 0 )
        {
          *(_BYTE *)a1 = 2 * v32;
LABEL_62:
          *(_BYTE *)(v26 + v32) = 0;
          if ( (char *)a3 == a4 )
            goto LABEL_74;
          v36 = (char *)(v26 + v11);
          if ( v10 < 0x20 )
          {
            v37 = (char *)a3;
            goto LABEL_73;
          }
          v38 = v10 & 0xFFFFFFFFFFFFFFE0LL;
          if ( (v10 & 0xFFFFFFFFFFFFFFE0LL) == 0 )
          {
            v37 = (char *)a3;
            do
            {
LABEL_73:
              v44 = *v37++;
              *v36++ = v44;
            }
            while ( a4 != v37 );
            goto LABEL_74;
          }
          if ( v36 < a4 && (unsigned __int64)&a4[v31 - a3 - (_QWORD)v9 + v26] > a3 )
          {
            v37 = (char *)a3;
            goto LABEL_73;
          }
          v36 += v38;
          v37 = (char *)(a3 + v38);
          v39 = (__int128 *)(a3 + 16);
          v40 = (char *)(v26 + v31 + 16 - (_QWORD)v9);
          v41 = v10 & 0xFFFFFFFFFFFFFFE0LL;
          do
          {
            v42 = *(v39 - 1);
            v43 = *v39;
            v39 += 2;
            v41 -= 32LL;
            *((_OWORD *)v40 - 1) = v42;
            *(_OWORD *)v40 = v43;
            v40 += 32;
          }
          while ( v41 );
          if ( v10 != v38 )
            goto LABEL_73;
LABEL_74:
          if ( (*(_BYTE *)a1 & 1) != 0 )
            v45 = (char *)a1[2];
          else
            v45 = (char *)a1 + 1;
          return (__int64)&v45[v11];
        }
LABEL_61:
        a1[1] = v32;
        goto LABEL_62;
      }
      if ( -17LL - v24 >= v23 + v10 - v24 )
      {
        if ( (v7 & 1) != 0 )
          v25 = (char *)a1[2];
        else
          v25 = (char *)a1 + 1;
        src = v25;
        if ( v24 > 0x7FFFFFFFFFFFFFE6LL )
        {
          v34 = -17LL;
        }
        else
        {
          v33 = 2 * v24;
          if ( v23 + v10 >= 2 * v24 )
            v33 = v23 + v10;
          if ( v33 >= 0x17 )
            v34 = (v33 + 16) & 0xFFFFFFFFFFFFFFF0LL;
          else
            v34 = 23LL;
        }
        v35 = (char *)malloc(v34);
        v26 = (size_t)v35;
        if ( v11 )
          memcpy(v35, src, v11);
        if ( v23 != v11 )
          memcpy((void *)(v26 + v11 + v10), &src[v11], v23 - v11);
        if ( v24 != 22 )
          free(src);
        a1[2] = v26;
        *a1 = v34 | 1;
        v31 = a2;
        v32 = v23 + v10;
        goto LABEL_61;
      }
LABEL_79:
      abort();
    }
  }
  else
  {
    v12 = (char *)a1 + 1;
    v13 = v7 >> 1;
    if ( (unsigned __int64)a1 + 1 > a3 )
      goto LABEL_19;
  }
  if ( (unsigned __int64)&v12[v13] <= a3 )
    goto LABEL_19;
  v50 = 0LL;
  p = 0LL;
  v49 = 0LL;
  if ( v10 >= 0xFFFFFFFFFFFFFFF0LL )
    goto LABEL_79;
  if ( v10 <= 0x16 )
  {
    LOBYTE(v49) = 2 * v10;
    v14 = (char *)&v49 + 1;
    if ( (char *)a3 == a4 )
      goto LABEL_33;
LABEL_13:
    if ( v10 >= 0x20 && (v15 = v10 & 0xFFFFFFFFFFFFFFE0LL, (v10 & 0xFFFFFFFFFFFFFFE0LL) != 0) )
    {
      v16 = (char *)(a3 + v15);
      v17 = &v14[v15];
      v18 = v14 + 16;
      v19 = (__int128 *)(a3 + 16);
      v20 = v10 & 0xFFFFFFFFFFFFFFE0LL;
      do
      {
        v21 = *(v19 - 1);
        v22 = *v19;
        v20 -= 32LL;
        v19 += 2;
        *(v18 - 1) = v21;
        *v18 = v22;
        v18 += 2;
      }
      while ( v20 );
      if ( v10 == v15 )
        goto LABEL_32;
    }
    else
    {
      v16 = (char *)a3;
      v17 = v14;
    }
    do
    {
      v27 = *v16++;
      *v17++ = v27;
    }
    while ( a4 != v16 );
LABEL_32:
    v14 += v10;
    goto LABEL_33;
  }
  v14 = malloc((v10 + 16) & 0xFFFFFFFFFFFFFFF0LL);
  v50 = (unsigned __int64)&a4[-a3];
  p = v14;
  v49 = (v10 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
  if ( (char *)a3 != a4 )
    goto LABEL_13;
LABEL_33:
  *v14 = 0;
  if ( (v49 & 1) != 0 )
    v28 = (char *)p;
  else
    v28 = (char *)&v49 + 1;
  if ( (v49 & 1) != 0 )
    v29 = v50;
  else
    v29 = (unsigned __int64)(unsigned __int8)v49 >> 1;
  v30 = sub_B2508(a1, a2, v28, &v28[v29]);
  if ( (v49 & 1) != 0 )
    free(p);
  return v30;
}

//----- (00000000000B28F0) ----------------------------------------------------
unsigned __int8 *__fastcall sub_B28F0(unsigned __int8 *a1, unsigned __int8 *a2, __int64 *a3)
{
  unsigned __int8 *v4; // x19
  int v6; // w8
  unsigned __int8 *v7; // x22
  unsigned __int8 *v8; // x0
  unsigned __int8 *v9; // x0
  int v10; // t1
  _BYTE *v11; // x22
  __int64 v12; // x0
  bool v13; // zf
  unsigned __int8 *v14; // x22

  v4 = a1;
  if ( a1 != a2 )
  {
    v6 = *a1;
    if ( v6 == 74 )
    {
      v11 = a1 + 1;
      if ( a1 + 1 != a2 )
      {
        while ( *v11 != 69 )
        {
          v12 = sub_B28F0(v11, a2, a3);
          v13 = v12 == (_QWORD)v11;
          v11 = (_BYTE *)v12;
          if ( v13 )
            return v4;
        }
        return v11 + 1;
      }
      return v4;
    }
    if ( v6 != 76 )
    {
      if ( v6 != 88 )
        return (unsigned __int8 *)sub_925FC(a1, a2, a3);
      v7 = a1 + 1;
      v8 = (unsigned __int8 *)sub_A20BC(a1 + 1, a2, (__int64)a3);
      if ( v8 == v7 )
        return v4;
      goto LABEL_6;
    }
    if ( a1 + 1 == a2 || a1[1] != 90 )
      return sub_A743C(a1, a2, a3);
    v14 = a1 + 2;
    v8 = sub_91038(a1 + 2, a2, a3);
    if ( v8 != v14 )
    {
LABEL_6:
      if ( v8 != a2 )
      {
        v10 = *v8;
        v9 = v8 + 1;
        if ( v10 == 69 )
          return v9;
      }
    }
  }
  return v4;
}
// 925FC: using guessed type __int64 __fastcall sub_925FC(_QWORD, _QWORD, _QWORD);

//----- (00000000000B2A24) ----------------------------------------------------
void __fastcall sub_B2A24(__int64 a1)
{
  __int64 v2; // x21
  __int64 v3; // x22
  void **v4; // x23
  void **v5; // x20
  void *v6; // x0
  unsigned __int64 v7; // x8
  void *v8; // x0
  unsigned __int64 v9; // x8

  v2 = *(_QWORD *)(a1 + 8);
  while ( 1 )
  {
    v3 = *(_QWORD *)(a1 + 16);
    if ( v3 == v2 )
      break;
    *(_QWORD *)(a1 + 16) = v3 - 32;
    v4 = *(void ***)(v3 - 32);
    if ( v4 )
    {
      v5 = *(void ***)(v3 - 24);
      v6 = *(void **)(v3 - 32);
      if ( v5 != v4 )
      {
        do
        {
          v5 -= 4;
          sub_9D32C(v5);
        }
        while ( v4 != v5 );
        v6 = *(void **)(v3 - 32);
      }
      v7 = *(_QWORD *)(v3 - 8);
      *(_QWORD *)(v3 - 24) = v4;
      if ( v7 + 4096 < (unsigned __int64)v6 || v7 > (unsigned __int64)v6 )
      {
        free(v6);
      }
      else if ( *(_QWORD *)(v7 + 4096) == *(_QWORD *)(v3 - 16) )
      {
        *(_QWORD *)(v7 + 4096) = v6;
      }
    }
  }
  v8 = *(void **)a1;
  if ( *(_QWORD *)a1 )
  {
    v9 = **(_QWORD **)(a1 + 32);
    if ( v9 + 4096 < (unsigned __int64)v8 || v9 > (unsigned __int64)v8 )
    {
      free(v8);
    }
    else if ( *(_QWORD *)(v9 + 4096) == *(_QWORD *)(a1 + 24) )
    {
      *(_QWORD *)(v9 + 4096) = v8;
    }
  }
}

//----- (00000000000B2B20) ----------------------------------------------------
unsigned __int8 *__fastcall sub_B2B20(unsigned __int8 *a1, unsigned __int8 *a2, __int64 a3)
{
  unsigned __int8 *v3; // x19
  __int64 v5; // x21
  unsigned __int64 v6; // x9
  unsigned __int64 v7; // x10
  __int16 v8; // w8
  unsigned __int64 v9; // x10
  int v10; // w23
  unsigned __int64 v11; // x24
  unsigned __int64 v12; // x10
  __int64 v13; // x9
  char *v14; // x0
  unsigned __int64 v15; // x9
  unsigned __int64 v16; // x10
  __int64 v17; // x8
  unsigned __int64 v18; // x10
  __int16 v19; // w8
  unsigned __int64 v20; // x10
  unsigned __int64 v21; // x10
  unsigned __int64 v22; // x24
  unsigned __int64 v23; // x10
  __int64 v24; // x9
  char *v25; // x0
  unsigned __int64 v26; // x10
  unsigned __int64 v27; // x10
  unsigned __int64 v28; // x23
  unsigned __int64 v29; // x10
  __int64 v30; // x9
  char *v31; // x0
  unsigned __int64 v32; // x10
  unsigned __int64 v33; // x23
  unsigned __int64 v34; // x10
  __int64 v35; // x9
  char *v36; // x0
  unsigned __int64 v37; // x10
  unsigned __int64 v38; // x10
  unsigned __int64 v39; // x23
  unsigned __int64 v40; // x10
  __int64 v41; // x9
  char *v42; // x0
  unsigned __int64 v43; // x10
  unsigned __int64 v44; // x24
  unsigned __int64 v45; // x10
  __int64 v46; // x9
  char *v47; // x0
  unsigned __int64 v48; // x10
  unsigned __int64 v49; // x10
  unsigned __int64 v50; // x10
  unsigned __int64 v51; // x23
  unsigned __int64 v52; // x10
  __int64 v53; // x9
  char *v54; // x0
  unsigned __int64 v55; // x10
  __int64 v56; // x8
  unsigned __int64 v57; // x10
  unsigned __int64 v58; // x10
  unsigned __int64 v59; // x10
  unsigned __int64 v60; // x10
  unsigned __int8 *v61; // x21
  unsigned __int8 *v62; // x0
  unsigned __int64 v63; // x10
  __int64 v64; // x8
  unsigned __int64 v65; // x10
  __int64 v66; // x8
  unsigned __int64 v67; // x24
  unsigned __int64 v68; // x10
  __int64 v69; // x9
  char *v70; // x0
  unsigned __int64 v71; // x24
  unsigned __int64 v72; // x10
  __int64 v73; // x9
  char *v74; // x0
  unsigned __int64 v75; // x23
  unsigned __int64 v76; // x10
  __int64 v77; // x9
  char *v78; // x0
  unsigned __int64 v79; // x23
  unsigned __int64 v80; // x10
  __int64 v81; // x9
  char *v82; // x0
  unsigned __int64 v83; // x23
  unsigned __int64 v84; // x10
  __int64 v85; // x9
  char *v86; // x0
  unsigned __int64 v87; // x24
  unsigned __int64 v88; // x10
  __int64 v89; // x9
  char *v90; // x0
  unsigned __int64 v91; // x23
  unsigned __int64 v92; // x10
  __int64 v93; // x9
  char *v94; // x0
  unsigned __int64 v95; // x23
  unsigned __int64 v96; // x10
  __int64 v97; // x9
  char *v98; // x0
  unsigned __int64 v99; // x23
  unsigned __int64 v100; // x10
  __int64 v101; // x9
  char *v102; // x0
  unsigned __int64 v103; // x23
  unsigned __int64 v104; // x10
  __int64 v105; // x9
  char *v106; // x0
  unsigned __int64 v107; // x23
  unsigned __int64 v108; // x10
  __int64 v109; // x9
  char *v110; // x0
  unsigned __int64 v111; // x23
  unsigned __int64 v112; // x10
  __int64 v113; // x9
  char *v114; // x0
  unsigned __int64 v115; // x23
  unsigned __int64 v116; // x10
  __int64 v117; // x9
  char *v118; // x0
  unsigned __int64 v119; // x23
  unsigned __int64 v120; // x10
  __int64 v121; // x9
  char *v122; // x0
  char *v123; // x8
  char *v124; // x9
  void **v125; // x11
  void **v126; // x23
  char *v127; // x10
  __int64 v128; // x12
  void **v129; // x21
  __int64 v130; // x24
  void **v131; // x25
  char *v132; // x8
  char *v133; // x9
  void **v134; // x11
  void **v135; // x23
  char *v136; // x10
  __int64 v137; // x12
  void **v138; // x25
  char *v139; // x8
  char *v140; // x9
  void **v141; // x11
  void **v142; // x23
  char *v143; // x10
  __int64 v144; // x12
  void **v145; // x25
  char *v146; // x8
  char *v147; // x9
  void **v148; // x11
  void **v149; // x23
  char *v150; // x10
  __int64 v151; // x12
  void **v152; // x25
  char *v153; // x8
  char *v154; // x9
  void **v155; // x11
  void **v156; // x23
  char *v157; // x10
  __int64 v158; // x12
  void **v159; // x25
  char *v160; // x8
  char *v161; // x9
  void **v162; // x11
  void **v163; // x23
  char *v164; // x10
  __int64 v165; // x12
  void **v166; // x25
  char *v167; // x8
  char *v168; // x9
  void **v169; // x11
  void **v170; // x23
  char *v171; // x10
  __int64 v172; // x12
  void **v173; // x25
  char *v174; // x8
  char *v175; // x9
  void **v176; // x11
  void **v177; // x23
  char *v178; // x10
  __int64 v179; // x12
  void **v180; // x25
  char *v181; // x8
  char *v182; // x9
  void **v183; // x11
  void **v184; // x23
  char *v185; // x10
  __int64 v186; // x12
  void **v187; // x25
  char *v188; // x8
  char *v189; // x9
  void **v190; // x11
  void **v191; // x23
  char *v192; // x10
  __int64 v193; // x12
  void **v194; // x25
  char *v195; // x8
  char *v196; // x9
  void **v197; // x11
  void **v198; // x23
  char *v199; // x10
  __int64 v200; // x12
  void **v201; // x25
  char *v202; // x8
  char *v203; // x9
  void **v204; // x11
  void **v205; // x23
  char *v206; // x10
  __int64 v207; // x12
  void **v208; // x25
  char *v209; // x8
  char *v210; // x9
  void **v211; // x11
  void **v212; // x23
  char *v213; // x10
  __int64 v214; // x12
  void **v215; // x25
  char *v216; // x8
  char *v217; // x9
  void **v218; // x11
  void **v219; // x23
  char *v220; // x10
  __int64 v221; // x12
  void **v222; // x25
  char *v223; // x8
  char *v224; // x9
  void **v225; // x11
  void **v226; // x23
  char *v227; // x10
  __int64 v228; // x12
  void **v229; // x25
  char *v230; // x8
  char *v231; // x9
  void **v232; // x11
  void **v233; // x23
  char *v234; // x10
  __int64 v235; // x12
  void **v236; // x25
  char *v237; // x8
  char *v238; // x9
  void **v239; // x11
  void **v240; // x23
  char *v241; // x10
  __int64 v242; // x12
  void **v243; // x25
  char *v244; // x8
  char *v245; // x9
  void **v246; // x11
  void **v247; // x23
  char *v248; // x10
  __int64 v249; // x12
  void **v250; // x25
  char *v251; // x8
  char *v252; // x9
  void **v253; // x11
  void **v254; // x23
  char *v255; // x10
  __int64 v256; // x12
  void **v257; // x25
  char *v258; // x8
  char *v259; // x9
  void **v260; // x11
  void **v261; // x23
  char *v262; // x10
  __int64 v263; // x12
  void **v264; // x25
  char *v265; // x8
  char *v266; // x9
  void **v267; // x11
  void **v268; // x23
  char *v269; // x10
  __int64 v270; // x12
  void **v271; // x25
  unsigned __int64 v272; // x8
  unsigned __int64 v274; // x10
  unsigned __int64 v275; // x23
  unsigned __int64 v276; // x10
  __int64 v277; // x9
  char *v278; // x0
  unsigned __int64 v279; // x10
  unsigned __int64 v280; // x23
  unsigned __int64 v281; // x10
  __int64 v282; // x9
  char *v283; // x0
  unsigned __int64 v284; // x10
  unsigned __int64 v285; // x23
  unsigned __int64 v286; // x10
  __int64 v287; // x9
  char *v288; // x0
  unsigned __int64 v289; // x10
  __int64 v290; // x23
  unsigned __int64 v291; // x24
  unsigned __int64 v292; // x10
  __int64 v293; // x9
  char *v294; // x0
  unsigned __int64 v295; // x10
  unsigned __int64 v296; // x10
  unsigned __int64 v297; // x10
  unsigned __int64 v298; // x10
  unsigned __int64 v299; // x24
  unsigned __int64 v300; // x10
  __int64 v301; // x9
  char *v302; // x0
  unsigned __int64 v303; // x23
  unsigned __int64 v304; // x10
  __int64 v305; // x9
  char *v306; // x0
  unsigned __int64 v307; // x23
  unsigned __int64 v308; // x10
  __int64 v309; // x9
  char *v310; // x0
  unsigned __int64 v311; // x23
  unsigned __int64 v312; // x10
  __int64 v313; // x9
  char *v314; // x0
  unsigned __int64 v315; // x24
  unsigned __int64 v316; // x10
  __int64 v317; // x9
  char *v318; // x0
  char *v319; // x8
  char *v320; // x9
  void **v321; // x11
  void **v322; // x23
  char *v323; // x10
  __int64 v324; // x12
  void **v325; // x21
  __int64 v326; // x24
  void **v327; // x25
  char *v328; // x8
  char *v329; // x9
  void **v330; // x11
  void **v331; // x23
  char *v332; // x10
  __int64 v333; // x12
  void **v334; // x25
  char *v335; // x8
  char *v336; // x9
  void **v337; // x11
  void **v338; // x23
  char *v339; // x10
  __int64 v340; // x12
  void **v341; // x25
  char *v342; // x8
  char *v343; // x9
  void **v344; // x11
  void **v345; // x23
  char *v346; // x10
  __int64 v347; // x12
  void **v348; // x25
  char *v349; // x8
  char *v350; // x9
  void **v351; // x11
  void **v352; // x23
  char *v353; // x10
  __int64 v354; // x12
  void **v355; // x25
  char *v356; // x8
  char *v357; // x9
  void **v358; // x11
  void **v359; // x23
  char *v360; // x10
  __int64 v361; // x12
  void **v362; // x25
  char *v363; // x8
  char *v364; // x9
  void **v365; // x11
  void **v366; // x23
  char *v367; // x10
  __int64 v368; // x12
  void **v369; // x25
  char *v370; // x8
  char *v371; // x9
  void **v372; // x11
  void **v373; // x23
  char *v374; // x10
  __int64 v375; // x12
  void **v376; // x25
  char *v377; // x8
  char *v378; // x9
  void **v379; // x11
  void **v380; // x23
  char *v381; // x10
  __int64 v382; // x12
  void **v383; // x25
  unsigned __int64 v384; // x8
  __int16 v385; // [xsp+0h] [xbp-70h]
  int v386; // [xsp+0h] [xbp-70h]
  char v387; // [xsp+2h] [xbp-6Eh]
  _QWORD v388[2]; // [xsp+8h] [xbp-68h] BYREF
  _QWORD v389[3]; // [xsp+18h] [xbp-58h] BYREF

  v3 = a1;
  v389[2] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a1 != a2 )
  {
    v5 = 0x555555555555555LL;
    switch ( *a1 )
    {
      case 'D':
        if ( a1 + 1 != a2 )
        {
          switch ( a1[1] )
          {
            case 'a':
              LOWORD(v388[1]) = 0;
              v388[0] = 0LL;
              *(_QWORD *)((char *)v389 + 7) = 0LL;
              v389[0] = 0LL;
              v6 = *(_QWORD *)(a3 + 8);
              v7 = *(_QWORD *)(a3 + 16);
              if ( v6 < v7 )
              {
                strcpy((char *)(v6 + 1), "auto");
                *(_BYTE *)v6 = 8;
                v8 = v388[1];
                v3 = a1 + 2;
                goto LABEL_74;
              }
              v299 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v6 - *(_QWORD *)a3) >> 4);
              if ( v299 + 1 > 0x555555555555555LL )
                abort();
              v300 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v7 - *(_QWORD *)a3) >> 4);
              if ( v300 >= 0x2AAAAAAAAAAAAAALL || (2 * v300 >= v299 + 1 ? (v5 = 2 * v300) : (v5 = v299 + 1), v5) )
              {
                v301 = *(_QWORD *)(a3 + 24);
                v302 = *(char **)(v301 + 4096);
                if ( v301 + 4096 - (__int64)v302 >= (unsigned __int64)(48 * v5) )
                  *(_QWORD *)(v301 + 4096) = &v302[48 * v5];
                else
                  v302 = (char *)malloc(48 * v5);
              }
              else
              {
                v302 = 0LL;
              }
              v335 = &v302[48 * v299];
              *v335 = 8;
              strcpy(v335 + 1, "auto");
              v336 = &v302[48 * v5];
              *((_WORD *)v335 + 7) = v388[1];
              *((_QWORD *)v335 + 2) = 0LL;
              *(_QWORD *)(v335 + 6) = v388[0];
              LOWORD(v388[1]) = 0;
              v388[0] = 0LL;
              v335[24] = 0;
              *((_QWORD *)v335 + 4) = *(_QWORD *)((char *)v389 + 7);
              *((_QWORD *)v335 + 5) = 0LL;
              *(_QWORD *)(v335 + 25) = v389[0];
              *(_QWORD *)((char *)v389 + 7) = 0LL;
              v389[0] = 0LL;
              v338 = *(void ***)a3;
              v337 = *(void ***)(a3 + 8);
              v339 = v335 + 48;
              if ( v337 == *(void ***)a3 )
              {
                v325 = *(void ***)a3;
              }
              else
              {
                do
                {
                  *((_QWORD *)v335 - 4) = *(v337 - 4);
                  *((_OWORD *)v335 - 3) = *((_OWORD *)v337 - 3);
                  v340 = (__int64)*(v337 - 1);
                  *(v337 - 5) = 0LL;
                  *(v337 - 4) = 0LL;
                  *(v337 - 6) = 0LL;
                  *((_QWORD *)v335 - 1) = v340;
                  *(_OWORD *)(v335 - 24) = *(_OWORD *)(v337 - 3);
                  *(v337 - 2) = 0LL;
                  *(v337 - 1) = 0LL;
                  *(v337 - 3) = 0LL;
                  v337 -= 6;
                  v335 -= 48;
                }
                while ( v338 != v337 );
                v325 = *(void ***)a3;
                v338 = *(void ***)(a3 + 8);
              }
              v326 = *(_QWORD *)(a3 + 16);
              *(_QWORD *)a3 = v335;
              *(_QWORD *)(a3 + 8) = v339;
              *(_QWORD *)(a3 + 16) = v336;
              if ( v338 != v325 )
              {
                do
                {
                  if ( (*(_BYTE *)(v338 - 3) & 1) != 0 )
                    free(*(v338 - 1));
                  v341 = v338 - 6;
                  if ( (*(_BYTE *)(v338 - 6) & 1) != 0 )
                    free(*(v338 - 4));
                  v338 -= 6;
                }
                while ( v325 != v341 );
              }
              goto LABEL_702;
            case 'c':
              *(_QWORD *)((char *)v389 + 7) = 0LL;
              v389[0] = 0LL;
              qmemcpy(v388, "decltype(auto)", 14);
              v6 = *(_QWORD *)(a3 + 8);
              v284 = *(_QWORD *)(a3 + 16);
              if ( v6 < v284 )
                goto LABEL_539;
              v285 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v6 - *(_QWORD *)a3) >> 4);
              if ( v285 + 1 > 0x555555555555555LL )
                abort();
              v286 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v284 - *(_QWORD *)a3) >> 4);
              if ( v286 >= 0x2AAAAAAAAAAAAAALL || (2 * v286 >= v285 + 1 ? (v5 = 2 * v286) : (v5 = v285 + 1), v5) )
              {
                v287 = *(_QWORD *)(a3 + 24);
                v288 = *(char **)(v287 + 4096);
                if ( v287 + 4096 - (__int64)v288 >= (unsigned __int64)(48 * v5) )
                  *(_QWORD *)(v287 + 4096) = &v288[48 * v5];
                else
                  v288 = (char *)malloc(48 * v5);
              }
              else
              {
                v288 = 0LL;
              }
              v342 = &v288[48 * v285];
              *v342 = 28;
              v343 = &v288[48 * v5];
              *(_QWORD *)(v342 + 7) = *(_QWORD *)((char *)v388 + 6);
              v342[15] = 0;
              *((_QWORD *)v342 + 2) = 0LL;
              *(_QWORD *)(v342 + 1) = v388[0];
              *(_QWORD *)((char *)v388 + 6) = 0LL;
              v388[0] = 0LL;
              v342[24] = 0;
              *((_QWORD *)v342 + 4) = *(_QWORD *)((char *)v389 + 7);
              *((_QWORD *)v342 + 5) = 0LL;
              *(_QWORD *)(v342 + 25) = v389[0];
              *(_QWORD *)((char *)v389 + 7) = 0LL;
              v389[0] = 0LL;
              v345 = *(void ***)a3;
              v344 = *(void ***)(a3 + 8);
              v346 = v342 + 48;
              if ( v344 == *(void ***)a3 )
              {
                v325 = *(void ***)a3;
              }
              else
              {
                do
                {
                  *((_QWORD *)v342 - 4) = *(v344 - 4);
                  *((_OWORD *)v342 - 3) = *((_OWORD *)v344 - 3);
                  v347 = (__int64)*(v344 - 1);
                  *(v344 - 5) = 0LL;
                  *(v344 - 4) = 0LL;
                  *(v344 - 6) = 0LL;
                  *((_QWORD *)v342 - 1) = v347;
                  *(_OWORD *)(v342 - 24) = *(_OWORD *)(v344 - 3);
                  *(v344 - 2) = 0LL;
                  *(v344 - 1) = 0LL;
                  *(v344 - 3) = 0LL;
                  v344 -= 6;
                  v342 -= 48;
                }
                while ( v345 != v344 );
                v325 = *(void ***)a3;
                v345 = *(void ***)(a3 + 8);
              }
              v326 = *(_QWORD *)(a3 + 16);
              *(_QWORD *)a3 = v342;
              *(_QWORD *)(a3 + 8) = v346;
              *(_QWORD *)(a3 + 16) = v343;
              if ( v345 != v325 )
              {
                do
                {
                  if ( (*(_BYTE *)(v345 - 3) & 1) != 0 )
                    free(*(v345 - 1));
                  v348 = v345 - 6;
                  if ( (*(_BYTE *)(v345 - 6) & 1) != 0 )
                    free(*(v345 - 4));
                  v345 -= 6;
                }
                while ( v325 != v348 );
              }
              goto LABEL_702;
            case 'd':
              *(_QWORD *)((char *)v389 + 7) = 0LL;
              v389[0] = 0LL;
              qmemcpy(v388, "decimal64", 9);
              v6 = *(_QWORD *)(a3 + 8);
              v274 = *(_QWORD *)(a3 + 16);
              if ( v6 < v274 )
                goto LABEL_543;
              v275 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v6 - *(_QWORD *)a3) >> 4);
              if ( v275 + 1 > 0x555555555555555LL )
                abort();
              v276 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v274 - *(_QWORD *)a3) >> 4);
              if ( v276 >= 0x2AAAAAAAAAAAAAALL || (2 * v276 >= v275 + 1 ? (v5 = 2 * v276) : (v5 = v275 + 1), v5) )
              {
                v277 = *(_QWORD *)(a3 + 24);
                v278 = *(char **)(v277 + 4096);
                if ( v277 + 4096 - (__int64)v278 >= (unsigned __int64)(48 * v5) )
                  *(_QWORD *)(v277 + 4096) = &v278[48 * v5];
                else
                  v278 = (char *)malloc(48 * v5);
              }
              else
              {
                v278 = 0LL;
              }
              v319 = &v278[48 * v275];
              *v319 = 18;
              v320 = &v278[48 * v5];
              *(_QWORD *)(v319 + 1) = v388[0];
              v319[10] = 0;
              v319[9] = v388[1];
              *(_DWORD *)(v319 + 11) = 0;
              *((_QWORD *)v319 + 2) = 0LL;
              v319[15] = 0;
              v388[0] = 0LL;
              LOBYTE(v388[1]) = 0;
              v319[24] = 0;
              *((_QWORD *)v319 + 4) = *(_QWORD *)((char *)v389 + 7);
              *((_QWORD *)v319 + 5) = 0LL;
              *(_QWORD *)(v319 + 25) = v389[0];
              *(_QWORD *)((char *)v389 + 7) = 0LL;
              v389[0] = 0LL;
              v322 = *(void ***)a3;
              v321 = *(void ***)(a3 + 8);
              v323 = v319 + 48;
              if ( v321 == *(void ***)a3 )
              {
                v325 = *(void ***)a3;
              }
              else
              {
                do
                {
                  *((_QWORD *)v319 - 4) = *(v321 - 4);
                  *((_OWORD *)v319 - 3) = *((_OWORD *)v321 - 3);
                  v324 = (__int64)*(v321 - 1);
                  *(v321 - 5) = 0LL;
                  *(v321 - 4) = 0LL;
                  *(v321 - 6) = 0LL;
                  *((_QWORD *)v319 - 1) = v324;
                  *(_OWORD *)(v319 - 24) = *(_OWORD *)(v321 - 3);
                  *(v321 - 2) = 0LL;
                  *(v321 - 1) = 0LL;
                  *(v321 - 3) = 0LL;
                  v321 -= 6;
                  v319 -= 48;
                }
                while ( v322 != v321 );
                v325 = *(void ***)a3;
                v322 = *(void ***)(a3 + 8);
              }
              v326 = *(_QWORD *)(a3 + 16);
              *(_QWORD *)a3 = v319;
              *(_QWORD *)(a3 + 8) = v323;
              *(_QWORD *)(a3 + 16) = v320;
              if ( v322 != v325 )
              {
                do
                {
                  if ( (*(_BYTE *)(v322 - 3) & 1) != 0 )
                    free(*(v322 - 1));
                  v327 = v322 - 6;
                  if ( (*(_BYTE *)(v322 - 6) & 1) != 0 )
                    free(*(v322 - 4));
                  v322 -= 6;
                }
                while ( v325 != v327 );
              }
              goto LABEL_702;
            case 'e':
              *(_QWORD *)((char *)v389 + 7) = 0LL;
              v389[0] = 0LL;
              qmemcpy(v388, "decimal128", 10);
              v6 = *(_QWORD *)(a3 + 8);
              v296 = *(_QWORD *)(a3 + 16);
              if ( v6 < v296 )
              {
                *(_BYTE *)v6 = 20;
                v56 = v388[0];
                v3 = a1 + 2;
                goto LABEL_88;
              }
              v307 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v6 - *(_QWORD *)a3) >> 4);
              if ( v307 + 1 > 0x555555555555555LL )
                abort();
              v308 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v296 - *(_QWORD *)a3) >> 4);
              if ( v308 >= 0x2AAAAAAAAAAAAAALL || (2 * v308 >= v307 + 1 ? (v5 = 2 * v308) : (v5 = v307 + 1), v5) )
              {
                v309 = *(_QWORD *)(a3 + 24);
                v310 = *(char **)(v309 + 4096);
                if ( v309 + 4096 - (__int64)v310 >= (unsigned __int64)(48 * v5) )
                  *(_QWORD *)(v309 + 4096) = &v310[48 * v5];
                else
                  v310 = (char *)malloc(48 * v5);
              }
              else
              {
                v310 = 0LL;
              }
              v363 = &v310[48 * v307];
              *v363 = 20;
              v364 = &v310[48 * v5];
              *(_QWORD *)(v363 + 1) = v388[0];
              v363[11] = 0;
              *((_DWORD *)v363 + 3) = 0;
              *((_QWORD *)v363 + 2) = 0LL;
              *(_WORD *)(v363 + 9) = v388[1];
              v388[0] = 0LL;
              LOWORD(v388[1]) = 0;
              v363[24] = 0;
              *((_QWORD *)v363 + 4) = *(_QWORD *)((char *)v389 + 7);
              *((_QWORD *)v363 + 5) = 0LL;
              *(_QWORD *)(v363 + 25) = v389[0];
              *(_QWORD *)((char *)v389 + 7) = 0LL;
              v389[0] = 0LL;
              v366 = *(void ***)a3;
              v365 = *(void ***)(a3 + 8);
              v367 = v363 + 48;
              if ( v365 == *(void ***)a3 )
              {
                v325 = *(void ***)a3;
              }
              else
              {
                do
                {
                  *((_QWORD *)v363 - 4) = *(v365 - 4);
                  *((_OWORD *)v363 - 3) = *((_OWORD *)v365 - 3);
                  v368 = (__int64)*(v365 - 1);
                  *(v365 - 5) = 0LL;
                  *(v365 - 4) = 0LL;
                  *(v365 - 6) = 0LL;
                  *((_QWORD *)v363 - 1) = v368;
                  *(_OWORD *)(v363 - 24) = *(_OWORD *)(v365 - 3);
                  *(v365 - 2) = 0LL;
                  *(v365 - 1) = 0LL;
                  *(v365 - 3) = 0LL;
                  v365 -= 6;
                  v363 -= 48;
                }
                while ( v366 != v365 );
                v325 = *(void ***)a3;
                v366 = *(void ***)(a3 + 8);
              }
              v326 = *(_QWORD *)(a3 + 16);
              *(_QWORD *)a3 = v363;
              *(_QWORD *)(a3 + 8) = v367;
              *(_QWORD *)(a3 + 16) = v364;
              if ( v366 != v325 )
              {
                do
                {
                  if ( (*(_BYTE *)(v366 - 3) & 1) != 0 )
                    free(*(v366 - 1));
                  v369 = v366 - 6;
                  if ( (*(_BYTE *)(v366 - 6) & 1) != 0 )
                    free(*(v366 - 4));
                  v366 -= 6;
                }
                while ( v325 != v369 );
              }
              goto LABEL_702;
            case 'f':
              *(_QWORD *)((char *)v389 + 7) = 0LL;
              v389[0] = 0LL;
              qmemcpy(v388, "decimal32", 9);
              v6 = *(_QWORD *)(a3 + 8);
              v297 = *(_QWORD *)(a3 + 16);
              if ( v6 < v297 )
                goto LABEL_543;
              v311 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v6 - *(_QWORD *)a3) >> 4);
              if ( v311 + 1 > 0x555555555555555LL )
                abort();
              v312 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v297 - *(_QWORD *)a3) >> 4);
              if ( v312 >= 0x2AAAAAAAAAAAAAALL || (2 * v312 >= v311 + 1 ? (v5 = 2 * v312) : (v5 = v311 + 1), v5) )
              {
                v313 = *(_QWORD *)(a3 + 24);
                v314 = *(char **)(v313 + 4096);
                if ( v313 + 4096 - (__int64)v314 >= (unsigned __int64)(48 * v5) )
                  *(_QWORD *)(v313 + 4096) = &v314[48 * v5];
                else
                  v314 = (char *)malloc(48 * v5);
              }
              else
              {
                v314 = 0LL;
              }
              v370 = &v314[48 * v311];
              *v370 = 18;
              v371 = &v314[48 * v5];
              *(_QWORD *)(v370 + 1) = v388[0];
              v370[10] = 0;
              v370[9] = v388[1];
              *(_DWORD *)(v370 + 11) = 0;
              *((_QWORD *)v370 + 2) = 0LL;
              v370[15] = 0;
              v388[0] = 0LL;
              LOBYTE(v388[1]) = 0;
              v370[24] = 0;
              *((_QWORD *)v370 + 4) = *(_QWORD *)((char *)v389 + 7);
              *((_QWORD *)v370 + 5) = 0LL;
              *(_QWORD *)(v370 + 25) = v389[0];
              *(_QWORD *)((char *)v389 + 7) = 0LL;
              v389[0] = 0LL;
              v373 = *(void ***)a3;
              v372 = *(void ***)(a3 + 8);
              v374 = v370 + 48;
              if ( v372 == *(void ***)a3 )
              {
                v325 = *(void ***)a3;
              }
              else
              {
                do
                {
                  *((_QWORD *)v370 - 4) = *(v372 - 4);
                  *((_OWORD *)v370 - 3) = *((_OWORD *)v372 - 3);
                  v375 = (__int64)*(v372 - 1);
                  *(v372 - 5) = 0LL;
                  *(v372 - 4) = 0LL;
                  *(v372 - 6) = 0LL;
                  *((_QWORD *)v370 - 1) = v375;
                  *(_OWORD *)(v370 - 24) = *(_OWORD *)(v372 - 3);
                  *(v372 - 2) = 0LL;
                  *(v372 - 1) = 0LL;
                  *(v372 - 3) = 0LL;
                  v372 -= 6;
                  v370 -= 48;
                }
                while ( v373 != v372 );
                v325 = *(void ***)a3;
                v373 = *(void ***)(a3 + 8);
              }
              v326 = *(_QWORD *)(a3 + 16);
              *(_QWORD *)a3 = v370;
              *(_QWORD *)(a3 + 8) = v374;
              *(_QWORD *)(a3 + 16) = v371;
              if ( v373 != v325 )
              {
                do
                {
                  if ( (*(_BYTE *)(v373 - 3) & 1) != 0 )
                    free(*(v373 - 1));
                  v376 = v373 - 6;
                  if ( (*(_BYTE *)(v373 - 6) & 1) != 0 )
                    free(*(v373 - 4));
                  v373 -= 6;
                }
                while ( v325 != v376 );
              }
              goto LABEL_702;
            case 'h':
              *(_QWORD *)((char *)v389 + 7) = 0LL;
              v389[0] = 0LL;
              qmemcpy(v388, "decimal16", 9);
              v6 = *(_QWORD *)(a3 + 8);
              v279 = *(_QWORD *)(a3 + 16);
              if ( v6 < v279 )
              {
LABEL_543:
                *(_BYTE *)v6 = 18;
                v66 = v388[0];
                v3 = a1 + 2;
                goto LABEL_109;
              }
              v280 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v6 - *(_QWORD *)a3) >> 4);
              if ( v280 + 1 > 0x555555555555555LL )
                abort();
              v281 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v279 - *(_QWORD *)a3) >> 4);
              if ( v281 >= 0x2AAAAAAAAAAAAAALL || (2 * v281 >= v280 + 1 ? (v5 = 2 * v281) : (v5 = v280 + 1), v5) )
              {
                v282 = *(_QWORD *)(a3 + 24);
                v283 = *(char **)(v282 + 4096);
                if ( v282 + 4096 - (__int64)v283 >= (unsigned __int64)(48 * v5) )
                  *(_QWORD *)(v282 + 4096) = &v283[48 * v5];
                else
                  v283 = (char *)malloc(48 * v5);
              }
              else
              {
                v283 = 0LL;
              }
              v328 = &v283[48 * v280];
              *v328 = 18;
              v329 = &v283[48 * v5];
              *(_QWORD *)(v328 + 1) = v388[0];
              v328[10] = 0;
              v328[9] = v388[1];
              *(_DWORD *)(v328 + 11) = 0;
              *((_QWORD *)v328 + 2) = 0LL;
              v328[15] = 0;
              v388[0] = 0LL;
              LOBYTE(v388[1]) = 0;
              v328[24] = 0;
              *((_QWORD *)v328 + 4) = *(_QWORD *)((char *)v389 + 7);
              *((_QWORD *)v328 + 5) = 0LL;
              *(_QWORD *)(v328 + 25) = v389[0];
              *(_QWORD *)((char *)v389 + 7) = 0LL;
              v389[0] = 0LL;
              v331 = *(void ***)a3;
              v330 = *(void ***)(a3 + 8);
              v332 = v328 + 48;
              if ( v330 == *(void ***)a3 )
              {
                v325 = *(void ***)a3;
              }
              else
              {
                do
                {
                  *((_QWORD *)v328 - 4) = *(v330 - 4);
                  *((_OWORD *)v328 - 3) = *((_OWORD *)v330 - 3);
                  v333 = (__int64)*(v330 - 1);
                  *(v330 - 5) = 0LL;
                  *(v330 - 4) = 0LL;
                  *(v330 - 6) = 0LL;
                  *((_QWORD *)v328 - 1) = v333;
                  *(_OWORD *)(v328 - 24) = *(_OWORD *)(v330 - 3);
                  *(v330 - 2) = 0LL;
                  *(v330 - 1) = 0LL;
                  *(v330 - 3) = 0LL;
                  v330 -= 6;
                  v328 -= 48;
                }
                while ( v331 != v330 );
                v325 = *(void ***)a3;
                v331 = *(void ***)(a3 + 8);
              }
              v326 = *(_QWORD *)(a3 + 16);
              *(_QWORD *)a3 = v328;
              *(_QWORD *)(a3 + 8) = v332;
              *(_QWORD *)(a3 + 16) = v329;
              if ( v331 != v325 )
              {
                do
                {
                  if ( (*(_BYTE *)(v331 - 3) & 1) != 0 )
                    free(*(v331 - 1));
                  v334 = v331 - 6;
                  if ( (*(_BYTE *)(v331 - 6) & 1) != 0 )
                    free(*(v331 - 4));
                  v331 -= 6;
                }
                while ( v325 != v334 );
              }
              goto LABEL_702;
            case 'i':
              WORD2(v388[0]) = 0;
              LODWORD(v388[0]) = 0;
              *(_QWORD *)((char *)v389 + 7) = 0LL;
              v389[0] = 0LL;
              v6 = *(_QWORD *)(a3 + 8);
              v289 = *(_QWORD *)(a3 + 16);
              v290 = 0x745F323372616863LL;
              if ( v6 < v289 )
                goto LABEL_545;
              v291 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v6 - *(_QWORD *)a3) >> 4);
              if ( v291 + 1 > 0x555555555555555LL )
                abort();
              v292 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v289 - *(_QWORD *)a3) >> 4);
              if ( v292 >= 0x2AAAAAAAAAAAAAALL || (2 * v292 >= v291 + 1 ? (v5 = 2 * v292) : (v5 = v291 + 1), v5) )
              {
                v293 = *(_QWORD *)(a3 + 24);
                v294 = *(char **)(v293 + 4096);
                if ( v293 + 4096 - (__int64)v294 >= (unsigned __int64)(48 * v5) )
                  *(_QWORD *)(v293 + 4096) = &v294[48 * v5];
                else
                  v294 = (char *)malloc(48 * v5);
              }
              else
              {
                v294 = 0LL;
              }
              v349 = &v294[48 * v291];
              *v349 = 16;
              strcpy(v349 + 1, "char32_t");
              v350 = &v294[48 * v5];
              *((_WORD *)v349 + 7) = WORD2(v388[0]);
              *((_QWORD *)v349 + 2) = 0LL;
              *(_DWORD *)(v349 + 10) = v388[0];
              WORD2(v388[0]) = 0;
              LODWORD(v388[0]) = 0;
              v349[24] = 0;
              *((_QWORD *)v349 + 4) = *(_QWORD *)((char *)v389 + 7);
              *((_QWORD *)v349 + 5) = 0LL;
              *(_QWORD *)(v349 + 25) = v389[0];
              *(_QWORD *)((char *)v389 + 7) = 0LL;
              v389[0] = 0LL;
              v352 = *(void ***)a3;
              v351 = *(void ***)(a3 + 8);
              v353 = v349 + 48;
              if ( v351 == *(void ***)a3 )
              {
                v325 = *(void ***)a3;
              }
              else
              {
                do
                {
                  *((_QWORD *)v349 - 4) = *(v351 - 4);
                  *((_OWORD *)v349 - 3) = *((_OWORD *)v351 - 3);
                  v354 = (__int64)*(v351 - 1);
                  *(v351 - 5) = 0LL;
                  *(v351 - 4) = 0LL;
                  *(v351 - 6) = 0LL;
                  *((_QWORD *)v349 - 1) = v354;
                  *(_OWORD *)(v349 - 24) = *(_OWORD *)(v351 - 3);
                  *(v351 - 2) = 0LL;
                  *(v351 - 1) = 0LL;
                  *(v351 - 3) = 0LL;
                  v351 -= 6;
                  v349 -= 48;
                }
                while ( v352 != v351 );
                v325 = *(void ***)a3;
                v352 = *(void ***)(a3 + 8);
              }
              v326 = *(_QWORD *)(a3 + 16);
              *(_QWORD *)a3 = v349;
              *(_QWORD *)(a3 + 8) = v353;
              *(_QWORD *)(a3 + 16) = v350;
              if ( v352 != v325 )
              {
                do
                {
                  if ( (*(_BYTE *)(v352 - 3) & 1) != 0 )
                    free(*(v352 - 1));
                  v355 = v352 - 6;
                  if ( (*(_BYTE *)(v352 - 6) & 1) != 0 )
                    free(*(v352 - 4));
                  v352 -= 6;
                }
                while ( v325 != v355 );
              }
              goto LABEL_702;
            case 'n':
              *(_QWORD *)((char *)v389 + 7) = 0LL;
              v389[0] = 0LL;
              qmemcpy(v388, "std::nullptr_t", 14);
              v6 = *(_QWORD *)(a3 + 8);
              v295 = *(_QWORD *)(a3 + 16);
              if ( v6 < v295 )
              {
LABEL_539:
                *(_BYTE *)v6 = 28;
                v64 = *(_QWORD *)((char *)v388 + 6);
                v3 = a1 + 2;
                goto LABEL_103;
              }
              v303 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v6 - *(_QWORD *)a3) >> 4);
              if ( v303 + 1 > 0x555555555555555LL )
                abort();
              v304 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v295 - *(_QWORD *)a3) >> 4);
              if ( v304 >= 0x2AAAAAAAAAAAAAALL || (2 * v304 >= v303 + 1 ? (v5 = 2 * v304) : (v5 = v303 + 1), v5) )
              {
                v305 = *(_QWORD *)(a3 + 24);
                v306 = *(char **)(v305 + 4096);
                if ( v305 + 4096 - (__int64)v306 >= (unsigned __int64)(48 * v5) )
                  *(_QWORD *)(v305 + 4096) = &v306[48 * v5];
                else
                  v306 = (char *)malloc(48 * v5);
              }
              else
              {
                v306 = 0LL;
              }
              v356 = &v306[48 * v303];
              *v356 = 28;
              v357 = &v306[48 * v5];
              *(_QWORD *)(v356 + 7) = *(_QWORD *)((char *)v388 + 6);
              v356[15] = 0;
              *((_QWORD *)v356 + 2) = 0LL;
              *(_QWORD *)(v356 + 1) = v388[0];
              *(_QWORD *)((char *)v388 + 6) = 0LL;
              v388[0] = 0LL;
              v356[24] = 0;
              *((_QWORD *)v356 + 4) = *(_QWORD *)((char *)v389 + 7);
              *((_QWORD *)v356 + 5) = 0LL;
              *(_QWORD *)(v356 + 25) = v389[0];
              *(_QWORD *)((char *)v389 + 7) = 0LL;
              v389[0] = 0LL;
              v359 = *(void ***)a3;
              v358 = *(void ***)(a3 + 8);
              v360 = v356 + 48;
              if ( v358 == *(void ***)a3 )
              {
                v325 = *(void ***)a3;
              }
              else
              {
                do
                {
                  *((_QWORD *)v356 - 4) = *(v358 - 4);
                  *((_OWORD *)v356 - 3) = *((_OWORD *)v358 - 3);
                  v361 = (__int64)*(v358 - 1);
                  *(v358 - 5) = 0LL;
                  *(v358 - 4) = 0LL;
                  *(v358 - 6) = 0LL;
                  *((_QWORD *)v356 - 1) = v361;
                  *(_OWORD *)(v356 - 24) = *(_OWORD *)(v358 - 3);
                  *(v358 - 2) = 0LL;
                  *(v358 - 1) = 0LL;
                  *(v358 - 3) = 0LL;
                  v358 -= 6;
                  v356 -= 48;
                }
                while ( v359 != v358 );
                v325 = *(void ***)a3;
                v359 = *(void ***)(a3 + 8);
              }
              v326 = *(_QWORD *)(a3 + 16);
              *(_QWORD *)a3 = v356;
              *(_QWORD *)(a3 + 8) = v360;
              *(_QWORD *)(a3 + 16) = v357;
              if ( v359 != v325 )
              {
                do
                {
                  if ( (*(_BYTE *)(v359 - 3) & 1) != 0 )
                    free(*(v359 - 1));
                  v362 = v359 - 6;
                  if ( (*(_BYTE *)(v359 - 6) & 1) != 0 )
                    free(*(v359 - 4));
                  v359 -= 6;
                }
                while ( v325 != v362 );
              }
              goto LABEL_702;
            case 's':
              WORD2(v388[0]) = 0;
              LODWORD(v388[0]) = 0;
              *(_QWORD *)((char *)v389 + 7) = 0LL;
              v389[0] = 0LL;
              v6 = *(_QWORD *)(a3 + 8);
              v298 = *(_QWORD *)(a3 + 16);
              v290 = 0x745F363172616863LL;
              if ( v6 < v298 )
              {
LABEL_545:
                *(_QWORD *)(v6 + 1) = v290;
                *(_BYTE *)(v6 + 9) = 0;
                *(_BYTE *)v6 = 16;
                v19 = WORD2(v388[0]);
                v3 = a1 + 2;
                goto LABEL_20;
              }
              v315 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v6 - *(_QWORD *)a3) >> 4);
              if ( v315 + 1 > 0x555555555555555LL )
                abort();
              v316 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v298 - *(_QWORD *)a3) >> 4);
              if ( v316 >= 0x2AAAAAAAAAAAAAALL || (2 * v316 >= v315 + 1 ? (v5 = 2 * v316) : (v5 = v315 + 1), v5) )
              {
                v317 = *(_QWORD *)(a3 + 24);
                v318 = *(char **)(v317 + 4096);
                if ( v317 + 4096 - (__int64)v318 >= (unsigned __int64)(48 * v5) )
                  *(_QWORD *)(v317 + 4096) = &v318[48 * v5];
                else
                  v318 = (char *)malloc(48 * v5);
              }
              else
              {
                v318 = 0LL;
              }
              v377 = &v318[48 * v315];
              *v377 = 16;
              strcpy(v377 + 1, "char16_t");
              v378 = &v318[48 * v5];
              *((_WORD *)v377 + 7) = WORD2(v388[0]);
              *((_QWORD *)v377 + 2) = 0LL;
              *(_DWORD *)(v377 + 10) = v388[0];
              WORD2(v388[0]) = 0;
              LODWORD(v388[0]) = 0;
              v377[24] = 0;
              *((_QWORD *)v377 + 4) = *(_QWORD *)((char *)v389 + 7);
              *((_QWORD *)v377 + 5) = 0LL;
              *(_QWORD *)(v377 + 25) = v389[0];
              *(_QWORD *)((char *)v389 + 7) = 0LL;
              v389[0] = 0LL;
              v380 = *(void ***)a3;
              v379 = *(void ***)(a3 + 8);
              v381 = v377 + 48;
              if ( v379 == *(void ***)a3 )
              {
                v325 = *(void ***)a3;
              }
              else
              {
                do
                {
                  *((_QWORD *)v377 - 4) = *(v379 - 4);
                  *((_OWORD *)v377 - 3) = *((_OWORD *)v379 - 3);
                  v382 = (__int64)*(v379 - 1);
                  *(v379 - 5) = 0LL;
                  *(v379 - 4) = 0LL;
                  *(v379 - 6) = 0LL;
                  *((_QWORD *)v377 - 1) = v382;
                  *(_OWORD *)(v377 - 24) = *(_OWORD *)(v379 - 3);
                  *(v379 - 2) = 0LL;
                  *(v379 - 1) = 0LL;
                  *(v379 - 3) = 0LL;
                  v379 -= 6;
                  v377 -= 48;
                }
                while ( v380 != v379 );
                v325 = *(void ***)a3;
                v380 = *(void ***)(a3 + 8);
              }
              v326 = *(_QWORD *)(a3 + 16);
              *(_QWORD *)a3 = v377;
              *(_QWORD *)(a3 + 8) = v381;
              *(_QWORD *)(a3 + 16) = v378;
              if ( v380 != v325 )
              {
                do
                {
                  if ( (*(_BYTE *)(v380 - 3) & 1) != 0 )
                    free(*(v380 - 1));
                  v383 = v380 - 6;
                  if ( (*(_BYTE *)(v380 - 6) & 1) != 0 )
                    free(*(v380 - 4));
                  v380 -= 6;
                }
                while ( v325 != v383 );
              }
LABEL_702:
              if ( !v325 )
                goto LABEL_708;
              v384 = *(_QWORD *)(a3 + 24);
              if ( v384 + 4096 < (unsigned __int64)v325 || v384 > (unsigned __int64)v325 )
              {
                free(v325);
              }
              else if ( *(_QWORD *)(v384 + 4096) == v326 )
              {
                *(_QWORD *)(v384 + 4096) = v325;
                v3 += 2;
                return v3;
              }
LABEL_708:
              v3 += 2;
              break;
            default:
              return v3;
          }
        }
        return v3;
      case 'a':
        *(_QWORD *)((char *)v389 + 7) = 0LL;
        v389[0] = 0LL;
        qmemcpy(v388, "signed char", 11);
        v6 = *(_QWORD *)(a3 + 8);
        v49 = *(_QWORD *)(a3 + 16);
        if ( v6 < v49 )
          goto LABEL_76;
        v91 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v6 - *(_QWORD *)a3) >> 4);
        if ( v91 + 1 > 0x555555555555555LL )
          abort();
        v92 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v49 - *(_QWORD *)a3) >> 4);
        if ( v92 >= 0x2AAAAAAAAAAAAAALL || (2 * v92 >= v91 + 1 ? (v5 = 2 * v92) : (v5 = v91 + 1), v5) )
        {
          v93 = *(_QWORD *)(a3 + 24);
          v94 = *(char **)(v93 + 4096);
          if ( v93 + 4096 - (__int64)v94 >= (unsigned __int64)(48 * v5) )
            *(_QWORD *)(v93 + 4096) = &v94[48 * v5];
          else
            v94 = (char *)malloc(48 * v5);
        }
        else
        {
          v94 = 0LL;
        }
        v209 = &v94[48 * v91];
        *v209 = 22;
        v210 = &v94[48 * v5];
        *(_QWORD *)(v209 + 1) = v388[0];
        v209[11] = BYTE2(v388[1]);
        v209[12] = 0;
        *(_WORD *)(v209 + 9) = v388[1];
        *(_WORD *)(v209 + 13) = 0;
        *((_QWORD *)v209 + 2) = 0LL;
        v209[15] = 0;
        v388[0] = 0LL;
        LOWORD(v388[1]) = 0;
        BYTE2(v388[1]) = 0;
        v209[24] = 0;
        *((_QWORD *)v209 + 4) = *(_QWORD *)((char *)v389 + 7);
        *((_QWORD *)v209 + 5) = 0LL;
        *(_QWORD *)(v209 + 25) = v389[0];
        *(_QWORD *)((char *)v389 + 7) = 0LL;
        v389[0] = 0LL;
        v212 = *(void ***)a3;
        v211 = *(void ***)(a3 + 8);
        v213 = v209 + 48;
        if ( v211 == *(void ***)a3 )
        {
          v129 = *(void ***)a3;
        }
        else
        {
          do
          {
            *((_QWORD *)v209 - 4) = *(v211 - 4);
            *((_OWORD *)v209 - 3) = *((_OWORD *)v211 - 3);
            v214 = (__int64)*(v211 - 1);
            *(v211 - 5) = 0LL;
            *(v211 - 4) = 0LL;
            *(v211 - 6) = 0LL;
            *((_QWORD *)v209 - 1) = v214;
            *(_OWORD *)(v209 - 24) = *(_OWORD *)(v211 - 3);
            *(v211 - 2) = 0LL;
            *(v211 - 1) = 0LL;
            *(v211 - 3) = 0LL;
            v211 -= 6;
            v209 -= 48;
          }
          while ( v212 != v211 );
          v129 = *(void ***)a3;
          v212 = *(void ***)(a3 + 8);
        }
        v130 = *(_QWORD *)(a3 + 16);
        *(_QWORD *)a3 = v209;
        *(_QWORD *)(a3 + 8) = v213;
        *(_QWORD *)(a3 + 16) = v210;
        if ( v212 != v129 )
        {
          do
          {
            if ( (*(_BYTE *)(v212 - 3) & 1) != 0 )
              free(*(v212 - 1));
            v215 = v212 - 6;
            if ( (*(_BYTE *)(v212 - 6) & 1) != 0 )
              free(*(v212 - 4));
            v212 -= 6;
          }
          while ( v129 != v215 );
        }
        goto LABEL_494;
      case 'b':
        LOWORD(v388[1]) = 0;
        v388[0] = 0LL;
        *(_QWORD *)((char *)v389 + 7) = 0LL;
        v389[0] = 0LL;
        v6 = *(_QWORD *)(a3 + 8);
        v21 = *(_QWORD *)(a3 + 16);
        v10 = 1819242338;
        if ( v6 < v21 )
          goto LABEL_73;
        v22 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v6 - *(_QWORD *)a3) >> 4);
        if ( v22 + 1 > 0x555555555555555LL )
          abort();
        v23 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v21 - *(_QWORD *)a3) >> 4);
        if ( v23 >= 0x2AAAAAAAAAAAAAALL || (2 * v23 >= v22 + 1 ? (v5 = 2 * v23) : (v5 = v22 + 1), v5) )
        {
          v24 = *(_QWORD *)(a3 + 24);
          v25 = *(char **)(v24 + 4096);
          if ( v24 + 4096 - (__int64)v25 >= (unsigned __int64)(48 * v5) )
            *(_QWORD *)(v24 + 4096) = &v25[48 * v5];
          else
            v25 = (char *)malloc(48 * v5);
        }
        else
        {
          v25 = 0LL;
        }
        v153 = &v25[48 * v22];
        *v153 = 8;
        strcpy(v153 + 1, "bool");
        v154 = &v25[48 * v5];
        *((_WORD *)v153 + 7) = v388[1];
        *((_QWORD *)v153 + 2) = 0LL;
        *(_QWORD *)(v153 + 6) = v388[0];
        LOWORD(v388[1]) = 0;
        v388[0] = 0LL;
        v153[24] = 0;
        *((_QWORD *)v153 + 4) = *(_QWORD *)((char *)v389 + 7);
        *((_QWORD *)v153 + 5) = 0LL;
        *(_QWORD *)(v153 + 25) = v389[0];
        *(_QWORD *)((char *)v389 + 7) = 0LL;
        v389[0] = 0LL;
        v156 = *(void ***)a3;
        v155 = *(void ***)(a3 + 8);
        v157 = v153 + 48;
        if ( v155 == *(void ***)a3 )
        {
          v129 = *(void ***)a3;
        }
        else
        {
          do
          {
            *((_QWORD *)v153 - 4) = *(v155 - 4);
            *((_OWORD *)v153 - 3) = *((_OWORD *)v155 - 3);
            v158 = (__int64)*(v155 - 1);
            *(v155 - 5) = 0LL;
            *(v155 - 4) = 0LL;
            *(v155 - 6) = 0LL;
            *((_QWORD *)v153 - 1) = v158;
            *(_OWORD *)(v153 - 24) = *(_OWORD *)(v155 - 3);
            *(v155 - 2) = 0LL;
            *(v155 - 1) = 0LL;
            *(v155 - 3) = 0LL;
            v155 -= 6;
            v153 -= 48;
          }
          while ( v156 != v155 );
          v129 = *(void ***)a3;
          v156 = *(void ***)(a3 + 8);
        }
        v130 = *(_QWORD *)(a3 + 16);
        *(_QWORD *)a3 = v153;
        *(_QWORD *)(a3 + 8) = v157;
        *(_QWORD *)(a3 + 16) = v154;
        if ( v156 != v129 )
        {
          do
          {
            if ( (*(_BYTE *)(v156 - 3) & 1) != 0 )
              free(*(v156 - 1));
            v159 = v156 - 6;
            if ( (*(_BYTE *)(v156 - 6) & 1) != 0 )
              free(*(v156 - 4));
            v156 -= 6;
          }
          while ( v129 != v159 );
        }
        goto LABEL_494;
      case 'c':
        LOWORD(v388[1]) = 0;
        v388[0] = 0LL;
        *(_QWORD *)((char *)v389 + 7) = 0LL;
        v389[0] = 0LL;
        v6 = *(_QWORD *)(a3 + 8);
        v48 = *(_QWORD *)(a3 + 16);
        v10 = 1918986339;
        if ( v6 < v48 )
          goto LABEL_73;
        v87 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v6 - *(_QWORD *)a3) >> 4);
        if ( v87 + 1 > 0x555555555555555LL )
          abort();
        v88 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v48 - *(_QWORD *)a3) >> 4);
        if ( v88 >= 0x2AAAAAAAAAAAAAALL || (2 * v88 >= v87 + 1 ? (v5 = 2 * v88) : (v5 = v87 + 1), v5) )
        {
          v89 = *(_QWORD *)(a3 + 24);
          v90 = *(char **)(v89 + 4096);
          if ( v89 + 4096 - (__int64)v90 >= (unsigned __int64)(48 * v5) )
            *(_QWORD *)(v89 + 4096) = &v90[48 * v5];
          else
            v90 = (char *)malloc(48 * v5);
        }
        else
        {
          v90 = 0LL;
        }
        v202 = &v90[48 * v87];
        *v202 = 8;
        strcpy(v202 + 1, "char");
        v203 = &v90[48 * v5];
        *((_WORD *)v202 + 7) = v388[1];
        *((_QWORD *)v202 + 2) = 0LL;
        *(_QWORD *)(v202 + 6) = v388[0];
        LOWORD(v388[1]) = 0;
        v388[0] = 0LL;
        v202[24] = 0;
        *((_QWORD *)v202 + 4) = *(_QWORD *)((char *)v389 + 7);
        *((_QWORD *)v202 + 5) = 0LL;
        *(_QWORD *)(v202 + 25) = v389[0];
        *(_QWORD *)((char *)v389 + 7) = 0LL;
        v389[0] = 0LL;
        v205 = *(void ***)a3;
        v204 = *(void ***)(a3 + 8);
        v206 = v202 + 48;
        if ( v204 == *(void ***)a3 )
        {
          v129 = *(void ***)a3;
        }
        else
        {
          do
          {
            *((_QWORD *)v202 - 4) = *(v204 - 4);
            *((_OWORD *)v202 - 3) = *((_OWORD *)v204 - 3);
            v207 = (__int64)*(v204 - 1);
            *(v204 - 5) = 0LL;
            *(v204 - 4) = 0LL;
            *(v204 - 6) = 0LL;
            *((_QWORD *)v202 - 1) = v207;
            *(_OWORD *)(v202 - 24) = *(_OWORD *)(v204 - 3);
            *(v204 - 2) = 0LL;
            *(v204 - 1) = 0LL;
            *(v204 - 3) = 0LL;
            v204 -= 6;
            v202 -= 48;
          }
          while ( v205 != v204 );
          v129 = *(void ***)a3;
          v205 = *(void ***)(a3 + 8);
        }
        v130 = *(_QWORD *)(a3 + 16);
        *(_QWORD *)a3 = v202;
        *(_QWORD *)(a3 + 8) = v206;
        *(_QWORD *)(a3 + 16) = v203;
        if ( v205 != v129 )
        {
          do
          {
            if ( (*(_BYTE *)(v205 - 3) & 1) != 0 )
              free(*(v205 - 1));
            v208 = v205 - 6;
            if ( (*(_BYTE *)(v205 - 6) & 1) != 0 )
              free(*(v205 - 4));
            v205 -= 6;
          }
          while ( v129 != v208 );
        }
        goto LABEL_494;
      case 'd':
        *(_QWORD *)((char *)v389 + 7) = 0LL;
        v389[0] = 0LL;
        qmemcpy(v388, "double", 6);
        v6 = *(_QWORD *)(a3 + 8);
        v26 = *(_QWORD *)(a3 + 16);
        if ( v6 < v26 )
        {
          *(_BYTE *)v6 = 12;
          v3 = a1 + 1;
          *(_DWORD *)(v6 + 1) = v388[0];
          *(_BYTE *)(v6 + 7) = 0;
          *(_QWORD *)(v6 + 8) = 0LL;
          *(_QWORD *)(v6 + 16) = 0LL;
          *(_WORD *)(v6 + 5) = WORD2(v388[0]);
          LODWORD(v388[0]) = 0;
          WORD2(v388[0]) = 0;
          goto LABEL_105;
        }
        v79 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v6 - *(_QWORD *)a3) >> 4);
        if ( v79 + 1 > 0x555555555555555LL )
          abort();
        v80 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v26 - *(_QWORD *)a3) >> 4);
        if ( v80 >= 0x2AAAAAAAAAAAAAALL || (2 * v80 >= v79 + 1 ? (v5 = 2 * v80) : (v5 = v79 + 1), v5) )
        {
          v81 = *(_QWORD *)(a3 + 24);
          v82 = *(char **)(v81 + 4096);
          if ( v81 + 4096 - (__int64)v82 >= (unsigned __int64)(48 * v5) )
            *(_QWORD *)(v81 + 4096) = &v82[48 * v5];
          else
            v82 = (char *)malloc(48 * v5);
        }
        else
        {
          v82 = 0LL;
        }
        v160 = &v82[48 * v79];
        *v160 = 12;
        v161 = &v82[48 * v5];
        *(_DWORD *)(v160 + 1) = v388[0];
        v160[7] = 0;
        *((_QWORD *)v160 + 1) = 0LL;
        *((_QWORD *)v160 + 2) = 0LL;
        *(_WORD *)(v160 + 5) = WORD2(v388[0]);
        LODWORD(v388[0]) = 0;
        WORD2(v388[0]) = 0;
        v160[24] = 0;
        *((_QWORD *)v160 + 4) = *(_QWORD *)((char *)v389 + 7);
        *((_QWORD *)v160 + 5) = 0LL;
        *(_QWORD *)(v160 + 25) = v389[0];
        *(_QWORD *)((char *)v389 + 7) = 0LL;
        v389[0] = 0LL;
        v163 = *(void ***)a3;
        v162 = *(void ***)(a3 + 8);
        v164 = v160 + 48;
        if ( v162 == *(void ***)a3 )
        {
          v129 = *(void ***)a3;
        }
        else
        {
          do
          {
            *((_QWORD *)v160 - 4) = *(v162 - 4);
            *((_OWORD *)v160 - 3) = *((_OWORD *)v162 - 3);
            v165 = (__int64)*(v162 - 1);
            *(v162 - 5) = 0LL;
            *(v162 - 4) = 0LL;
            *(v162 - 6) = 0LL;
            *((_QWORD *)v160 - 1) = v165;
            *(_OWORD *)(v160 - 24) = *(_OWORD *)(v162 - 3);
            *(v162 - 2) = 0LL;
            *(v162 - 1) = 0LL;
            *(v162 - 3) = 0LL;
            v162 -= 6;
            v160 -= 48;
          }
          while ( v163 != v162 );
          v129 = *(void ***)a3;
          v163 = *(void ***)(a3 + 8);
        }
        v130 = *(_QWORD *)(a3 + 16);
        *(_QWORD *)a3 = v160;
        *(_QWORD *)(a3 + 8) = v164;
        *(_QWORD *)(a3 + 16) = v161;
        if ( v163 != v129 )
        {
          do
          {
            if ( (*(_BYTE *)(v163 - 3) & 1) != 0 )
              free(*(v163 - 1));
            v166 = v163 - 6;
            if ( (*(_BYTE *)(v163 - 6) & 1) != 0 )
              free(*(v163 - 4));
            v163 -= 6;
          }
          while ( v129 != v166 );
        }
        goto LABEL_494;
      case 'e':
        *(_QWORD *)((char *)v389 + 7) = 0LL;
        v389[0] = 0LL;
        qmemcpy(v388, "long double", 11);
        v6 = *(_QWORD *)(a3 + 8);
        v38 = *(_QWORD *)(a3 + 16);
        if ( v6 < v38 )
        {
LABEL_76:
          *(_BYTE *)v6 = 22;
          v3 = a1 + 1;
          *(_QWORD *)(v6 + 1) = v388[0];
          *(_BYTE *)(v6 + 11) = BYTE2(v388[1]);
          *(_BYTE *)(v6 + 12) = 0;
          *(_WORD *)(v6 + 9) = v388[1];
          *(_WORD *)(v6 + 13) = 0;
          *(_QWORD *)(v6 + 16) = 0LL;
          *(_BYTE *)(v6 + 15) = 0;
          v388[0] = 0LL;
          LOWORD(v388[1]) = 0;
          BYTE2(v388[1]) = 0;
          goto LABEL_105;
        }
        v39 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v6 - *(_QWORD *)a3) >> 4);
        if ( v39 + 1 > 0x555555555555555LL )
          abort();
        v40 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v38 - *(_QWORD *)a3) >> 4);
        if ( v40 >= 0x2AAAAAAAAAAAAAALL || (2 * v40 >= v39 + 1 ? (v5 = 2 * v40) : (v5 = v39 + 1), v5) )
        {
          v41 = *(_QWORD *)(a3 + 24);
          v42 = *(char **)(v41 + 4096);
          if ( v41 + 4096 - (__int64)v42 >= (unsigned __int64)(48 * v5) )
            *(_QWORD *)(v41 + 4096) = &v42[48 * v5];
          else
            v42 = (char *)malloc(48 * v5);
        }
        else
        {
          v42 = 0LL;
        }
        v188 = &v42[48 * v39];
        *v188 = 22;
        v189 = &v42[48 * v5];
        *(_QWORD *)(v188 + 1) = v388[0];
        v188[11] = BYTE2(v388[1]);
        v188[12] = 0;
        *(_WORD *)(v188 + 9) = v388[1];
        *(_WORD *)(v188 + 13) = 0;
        *((_QWORD *)v188 + 2) = 0LL;
        v188[15] = 0;
        v388[0] = 0LL;
        LOWORD(v388[1]) = 0;
        BYTE2(v388[1]) = 0;
        v188[24] = 0;
        *((_QWORD *)v188 + 4) = *(_QWORD *)((char *)v389 + 7);
        *((_QWORD *)v188 + 5) = 0LL;
        *(_QWORD *)(v188 + 25) = v389[0];
        *(_QWORD *)((char *)v389 + 7) = 0LL;
        v389[0] = 0LL;
        v191 = *(void ***)a3;
        v190 = *(void ***)(a3 + 8);
        v192 = v188 + 48;
        if ( v190 == *(void ***)a3 )
        {
          v129 = *(void ***)a3;
        }
        else
        {
          do
          {
            *((_QWORD *)v188 - 4) = *(v190 - 4);
            *((_OWORD *)v188 - 3) = *((_OWORD *)v190 - 3);
            v193 = (__int64)*(v190 - 1);
            *(v190 - 5) = 0LL;
            *(v190 - 4) = 0LL;
            *(v190 - 6) = 0LL;
            *((_QWORD *)v188 - 1) = v193;
            *(_OWORD *)(v188 - 24) = *(_OWORD *)(v190 - 3);
            *(v190 - 2) = 0LL;
            *(v190 - 1) = 0LL;
            *(v190 - 3) = 0LL;
            v190 -= 6;
            v188 -= 48;
          }
          while ( v191 != v190 );
          v129 = *(void ***)a3;
          v191 = *(void ***)(a3 + 8);
        }
        v130 = *(_QWORD *)(a3 + 16);
        *(_QWORD *)a3 = v188;
        *(_QWORD *)(a3 + 8) = v192;
        *(_QWORD *)(a3 + 16) = v189;
        if ( v191 != v129 )
        {
          do
          {
            if ( (*(_BYTE *)(v191 - 3) & 1) != 0 )
              free(*(v191 - 1));
            v194 = v191 - 6;
            if ( (*(_BYTE *)(v191 - 6) & 1) != 0 )
              free(*(v191 - 4));
            v191 -= 6;
          }
          while ( v129 != v194 );
        }
        goto LABEL_494;
      case 'f':
        v388[0] = 0LL;
        LOBYTE(v388[1]) = 0;
        *(_QWORD *)((char *)v389 + 7) = 0LL;
        v389[0] = 0LL;
        v386 = 1634692198;
        v6 = *(_QWORD *)(a3 + 8);
        v50 = *(_QWORD *)(a3 + 16);
        if ( v6 < v50 )
          goto LABEL_93;
        v51 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v6 - *(_QWORD *)a3) >> 4);
        if ( v51 + 1 > 0x555555555555555LL )
          abort();
        v52 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v50 - *(_QWORD *)a3) >> 4);
        if ( v52 >= 0x2AAAAAAAAAAAAAALL || (2 * v52 >= v51 + 1 ? (v5 = 2 * v52) : (v5 = v51 + 1), v5) )
        {
          v53 = *(_QWORD *)(a3 + 24);
          v54 = *(char **)(v53 + 4096);
          if ( v53 + 4096 - (__int64)v54 >= (unsigned __int64)(48 * v5) )
            *(_QWORD *)(v53 + 4096) = &v54[48 * v5];
          else
            v54 = (char *)malloc(48 * v5);
        }
        else
        {
          v54 = 0LL;
        }
        v216 = &v54[48 * v51];
        *v216 = 10;
        v217 = &v54[48 * v5];
        *(_DWORD *)(v216 + 1) = 1634692198;
        v216[6] = 0;
        v216[5] = 116;
        *(_QWORD *)(v216 + 7) = v388[0];
        *((_QWORD *)v216 + 2) = 0LL;
        v216[15] = v388[1];
        LOBYTE(v388[1]) = 0;
        v388[0] = 0LL;
        v216[24] = 0;
        *((_QWORD *)v216 + 4) = *(_QWORD *)((char *)v389 + 7);
        *((_QWORD *)v216 + 5) = 0LL;
        *(_QWORD *)(v216 + 25) = v389[0];
        *(_QWORD *)((char *)v389 + 7) = 0LL;
        v389[0] = 0LL;
        v219 = *(void ***)a3;
        v218 = *(void ***)(a3 + 8);
        v220 = v216 + 48;
        if ( v218 == *(void ***)a3 )
        {
          v129 = *(void ***)a3;
        }
        else
        {
          do
          {
            *((_QWORD *)v216 - 4) = *(v218 - 4);
            *((_OWORD *)v216 - 3) = *((_OWORD *)v218 - 3);
            v221 = (__int64)*(v218 - 1);
            *(v218 - 5) = 0LL;
            *(v218 - 4) = 0LL;
            *(v218 - 6) = 0LL;
            *((_QWORD *)v216 - 1) = v221;
            *(_OWORD *)(v216 - 24) = *(_OWORD *)(v218 - 3);
            *(v218 - 2) = 0LL;
            *(v218 - 1) = 0LL;
            *(v218 - 3) = 0LL;
            v218 -= 6;
            v216 -= 48;
          }
          while ( v219 != v218 );
          v129 = *(void ***)a3;
          v219 = *(void ***)(a3 + 8);
        }
        v130 = *(_QWORD *)(a3 + 16);
        *(_QWORD *)a3 = v216;
        *(_QWORD *)(a3 + 8) = v220;
        *(_QWORD *)(a3 + 16) = v217;
        if ( v219 != v129 )
        {
          do
          {
            if ( (*(_BYTE *)(v219 - 3) & 1) != 0 )
              free(*(v219 - 1));
            v222 = v219 - 6;
            if ( (*(_BYTE *)(v219 - 6) & 1) != 0 )
              free(*(v219 - 4));
            v219 -= 6;
          }
          while ( v129 != v222 );
        }
        goto LABEL_494;
      case 'g':
        *(_QWORD *)((char *)v389 + 7) = 0LL;
        v389[0] = 0LL;
        qmemcpy(v388, "__float128", 10);
        v6 = *(_QWORD *)(a3 + 8);
        v55 = *(_QWORD *)(a3 + 16);
        if ( v6 < v55 )
        {
          *(_BYTE *)v6 = 20;
          v56 = v388[0];
          v3 = a1 + 1;
LABEL_88:
          *(_QWORD *)(v6 + 1) = v56;
          *(_BYTE *)(v6 + 11) = 0;
          *(_DWORD *)(v6 + 12) = 0;
          *(_QWORD *)(v6 + 16) = 0LL;
          *(_WORD *)(v6 + 9) = v388[1];
          v388[0] = 0LL;
          LOWORD(v388[1]) = 0;
          goto LABEL_105;
        }
        v95 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v6 - *(_QWORD *)a3) >> 4);
        if ( v95 + 1 > 0x555555555555555LL )
          abort();
        v96 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v55 - *(_QWORD *)a3) >> 4);
        if ( v96 >= 0x2AAAAAAAAAAAAAALL || (2 * v96 >= v95 + 1 ? (v5 = 2 * v96) : (v5 = v95 + 1), v5) )
        {
          v97 = *(_QWORD *)(a3 + 24);
          v98 = *(char **)(v97 + 4096);
          if ( v97 + 4096 - (__int64)v98 >= (unsigned __int64)(48 * v5) )
            *(_QWORD *)(v97 + 4096) = &v98[48 * v5];
          else
            v98 = (char *)malloc(48 * v5);
        }
        else
        {
          v98 = 0LL;
        }
        v223 = &v98[48 * v95];
        *v223 = 20;
        v224 = &v98[48 * v5];
        *(_QWORD *)(v223 + 1) = v388[0];
        v223[11] = 0;
        *((_DWORD *)v223 + 3) = 0;
        *((_QWORD *)v223 + 2) = 0LL;
        *(_WORD *)(v223 + 9) = v388[1];
        v388[0] = 0LL;
        LOWORD(v388[1]) = 0;
        v223[24] = 0;
        *((_QWORD *)v223 + 4) = *(_QWORD *)((char *)v389 + 7);
        *((_QWORD *)v223 + 5) = 0LL;
        *(_QWORD *)(v223 + 25) = v389[0];
        *(_QWORD *)((char *)v389 + 7) = 0LL;
        v389[0] = 0LL;
        v226 = *(void ***)a3;
        v225 = *(void ***)(a3 + 8);
        v227 = v223 + 48;
        if ( v225 == *(void ***)a3 )
        {
          v129 = *(void ***)a3;
        }
        else
        {
          do
          {
            *((_QWORD *)v223 - 4) = *(v225 - 4);
            *((_OWORD *)v223 - 3) = *((_OWORD *)v225 - 3);
            v228 = (__int64)*(v225 - 1);
            *(v225 - 5) = 0LL;
            *(v225 - 4) = 0LL;
            *(v225 - 6) = 0LL;
            *((_QWORD *)v223 - 1) = v228;
            *(_OWORD *)(v223 - 24) = *(_OWORD *)(v225 - 3);
            *(v225 - 2) = 0LL;
            *(v225 - 1) = 0LL;
            *(v225 - 3) = 0LL;
            v225 -= 6;
            v223 -= 48;
          }
          while ( v226 != v225 );
          v129 = *(void ***)a3;
          v226 = *(void ***)(a3 + 8);
        }
        v130 = *(_QWORD *)(a3 + 16);
        *(_QWORD *)a3 = v223;
        *(_QWORD *)(a3 + 8) = v227;
        *(_QWORD *)(a3 + 16) = v224;
        if ( v226 != v129 )
        {
          do
          {
            if ( (*(_BYTE *)(v226 - 3) & 1) != 0 )
              free(*(v226 - 1));
            v229 = v226 - 6;
            if ( (*(_BYTE *)(v226 - 6) & 1) != 0 )
              free(*(v226 - 4));
            v226 -= 6;
          }
          while ( v129 != v229 );
        }
        goto LABEL_494;
      case 'h':
        *(_QWORD *)((char *)v389 + 7) = 0LL;
        v389[0] = 0LL;
        qmemcpy(v388, "unsigned char", 13);
        v6 = *(_QWORD *)(a3 + 8);
        v60 = *(_QWORD *)(a3 + 16);
        if ( v6 < v60 )
          goto LABEL_97;
        v111 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v6 - *(_QWORD *)a3) >> 4);
        if ( v111 + 1 > 0x555555555555555LL )
          abort();
        v112 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v60 - *(_QWORD *)a3) >> 4);
        if ( v112 >= 0x2AAAAAAAAAAAAAALL || (2 * v112 >= v111 + 1 ? (v5 = 2 * v112) : (v5 = v111 + 1), v5) )
        {
          v113 = *(_QWORD *)(a3 + 24);
          v114 = *(char **)(v113 + 4096);
          if ( v113 + 4096 - (__int64)v114 >= (unsigned __int64)(48 * v5) )
            *(_QWORD *)(v113 + 4096) = &v114[48 * v5];
          else
            v114 = (char *)malloc(48 * v5);
        }
        else
        {
          v114 = 0LL;
        }
        v251 = &v114[48 * v111];
        *v251 = 26;
        v252 = &v114[48 * v5];
        *(_QWORD *)(v251 + 6) = *(_QWORD *)((char *)v388 + 5);
        *((_WORD *)v251 + 7) = 0;
        *((_QWORD *)v251 + 2) = 0LL;
        *(_QWORD *)(v251 + 1) = v388[0];
        *(_QWORD *)((char *)v388 + 5) = 0LL;
        v388[0] = 0LL;
        v251[24] = 0;
        *((_QWORD *)v251 + 4) = *(_QWORD *)((char *)v389 + 7);
        *((_QWORD *)v251 + 5) = 0LL;
        *(_QWORD *)(v251 + 25) = v389[0];
        *(_QWORD *)((char *)v389 + 7) = 0LL;
        v389[0] = 0LL;
        v254 = *(void ***)a3;
        v253 = *(void ***)(a3 + 8);
        v255 = v251 + 48;
        if ( v253 == *(void ***)a3 )
        {
          v129 = *(void ***)a3;
        }
        else
        {
          do
          {
            *((_QWORD *)v251 - 4) = *(v253 - 4);
            *((_OWORD *)v251 - 3) = *((_OWORD *)v253 - 3);
            v256 = (__int64)*(v253 - 1);
            *(v253 - 5) = 0LL;
            *(v253 - 4) = 0LL;
            *(v253 - 6) = 0LL;
            *((_QWORD *)v251 - 1) = v256;
            *(_OWORD *)(v251 - 24) = *(_OWORD *)(v253 - 3);
            *(v253 - 2) = 0LL;
            *(v253 - 1) = 0LL;
            *(v253 - 3) = 0LL;
            v253 -= 6;
            v251 -= 48;
          }
          while ( v254 != v253 );
          v129 = *(void ***)a3;
          v254 = *(void ***)(a3 + 8);
        }
        v130 = *(_QWORD *)(a3 + 16);
        *(_QWORD *)a3 = v251;
        *(_QWORD *)(a3 + 8) = v255;
        *(_QWORD *)(a3 + 16) = v252;
        if ( v254 != v129 )
        {
          do
          {
            if ( (*(_BYTE *)(v254 - 3) & 1) != 0 )
              free(*(v254 - 1));
            v257 = v254 - 6;
            if ( (*(_BYTE *)(v254 - 6) & 1) != 0 )
              free(*(v254 - 4));
            v254 -= 6;
          }
          while ( v129 != v257 );
        }
        goto LABEL_494;
      case 'i':
        v388[0] = 0LL;
        BYTE2(v388[1]) = 0;
        LOWORD(v388[1]) = 0;
        *(_QWORD *)((char *)v389 + 7) = 0LL;
        v389[0] = 0LL;
        v387 = 116;
        v385 = 28265;
        v6 = *(_QWORD *)(a3 + 8);
        v59 = *(_QWORD *)(a3 + 16);
        if ( v6 < v59 )
          goto LABEL_95;
        v107 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v6 - *(_QWORD *)a3) >> 4);
        if ( v107 + 1 > 0x555555555555555LL )
          abort();
        v108 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v59 - *(_QWORD *)a3) >> 4);
        if ( v108 >= 0x2AAAAAAAAAAAAAALL || (2 * v108 >= v107 + 1 ? (v5 = 2 * v108) : (v5 = v107 + 1), v5) )
        {
          v109 = *(_QWORD *)(a3 + 24);
          v110 = *(char **)(v109 + 4096);
          if ( v109 + 4096 - (__int64)v110 >= (unsigned __int64)(48 * v5) )
            *(_QWORD *)(v109 + 4096) = &v110[48 * v5];
          else
            v110 = (char *)malloc(48 * v5);
        }
        else
        {
          v110 = 0LL;
        }
        v244 = &v110[48 * v107];
        *v244 = 6;
        v245 = &v110[48 * v5];
        *(_WORD *)(v244 + 1) = 28265;
        v244[4] = 0;
        v244[3] = 116;
        *(_QWORD *)(v244 + 5) = v388[0];
        v244[15] = BYTE2(v388[1]);
        *((_QWORD *)v244 + 2) = 0LL;
        *(_WORD *)(v244 + 13) = v388[1];
        LOWORD(v388[1]) = 0;
        v388[0] = 0LL;
        BYTE2(v388[1]) = 0;
        v244[24] = 0;
        *((_QWORD *)v244 + 4) = *(_QWORD *)((char *)v389 + 7);
        *((_QWORD *)v244 + 5) = 0LL;
        *(_QWORD *)(v244 + 25) = v389[0];
        *(_QWORD *)((char *)v389 + 7) = 0LL;
        v389[0] = 0LL;
        v247 = *(void ***)a3;
        v246 = *(void ***)(a3 + 8);
        v248 = v244 + 48;
        if ( v246 == *(void ***)a3 )
        {
          v129 = *(void ***)a3;
        }
        else
        {
          do
          {
            *((_QWORD *)v244 - 4) = *(v246 - 4);
            *((_OWORD *)v244 - 3) = *((_OWORD *)v246 - 3);
            v249 = (__int64)*(v246 - 1);
            *(v246 - 5) = 0LL;
            *(v246 - 4) = 0LL;
            *(v246 - 6) = 0LL;
            *((_QWORD *)v244 - 1) = v249;
            *(_OWORD *)(v244 - 24) = *(_OWORD *)(v246 - 3);
            *(v246 - 2) = 0LL;
            *(v246 - 1) = 0LL;
            *(v246 - 3) = 0LL;
            v246 -= 6;
            v244 -= 48;
          }
          while ( v247 != v246 );
          v129 = *(void ***)a3;
          v247 = *(void ***)(a3 + 8);
        }
        v130 = *(_QWORD *)(a3 + 16);
        *(_QWORD *)a3 = v244;
        *(_QWORD *)(a3 + 8) = v248;
        *(_QWORD *)(a3 + 16) = v245;
        if ( v247 != v129 )
        {
          do
          {
            if ( (*(_BYTE *)(v247 - 3) & 1) != 0 )
              free(*(v247 - 1));
            v250 = v247 - 6;
            if ( (*(_BYTE *)(v247 - 6) & 1) != 0 )
              free(*(v247 - 4));
            v247 -= 6;
          }
          while ( v129 != v250 );
        }
        goto LABEL_494;
      case 'j':
        *(_QWORD *)((char *)v389 + 7) = 0LL;
        v389[0] = 0LL;
        qmemcpy(v388, "unsigned int", 12);
        v6 = *(_QWORD *)(a3 + 8);
        v20 = *(_QWORD *)(a3 + 16);
        if ( v6 < v20 )
        {
          *(_BYTE *)v6 = 24;
          v3 = a1 + 1;
          *(_DWORD *)(v6 + 9) = v388[1];
          *(_BYTE *)(v6 + 13) = 0;
          *(_WORD *)(v6 + 14) = 0;
          *(_QWORD *)(v6 + 16) = 0LL;
          *(_QWORD *)(v6 + 1) = v388[0];
          LODWORD(v388[1]) = 0;
          goto LABEL_104;
        }
        v75 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v6 - *(_QWORD *)a3) >> 4);
        if ( v75 + 1 > 0x555555555555555LL )
          abort();
        v76 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v20 - *(_QWORD *)a3) >> 4);
        if ( v76 >= 0x2AAAAAAAAAAAAAALL || (2 * v76 >= v75 + 1 ? (v5 = 2 * v76) : (v5 = v75 + 1), v5) )
        {
          v77 = *(_QWORD *)(a3 + 24);
          v78 = *(char **)(v77 + 4096);
          if ( v77 + 4096 - (__int64)v78 >= (unsigned __int64)(48 * v5) )
            *(_QWORD *)(v77 + 4096) = &v78[48 * v5];
          else
            v78 = (char *)malloc(48 * v5);
        }
        else
        {
          v78 = 0LL;
        }
        v146 = &v78[48 * v75];
        *v146 = 24;
        v147 = &v78[48 * v5];
        *(_DWORD *)(v146 + 9) = v388[1];
        v146[13] = 0;
        *((_WORD *)v146 + 7) = 0;
        *((_QWORD *)v146 + 2) = 0LL;
        *(_QWORD *)(v146 + 1) = v388[0];
        LODWORD(v388[1]) = 0;
        v388[0] = 0LL;
        v146[24] = 0;
        *((_QWORD *)v146 + 4) = *(_QWORD *)((char *)v389 + 7);
        *((_QWORD *)v146 + 5) = 0LL;
        *(_QWORD *)(v146 + 25) = v389[0];
        *(_QWORD *)((char *)v389 + 7) = 0LL;
        v389[0] = 0LL;
        v149 = *(void ***)a3;
        v148 = *(void ***)(a3 + 8);
        v150 = v146 + 48;
        if ( v148 == *(void ***)a3 )
        {
          v129 = *(void ***)a3;
        }
        else
        {
          do
          {
            *((_QWORD *)v146 - 4) = *(v148 - 4);
            *((_OWORD *)v146 - 3) = *((_OWORD *)v148 - 3);
            v151 = (__int64)*(v148 - 1);
            *(v148 - 5) = 0LL;
            *(v148 - 4) = 0LL;
            *(v148 - 6) = 0LL;
            *((_QWORD *)v146 - 1) = v151;
            *(_OWORD *)(v146 - 24) = *(_OWORD *)(v148 - 3);
            *(v148 - 2) = 0LL;
            *(v148 - 1) = 0LL;
            *(v148 - 3) = 0LL;
            v148 -= 6;
            v146 -= 48;
          }
          while ( v149 != v148 );
          v129 = *(void ***)a3;
          v149 = *(void ***)(a3 + 8);
        }
        v130 = *(_QWORD *)(a3 + 16);
        *(_QWORD *)a3 = v146;
        *(_QWORD *)(a3 + 8) = v150;
        *(_QWORD *)(a3 + 16) = v147;
        if ( v149 != v129 )
        {
          do
          {
            if ( (*(_BYTE *)(v149 - 3) & 1) != 0 )
              free(*(v149 - 1));
            v152 = v149 - 6;
            if ( (*(_BYTE *)(v149 - 6) & 1) != 0 )
              free(*(v149 - 4));
            v149 -= 6;
          }
          while ( v129 != v152 );
        }
        goto LABEL_494;
      case 'l':
        LOWORD(v388[1]) = 0;
        v388[0] = 0LL;
        *(_QWORD *)((char *)v389 + 7) = 0LL;
        v389[0] = 0LL;
        v6 = *(_QWORD *)(a3 + 8);
        v43 = *(_QWORD *)(a3 + 16);
        v10 = 1735290732;
        if ( v6 < v43 )
          goto LABEL_73;
        v44 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v6 - *(_QWORD *)a3) >> 4);
        if ( v44 + 1 > 0x555555555555555LL )
          abort();
        v45 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v43 - *(_QWORD *)a3) >> 4);
        if ( v45 >= 0x2AAAAAAAAAAAAAALL || (2 * v45 >= v44 + 1 ? (v5 = 2 * v45) : (v5 = v44 + 1), v5) )
        {
          v46 = *(_QWORD *)(a3 + 24);
          v47 = *(char **)(v46 + 4096);
          if ( v46 + 4096 - (__int64)v47 >= (unsigned __int64)(48 * v5) )
            *(_QWORD *)(v46 + 4096) = &v47[48 * v5];
          else
            v47 = (char *)malloc(48 * v5);
        }
        else
        {
          v47 = 0LL;
        }
        v195 = &v47[48 * v44];
        *v195 = 8;
        strcpy(v195 + 1, "long");
        v196 = &v47[48 * v5];
        *((_WORD *)v195 + 7) = v388[1];
        *((_QWORD *)v195 + 2) = 0LL;
        *(_QWORD *)(v195 + 6) = v388[0];
        LOWORD(v388[1]) = 0;
        v388[0] = 0LL;
        v195[24] = 0;
        *((_QWORD *)v195 + 4) = *(_QWORD *)((char *)v389 + 7);
        *((_QWORD *)v195 + 5) = 0LL;
        *(_QWORD *)(v195 + 25) = v389[0];
        *(_QWORD *)((char *)v389 + 7) = 0LL;
        v389[0] = 0LL;
        v198 = *(void ***)a3;
        v197 = *(void ***)(a3 + 8);
        v199 = v195 + 48;
        if ( v197 == *(void ***)a3 )
        {
          v129 = *(void ***)a3;
        }
        else
        {
          do
          {
            *((_QWORD *)v195 - 4) = *(v197 - 4);
            *((_OWORD *)v195 - 3) = *((_OWORD *)v197 - 3);
            v200 = (__int64)*(v197 - 1);
            *(v197 - 5) = 0LL;
            *(v197 - 4) = 0LL;
            *(v197 - 6) = 0LL;
            *((_QWORD *)v195 - 1) = v200;
            *(_OWORD *)(v195 - 24) = *(_OWORD *)(v197 - 3);
            *(v197 - 2) = 0LL;
            *(v197 - 1) = 0LL;
            *(v197 - 3) = 0LL;
            v197 -= 6;
            v195 -= 48;
          }
          while ( v198 != v197 );
          v129 = *(void ***)a3;
          v198 = *(void ***)(a3 + 8);
        }
        v130 = *(_QWORD *)(a3 + 16);
        *(_QWORD *)a3 = v195;
        *(_QWORD *)(a3 + 8) = v199;
        *(_QWORD *)(a3 + 16) = v196;
        if ( v198 != v129 )
        {
          do
          {
            if ( (*(_BYTE *)(v198 - 3) & 1) != 0 )
              free(*(v198 - 1));
            v201 = v198 - 6;
            if ( (*(_BYTE *)(v198 - 6) & 1) != 0 )
              free(*(v198 - 4));
            v198 -= 6;
          }
          while ( v129 != v201 );
        }
        goto LABEL_494;
      case 'm':
        *(_QWORD *)((char *)v389 + 7) = 0LL;
        v389[0] = 0LL;
        qmemcpy(v388, "unsigned long", 13);
        v6 = *(_QWORD *)(a3 + 8);
        v32 = *(_QWORD *)(a3 + 16);
        if ( v6 < v32 )
        {
LABEL_97:
          *(_BYTE *)v6 = 26;
          v3 = a1 + 1;
          *(_QWORD *)(v6 + 6) = *(_QWORD *)((char *)v388 + 5);
          *(_WORD *)(v6 + 14) = 0;
          *(_QWORD *)(v6 + 16) = 0LL;
          *(_QWORD *)(v6 + 1) = v388[0];
          *(_QWORD *)((char *)v388 + 5) = 0LL;
          goto LABEL_104;
        }
        v33 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v6 - *(_QWORD *)a3) >> 4);
        if ( v33 + 1 > 0x555555555555555LL )
          abort();
        v34 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v32 - *(_QWORD *)a3) >> 4);
        if ( v34 >= 0x2AAAAAAAAAAAAAALL || (2 * v34 >= v33 + 1 ? (v5 = 2 * v34) : (v5 = v33 + 1), v5) )
        {
          v35 = *(_QWORD *)(a3 + 24);
          v36 = *(char **)(v35 + 4096);
          if ( v35 + 4096 - (__int64)v36 >= (unsigned __int64)(48 * v5) )
            *(_QWORD *)(v35 + 4096) = &v36[48 * v5];
          else
            v36 = (char *)malloc(48 * v5);
        }
        else
        {
          v36 = 0LL;
        }
        v174 = &v36[48 * v33];
        *v174 = 26;
        v175 = &v36[48 * v5];
        *(_QWORD *)(v174 + 6) = *(_QWORD *)((char *)v388 + 5);
        *((_WORD *)v174 + 7) = 0;
        *((_QWORD *)v174 + 2) = 0LL;
        *(_QWORD *)(v174 + 1) = v388[0];
        *(_QWORD *)((char *)v388 + 5) = 0LL;
        v388[0] = 0LL;
        v174[24] = 0;
        *((_QWORD *)v174 + 4) = *(_QWORD *)((char *)v389 + 7);
        *((_QWORD *)v174 + 5) = 0LL;
        *(_QWORD *)(v174 + 25) = v389[0];
        *(_QWORD *)((char *)v389 + 7) = 0LL;
        v389[0] = 0LL;
        v177 = *(void ***)a3;
        v176 = *(void ***)(a3 + 8);
        v178 = v174 + 48;
        if ( v176 == *(void ***)a3 )
        {
          v129 = *(void ***)a3;
        }
        else
        {
          do
          {
            *((_QWORD *)v174 - 4) = *(v176 - 4);
            *((_OWORD *)v174 - 3) = *((_OWORD *)v176 - 3);
            v179 = (__int64)*(v176 - 1);
            *(v176 - 5) = 0LL;
            *(v176 - 4) = 0LL;
            *(v176 - 6) = 0LL;
            *((_QWORD *)v174 - 1) = v179;
            *(_OWORD *)(v174 - 24) = *(_OWORD *)(v176 - 3);
            *(v176 - 2) = 0LL;
            *(v176 - 1) = 0LL;
            *(v176 - 3) = 0LL;
            v176 -= 6;
            v174 -= 48;
          }
          while ( v177 != v176 );
          v129 = *(void ***)a3;
          v177 = *(void ***)(a3 + 8);
        }
        v130 = *(_QWORD *)(a3 + 16);
        *(_QWORD *)a3 = v174;
        *(_QWORD *)(a3 + 8) = v178;
        *(_QWORD *)(a3 + 16) = v175;
        if ( v177 != v129 )
        {
          do
          {
            if ( (*(_BYTE *)(v177 - 3) & 1) != 0 )
              free(*(v177 - 1));
            v180 = v177 - 6;
            if ( (*(_BYTE *)(v177 - 6) & 1) != 0 )
              free(*(v177 - 4));
            v177 -= 6;
          }
          while ( v129 != v180 );
        }
        goto LABEL_494;
      case 'n':
        WORD2(v388[0]) = 0;
        LODWORD(v388[0]) = 0;
        *(_QWORD *)((char *)v389 + 7) = 0LL;
        v389[0] = 0LL;
        v6 = *(_QWORD *)(a3 + 8);
        v18 = *(_QWORD *)(a3 + 16);
        if ( v6 < v18 )
        {
          strcpy((char *)(v6 + 1), "__int128");
          *(_BYTE *)v6 = 16;
          v19 = WORD2(v388[0]);
          v3 = a1 + 1;
LABEL_20:
          *(_WORD *)(v6 + 14) = v19;
          *(_QWORD *)(v6 + 16) = 0LL;
          *(_DWORD *)(v6 + 10) = v388[0];
          WORD2(v388[0]) = 0;
          LODWORD(v388[0]) = 0;
          goto LABEL_105;
        }
        v71 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v6 - *(_QWORD *)a3) >> 4);
        if ( v71 + 1 > 0x555555555555555LL )
          abort();
        v72 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v18 - *(_QWORD *)a3) >> 4);
        if ( v72 >= 0x2AAAAAAAAAAAAAALL || (2 * v72 >= v71 + 1 ? (v5 = 2 * v72) : (v5 = v71 + 1), v5) )
        {
          v73 = *(_QWORD *)(a3 + 24);
          v74 = *(char **)(v73 + 4096);
          if ( v73 + 4096 - (__int64)v74 >= (unsigned __int64)(48 * v5) )
            *(_QWORD *)(v73 + 4096) = &v74[48 * v5];
          else
            v74 = (char *)malloc(48 * v5);
        }
        else
        {
          v74 = 0LL;
        }
        v139 = &v74[48 * v71];
        *v139 = 16;
        strcpy(v139 + 1, "__int128");
        v140 = &v74[48 * v5];
        *((_WORD *)v139 + 7) = WORD2(v388[0]);
        *((_QWORD *)v139 + 2) = 0LL;
        *(_DWORD *)(v139 + 10) = v388[0];
        WORD2(v388[0]) = 0;
        LODWORD(v388[0]) = 0;
        v139[24] = 0;
        *((_QWORD *)v139 + 4) = *(_QWORD *)((char *)v389 + 7);
        *((_QWORD *)v139 + 5) = 0LL;
        *(_QWORD *)(v139 + 25) = v389[0];
        *(_QWORD *)((char *)v389 + 7) = 0LL;
        v389[0] = 0LL;
        v142 = *(void ***)a3;
        v141 = *(void ***)(a3 + 8);
        v143 = v139 + 48;
        if ( v141 == *(void ***)a3 )
        {
          v129 = *(void ***)a3;
        }
        else
        {
          do
          {
            *((_QWORD *)v139 - 4) = *(v141 - 4);
            *((_OWORD *)v139 - 3) = *((_OWORD *)v141 - 3);
            v144 = (__int64)*(v141 - 1);
            *(v141 - 5) = 0LL;
            *(v141 - 4) = 0LL;
            *(v141 - 6) = 0LL;
            *((_QWORD *)v139 - 1) = v144;
            *(_OWORD *)(v139 - 24) = *(_OWORD *)(v141 - 3);
            *(v141 - 2) = 0LL;
            *(v141 - 1) = 0LL;
            *(v141 - 3) = 0LL;
            v141 -= 6;
            v139 -= 48;
          }
          while ( v142 != v141 );
          v129 = *(void ***)a3;
          v142 = *(void ***)(a3 + 8);
        }
        v130 = *(_QWORD *)(a3 + 16);
        *(_QWORD *)a3 = v139;
        *(_QWORD *)(a3 + 8) = v143;
        *(_QWORD *)(a3 + 16) = v140;
        if ( v142 != v129 )
        {
          do
          {
            if ( (*(_BYTE *)(v142 - 3) & 1) != 0 )
              free(*(v142 - 1));
            v145 = v142 - 6;
            if ( (*(_BYTE *)(v142 - 6) & 1) != 0 )
              free(*(v142 - 4));
            v142 -= 6;
          }
          while ( v129 != v145 );
        }
        goto LABEL_494;
      case 'o':
        memset(v388, 0, 15);
        qmemcpy(v389, "unsigned __int1", 15);
        v15 = *(_QWORD *)(a3 + 8);
        v57 = *(_QWORD *)(a3 + 16);
        if ( v15 < v57 )
        {
          *(_BYTE *)v15 = 34;
          v3 = a1 + 1;
          *(_QWORD *)(v15 + 8) = *(_QWORD *)((char *)v389 + 7);
          v17 = v389[0];
          *(_QWORD *)(v15 + 16) = 14386LL;
          goto LABEL_91;
        }
        v99 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v15 - *(_QWORD *)a3) >> 4);
        if ( v99 + 1 > 0x555555555555555LL )
          abort();
        v100 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v57 - *(_QWORD *)a3) >> 4);
        if ( v100 >= 0x2AAAAAAAAAAAAAALL || (2 * v100 >= v99 + 1 ? (v5 = 2 * v100) : (v5 = v99 + 1), v5) )
        {
          v101 = *(_QWORD *)(a3 + 24);
          v102 = *(char **)(v101 + 4096);
          if ( v101 + 4096 - (__int64)v102 >= (unsigned __int64)(48 * v5) )
            *(_QWORD *)(v101 + 4096) = &v102[48 * v5];
          else
            v102 = (char *)malloc(48 * v5);
        }
        else
        {
          v102 = 0LL;
        }
        v230 = &v102[48 * v99];
        *v230 = 34;
        v231 = &v102[48 * v5];
        *((_QWORD *)v230 + 1) = *(_QWORD *)((char *)v389 + 7);
        *((_QWORD *)v230 + 2) = 14386LL;
        *(_QWORD *)(v230 + 1) = v389[0];
        *(_QWORD *)((char *)v389 + 7) = 0LL;
        v389[0] = 0LL;
        v230[24] = 0;
        *((_QWORD *)v230 + 4) = *(_QWORD *)((char *)v388 + 7);
        *((_QWORD *)v230 + 5) = 0LL;
        *(_QWORD *)(v230 + 25) = v388[0];
        memset(v388, 0, 15);
        v233 = *(void ***)a3;
        v232 = *(void ***)(a3 + 8);
        v234 = v230 + 48;
        if ( v232 == *(void ***)a3 )
        {
          v129 = *(void ***)a3;
        }
        else
        {
          do
          {
            *((_QWORD *)v230 - 4) = *(v232 - 4);
            *((_OWORD *)v230 - 3) = *((_OWORD *)v232 - 3);
            v235 = (__int64)*(v232 - 1);
            *(v232 - 5) = 0LL;
            *(v232 - 4) = 0LL;
            *(v232 - 6) = 0LL;
            *((_QWORD *)v230 - 1) = v235;
            *(_OWORD *)(v230 - 24) = *(_OWORD *)(v232 - 3);
            *(v232 - 2) = 0LL;
            *(v232 - 1) = 0LL;
            *(v232 - 3) = 0LL;
            v232 -= 6;
            v230 -= 48;
          }
          while ( v233 != v232 );
          v129 = *(void ***)a3;
          v233 = *(void ***)(a3 + 8);
        }
        v130 = *(_QWORD *)(a3 + 16);
        *(_QWORD *)a3 = v230;
        *(_QWORD *)(a3 + 8) = v234;
        *(_QWORD *)(a3 + 16) = v231;
        if ( v233 != v129 )
        {
          do
          {
            if ( (*(_BYTE *)(v233 - 3) & 1) != 0 )
              free(*(v233 - 1));
            v236 = v233 - 6;
            if ( (*(_BYTE *)(v233 - 6) & 1) != 0 )
              free(*(v233 - 4));
            v233 -= 6;
          }
          while ( v129 != v236 );
        }
        goto LABEL_494;
      case 's':
        v388[0] = 0LL;
        LOBYTE(v388[1]) = 0;
        *(_QWORD *)((char *)v389 + 7) = 0LL;
        v389[0] = 0LL;
        v386 = 1919903859;
        v6 = *(_QWORD *)(a3 + 8);
        v58 = *(_QWORD *)(a3 + 16);
        if ( v6 < v58 )
        {
LABEL_93:
          *(_BYTE *)v6 = 10;
          v3 = a1 + 1;
          *(_DWORD *)(v6 + 1) = v386;
          *(_BYTE *)(v6 + 6) = 0;
          *(_BYTE *)(v6 + 5) = 116;
          *(_QWORD *)(v6 + 7) = v388[0];
          *(_QWORD *)(v6 + 16) = 0LL;
          *(_BYTE *)(v6 + 15) = v388[1];
          LOBYTE(v388[1]) = 0;
          goto LABEL_104;
        }
        v103 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v6 - *(_QWORD *)a3) >> 4);
        if ( v103 + 1 > 0x555555555555555LL )
          abort();
        v104 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v58 - *(_QWORD *)a3) >> 4);
        if ( v104 >= 0x2AAAAAAAAAAAAAALL || (2 * v104 >= v103 + 1 ? (v5 = 2 * v104) : (v5 = v103 + 1), v5) )
        {
          v105 = *(_QWORD *)(a3 + 24);
          v106 = *(char **)(v105 + 4096);
          if ( v105 + 4096 - (__int64)v106 >= (unsigned __int64)(48 * v5) )
            *(_QWORD *)(v105 + 4096) = &v106[48 * v5];
          else
            v106 = (char *)malloc(48 * v5);
        }
        else
        {
          v106 = 0LL;
        }
        v237 = &v106[48 * v103];
        *v237 = 10;
        v238 = &v106[48 * v5];
        *(_DWORD *)(v237 + 1) = 1919903859;
        v237[6] = 0;
        v237[5] = 116;
        *(_QWORD *)(v237 + 7) = v388[0];
        *((_QWORD *)v237 + 2) = 0LL;
        v237[15] = v388[1];
        LOBYTE(v388[1]) = 0;
        v388[0] = 0LL;
        v237[24] = 0;
        *((_QWORD *)v237 + 4) = *(_QWORD *)((char *)v389 + 7);
        *((_QWORD *)v237 + 5) = 0LL;
        *(_QWORD *)(v237 + 25) = v389[0];
        *(_QWORD *)((char *)v389 + 7) = 0LL;
        v389[0] = 0LL;
        v240 = *(void ***)a3;
        v239 = *(void ***)(a3 + 8);
        v241 = v237 + 48;
        if ( v239 == *(void ***)a3 )
        {
          v129 = *(void ***)a3;
        }
        else
        {
          do
          {
            *((_QWORD *)v237 - 4) = *(v239 - 4);
            *((_OWORD *)v237 - 3) = *((_OWORD *)v239 - 3);
            v242 = (__int64)*(v239 - 1);
            *(v239 - 5) = 0LL;
            *(v239 - 4) = 0LL;
            *(v239 - 6) = 0LL;
            *((_QWORD *)v237 - 1) = v242;
            *(_OWORD *)(v237 - 24) = *(_OWORD *)(v239 - 3);
            *(v239 - 2) = 0LL;
            *(v239 - 1) = 0LL;
            *(v239 - 3) = 0LL;
            v239 -= 6;
            v237 -= 48;
          }
          while ( v240 != v239 );
          v129 = *(void ***)a3;
          v240 = *(void ***)(a3 + 8);
        }
        v130 = *(_QWORD *)(a3 + 16);
        *(_QWORD *)a3 = v237;
        *(_QWORD *)(a3 + 8) = v241;
        *(_QWORD *)(a3 + 16) = v238;
        if ( v240 != v129 )
        {
          do
          {
            if ( (*(_BYTE *)(v240 - 3) & 1) != 0 )
              free(*(v240 - 1));
            v243 = v240 - 6;
            if ( (*(_BYTE *)(v240 - 6) & 1) != 0 )
              free(*(v240 - 4));
            v240 -= 6;
          }
          while ( v129 != v243 );
        }
        goto LABEL_494;
      case 't':
        *(_QWORD *)((char *)v389 + 7) = 0LL;
        v389[0] = 0LL;
        qmemcpy(v388, "unsigned short", 14);
        v6 = *(_QWORD *)(a3 + 8);
        v63 = *(_QWORD *)(a3 + 16);
        if ( v6 < v63 )
        {
          *(_BYTE *)v6 = 28;
          v64 = *(_QWORD *)((char *)v388 + 6);
          v3 = a1 + 1;
LABEL_103:
          *(_QWORD *)(v6 + 7) = v64;
          *(_BYTE *)(v6 + 15) = 0;
          *(_QWORD *)(v6 + 16) = 0LL;
          *(_QWORD *)(v6 + 1) = v388[0];
          *(_QWORD *)((char *)v388 + 6) = 0LL;
          goto LABEL_104;
        }
        v115 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v6 - *(_QWORD *)a3) >> 4);
        if ( v115 + 1 > 0x555555555555555LL )
          abort();
        v116 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v63 - *(_QWORD *)a3) >> 4);
        if ( v116 >= 0x2AAAAAAAAAAAAAALL || (2 * v116 >= v115 + 1 ? (v5 = 2 * v116) : (v5 = v115 + 1), v5) )
        {
          v117 = *(_QWORD *)(a3 + 24);
          v118 = *(char **)(v117 + 4096);
          if ( v117 + 4096 - (__int64)v118 >= (unsigned __int64)(48 * v5) )
            *(_QWORD *)(v117 + 4096) = &v118[48 * v5];
          else
            v118 = (char *)malloc(48 * v5);
        }
        else
        {
          v118 = 0LL;
        }
        v258 = &v118[48 * v115];
        *v258 = 28;
        v259 = &v118[48 * v5];
        *(_QWORD *)(v258 + 7) = *(_QWORD *)((char *)v388 + 6);
        v258[15] = 0;
        *((_QWORD *)v258 + 2) = 0LL;
        *(_QWORD *)(v258 + 1) = v388[0];
        *(_QWORD *)((char *)v388 + 6) = 0LL;
        v388[0] = 0LL;
        v258[24] = 0;
        *((_QWORD *)v258 + 4) = *(_QWORD *)((char *)v389 + 7);
        *((_QWORD *)v258 + 5) = 0LL;
        *(_QWORD *)(v258 + 25) = v389[0];
        *(_QWORD *)((char *)v389 + 7) = 0LL;
        v389[0] = 0LL;
        v261 = *(void ***)a3;
        v260 = *(void ***)(a3 + 8);
        v262 = v258 + 48;
        if ( v260 == *(void ***)a3 )
        {
          v129 = *(void ***)a3;
        }
        else
        {
          do
          {
            *((_QWORD *)v258 - 4) = *(v260 - 4);
            *((_OWORD *)v258 - 3) = *((_OWORD *)v260 - 3);
            v263 = (__int64)*(v260 - 1);
            *(v260 - 5) = 0LL;
            *(v260 - 4) = 0LL;
            *(v260 - 6) = 0LL;
            *((_QWORD *)v258 - 1) = v263;
            *(_OWORD *)(v258 - 24) = *(_OWORD *)(v260 - 3);
            *(v260 - 2) = 0LL;
            *(v260 - 1) = 0LL;
            *(v260 - 3) = 0LL;
            v260 -= 6;
            v258 -= 48;
          }
          while ( v261 != v260 );
          v129 = *(void ***)a3;
          v261 = *(void ***)(a3 + 8);
        }
        v130 = *(_QWORD *)(a3 + 16);
        *(_QWORD *)a3 = v258;
        *(_QWORD *)(a3 + 8) = v262;
        *(_QWORD *)(a3 + 16) = v259;
        if ( v261 != v129 )
        {
          do
          {
            if ( (*(_BYTE *)(v261 - 3) & 1) != 0 )
              free(*(v261 - 1));
            v264 = v261 - 6;
            if ( (*(_BYTE *)(v261 - 6) & 1) != 0 )
              free(*(v261 - 4));
            v261 -= 6;
          }
          while ( v129 != v264 );
        }
        goto LABEL_494;
      case 'u':
        v61 = a1 + 1;
        v62 = sub_B190C(a1 + 1, a2, (void **)a3);
        if ( v62 != v61 )
          return v62;
        return v3;
      case 'v':
        LOWORD(v388[1]) = 0;
        v388[0] = 0LL;
        *(_QWORD *)((char *)v389 + 7) = 0LL;
        v389[0] = 0LL;
        v6 = *(_QWORD *)(a3 + 8);
        v9 = *(_QWORD *)(a3 + 16);
        v10 = 1684631414;
        if ( v6 >= v9 )
        {
          v11 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v6 - *(_QWORD *)a3) >> 4);
          if ( v11 + 1 > 0x555555555555555LL )
            abort();
          v12 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v9 - *(_QWORD *)a3) >> 4);
          if ( v12 >= 0x2AAAAAAAAAAAAAALL || (2 * v12 >= v11 + 1 ? (v5 = 2 * v12) : (v5 = v11 + 1), v5) )
          {
            v13 = *(_QWORD *)(a3 + 24);
            v14 = *(char **)(v13 + 4096);
            if ( v13 + 4096 - (__int64)v14 >= (unsigned __int64)(48 * v5) )
              *(_QWORD *)(v13 + 4096) = &v14[48 * v5];
            else
              v14 = (char *)malloc(48 * v5);
          }
          else
          {
            v14 = 0LL;
          }
          v123 = &v14[48 * v11];
          *v123 = 8;
          strcpy(v123 + 1, "void");
          v124 = &v14[48 * v5];
          *((_WORD *)v123 + 7) = v388[1];
          *((_QWORD *)v123 + 2) = 0LL;
          *(_QWORD *)(v123 + 6) = v388[0];
          LOWORD(v388[1]) = 0;
          v388[0] = 0LL;
          v123[24] = 0;
          *((_QWORD *)v123 + 4) = *(_QWORD *)((char *)v389 + 7);
          *((_QWORD *)v123 + 5) = 0LL;
          *(_QWORD *)(v123 + 25) = v389[0];
          *(_QWORD *)((char *)v389 + 7) = 0LL;
          v389[0] = 0LL;
          v126 = *(void ***)a3;
          v125 = *(void ***)(a3 + 8);
          v127 = v123 + 48;
          if ( v125 == *(void ***)a3 )
          {
            v129 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v123 - 4) = *(v125 - 4);
              *((_OWORD *)v123 - 3) = *((_OWORD *)v125 - 3);
              v128 = (__int64)*(v125 - 1);
              *(v125 - 5) = 0LL;
              *(v125 - 4) = 0LL;
              *(v125 - 6) = 0LL;
              *((_QWORD *)v123 - 1) = v128;
              *(_OWORD *)(v123 - 24) = *(_OWORD *)(v125 - 3);
              *(v125 - 2) = 0LL;
              *(v125 - 1) = 0LL;
              *(v125 - 3) = 0LL;
              v125 -= 6;
              v123 -= 48;
            }
            while ( v126 != v125 );
            v129 = *(void ***)a3;
            v126 = *(void ***)(a3 + 8);
          }
          v130 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v123;
          *(_QWORD *)(a3 + 8) = v127;
          *(_QWORD *)(a3 + 16) = v124;
          if ( v126 != v129 )
          {
            do
            {
              if ( (*(_BYTE *)(v126 - 3) & 1) != 0 )
                free(*(v126 - 1));
              v131 = v126 - 6;
              if ( (*(_BYTE *)(v126 - 6) & 1) != 0 )
                free(*(v126 - 4));
              v126 -= 6;
            }
            while ( v129 != v131 );
          }
          goto LABEL_494;
        }
LABEL_73:
        *(_DWORD *)(v6 + 1) = v10;
        *(_BYTE *)(v6 + 5) = 0;
        *(_BYTE *)v6 = 8;
        v8 = v388[1];
        v3 = a1 + 1;
LABEL_74:
        *(_WORD *)(v6 + 14) = v8;
        *(_QWORD *)(v6 + 16) = 0LL;
        *(_QWORD *)(v6 + 6) = v388[0];
        LOWORD(v388[1]) = 0;
LABEL_104:
        v388[0] = 0LL;
        goto LABEL_105;
      case 'w':
        *(_QWORD *)((char *)v389 + 7) = 0LL;
        v389[0] = 0LL;
        qmemcpy(v388, "wchar_t", 7);
        v6 = *(_QWORD *)(a3 + 8);
        v37 = *(_QWORD *)(a3 + 16);
        if ( v6 < v37 )
        {
          *(_BYTE *)v6 = 14;
          v3 = a1 + 1;
          *(_DWORD *)(v6 + 1) = v388[0];
          *(_BYTE *)(v6 + 7) = BYTE6(v388[0]);
          *(_BYTE *)(v6 + 8) = 0;
          *(_WORD *)(v6 + 5) = WORD2(v388[0]);
          *(_DWORD *)(v6 + 9) = 0;
          *(_BYTE *)(v6 + 15) = 0;
          *(_QWORD *)(v6 + 16) = 0LL;
          *(_WORD *)(v6 + 13) = 0;
          BYTE6(v388[0]) = 0;
          WORD2(v388[0]) = 0;
          LODWORD(v388[0]) = 0;
          goto LABEL_105;
        }
        v83 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v6 - *(_QWORD *)a3) >> 4);
        if ( v83 + 1 > 0x555555555555555LL )
          abort();
        v84 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v37 - *(_QWORD *)a3) >> 4);
        if ( v84 >= 0x2AAAAAAAAAAAAAALL || (2 * v84 >= v83 + 1 ? (v5 = 2 * v84) : (v5 = v83 + 1), v5) )
        {
          v85 = *(_QWORD *)(a3 + 24);
          v86 = *(char **)(v85 + 4096);
          if ( v85 + 4096 - (__int64)v86 >= (unsigned __int64)(48 * v5) )
            *(_QWORD *)(v85 + 4096) = &v86[48 * v5];
          else
            v86 = (char *)malloc(48 * v5);
        }
        else
        {
          v86 = 0LL;
        }
        v181 = &v86[48 * v83];
        *v181 = 14;
        v182 = &v86[48 * v5];
        *(_DWORD *)(v181 + 1) = v388[0];
        v181[7] = BYTE6(v388[0]);
        v181[8] = 0;
        *(_WORD *)(v181 + 5) = WORD2(v388[0]);
        *(_DWORD *)(v181 + 9) = 0;
        v181[15] = 0;
        *((_QWORD *)v181 + 2) = 0LL;
        *(_WORD *)(v181 + 13) = 0;
        BYTE6(v388[0]) = 0;
        WORD2(v388[0]) = 0;
        LODWORD(v388[0]) = 0;
        v181[24] = 0;
        *((_QWORD *)v181 + 4) = *(_QWORD *)((char *)v389 + 7);
        *((_QWORD *)v181 + 5) = 0LL;
        *(_QWORD *)(v181 + 25) = v389[0];
        *(_QWORD *)((char *)v389 + 7) = 0LL;
        v389[0] = 0LL;
        v184 = *(void ***)a3;
        v183 = *(void ***)(a3 + 8);
        v185 = v181 + 48;
        if ( v183 == *(void ***)a3 )
        {
          v129 = *(void ***)a3;
        }
        else
        {
          do
          {
            *((_QWORD *)v181 - 4) = *(v183 - 4);
            *((_OWORD *)v181 - 3) = *((_OWORD *)v183 - 3);
            v186 = (__int64)*(v183 - 1);
            *(v183 - 5) = 0LL;
            *(v183 - 4) = 0LL;
            *(v183 - 6) = 0LL;
            *((_QWORD *)v181 - 1) = v186;
            *(_OWORD *)(v181 - 24) = *(_OWORD *)(v183 - 3);
            *(v183 - 2) = 0LL;
            *(v183 - 1) = 0LL;
            *(v183 - 3) = 0LL;
            v183 -= 6;
            v181 -= 48;
          }
          while ( v184 != v183 );
          v129 = *(void ***)a3;
          v184 = *(void ***)(a3 + 8);
        }
        v130 = *(_QWORD *)(a3 + 16);
        *(_QWORD *)a3 = v181;
        *(_QWORD *)(a3 + 8) = v185;
        *(_QWORD *)(a3 + 16) = v182;
        if ( v184 != v129 )
        {
          do
          {
            if ( (*(_BYTE *)(v184 - 3) & 1) != 0 )
              free(*(v184 - 1));
            v187 = v184 - 6;
            if ( (*(_BYTE *)(v184 - 6) & 1) != 0 )
              free(*(v184 - 4));
            v184 -= 6;
          }
          while ( v129 != v187 );
        }
        goto LABEL_494;
      case 'x':
        *(_QWORD *)((char *)v389 + 7) = 0LL;
        v389[0] = 0LL;
        qmemcpy(v388, "long long", 9);
        v6 = *(_QWORD *)(a3 + 8);
        v65 = *(_QWORD *)(a3 + 16);
        if ( v6 < v65 )
        {
          *(_BYTE *)v6 = 18;
          v66 = v388[0];
          v3 = a1 + 1;
LABEL_109:
          *(_QWORD *)(v6 + 1) = v66;
          *(_BYTE *)(v6 + 10) = 0;
          *(_BYTE *)(v6 + 9) = v388[1];
          *(_DWORD *)(v6 + 11) = 0;
          *(_QWORD *)(v6 + 16) = 0LL;
          *(_BYTE *)(v6 + 15) = 0;
          v388[0] = 0LL;
          LOBYTE(v388[1]) = 0;
          goto LABEL_105;
        }
        v119 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v6 - *(_QWORD *)a3) >> 4);
        if ( v119 + 1 > 0x555555555555555LL )
          abort();
        v120 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v65 - *(_QWORD *)a3) >> 4);
        if ( v120 >= 0x2AAAAAAAAAAAAAALL || (2 * v120 >= v119 + 1 ? (v5 = 2 * v120) : (v5 = v119 + 1), v5) )
        {
          v121 = *(_QWORD *)(a3 + 24);
          v122 = *(char **)(v121 + 4096);
          if ( v121 + 4096 - (__int64)v122 >= (unsigned __int64)(48 * v5) )
            *(_QWORD *)(v121 + 4096) = &v122[48 * v5];
          else
            v122 = (char *)malloc(48 * v5);
        }
        else
        {
          v122 = 0LL;
        }
        v265 = &v122[48 * v119];
        *v265 = 18;
        v266 = &v122[48 * v5];
        *(_QWORD *)(v265 + 1) = v388[0];
        v265[10] = 0;
        v265[9] = v388[1];
        *(_DWORD *)(v265 + 11) = 0;
        *((_QWORD *)v265 + 2) = 0LL;
        v265[15] = 0;
        v388[0] = 0LL;
        LOBYTE(v388[1]) = 0;
        v265[24] = 0;
        *((_QWORD *)v265 + 4) = *(_QWORD *)((char *)v389 + 7);
        *((_QWORD *)v265 + 5) = 0LL;
        *(_QWORD *)(v265 + 25) = v389[0];
        *(_QWORD *)((char *)v389 + 7) = 0LL;
        v389[0] = 0LL;
        v268 = *(void ***)a3;
        v267 = *(void ***)(a3 + 8);
        v269 = v265 + 48;
        if ( v267 == *(void ***)a3 )
        {
          v129 = *(void ***)a3;
        }
        else
        {
          do
          {
            *((_QWORD *)v265 - 4) = *(v267 - 4);
            *((_OWORD *)v265 - 3) = *((_OWORD *)v267 - 3);
            v270 = (__int64)*(v267 - 1);
            *(v267 - 5) = 0LL;
            *(v267 - 4) = 0LL;
            *(v267 - 6) = 0LL;
            *((_QWORD *)v265 - 1) = v270;
            *(_OWORD *)(v265 - 24) = *(_OWORD *)(v267 - 3);
            *(v267 - 2) = 0LL;
            *(v267 - 1) = 0LL;
            *(v267 - 3) = 0LL;
            v267 -= 6;
            v265 -= 48;
          }
          while ( v268 != v267 );
          v129 = *(void ***)a3;
          v268 = *(void ***)(a3 + 8);
        }
        v130 = *(_QWORD *)(a3 + 16);
        *(_QWORD *)a3 = v265;
        *(_QWORD *)(a3 + 8) = v269;
        *(_QWORD *)(a3 + 16) = v266;
        if ( v268 != v129 )
        {
          do
          {
            if ( (*(_BYTE *)(v268 - 3) & 1) != 0 )
              free(*(v268 - 1));
            v271 = v268 - 6;
            if ( (*(_BYTE *)(v268 - 6) & 1) != 0 )
              free(*(v268 - 4));
            v268 -= 6;
          }
          while ( v129 != v271 );
        }
        goto LABEL_494;
      case 'y':
        memset(v388, 0, 15);
        qmemcpy(v389, "unsigned long l", 15);
        v15 = *(_QWORD *)(a3 + 8);
        v16 = *(_QWORD *)(a3 + 16);
        if ( v15 >= v16 )
        {
          v67 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v15 - *(_QWORD *)a3) >> 4);
          if ( v67 + 1 > 0x555555555555555LL )
            abort();
          v68 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v16 - *(_QWORD *)a3) >> 4);
          if ( v68 >= 0x2AAAAAAAAAAAAAALL || (2 * v68 >= v67 + 1 ? (v5 = 2 * v68) : (v5 = v67 + 1), v5) )
          {
            v69 = *(_QWORD *)(a3 + 24);
            v70 = *(char **)(v69 + 4096);
            if ( v69 + 4096 - (__int64)v70 >= (unsigned __int64)(48 * v5) )
              *(_QWORD *)(v69 + 4096) = &v70[48 * v5];
            else
              v70 = (char *)malloc(48 * v5);
          }
          else
          {
            v70 = 0LL;
          }
          v132 = &v70[48 * v67];
          *v132 = 36;
          v133 = &v70[48 * v5];
          *((_QWORD *)v132 + 1) = *(_QWORD *)((char *)v389 + 7);
          *((_QWORD *)v132 + 2) = 6778479LL;
          *(_QWORD *)(v132 + 1) = v389[0];
          *(_QWORD *)((char *)v389 + 7) = 0LL;
          v389[0] = 0LL;
          v132[24] = 0;
          *((_QWORD *)v132 + 4) = *(_QWORD *)((char *)v388 + 7);
          *((_QWORD *)v132 + 5) = 0LL;
          *(_QWORD *)(v132 + 25) = v388[0];
          memset(v388, 0, 15);
          v135 = *(void ***)a3;
          v134 = *(void ***)(a3 + 8);
          v136 = v132 + 48;
          if ( v134 == *(void ***)a3 )
          {
            v129 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v132 - 4) = *(v134 - 4);
              *((_OWORD *)v132 - 3) = *((_OWORD *)v134 - 3);
              v137 = (__int64)*(v134 - 1);
              *(v134 - 5) = 0LL;
              *(v134 - 4) = 0LL;
              *(v134 - 6) = 0LL;
              *((_QWORD *)v132 - 1) = v137;
              *(_OWORD *)(v132 - 24) = *(_OWORD *)(v134 - 3);
              *(v134 - 2) = 0LL;
              *(v134 - 1) = 0LL;
              *(v134 - 3) = 0LL;
              v134 -= 6;
              v132 -= 48;
            }
            while ( v135 != v134 );
            v129 = *(void ***)a3;
            v135 = *(void ***)(a3 + 8);
          }
          v130 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v132;
          *(_QWORD *)(a3 + 8) = v136;
          *(_QWORD *)(a3 + 16) = v133;
          if ( v135 != v129 )
          {
            do
            {
              if ( (*(_BYTE *)(v135 - 3) & 1) != 0 )
                free(*(v135 - 1));
              v138 = v135 - 6;
              if ( (*(_BYTE *)(v135 - 6) & 1) != 0 )
                free(*(v135 - 4));
              v135 -= 6;
            }
            while ( v129 != v138 );
          }
          goto LABEL_494;
        }
        *(_BYTE *)v15 = 36;
        v3 = a1 + 1;
        *(_QWORD *)(v15 + 8) = *(_QWORD *)((char *)v389 + 7);
        *(_QWORD *)(v15 + 16) = 6778479LL;
        v17 = v389[0];
LABEL_91:
        *(_QWORD *)(v15 + 1) = v17;
        *(_QWORD *)((char *)v389 + 7) = 0LL;
        v389[0] = 0LL;
        *(_BYTE *)(v15 + 24) = 0;
        *(_QWORD *)(v15 + 32) = *(_QWORD *)((char *)v388 + 7);
        *(_QWORD *)(v15 + 40) = 0LL;
        *(_QWORD *)(v15 + 25) = v388[0];
        memset(v388, 0, 15);
        goto LABEL_106;
      case 'z':
        v388[0] = 0LL;
        BYTE2(v388[1]) = 0;
        LOWORD(v388[1]) = 0;
        *(_QWORD *)((char *)v389 + 7) = 0LL;
        v389[0] = 0LL;
        v387 = 46;
        v385 = 11822;
        v6 = *(_QWORD *)(a3 + 8);
        v27 = *(_QWORD *)(a3 + 16);
        if ( v6 < v27 )
        {
LABEL_95:
          *(_BYTE *)v6 = 6;
          v3 = a1 + 1;
          *(_WORD *)(v6 + 1) = v385;
          *(_BYTE *)(v6 + 4) = 0;
          *(_BYTE *)(v6 + 3) = v387;
          *(_QWORD *)(v6 + 5) = v388[0];
          *(_BYTE *)(v6 + 15) = BYTE2(v388[1]);
          *(_QWORD *)(v6 + 16) = 0LL;
          *(_WORD *)(v6 + 13) = v388[1];
          LOWORD(v388[1]) = 0;
          v388[0] = 0LL;
          BYTE2(v388[1]) = 0;
LABEL_105:
          *(_BYTE *)(v6 + 24) = 0;
          *(_QWORD *)(v6 + 32) = *(_QWORD *)((char *)v389 + 7);
          *(_QWORD *)(v6 + 40) = 0LL;
          *(_QWORD *)(v6 + 25) = v389[0];
          *(_QWORD *)((char *)v389 + 7) = 0LL;
          v389[0] = 0LL;
LABEL_106:
          *(_QWORD *)(a3 + 8) += 48LL;
        }
        else
        {
          v28 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v6 - *(_QWORD *)a3) >> 4);
          if ( v28 + 1 > 0x555555555555555LL )
            abort();
          v29 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v27 - *(_QWORD *)a3) >> 4);
          if ( v29 >= 0x2AAAAAAAAAAAAAALL || (2 * v29 >= v28 + 1 ? (v5 = 2 * v29) : (v5 = v28 + 1), v5) )
          {
            v30 = *(_QWORD *)(a3 + 24);
            v31 = *(char **)(v30 + 4096);
            if ( v30 + 4096 - (__int64)v31 >= (unsigned __int64)(48 * v5) )
              *(_QWORD *)(v30 + 4096) = &v31[48 * v5];
            else
              v31 = (char *)malloc(48 * v5);
          }
          else
          {
            v31 = 0LL;
          }
          v167 = &v31[48 * v28];
          *v167 = 6;
          v168 = &v31[48 * v5];
          *(_WORD *)(v167 + 1) = 11822;
          v167[4] = 0;
          v167[3] = 46;
          *(_QWORD *)(v167 + 5) = v388[0];
          v167[15] = BYTE2(v388[1]);
          *((_QWORD *)v167 + 2) = 0LL;
          *(_WORD *)(v167 + 13) = v388[1];
          LOWORD(v388[1]) = 0;
          v388[0] = 0LL;
          BYTE2(v388[1]) = 0;
          v167[24] = 0;
          *((_QWORD *)v167 + 4) = *(_QWORD *)((char *)v389 + 7);
          *((_QWORD *)v167 + 5) = 0LL;
          *(_QWORD *)(v167 + 25) = v389[0];
          *(_QWORD *)((char *)v389 + 7) = 0LL;
          v389[0] = 0LL;
          v170 = *(void ***)a3;
          v169 = *(void ***)(a3 + 8);
          v171 = v167 + 48;
          if ( v169 == *(void ***)a3 )
          {
            v129 = *(void ***)a3;
          }
          else
          {
            do
            {
              *((_QWORD *)v167 - 4) = *(v169 - 4);
              *((_OWORD *)v167 - 3) = *((_OWORD *)v169 - 3);
              v172 = (__int64)*(v169 - 1);
              *(v169 - 5) = 0LL;
              *(v169 - 4) = 0LL;
              *(v169 - 6) = 0LL;
              *((_QWORD *)v167 - 1) = v172;
              *(_OWORD *)(v167 - 24) = *(_OWORD *)(v169 - 3);
              *(v169 - 2) = 0LL;
              *(v169 - 1) = 0LL;
              *(v169 - 3) = 0LL;
              v169 -= 6;
              v167 -= 48;
            }
            while ( v170 != v169 );
            v129 = *(void ***)a3;
            v170 = *(void ***)(a3 + 8);
          }
          v130 = *(_QWORD *)(a3 + 16);
          *(_QWORD *)a3 = v167;
          *(_QWORD *)(a3 + 8) = v171;
          *(_QWORD *)(a3 + 16) = v168;
          if ( v170 != v129 )
          {
            do
            {
              if ( (*(_BYTE *)(v170 - 3) & 1) != 0 )
                free(*(v170 - 1));
              v173 = v170 - 6;
              if ( (*(_BYTE *)(v170 - 6) & 1) != 0 )
                free(*(v170 - 4));
              v170 -= 6;
            }
            while ( v129 != v173 );
          }
LABEL_494:
          if ( v129 )
          {
            v272 = *(_QWORD *)(a3 + 24);
            if ( v272 + 4096 < (unsigned __int64)v129 || v272 > (unsigned __int64)v129 )
            {
              free(v129);
            }
            else if ( *(_QWORD *)(v272 + 4096) == v130 )
            {
              *(_QWORD *)(v272 + 4096) = v129;
            }
          }
          ++v3;
        }
        break;
      default:
        return v3;
    }
  }
  return v3;
}

//----- (00000000000B64BC) ----------------------------------------------------
void __fastcall sub_B64BC(void ***a1)
{
  void **v2; // x21
  void **v3; // x22
  void **v4; // x0
  void **v5; // x23
  void **v6; // x24
  void **v7; // t1
  void **v8; // x20
  void *v9; // x0
  unsigned __int64 v10; // x8
  unsigned __int64 v11; // x8

  v2 = *a1;
  if ( !*a1 )
    return;
  v3 = a1[1];
  v4 = *a1;
  if ( v3 == v2 )
    goto LABEL_16;
  do
  {
    while ( 1 )
    {
      while ( 1 )
      {
        v5 = v3;
        v7 = (void **)*(v3 - 4);
        v3 -= 4;
        v6 = v7;
        if ( v7 )
          break;
LABEL_10:
        if ( v3 == v2 )
          goto LABEL_15;
      }
      v8 = (void **)*(v5 - 3);
      v9 = v6;
      if ( v8 != v6 )
      {
        do
        {
          v8 -= 4;
          sub_9D32C(v8);
        }
        while ( v6 != v8 );
        v9 = *v3;
      }
      v10 = (unsigned __int64)*(v5 - 1);
      *(v5 - 3) = v6;
      if ( v10 + 4096 >= (unsigned __int64)v9 && v10 <= (unsigned __int64)v9 )
        break;
      free(v9);
      if ( v3 == v2 )
        goto LABEL_15;
    }
    if ( *(void **)(v10 + 4096) != *(v5 - 2) )
      goto LABEL_10;
    *(_QWORD *)(v10 + 4096) = v9;
  }
  while ( v3 != v2 );
LABEL_15:
  v4 = *a1;
LABEL_16:
  v11 = (unsigned __int64)a1[3];
  a1[1] = v2;
  if ( v11 + 4096 < (unsigned __int64)v4 || v11 > (unsigned __int64)v4 )
  {
    free(v4);
  }
  else if ( *(void ***)(v11 + 4096) == a1[2] )
  {
    *(_QWORD *)(v11 + 4096) = v4;
  }
}

//----- (00000000000B65E0) ----------------------------------------------------
void __fastcall sub_B65E0(std::type_info *a1)
{
  std::type_info::~type_info(a1);
  operator delete(a1);
}

//----- (00000000000B6604) ----------------------------------------------------
void __fastcall sub_B6604(std::type_info *a1)
{
  std::type_info::~type_info(a1);
  operator delete(a1);
}

//----- (00000000000B6628) ----------------------------------------------------
void __fastcall sub_B6628(std::type_info *a1)
{
  std::type_info::~type_info(a1);
  operator delete(a1);
}

//----- (00000000000B664C) ----------------------------------------------------
void __fastcall sub_B664C(std::type_info *a1)
{
  std::type_info::~type_info(a1);
  operator delete(a1);
}

//----- (00000000000B6670) ----------------------------------------------------
void __fastcall sub_B6670(std::type_info *a1)
{
  std::type_info::~type_info(a1);
  operator delete(a1);
}

//----- (00000000000B6694) ----------------------------------------------------
void __fastcall sub_B6694(std::type_info *a1)
{
  std::type_info::~type_info(a1);
  operator delete(a1);
}

//----- (00000000000B66B8) ----------------------------------------------------
void __fastcall sub_B66B8(std::type_info *a1)
{
  std::type_info::~type_info(a1);
  operator delete(a1);
}

//----- (00000000000B66DC) ----------------------------------------------------
void __fastcall sub_B66DC(std::type_info *a1)
{
  std::type_info::~type_info(a1);
  operator delete(a1);
}

//----- (00000000000B6700) ----------------------------------------------------
void __fastcall sub_B6700(std::type_info *a1)
{
  std::type_info::~type_info(a1);
  operator delete(a1);
}

//----- (00000000000B6724) ----------------------------------------------------
void __fastcall sub_B6724(std::type_info *a1)
{
  std::type_info::~type_info(a1);
  operator delete(a1);
}

//----- (00000000000B6748) ----------------------------------------------------
bool __fastcall sub_B6748(__int64 a1, __int64 a2)
{
  return a1 == a2;
}

//----- (00000000000B6754) ----------------------------------------------------
__int64 sub_B6754()
{
  return 0LL;
}

//----- (00000000000B675C) ----------------------------------------------------
__int64 sub_B675C()
{
  return 0LL;
}

//----- (00000000000B6764) ----------------------------------------------------
bool __fastcall sub_B6764(__int64 a1, __int64 a2)
{
  return a1 == a2;
}

//----- (00000000000B6770) ----------------------------------------------------
void *__fastcall sub_B6770(void *a1, void *lpsrc, _QWORD *a3)
{
  void *result; // x0
  _QWORD v6[4]; // [xsp+8h] [xbp-78h] BYREF
  __int128 v7; // [xsp+28h] [xbp-58h]
  __int128 v8; // [xsp+38h] [xbp-48h]
  __int64 v9; // [xsp+48h] [xbp-38h]
  _BYTE v10[7]; // [xsp+50h] [xbp-30h]
  __int64 v11; // [xsp+58h] [xbp-28h]

  v11 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a1 == lpsrc )
    return &dword_0 + 1;
  if ( lpsrc )
  {
    result = __dynamic_cast(
               lpsrc,
               (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__shim_type_info,
               (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__class_type_info,
               0LL);
    if ( !result )
      return result;
    v6[0] = result;
    v6[1] = 0LL;
    v6[2] = a1;
    v6[3] = -1LL;
    *(_DWORD *)&v10[3] = 0;
    v9 = 0LL;
    v8 = 0u;
    v7 = 0u;
    *(_DWORD *)v10 = 1;
    (*(void (__fastcall **)(void *, _QWORD *, _QWORD, __int64))(*(_QWORD *)result + 56LL))(result, v6, *a3, 1LL);
    if ( (_DWORD)v8 == 1 )
    {
      *a3 = v7;
      return &dword_0 + 1;
    }
  }
  return 0LL;
}
// 0: using guessed type int dword_0;
// 69E8CC0: using guessed type __int64 *`typeinfo for'__cxxabiv1::__shim_type_info;
// 69E8CE0: using guessed type __int64 *`typeinfo for'__cxxabiv1::__class_type_info;

//----- (00000000000B6850) ----------------------------------------------------
void __fastcall sub_B6850(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  __int64 v4; // x8
  int v5; // w8

  v4 = *(_QWORD *)(a2 + 32);
  if ( v4 )
  {
    if ( v4 == a3 )
    {
      if ( *(_DWORD *)(a2 + 48) == 2 )
        *(_DWORD *)(a2 + 48) = a4;
    }
    else
    {
      v5 = *(_DWORD *)(a2 + 60);
      *(_DWORD *)(a2 + 48) = 2;
      *(_DWORD *)(a2 + 60) = v5 + 1;
      *(_BYTE *)(a2 + 78) = 1;
    }
  }
  else
  {
    *(_QWORD *)(a2 + 32) = a3;
    *(_DWORD *)(a2 + 48) = a4;
    *(_DWORD *)(a2 + 60) = 1;
  }
}

//----- (00000000000B68AC) ----------------------------------------------------
__int64 __fastcall sub_B68AC(__int64 result, __int64 a2, __int64 a3, int a4)
{
  __int64 v4; // x8
  int v5; // w8

  if ( result == *(_QWORD *)(a2 + 16) )
  {
    v4 = *(_QWORD *)(a2 + 32);
    if ( v4 )
    {
      if ( v4 == a3 )
      {
        if ( *(_DWORD *)(a2 + 48) == 2 )
          *(_DWORD *)(a2 + 48) = a4;
      }
      else
      {
        v5 = *(_DWORD *)(a2 + 60);
        *(_DWORD *)(a2 + 48) = 2;
        *(_DWORD *)(a2 + 60) = v5 + 1;
        *(_BYTE *)(a2 + 78) = 1;
      }
    }
    else
    {
      *(_QWORD *)(a2 + 32) = a3;
      *(_DWORD *)(a2 + 48) = a4;
      *(_DWORD *)(a2 + 60) = 1;
    }
  }
  return result;
}

//----- (00000000000B6914) ----------------------------------------------------
__int64 __fastcall sub_B6914(__int64 result, __int64 a2, __int64 a3, int a4)
{
  __int64 v4; // x8
  int v5; // w8

  if ( result != *(_QWORD *)(a2 + 16) )
    return (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(result + 16) + 56LL))(*(_QWORD *)(result + 16));
  v4 = *(_QWORD *)(a2 + 32);
  if ( v4 )
  {
    if ( v4 == a3 )
    {
      if ( *(_DWORD *)(a2 + 48) == 2 )
        *(_DWORD *)(a2 + 48) = a4;
    }
    else
    {
      v5 = *(_DWORD *)(a2 + 60);
      *(_DWORD *)(a2 + 48) = 2;
      *(_DWORD *)(a2 + 60) = v5 + 1;
      *(_BYTE *)(a2 + 78) = 1;
    }
  }
  else
  {
    *(_QWORD *)(a2 + 32) = a3;
    *(_DWORD *)(a2 + 48) = a4;
    *(_DWORD *)(a2 + 60) = 1;
  }
  return result;
}

//----- (00000000000B698C) ----------------------------------------------------
__int64 __fastcall sub_B698C(__int64 *a1, __int64 a2, _QWORD *a3, __int64 a4)
{
  __int64 v4; // x8
  __int64 v5; // x9
  __int64 v6; // x0
  char *v7; // x2

  v4 = a1[1];
  if ( a3 )
  {
    v5 = v4 >> 8;
    if ( (v4 & 1) != 0 )
      v5 = *(_QWORD *)(*a3 + v5);
  }
  else
  {
    v5 = 0LL;
  }
  v6 = *a1;
  v7 = (char *)a3 + v5;
  if ( (v4 & 2) != 0 )
    a4 = (unsigned int)a4;
  else
    a4 = 2LL;
  return (*(__int64 (__fastcall **)(__int64, __int64, char *, __int64))(*(_QWORD *)v6 + 56LL))(v6, a2, v7, a4);
}

//----- (00000000000B69CC) ----------------------------------------------------
__int64 __fastcall sub_B69CC(__int64 result, __int64 a2, char *a3, __int64 a4)
{
  __int64 v5; // x22
  unsigned int v6; // w20
  __int64 v8; // x24
  __int64 v9; // x8
  __int64 v10; // x9
  char *v11; // x8
  int v12; // w8
  __int64 v13; // x0
  char *v14; // x2
  unsigned __int64 v15; // x24
  _QWORD *v16; // x22
  __int64 v17; // x8
  __int64 v18; // x9
  __int64 v19; // x3

  v5 = result;
  v6 = a4;
  if ( result == *(_QWORD *)(a2 + 16) )
  {
    v11 = *(char **)(a2 + 32);
    if ( v11 )
    {
      if ( v11 == a3 )
      {
        if ( *(_DWORD *)(a2 + 48) == 2 )
          *(_DWORD *)(a2 + 48) = a4;
      }
      else
      {
        v12 = *(_DWORD *)(a2 + 60);
        *(_DWORD *)(a2 + 48) = 2;
        *(_DWORD *)(a2 + 60) = v12 + 1;
        *(_BYTE *)(a2 + 78) = 1;
      }
    }
    else
    {
      *(_QWORD *)(a2 + 32) = a3;
      *(_DWORD *)(a2 + 48) = a4;
      *(_DWORD *)(a2 + 60) = 1;
    }
  }
  else
  {
    v8 = *(unsigned int *)(result + 20);
    v9 = *(_QWORD *)(result + 32);
    if ( a3 )
    {
      v10 = v9 >> 8;
      if ( (v9 & 1) != 0 )
        v10 = *(_QWORD *)(*(_QWORD *)a3 + v10);
    }
    else
    {
      v10 = 0LL;
    }
    v13 = *(_QWORD *)(result + 24);
    v14 = &a3[v10];
    if ( (v9 & 2) != 0 )
      a4 = (unsigned int)a4;
    else
      a4 = 2LL;
    result = (*(__int64 (__fastcall **)(__int64, __int64, char *, __int64))(*(_QWORD *)v13 + 56LL))(v13, a2, v14, a4);
    if ( (unsigned int)v8 >= 2 )
    {
      v15 = v5 + 16 * v8 + 24;
      v16 = (_QWORD *)(v5 + 40);
      do
      {
        v17 = v16[1];
        if ( a3 )
        {
          v18 = v17 >> 8;
          if ( (v17 & 1) != 0 )
            v18 = *(_QWORD *)(*(_QWORD *)a3 + v18);
        }
        else
        {
          v18 = 0LL;
        }
        if ( (v17 & 2) != 0 )
          v19 = v6;
        else
          v19 = 2LL;
        result = (*(__int64 (__fastcall **)(_QWORD, __int64, char *, __int64))(*(_QWORD *)*v16 + 56LL))(
                   *v16,
                   a2,
                   &a3[v18],
                   v19);
        if ( *(_BYTE *)(a2 + 78) )
          break;
        v16 += 2;
      }
      while ( (unsigned __int64)v16 < v15 );
    }
  }
  return result;
}

//----- (00000000000B6B18) ----------------------------------------------------
_BYTE *__fastcall sub_B6B18(const char **a1, const char **lpsrc)
{
  _BYTE *result; // x0

  if ( ((_BYTE)a1[2] & 0x18) != 0 )
    return (_BYTE *)(strcmp(a1[1], lpsrc[1]) == 0);
  if ( !lpsrc )
    return 0LL;
  result = __dynamic_cast(
             lpsrc,
             (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__shim_type_info,
             (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__pbase_type_info,
             0LL);
  if ( result )
  {
    if ( (result[16] & 0x18) == 0 )
      return (_BYTE *)(a1 == lpsrc);
    return (_BYTE *)(strcmp(a1[1], lpsrc[1]) == 0);
  }
  return result;
}
// 69E8CC0: using guessed type __int64 *`typeinfo for'__cxxabiv1::__shim_type_info;
// 69E8D00: using guessed type __int64 *`typeinfo for'__cxxabiv1::__pbase_type_info;

//----- (00000000000B6B98) ----------------------------------------------------
void (__fastcall **__fastcall sub_B6B98(__int64 a1, const char **lpsrc, _QWORD **a3))(std::type_info *__hidden this)
{
  void (__fastcall **result)(std::type_info *__hidden); // x0
  void (__fastcall **v7)(std::type_info *__hidden); // x21
  int v8; // w8
  int v9; // w9
  void (__fastcall **v10)(std::type_info *__hidden); // x8
  void *v11; // x0
  _BYTE *v12; // x0
  _QWORD *v13; // x8
  _QWORD *v14; // x22
  void (__fastcall **v15)(std::type_info *__hidden); // x20
  _QWORD v16[4]; // [xsp+8h] [xbp-88h] BYREF
  __int128 v17; // [xsp+28h] [xbp-68h]
  __int128 v18; // [xsp+38h] [xbp-58h]
  __int64 v19; // [xsp+48h] [xbp-48h]
  _BYTE v20[7]; // [xsp+50h] [xbp-40h]
  __int64 v21; // [xsp+58h] [xbp-38h]

  v21 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( lpsrc == (const char **)&`typeinfo for'decltype(nullptr) )
  {
    *a3 = 0LL;
    return (void (__fastcall **)(std::type_info *__hidden))(&dword_0 + 1);
  }
  if ( (*(_BYTE *)(a1 + 16) & 0x18) != 0 )
  {
LABEL_3:
    if ( strcmp(*(const char **)(a1 + 8), lpsrc[1]) )
      goto LABEL_4;
LABEL_20:
    if ( *a3 )
    {
      v13 = (_QWORD *)**a3;
LABEL_22:
      *a3 = v13;
    }
    return (void (__fastcall **)(std::type_info *__hidden))(&dword_0 + 1);
  }
  if ( !lpsrc )
    return 0LL;
  v12 = __dynamic_cast(
          lpsrc,
          (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__shim_type_info,
          (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__pbase_type_info,
          0LL);
  if ( v12 )
  {
    if ( (v12[16] & 0x18) != 0 )
      goto LABEL_3;
    if ( (const char **)a1 == lpsrc )
      goto LABEL_20;
  }
LABEL_4:
  result = (void (__fastcall **)(std::type_info *__hidden))__dynamic_cast(
                                                             lpsrc,
                                                             (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__shim_type_info,
                                                             (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__pointer_type_info,
                                                             0LL);
  v7 = result;
  if ( !result )
    return result;
  if ( *a3 )
    *a3 = (_QWORD *)**a3;
  v8 = *((_DWORD *)result + 4);
  v9 = *(_DWORD *)(a1 + 16);
  if ( ((unsigned __int8)v8 & (unsigned __int8)~(_BYTE)v9 & 7) != 0
    || ((unsigned __int8)v9 & (unsigned __int8)~(_BYTE)v8 & 0x60) != 0 )
  {
    return 0LL;
  }
  result = *(void (__fastcall ***)(std::type_info *__hidden))(a1 + 24);
  v10 = (void (__fastcall **)(std::type_info *__hidden))v7[3];
  if ( result == v10 )
    return (void (__fastcall **)(std::type_info *__hidden))(&dword_0 + 1);
  if ( result == &`typeinfo for'void )
  {
    if ( v10 )
      return (void (__fastcall **)(std::type_info *__hidden))(__dynamic_cast(
                                                                v7[3],
                                                                (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__shim_type_info,
                                                                (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__function_type_info,
                                                                0LL) == 0LL);
    return (void (__fastcall **)(std::type_info *__hidden))(&dword_0 + 1);
  }
  if ( !result )
    return result;
  v11 = __dynamic_cast(
          result,
          (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__shim_type_info,
          (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__pointer_type_info,
          0LL);
  if ( v11 )
  {
    if ( (*(_BYTE *)(a1 + 16) & 1) != 0 )
      return (void (__fastcall **)(std::type_info *__hidden))(sub_B6E94((int)v11, v7[3]) & 1);
    return 0LL;
  }
  result = *(void (__fastcall ***)(std::type_info *__hidden))(a1 + 24);
  if ( !result )
    return result;
  v14 = __dynamic_cast(
          result,
          (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__shim_type_info,
          (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__pointer_to_member_type_info,
          0LL);
  if ( !v14 )
  {
    result = *(void (__fastcall ***)(std::type_info *__hidden))(a1 + 24);
    if ( !result )
      return result;
    result = (void (__fastcall **)(std::type_info *__hidden))__dynamic_cast(
                                                               result,
                                                               (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__shim_type_info,
                                                               (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__class_type_info,
                                                               0LL);
    v15 = result;
    if ( !result )
      return result;
    result = (void (__fastcall **)(std::type_info *__hidden))v7[3];
    if ( !result )
      return result;
    result = (void (__fastcall **)(std::type_info *__hidden))__dynamic_cast(
                                                               result,
                                                               (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__shim_type_info,
                                                               (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__class_type_info,
                                                               0LL);
    if ( !result )
      return result;
    v16[0] = result;
    v16[1] = 0LL;
    v16[2] = v15;
    v16[3] = -1LL;
    *(_DWORD *)&v20[3] = 0;
    v19 = 0LL;
    v18 = 0u;
    v17 = 0u;
    *(_DWORD *)v20 = 1;
    (*((void (__fastcall **)(void (__fastcall **)(std::type_info *__hidden), _QWORD *, _QWORD, __int64))*result + 7))(
      result,
      v16,
      *a3,
      1LL);
    if ( (_DWORD)v18 != 1 )
      return 0LL;
    if ( *a3 )
    {
      v13 = (_QWORD *)v17;
      goto LABEL_22;
    }
    return (void (__fastcall **)(std::type_info *__hidden))(&dword_0 + 1);
  }
  if ( (*(_BYTE *)(a1 + 16) & 1) == 0 )
    return 0LL;
  result = (void (__fastcall **)(std::type_info *__hidden))v7[3];
  if ( result )
  {
    result = (void (__fastcall **)(std::type_info *__hidden))__dynamic_cast(
                                                               result,
                                                               (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__shim_type_info,
                                                               (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__pointer_to_member_type_info,
                                                               0LL);
    if ( result )
    {
      if ( ((_DWORD)result[2] & ~*((_DWORD *)v14 + 4)) == 0
        && (void (__fastcall *)(std::type_info *__hidden))v14[3] == result[3] )
      {
        return (void (__fastcall **)(std::type_info *__hidden))(v14[4] == (_QWORD)result[4]);
      }
      return 0LL;
    }
  }
  return result;
}
// 0: using guessed type int dword_0;
// 69E8CC0: using guessed type __int64 *`typeinfo for'__cxxabiv1::__shim_type_info;
// 69E8CE0: using guessed type __int64 *`typeinfo for'__cxxabiv1::__class_type_info;
// 69E8D00: using guessed type __int64 *`typeinfo for'__cxxabiv1::__pbase_type_info;
// 69E8D20: using guessed type __int64 *`typeinfo for'__cxxabiv1::__pointer_type_info;
// 69E8D40: using guessed type __int64 *`typeinfo for'__cxxabiv1::__function_type_info;
// 69E8D60: using guessed type __int64 *`typeinfo for'__cxxabiv1::__pointer_to_member_type_info;
// 69E8E08: using guessed type void (__fastcall *`typeinfo for'void)(std::type_info *__hidden this);
// 69E8E60: using guessed type void (__fastcall *`typeinfo for'decltype(nullptr))(std::type_info *__hidden this);

//----- (00000000000B6E94) ----------------------------------------------------
_QWORD *__fastcall sub_B6E94(void *a1, void *lpsrc)
{
  const void *v2; // x8
  _QWORD *result; // x0
  _QWORD *v5; // x21
  int v6; // w9
  __int64 v7; // x8
  void *v8; // x0
  _QWORD *v9; // x19

  v2 = lpsrc;
  if ( !lpsrc )
    return 0LL;
  while ( 1 )
  {
    result = __dynamic_cast(
               v2,
               (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__shim_type_info,
               (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__pointer_type_info,
               0LL);
    v5 = result;
    if ( !result )
      break;
    v6 = *((_DWORD *)a1 + 4);
    if ( ((_DWORD)result[2] & ~v6) != 0 )
      return 0LL;
    v7 = *((_QWORD *)a1 + 3);
    if ( v7 == result[3] )
      return (_QWORD *)(&dword_0 + 1);
    result = 0LL;
    if ( (v6 & 1) == 0 || !v7 )
      return result;
    v8 = __dynamic_cast(
           *((const void **)a1 + 3),
           (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__shim_type_info,
           (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__pointer_type_info,
           0LL);
    if ( !v8 )
    {
      result = (_QWORD *)*((_QWORD *)a1 + 3);
      if ( !result )
        return result;
      result = __dynamic_cast(
                 result,
                 (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__shim_type_info,
                 (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__pointer_to_member_type_info,
                 0LL);
      v9 = result;
      if ( !result )
        return result;
      result = (_QWORD *)v5[3];
      if ( !result )
        return result;
      result = __dynamic_cast(
                 result,
                 (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__shim_type_info,
                 (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__pointer_to_member_type_info,
                 0LL);
      if ( !result )
        return result;
      if ( ((_DWORD)result[2] & ~*((_DWORD *)v9 + 4)) == 0 && v9[3] == result[3] )
        return (_QWORD *)(v9[4] == result[4]);
      return 0LL;
    }
    v2 = (const void *)v5[3];
    a1 = v8;
    if ( !v2 )
      return 0LL;
  }
  return result;
}
// 0: using guessed type int dword_0;
// 69E8CC0: using guessed type __int64 *`typeinfo for'__cxxabiv1::__shim_type_info;
// 69E8D20: using guessed type __int64 *`typeinfo for'__cxxabiv1::__pointer_type_info;
// 69E8D60: using guessed type __int64 *`typeinfo for'__cxxabiv1::__pointer_to_member_type_info;

//----- (00000000000B6FC8) ----------------------------------------------------
_QWORD *__fastcall sub_B6FC8(__int64 a1, void *lpsrc)
{
  _QWORD *result; // x0

  if ( lpsrc )
  {
    result = __dynamic_cast(
               lpsrc,
               (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__shim_type_info,
               (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__pointer_to_member_type_info,
               0LL);
    if ( !result )
      return result;
    if ( ((_DWORD)result[2] & ~*(_DWORD *)(a1 + 16)) == 0 && *(_QWORD *)(a1 + 24) == result[3] )
      return (_QWORD *)(*(_QWORD *)(a1 + 32) == result[4]);
  }
  return 0LL;
}
// 69E8CC0: using guessed type __int64 *`typeinfo for'__cxxabiv1::__shim_type_info;
// 69E8D60: using guessed type __int64 *`typeinfo for'__cxxabiv1::__pointer_to_member_type_info;

//----- (00000000000B7044) ----------------------------------------------------
_DWORD *__fastcall sub_B7044(__int64 a1, const char **lpsrc, _QWORD *a3)
{
  _DWORD *result; // x0
  int v7; // w8
  int v8; // w9
  const void *v9; // x0
  void *v10; // x19
  _BYTE *v11; // x0

  if ( lpsrc != (const char **)&`typeinfo for'decltype(nullptr) )
  {
    if ( (*(_BYTE *)(a1 + 16) & 0x18) != 0 )
      goto LABEL_3;
    if ( !lpsrc )
      return 0LL;
    v11 = __dynamic_cast(
            lpsrc,
            (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__shim_type_info,
            (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__pbase_type_info,
            0LL);
    if ( v11 )
    {
      if ( (v11[16] & 0x18) != 0 )
      {
LABEL_3:
        if ( strcmp(*(const char **)(a1 + 8), lpsrc[1]) )
          goto LABEL_4;
        return &dword_0 + 1;
      }
      if ( (const char **)a1 == lpsrc )
        return &dword_0 + 1;
    }
LABEL_4:
    result = __dynamic_cast(
               lpsrc,
               (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__shim_type_info,
               (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__pointer_to_member_type_info,
               0LL);
    if ( !result )
      return result;
    v7 = result[4];
    v8 = *(_DWORD *)(a1 + 16);
    if ( ((unsigned __int8)v7 & (unsigned __int8)~(_BYTE)v8 & 7) == 0
      && ((unsigned __int8)v8 & (unsigned __int8)~(_BYTE)v7 & 0x60) == 0
      && *(_QWORD *)(a1 + 24) == *((_QWORD *)result + 3) )
    {
      return (_DWORD *)(*(_QWORD *)(a1 + 32) == *((_QWORD *)result + 4));
    }
    return 0LL;
  }
  v9 = *(const void **)(a1 + 24);
  v10 = &unk_69D22D0;
  if ( v9
    && __dynamic_cast(
         v9,
         (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__shim_type_info,
         (const struct __class_type_info *)&`typeinfo for'__cxxabiv1::__function_type_info,
         0LL) )
  {
    v10 = &unk_69D22C0;
  }
  *a3 = v10;
  return &dword_0 + 1;
}
// 0: using guessed type int dword_0;
// 69E8CC0: using guessed type __int64 *`typeinfo for'__cxxabiv1::__shim_type_info;
// 69E8D00: using guessed type __int64 *`typeinfo for'__cxxabiv1::__pbase_type_info;
// 69E8D40: using guessed type __int64 *`typeinfo for'__cxxabiv1::__function_type_info;
// 69E8D60: using guessed type __int64 *`typeinfo for'__cxxabiv1::__pointer_to_member_type_info;
// 69E8E60: using guessed type void (__fastcall *`typeinfo for'decltype(nullptr))(std::type_info *__hidden this);

//----- (00000000000B7188) ----------------------------------------------------
void *_dynamic_cast(
        const void *lpsrc,
        const struct __class_type_info *lpstype,
        const struct __class_type_info *lpdtype,
        ptrdiff_t s2d)
{
  const struct __class_type_info *v5; // x0
  __int64 v6; // x10
  char *v7; // x19
  void *result; // x0
  _QWORD v11[4]; // [xsp+8h] [xbp-68h] BYREF
  __int128 v12; // [xsp+28h] [xbp-48h]
  __int128 v13; // [xsp+38h] [xbp-38h]
  _QWORD v14[3]; // [xsp+48h] [xbp-28h]

  v14[2] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v6 = *(_QWORD *)(*(_QWORD *)lpsrc - 16LL);
  v5 = *(const struct __class_type_info **)(*(_QWORD *)lpsrc - 8LL);
  v11[0] = lpdtype;
  v11[1] = lpsrc;
  v11[2] = lpstype;
  v11[3] = s2d;
  *(_QWORD *)((char *)v14 + 7) = 0LL;
  v7 = (char *)lpsrc + v6;
  v14[0] = 0LL;
  v13 = 0u;
  v12 = 0u;
  if ( v5 == lpdtype )
  {
    LODWORD(v14[1]) = 1;
    (*(void (__fastcall **)(const struct __class_type_info *, _QWORD *, char *, char *, __int64, _QWORD))(*(_QWORD *)lpdtype + 40LL))(
      lpdtype,
      v11,
      v7,
      v7,
      1LL,
      0LL);
    if ( (_DWORD)v13 == 1 )
      return v7;
    else
      return 0LL;
  }
  else
  {
    (*(void (__fastcall **)(const struct __class_type_info *, _QWORD *, char *, __int64, _QWORD))(*(_QWORD *)v5 + 48LL))(
      v5,
      v11,
      (char *)lpsrc + v6,
      1LL,
      0LL);
    if ( HIDWORD(v13) == 1 )
    {
      if ( (_DWORD)v13 == 1 )
        return (void *)v12;
      result = 0LL;
      if ( !LODWORD(v14[0]) && *(_QWORD *)((char *)&v13 + 4) == 0x100000001LL )
        return (void *)v12;
    }
    else if ( HIDWORD(v13) )
    {
      return 0LL;
    }
    else if ( DWORD2(v13) == 1 && DWORD1(v13) == 1 && LODWORD(v14[0]) == 1 )
    {
      return (void *)*((_QWORD *)&v12 + 1);
    }
    else
    {
      return 0LL;
    }
  }
  return result;
}

//----- (00000000000B72C0) ----------------------------------------------------
void __fastcall sub_B72C0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int a5)
{
  __int64 v5; // x9
  __int64 v6; // x9
  int v7; // w8
  int v8; // w8
  int v9; // w8

  v5 = *(_QWORD *)(a2 + 8);
  *(_BYTE *)(a2 + 77) = 1;
  if ( v5 == a4 )
  {
    v6 = *(_QWORD *)(a2 + 32);
    *(_BYTE *)(a2 + 76) = 1;
    if ( v6 )
    {
      if ( v6 == a3 )
      {
        v9 = *(_DWORD *)(a2 + 48);
        if ( v9 == 2 )
        {
          v9 = a5;
          *(_DWORD *)(a2 + 48) = a5;
        }
        if ( *(_DWORD *)(a2 + 72) == 1 && v9 == 1 )
          *(_BYTE *)(a2 + 78) = 1;
      }
      else
      {
        v7 = *(_DWORD *)(a2 + 60);
        *(_BYTE *)(a2 + 78) = 1;
        *(_DWORD *)(a2 + 60) = v7 + 1;
      }
    }
    else
    {
      v8 = *(_DWORD *)(a2 + 72);
      *(_QWORD *)(a2 + 32) = a3;
      *(_DWORD *)(a2 + 48) = a5;
      *(_DWORD *)(a2 + 60) = 1;
      if ( v8 == 1 && a5 == 1 )
        *(_BYTE *)(a2 + 78) = 1;
    }
  }
}

//----- (00000000000B7364) ----------------------------------------------------
void __fastcall sub_B7364(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  if ( *(_QWORD *)(a2 + 8) == a3 && *(_DWORD *)(a2 + 52) != 1 )
    *(_DWORD *)(a2 + 52) = a4;
}

//----- (00000000000B7384) ----------------------------------------------------
__int64 __fastcall sub_B7384(__int64 result, __int64 a2, char *a3, unsigned int a4, char a5)
{
  __int64 v6; // x8
  __int64 v10; // x23
  const char *v11; // x24
  __int64 v12; // x8
  __int64 v13; // x24
  __int64 v14; // x9
  __int64 v15; // x3
  int v16; // w8
  unsigned __int64 v17; // x24
  __int64 *v18; // x23
  __int64 v19; // x8
  __int64 v20; // x9
  __int64 v21; // x0
  __int64 v22; // t1
  __int64 v23; // x3
  int v24; // w8
  __int64 v25; // x8
  char v26; // w22
  char v27; // w24
  _QWORD *v28; // x25
  unsigned __int64 v29; // x26
  __int64 v30; // x8
  __int64 v31; // x9
  __int64 v32; // x8
  __int64 v33; // x9
  __int64 v34; // x0
  __int64 v35; // t1
  __int64 v36; // x3
  __int64 v37; // x8
  __int64 v38; // x9
  __int64 v39; // x0
  __int64 v40; // t1
  __int64 v41; // x3
  int v42; // w8
  int v43; // w9
  int v44; // w8

  v6 = *(_QWORD *)(a2 + 16);
  v10 = result;
  if ( (a5 & 1) != 0 )
  {
    v11 = *(const char **)(result + 8);
    result = strcmp(v11, *(const char **)(v6 + 8));
    if ( (_DWORD)result )
    {
      result = strcmp(v11, *(const char **)(*(_QWORD *)a2 + 8LL));
      if ( (_DWORD)result )
      {
LABEL_4:
        v12 = *(_QWORD *)(v10 + 32);
        v13 = *(unsigned int *)(v10 + 20);
        v14 = v12 >> 8;
        if ( (v12 & 1) != 0 )
          v14 = *(_QWORD *)(*(_QWORD *)a3 + v14);
        if ( (v12 & 2) != 0 )
          v15 = a4;
        else
          v15 = 2LL;
        result = (*(__int64 (__fastcall **)(_QWORD, __int64, char *, __int64, _QWORD))(**(_QWORD **)(v10 + 24) + 48LL))(
                   *(_QWORD *)(v10 + 24),
                   a2,
                   &a3[v14],
                   v15,
                   a5 & 1);
        if ( (unsigned int)v13 >= 2 )
        {
          v16 = *(_DWORD *)(v10 + 16);
          v17 = v10 + 16 * v13 + 24;
          v18 = (__int64 *)(v10 + 40);
          if ( (v16 & 2) != 0 || *(_DWORD *)(a2 + 60) == 1 )
          {
            do
            {
              if ( *(_BYTE *)(a2 + 78) )
                break;
              v19 = v18[1];
              v20 = v19 >> 8;
              if ( (v19 & 1) != 0 )
                v20 = *(_QWORD *)(*(_QWORD *)a3 + v20);
              v22 = *v18;
              v18 += 2;
              v21 = v22;
              v23 = (v19 & 2) != 0 ? a4 : 2LL;
              result = (*(__int64 (__fastcall **)(__int64, __int64, char *, __int64, _QWORD))(*(_QWORD *)v21 + 48LL))(
                         v21,
                         a2,
                         &a3[v20],
                         v23,
                         a5 & 1);
            }
            while ( (unsigned __int64)v18 < v17 );
          }
          else if ( (v16 & 1) != 0 )
          {
            do
            {
              if ( *(_BYTE *)(a2 + 78) || *(_DWORD *)(a2 + 60) == 1 && *(_DWORD *)(a2 + 48) == 1 )
                break;
              v37 = v18[1];
              v38 = v37 >> 8;
              if ( (v37 & 1) != 0 )
                v38 = *(_QWORD *)(*(_QWORD *)a3 + v38);
              v40 = *v18;
              v18 += 2;
              v39 = v40;
              v41 = (v37 & 2) != 0 ? a4 : 2LL;
              result = (*(__int64 (__fastcall **)(__int64, __int64, char *, __int64, _QWORD))(*(_QWORD *)v39 + 48LL))(
                         v39,
                         a2,
                         &a3[v38],
                         v41,
                         a5 & 1);
            }
            while ( (unsigned __int64)v18 < v17 );
          }
          else
          {
            do
            {
              if ( *(_BYTE *)(a2 + 78) || *(_DWORD *)(a2 + 60) == 1 )
                break;
              v32 = v18[1];
              v33 = v32 >> 8;
              if ( (v32 & 1) != 0 )
                v33 = *(_QWORD *)(*(_QWORD *)a3 + v33);
              v35 = *v18;
              v18 += 2;
              v34 = v35;
              v36 = (v32 & 2) != 0 ? a4 : 2LL;
              result = (*(__int64 (__fastcall **)(__int64, __int64, char *, __int64, _QWORD))(*(_QWORD *)v34 + 48LL))(
                         v34,
                         a2,
                         &a3[v33],
                         v36,
                         a5 & 1);
            }
            while ( (unsigned __int64)v18 < v17 );
          }
        }
        return result;
      }
      goto LABEL_22;
    }
LABEL_39:
    if ( *(char **)(a2 + 8) == a3 && *(_DWORD *)(a2 + 52) != 1 )
      *(_DWORD *)(a2 + 52) = a4;
    return result;
  }
  if ( result == v6 )
    goto LABEL_39;
  if ( result != *(_QWORD *)a2 )
    goto LABEL_4;
LABEL_22:
  if ( *(char **)(a2 + 32) != a3 && *(char **)(a2 + 40) != a3 )
  {
    v24 = *(_DWORD *)(a2 + 68);
    *(_DWORD *)(a2 + 56) = a4;
    if ( v24 == 4 )
      return result;
    v25 = *(unsigned int *)(v10 + 20);
    if ( (_DWORD)v25 )
    {
      v26 = 0;
      v27 = 0;
      v28 = (_QWORD *)(v10 + 24);
      v29 = v10 + 16 * v25 + 24;
      do
      {
        *(_WORD *)(a2 + 76) = 0;
        v30 = v28[1];
        v31 = v30 >> 8;
        if ( (v30 & 1) != 0 )
          v31 = *(_QWORD *)(*(_QWORD *)a3 + v31);
        result = (*(__int64 (__fastcall **)(_QWORD, __int64, char *, char *, _QWORD, _QWORD))(*(_QWORD *)*v28 + 40LL))(
                   *v28,
                   a2,
                   a3,
                   &a3[v31],
                   2 - (((unsigned int)v30 >> 1) & 1),
                   a5 & 1);
        if ( *(_BYTE *)(a2 + 78) )
          break;
        if ( *(_BYTE *)(a2 + 77) )
        {
          if ( *(_BYTE *)(a2 + 76) )
          {
            if ( *(_DWORD *)(a2 + 48) == 1 || (*(_BYTE *)(v10 + 16) & 2) == 0 )
              goto LABEL_70;
            v27 = 1;
            v26 = 1;
          }
          else
          {
            v26 = 1;
            if ( (*(_BYTE *)(v10 + 16) & 1) == 0 )
              break;
          }
        }
        v28 += 2;
      }
      while ( (unsigned __int64)v28 < v29 );
      if ( (v27 & 1) != 0 )
        goto LABEL_69;
    }
    else
    {
      v26 = 0;
    }
    v43 = *(_DWORD *)(a2 + 60);
    v42 = *(_DWORD *)(a2 + 64);
    *(_QWORD *)(a2 + 40) = a3;
    *(_DWORD *)(a2 + 64) = v42 + 1;
    if ( v43 == 1 && *(_DWORD *)(a2 + 48) == 2 )
    {
      *(_BYTE *)(a2 + 78) = 1;
      if ( (v26 & 1) != 0 )
      {
LABEL_70:
        v44 = 3;
        goto LABEL_71;
      }
LABEL_68:
      v44 = 4;
LABEL_71:
      *(_DWORD *)(a2 + 68) = v44;
      return result;
    }
LABEL_69:
    if ( (v26 & 1) != 0 )
      goto LABEL_70;
    goto LABEL_68;
  }
  if ( a4 == 1 )
    *(_DWORD *)(a2 + 56) = 1;
  return result;
}

//----- (00000000000B76F0) ----------------------------------------------------
__int64 __fastcall sub_B76F0(__int64 *a1, __int64 a2, __int64 a3, _QWORD *a4, __int64 a5, char a6)
{
  __int64 v6; // x8
  __int64 v7; // x9
  __int64 v8; // x0
  char *v9; // x3

  v6 = a1[1];
  v7 = v6 >> 8;
  if ( (v6 & 1) != 0 )
    v7 = *(_QWORD *)(*a4 + v7);
  v8 = *a1;
  v9 = (char *)a4 + v7;
  if ( (v6 & 2) != 0 )
    a5 = (unsigned int)a5;
  else
    a5 = 2LL;
  return (*(__int64 (__fastcall **)(__int64, __int64, __int64, char *, __int64, _QWORD))(*(_QWORD *)v8 + 40LL))(
           v8,
           a2,
           a3,
           v9,
           a5,
           a6 & 1);
}

//----- (00000000000B7728) ----------------------------------------------------
__int64 __fastcall sub_B7728(__int64 *a1, __int64 a2, _QWORD *a3, __int64 a4, char a5)
{
  __int64 v5; // x8
  __int64 v6; // x9
  __int64 v7; // x0
  char *v8; // x2

  v5 = a1[1];
  v6 = v5 >> 8;
  if ( (v5 & 1) != 0 )
    v6 = *(_QWORD *)(*a3 + v6);
  v7 = *a1;
  v8 = (char *)a3 + v6;
  if ( (v5 & 2) != 0 )
    a4 = (unsigned int)a4;
  else
    a4 = 2LL;
  return (*(__int64 (__fastcall **)(__int64, __int64, char *, __int64, _QWORD))(*(_QWORD *)v7 + 48LL))(
           v7,
           a2,
           v8,
           a4,
           a5 & 1);
}

//----- (00000000000B7760) ----------------------------------------------------
__int64 __fastcall sub_B7760(__int64 result, __int64 a2, __int64 a3, unsigned int a4, char a5)
{
  __int64 v6; // x8
  __int64 v10; // x23
  const char *v11; // x24
  int v12; // w8
  int v13; // w8
  int v14; // w9
  int v15; // w10

  v6 = *(_QWORD *)(a2 + 16);
  v10 = result;
  if ( (a5 & 1) != 0 )
  {
    v11 = *(const char **)(result + 8);
    result = strcmp(v11, *(const char **)(v6 + 8));
    if ( (_DWORD)result )
    {
      result = strcmp(v11, *(const char **)(*(_QWORD *)a2 + 8LL));
      if ( (_DWORD)result )
        return (*(__int64 (__fastcall **)(_QWORD, __int64, __int64, _QWORD, _QWORD))(**(_QWORD **)(v10 + 16) + 48LL))(
                 *(_QWORD *)(v10 + 16),
                 a2,
                 a3,
                 a4,
                 a5 & 1);
      goto LABEL_7;
    }
LABEL_13:
    if ( *(_QWORD *)(a2 + 8) == a3 && *(_DWORD *)(a2 + 52) != 1 )
      *(_DWORD *)(a2 + 52) = a4;
    return result;
  }
  if ( result == v6 )
    goto LABEL_13;
  if ( result != *(_QWORD *)a2 )
    return (*(__int64 (__fastcall **)(_QWORD, __int64, __int64, _QWORD, _QWORD))(**(_QWORD **)(v10 + 16) + 48LL))(
             *(_QWORD *)(v10 + 16),
             a2,
             a3,
             a4,
             a5 & 1);
LABEL_7:
  if ( *(_QWORD *)(a2 + 32) != a3 && *(_QWORD *)(a2 + 40) != a3 )
  {
    v12 = *(_DWORD *)(a2 + 68);
    *(_DWORD *)(a2 + 56) = a4;
    if ( v12 == 4 )
      return result;
    *(_WORD *)(a2 + 76) = 0;
    result = (*(__int64 (__fastcall **)(_QWORD, __int64, __int64, __int64, __int64, _QWORD))(**(_QWORD **)(v10 + 16)
                                                                                           + 40LL))(
               *(_QWORD *)(v10 + 16),
               a2,
               a3,
               a3,
               1LL,
               a5 & 1);
    if ( *(_BYTE *)(a2 + 77) )
    {
      v13 = 3;
      if ( *(_BYTE *)(a2 + 76) )
      {
LABEL_22:
        *(_DWORD *)(a2 + 68) = v13;
        return result;
      }
    }
    else
    {
      v13 = 4;
    }
    v15 = *(_DWORD *)(a2 + 60);
    v14 = *(_DWORD *)(a2 + 64);
    *(_QWORD *)(a2 + 40) = a3;
    *(_DWORD *)(a2 + 64) = v14 + 1;
    if ( v15 == 1 && *(_DWORD *)(a2 + 48) == 2 )
      *(_BYTE *)(a2 + 78) = 1;
    goto LABEL_22;
  }
  if ( a4 == 1 )
    *(_DWORD *)(a2 + 56) = 1;
  return result;
}

//----- (00000000000B78E0) ----------------------------------------------------
__int64 __fastcall sub_B78E0(__int64 result, __int64 a2, __int64 a3, int a4, char a5)
{
  __int64 v6; // x8
  const char *v9; // x22
  int v10; // w8
  int v11; // w9

  v6 = *(_QWORD *)(a2 + 16);
  if ( (a5 & 1) != 0 )
  {
    v9 = *(const char **)(result + 8);
    result = strcmp(v9, *(const char **)(v6 + 8));
    if ( (_DWORD)result )
    {
      result = strcmp(v9, *(const char **)(*(_QWORD *)a2 + 8LL));
      if ( (_DWORD)result )
        return result;
LABEL_7:
      if ( *(_QWORD *)(a2 + 32) == a3 || *(_QWORD *)(a2 + 40) == a3 )
      {
        if ( a4 == 1 )
          *(_DWORD *)(a2 + 56) = 1;
      }
      else
      {
        v11 = *(_DWORD *)(a2 + 60);
        v10 = *(_DWORD *)(a2 + 64);
        *(_DWORD *)(a2 + 56) = a4;
        *(_QWORD *)(a2 + 40) = a3;
        *(_DWORD *)(a2 + 64) = v10 + 1;
        if ( v11 == 1 && *(_DWORD *)(a2 + 48) == 2 )
          *(_BYTE *)(a2 + 78) = 1;
        *(_DWORD *)(a2 + 68) = 4;
      }
      return result;
    }
  }
  else if ( result != v6 )
  {
    if ( result != *(_QWORD *)a2 )
      return result;
    goto LABEL_7;
  }
  if ( *(_QWORD *)(a2 + 8) == a3 && *(_DWORD *)(a2 + 52) != 1 )
    *(_DWORD *)(a2 + 52) = a4;
  return result;
}

//----- (00000000000B79D8) ----------------------------------------------------
__int64 __fastcall sub_B79D8(__int64 result, __int64 a2, __int64 a3, char *a4, unsigned int a5, char a6)
{
  __int64 v7; // x8
  __int64 v12; // x24
  char v13; // w26
  char v14; // w10
  __int64 v15; // x25
  __int64 v16; // x8
  __int64 v17; // x9
  __int64 v18; // x4
  unsigned __int64 v19; // x28
  __int64 *v20; // x25
  __int64 v21; // x8
  __int64 v22; // x9
  __int64 v23; // x0
  __int64 v24; // t1
  __int64 v25; // x4
  char *v26; // x9
  __int64 v27; // x9
  int v28; // w8
  unsigned int v29; // w8
  char v30; // [xsp+Ch] [xbp-54h]

  v7 = *(_QWORD *)(a2 + 16);
  v12 = result;
  if ( (a6 & 1) != 0 )
  {
    result = strcmp(*(const char **)(result + 8), *(const char **)(v7 + 8));
    if ( (_DWORD)result )
    {
LABEL_3:
      v13 = *(_BYTE *)(a2 + 76);
      v14 = *(_BYTE *)(a2 + 77);
      v15 = *(unsigned int *)(v12 + 20);
      *(_WORD *)(a2 + 76) = 0;
      v16 = *(_QWORD *)(v12 + 32);
      v30 = v14;
      v17 = v16 >> 8;
      if ( (v16 & 1) != 0 )
        v17 = *(_QWORD *)(*(_QWORD *)a4 + v17);
      if ( (v16 & 2) != 0 )
        v18 = a5;
      else
        v18 = 2LL;
      result = (*(__int64 (__fastcall **)(_QWORD, __int64, __int64, char *, __int64, _QWORD))(**(_QWORD **)(v12 + 24)
                                                                                            + 40LL))(
                 *(_QWORD *)(v12 + 24),
                 a2,
                 a3,
                 &a4[v17],
                 v18,
                 a6 & 1);
      if ( (unsigned int)v15 >= 2 )
      {
        v19 = v12 + 16 * v15 + 24;
        v20 = (__int64 *)(v12 + 40);
        do
        {
          if ( *(_BYTE *)(a2 + 78) )
            break;
          if ( *(_BYTE *)(a2 + 76) )
          {
            if ( *(_DWORD *)(a2 + 48) == 1 || (*(_BYTE *)(v12 + 16) & 2) == 0 )
              break;
          }
          else if ( *(_BYTE *)(a2 + 77) && (*(_BYTE *)(v12 + 16) & 1) == 0 )
          {
            break;
          }
          *(_WORD *)(a2 + 76) = 0;
          v21 = v20[1];
          v22 = v21 >> 8;
          if ( (v21 & 1) != 0 )
            v22 = *(_QWORD *)(*(_QWORD *)a4 + v22);
          v24 = *v20;
          v20 += 2;
          v23 = v24;
          v25 = (v21 & 2) != 0 ? a5 : 2LL;
          result = (*(__int64 (__fastcall **)(__int64, __int64, __int64, char *, __int64, _QWORD))(*(_QWORD *)v23 + 40LL))(
                     v23,
                     a2,
                     a3,
                     &a4[v22],
                     v25,
                     a6 & 1);
        }
        while ( (unsigned __int64)v20 < v19 );
      }
      *(_BYTE *)(a2 + 76) = v13;
      *(_BYTE *)(a2 + 77) = v30;
      return result;
    }
  }
  else if ( result != v7 )
  {
    goto LABEL_3;
  }
  v26 = *(char **)(a2 + 8);
  *(_BYTE *)(a2 + 77) = 1;
  if ( v26 != a4 )
    return result;
  v27 = *(_QWORD *)(a2 + 32);
  *(_BYTE *)(a2 + 76) = 1;
  if ( !v27 )
  {
    *(_QWORD *)(a2 + 32) = a3;
    *(_DWORD *)(a2 + 48) = a5;
    *(_DWORD *)(a2 + 60) = 1;
    if ( a5 != 1 )
      return result;
    goto LABEL_35;
  }
  if ( v27 != a3 )
  {
    v28 = *(_DWORD *)(a2 + 60);
    *(_BYTE *)(a2 + 78) = 1;
    *(_DWORD *)(a2 + 60) = v28 + 1;
    return result;
  }
  v29 = *(_DWORD *)(a2 + 48);
  if ( v29 == 2 )
  {
    v29 = a5;
    *(_DWORD *)(a2 + 48) = a5;
  }
  if ( v29 == 1 )
  {
LABEL_35:
    if ( *(_DWORD *)(a2 + 72) == 1 )
      *(_BYTE *)(a2 + 78) = 1;
  }
  return result;
}

//----- (00000000000B7BD4) ----------------------------------------------------
__int64 __fastcall sub_B7BD4(__int64 result, __int64 a2, __int64 a3, __int64 a4, unsigned int a5, char a6)
{
  __int64 v7; // x8
  __int64 v12; // x24
  __int64 v13; // x9
  __int64 v14; // x9
  int v15; // w8
  unsigned int v16; // w8

  v7 = *(_QWORD *)(a2 + 16);
  v12 = result;
  if ( (a6 & 1) != 0 )
  {
    result = strcmp(*(const char **)(result + 8), *(const char **)(v7 + 8));
    if ( (_DWORD)result )
      return (*(__int64 (__fastcall **)(_QWORD, __int64, __int64, __int64, _QWORD, _QWORD))(**(_QWORD **)(v12 + 16)
                                                                                          + 40LL))(
               *(_QWORD *)(v12 + 16),
               a2,
               a3,
               a4,
               a5,
               a6 & 1);
  }
  else if ( result != v7 )
  {
    return (*(__int64 (__fastcall **)(_QWORD, __int64, __int64, __int64, _QWORD, _QWORD))(**(_QWORD **)(v12 + 16) + 40LL))(
             *(_QWORD *)(v12 + 16),
             a2,
             a3,
             a4,
             a5,
             a6 & 1);
  }
  v13 = *(_QWORD *)(a2 + 8);
  *(_BYTE *)(a2 + 77) = 1;
  if ( v13 != a4 )
    return result;
  v14 = *(_QWORD *)(a2 + 32);
  *(_BYTE *)(a2 + 76) = 1;
  if ( !v14 )
  {
    *(_QWORD *)(a2 + 32) = a3;
    *(_DWORD *)(a2 + 48) = a5;
    *(_DWORD *)(a2 + 60) = 1;
    if ( a5 != 1 )
      return result;
    goto LABEL_15;
  }
  if ( v14 != a3 )
  {
    v15 = *(_DWORD *)(a2 + 60);
    *(_BYTE *)(a2 + 78) = 1;
    *(_DWORD *)(a2 + 60) = v15 + 1;
    return result;
  }
  v16 = *(_DWORD *)(a2 + 48);
  if ( v16 == 2 )
  {
    v16 = a5;
    *(_DWORD *)(a2 + 48) = a5;
  }
  if ( v16 == 1 )
  {
LABEL_15:
    if ( *(_DWORD *)(a2 + 72) == 1 )
      *(_BYTE *)(a2 + 78) = 1;
  }
  return result;
}

//----- (00000000000B7CF4) ----------------------------------------------------
__int64 __fastcall sub_B7CF4(__int64 result, __int64 a2, __int64 a3, __int64 a4, int a5, char a6)
{
  __int64 v7; // x8
  __int64 v11; // x9
  __int64 v12; // x9
  int v13; // w8
  int v14; // w8

  v7 = *(_QWORD *)(a2 + 16);
  if ( (a6 & 1) != 0 )
  {
    result = strcmp(*(const char **)(result + 8), *(const char **)(v7 + 8));
    if ( (_DWORD)result )
      return result;
  }
  else if ( result != v7 )
  {
    return result;
  }
  v11 = *(_QWORD *)(a2 + 8);
  *(_BYTE *)(a2 + 77) = 1;
  if ( v11 == a4 )
  {
    v12 = *(_QWORD *)(a2 + 32);
    *(_BYTE *)(a2 + 76) = 1;
    if ( v12 )
    {
      if ( v12 != a3 )
      {
        v13 = *(_DWORD *)(a2 + 60);
        *(_BYTE *)(a2 + 78) = 1;
        *(_DWORD *)(a2 + 60) = v13 + 1;
        return result;
      }
      v14 = *(_DWORD *)(a2 + 48);
      if ( v14 == 2 )
      {
        v14 = a5;
        *(_DWORD *)(a2 + 48) = a5;
      }
      if ( v14 != 1 )
        return result;
    }
    else
    {
      *(_QWORD *)(a2 + 32) = a3;
      *(_DWORD *)(a2 + 48) = a5;
      *(_DWORD *)(a2 + 60) = 1;
      if ( a5 != 1 )
        return result;
    }
    if ( *(_DWORD *)(a2 + 72) == 1 )
      *(_BYTE *)(a2 + 78) = 1;
  }
  return result;
}

//----- (00000000000B7DDC) ----------------------------------------------------
_QWORD *__fastcall std::bad_cast::bad_cast(_QWORD *this)
{
  *this = off_69E9860;
  return this;
}
// 69E9860: using guessed type void (__fastcall *[2])(std::bad_cast *__hidden this);

//----- (00000000000B7DF4) ----------------------------------------------------
void __fastcall std::bad_cast::~bad_cast(std::bad_cast *this)
{
  std::exception::~exception(this);
  operator delete(this);
}

//----- (00000000000B7E18) ----------------------------------------------------
const char *__fastcall std::bad_cast::what(std::bad_cast *this)
{
  return "std::bad_cast";
}

//----- (00000000000B7E24) ----------------------------------------------------
_QWORD *__fastcall std::bad_typeid::bad_typeid(_QWORD *this)
{
  *this = off_69E9888;
  return this;
}
// 69E9888: using guessed type void (__fastcall *[2])(std::bad_typeid *__hidden this);

//----- (00000000000B7E3C) ----------------------------------------------------
void __fastcall std::bad_typeid::~bad_typeid(std::bad_typeid *this)
{
  std::exception::~exception(this);
  operator delete(this);
}

//----- (00000000000B7E60) ----------------------------------------------------
const char *__fastcall std::bad_typeid::what(std::bad_typeid *this)
{
  return "std::bad_typeid";
}

//----- (00000000000B7E6C) ----------------------------------------------------
void __noreturn _cxa_pure_virtual(void)
{
  sub_9035C("Pure virtual function called!");
}

//----- (00000000000B7E80) ----------------------------------------------------
void __noreturn _cxa_deleted_virtual(void)
{
  sub_9035C("Deleted virtual function called!");
}

//----- (00000000000B7EBC) ----------------------------------------------------
char *__fastcall sub_B7EBC(char *result, _QWORD *a2)
{
  __int64 v2; // x2
  unsigned int v3; // w3
  char v4; // w4
  char v5; // t1
  unsigned __int64 v6; // x5

  v2 = 0LL;
  v3 = 0;
  do
  {
    v5 = *result++;
    v4 = v5;
    v6 = (unsigned __int64)(v5 & 0x7F) << v3;
    v3 += 7;
    v2 |= v6;
  }
  while ( v5 < 0 );
  if ( v3 <= 0x3F && (v4 & 0x40) != 0 )
    v2 |= -1LL << v3;
  *a2 = v2;
  return result;
}

//----- (00000000000B7EFC) ----------------------------------------------------
char *__fastcall sub_B7EFC(char a1, char *a2, char *a3, unsigned __int64 *a4)
{
  char *v5; // x19
  _QWORD *v8; // x0
  char *result; // x0
  unsigned __int64 v10; // x1
  _QWORD *v11; // t1
  _QWORD *v12; // [xsp+38h] [xbp+38h] BYREF

  v5 = a3;
  if ( a1 == 80 )
  {
    v8 = (_QWORD *)((unsigned __int64)(a3 + 7) & 0xFFFFFFFFFFFFFFF8LL);
    v11 = (_QWORD *)*v8;
    result = (char *)(v8 + 1);
    v10 = (unsigned __int64)v11;
  }
  else
  {
    switch ( a1 & 0xF )
    {
      case 0:
      case 4:
      case 0xC:
        result = a3 + 8;
        v10 = *(_QWORD *)a3;
        break;
      case 1:
        ((void (__fastcall __noreturn *)(char *, _QWORD **))loc_B7E94)(a3, &v12);
      case 2:
        result = a3 + 2;
        v10 = *(unsigned __int16 *)a3;
        break;
      case 3:
        result = a3 + 4;
        v10 = *(unsigned int *)a3;
        break;
      case 9:
        result = sub_B7EBC(a3, &v12);
        v10 = (unsigned __int64)v12;
        break;
      case 0xA:
        result = a3 + 2;
        v10 = *(__int16 *)a3;
        break;
      case 0xB:
        result = a3 + 4;
        v10 = *(int *)a3;
        break;
      default:
        abort();
    }
    if ( v10 )
    {
      if ( (a1 & 0x70) != 0x10 )
        v5 = a2;
      v10 += (unsigned __int64)v5;
      if ( a1 < 0 )
        v10 = *(_QWORD *)v10;
    }
  }
  *a4 = v10;
  return result;
}

//----- (00000000000B7FEC) ----------------------------------------------------
__int64 sub_B7FEC()
{
  __int64 result; // x0

  result = 8LL;
  memset(&byte_69EA280, 8, 32);
  memset(&byte_69EA2C0, 8, 33);
  return result;
}
// 69EA280: using guessed type char byte_69EA280;
// 69EA2C0: using guessed type char byte_69EA2C0;

//----- (00000000000B8100) ----------------------------------------------------
__int64 __fastcall sub_B8100(__int64 result, __int64 a2, _QWORD *a3)
{
  if ( byte_69EA29F != 8 )
    abort();
  *a3 = a2;
  if ( (*(_QWORD *)(result + 832) & 0x4000000000000000LL) != 0 )
    *(_BYTE *)(result + 887) = 0;
  *(_QWORD *)(result + 248) = a3;
  return result;
}
// 69EA29F: using guessed type char byte_69EA29F;

//----- (00000000000B813C) ----------------------------------------------------
__int64 __fastcall Unwind_GetGR(__int64 a1, int a2)
{
  __int64 v2; // x2
  __int64 v3; // x1

  if ( a2 > 97 )
LABEL_2:
    abort();
  v2 = a2;
  v3 = *(_QWORD *)(a1 + 8LL * a2);
  if ( (*(_QWORD *)(a1 + 832) & 0x4000000000000000LL) != 0 && *(_BYTE *)(a1 + v2 + 856) )
    return v3;
  if ( byte_69EA280[v2] != 8 )
    goto LABEL_2;
  return *(_QWORD *)v3;
}

//----- (00000000000B8194) ----------------------------------------------------
__int64 __fastcall sub_B8194(__int64 a1, __int64 a2)
{
  __int64 i; // x20
  _QWORD *v5; // x0
  _QWORD *v6; // x1
  __int64 result; // x0
  __int64 v8; // [xsp+38h] [xbp+38h] BYREF

  if ( ((*(_QWORD *)(a2 + 832) & 0x4000000000000000LL) == 0 || !*(_BYTE *)(a2 + 887)) && !*(_QWORD *)(a2 + 248) )
    sub_B8100(a2, *(_QWORD *)(a2 + 784), &v8);
  for ( i = 0LL; i != 97; ++i )
  {
    v5 = *(_QWORD **)(a1 + 8 * i);
    v6 = *(_QWORD **)(a2 + 8 * i);
    if ( *(_BYTE *)(a1 + i + 856) )
LABEL_7:
      abort();
    if ( *(_BYTE *)(a2 + i + 856) && v5 )
    {
      if ( byte_69EA280[i] != 8 )
        goto LABEL_7;
      *v5 = v6;
    }
    else if ( v5 != 0LL && v6 != 0LL && v6 != v5 )
    {
      memcpy(v5, v6, (unsigned __int8)byte_69EA280[i]);
    }
  }
  if ( (*(_QWORD *)(a1 + 832) & 0x4000000000000000LL) == 0 || (result = 0LL, !*(_BYTE *)(a1 + 887)) )
  {
    result = 0LL;
    if ( !*(_QWORD *)(a1 + 248) )
      return Unwind_GetGR(a2, 31) - *(_QWORD *)(a1 + 784) + *(_QWORD *)(a2 + 848);
  }
  return result;
}

//----- (00000000000B82A0) ----------------------------------------------------
__int64 __fastcall Unwind_GetCFA(__int64 a1)
{
  return *(_QWORD *)(a1 + 784);
}

//----- (00000000000B82A8) ----------------------------------------------------
_QWORD *__fastcall Unwind_SetGR(_QWORD *result, int a2, __int64 a3)
{
  if ( a2 > 97 )
LABEL_2:
    abort();
  if ( (result[104] & 0x4000000000000000LL) != 0 && *((_BYTE *)result + a2 + 856) )
  {
    result[a2] = a3;
  }
  else
  {
    result = (_QWORD *)result[a2];
    if ( byte_69EA280[a2] != 8 )
      goto LABEL_2;
    *result = a3;
  }
  return result;
}

//----- (00000000000B8300) ----------------------------------------------------
__int64 __fastcall Unwind_GetIP(__int64 a1)
{
  return *(_QWORD *)(a1 + 792);
}

//----- (00000000000B8308) ----------------------------------------------------
__int64 __fastcall Unwind_GetIPInfo(__int64 a1, _DWORD *a2)
{
  unsigned __int64 v2; // x2
  __int64 result; // x0

  v2 = *(_QWORD *)(a1 + 832);
  result = *(_QWORD *)(a1 + 792);
  *a2 = v2 >> 63;
  return result;
}

//----- (00000000000B831C) ----------------------------------------------------
__int64 __fastcall Unwind_SetIP(__int64 result, __int64 a2)
{
  *(_QWORD *)(result + 792) = a2;
  return result;
}

//----- (00000000000B8324) ----------------------------------------------------
__int64 __fastcall Unwind_GetLanguageSpecificData(__int64 a1)
{
  return *(_QWORD *)(a1 + 800);
}

//----- (00000000000B832C) ----------------------------------------------------
__int64 __fastcall Unwind_GetRegionStart(__int64 a1)
{
  return *(_QWORD *)(a1 + 824);
}

//----- (00000000000B8334) ----------------------------------------------------
__int64 Unwind_FindEnclosingFunction()
{
  bool v0; // zf
  __int64 result; // x0
  __int64 v2; // [xsp+28h] [xbp+28h]

  v0 = _Unwind_Find_FDE() == 0;
  result = v2;
  if ( v0 )
    return 0LL;
  return result;
}
// B834C: variable 'v2' is possibly undefined

//----- (00000000000B835C) ----------------------------------------------------
__int64 __fastcall Unwind_GetDataRelBase(__int64 a1)
{
  return *(_QWORD *)(a1 + 816);
}

//----- (00000000000B8364) ----------------------------------------------------
__int64 __fastcall Unwind_GetTextRelBase(__int64 a1)
{
  return *(_QWORD *)(a1 + 808);
}

//----- (00000000000B836C) ----------------------------------------------------
__int64 __fastcall sub_B836C(unsigned __int8 a1)
{
  unsigned int v1; // w2

  if ( a1 == 255 )
    return 0LL;
  v1 = a1 & 0x70;
  if ( v1 == 32 )
    return _Unwind_GetTextRelBase();
  if ( v1 <= 0x20 )
  {
    if ( (a1 & 0x70) == 0 || v1 == 16 )
      return 0LL;
LABEL_13:
    abort();
  }
  if ( v1 == 64 )
    return _Unwind_GetRegionStart();
  if ( v1 != 80 )
  {
    if ( v1 == 48 )
      return _Unwind_GetDataRelBase();
    goto LABEL_13;
  }
  return 0LL;
}

//----- (00000000000B83E4) ----------------------------------------------------
char *__fastcall sub_B83E4(char *result, unsigned __int64 a2, __int64 a3, char *dest)
{
  __int64 *v7; // x24
  unsigned __int64 v8; // x2
  char v9; // w1
  char *v10; // x20
  int v11; // w3
  char *v12; // x0
  __int64 *v13; // x3
  __int64 *v14; // x3
  __int64 v15; // x0
  char *v16; // x2
  __int64 v17; // x1
  __int64 v18; // [xsp-660h] [xbp-660h] BYREF
  unsigned __int64 v19; // [xsp+68h] [xbp+68h]
  __int64 v20; // [xsp+78h] [xbp+78h] BYREF
  __int64 v21; // [xsp+80h] [xbp+80h] BYREF
  unsigned __int64 v22; // [xsp+88h] [xbp+88h] BYREF

  *((_QWORD *)dest + 196) = 0LL;
  v7 = 0LL;
  while ( (unsigned __int64)result < a2 )
  {
    v8 = *((_QWORD *)dest + 201);
    if ( v8 >= *(_QWORD *)(a3 + 792) + (*(_QWORD *)(a3 + 832) >> 63) )
      break;
    v9 = *result;
    v10 = result + 1;
    v11 = *result & 0xC0;
    switch ( v11 )
    {
      case 64:
        *((_QWORD *)dest + 201) = v8 + (v9 & 0x3F) * *((_QWORD *)dest + 204);
        break;
      case 128:
        v20 = v9 & 0x3F;
        ((void (__fastcall __noreturn *)(char *, __int64 *))loc_B7E94)(result + 1, &v21);
      case 192:
        *(_DWORD *)&dest[16 * (v9 & 0x3F) + 8] = 0;
        break;
      default:
        switch ( *result )
        {
          case 0:
            goto LABEL_41;
          case 1:
            v19 = (unsigned __int8)dest[1648];
            v12 = (char *)sub_B836C(v19);
            v10 = sub_B7EFC(v19, v12, v10, &v22);
            *((_QWORD *)dest + 201) = v22;
            break;
          case 2:
            v10 = result + 2;
            *((_QWORD *)dest + 201) = v8 + (unsigned __int8)result[1] * *((_QWORD *)dest + 204);
            break;
          case 3:
            v10 = result + 3;
            *((_QWORD *)dest + 201) = v8 + *(unsigned __int16 *)(result + 1) * *((_QWORD *)dest + 204);
            break;
          case 4:
            v10 = result + 5;
            *((_QWORD *)dest + 201) = v8 + *(unsigned int *)(result + 1) * *((_QWORD *)dest + 204);
            break;
          case 5:
            ((void (__fastcall __noreturn *)(char *, __int64 *))loc_B7E94)(result + 1, &v20);
          case 6:
          case 8:
            ((void (__fastcall __noreturn *)(char *, __int64 *))loc_B7E94)(result + 1, &v20);
          case 7:
            ((void (__fastcall __noreturn *)(char *, __int64 *))loc_B7E94)(result + 1, &v20);
          case 9:
            ((void (__fastcall __noreturn *)(char *, __int64 *))loc_B7E94)(result + 1, &v20);
          case 10:
            if ( v7 )
            {
              v13 = v7;
              v7 = (__int64 *)v7[196];
            }
            else
            {
              v13 = &v18;
            }
            *((_QWORD *)dest + 196) = memcpy(v13, dest, 0x648uLL);
            break;
          case 11:
            v19 = *((_QWORD *)dest + 196);
            memcpy(dest, (const void *)v19, 0x648uLL);
            v14 = (__int64 *)v19;
            *(_QWORD *)(v19 + 1568) = v7;
            v7 = v14;
            break;
          case 12:
            ((void (__fastcall __noreturn *)(char *, __int64 *))loc_B7E94)(result + 1, &v21);
          case 13:
            ((void (__fastcall __noreturn *)(char *, __int64 *))loc_B7E94)(result + 1, &v21);
          case 14:
            ((void (__fastcall __noreturn *)(char *, __int64 *))loc_B7E94)(result + 1, &v21);
          case 15:
            *((_QWORD *)dest + 199) = v10;
            *((_DWORD *)dest + 400) = 2;
            ((void (__fastcall __noreturn *)(char *, __int64 *))loc_B7E94)(result + 1, &v21);
          case 16:
            ((void (__fastcall __noreturn *)(char *, __int64 *))loc_B7E94)(result + 1, &v20);
          case 17:
            ((void (__fastcall __noreturn *)(char *, __int64 *))loc_B7E94)(result + 1, &v20);
          case 18:
            ((void (__fastcall __noreturn *)(char *, __int64 *))loc_B7E94)(result + 1, &v21);
          case 19:
            v10 = sub_B7EBC(result + 1, &v22);
            *((_QWORD *)dest + 197) = v22 * *((_QWORD *)dest + 203);
            break;
          case 20:
            ((void (__fastcall __noreturn *)(char *, __int64 *))loc_B7E94)(result + 1, &v20);
          case 21:
            ((void (__fastcall __noreturn *)(char *, __int64 *))loc_B7E94)(result + 1, &v20);
          case 22:
            ((void (__fastcall __noreturn *)(char *, __int64 *))loc_B7E94)(result + 1, &v20);
          case 45:
            v15 = 16LL;
            v16 = dest + 256;
            v20 = 16LL;
            v17 = 0LL;
            do
            {
              *((_DWORD *)v16 + 2) = 1;
              ++v15;
              *(_QWORD *)v16 = v17;
              v16 += 16;
              v17 += 8LL;
            }
            while ( v15 != 32 );
            break;
          case 46:
            ((void (__fastcall __noreturn *)(char *, __int64 *))loc_B7E94)(result + 1, &v21);
          case 47:
            ((void (__fastcall __noreturn *)(char *, __int64 *))loc_B7E94)(result + 1, &v20);
          default:
            abort();
        }
        break;
    }
LABEL_41:
    result = v10;
  }
  return result;
}

//----- (00000000000B88DC) ----------------------------------------------------
__int64 __fastcall sub_B88DC(_QWORD *a1, char *s)
{
  __int64 v4; // x1
  __int64 FDE; // x0
  _DWORD *v7; // x1
  __int64 v8; // x20
  __int64 v9; // x0
  char *v10; // x2
  _DWORD *i; // x0
  char *v12; // x2
  __int64 v13; // x22
  size_t v14; // x0
  __int64 v15; // t1
  __int64 v16; // [xsp+78h] [xbp+78h] BYREF

  memset(s, 0, 0x680uLL);
  v4 = a1[99];
  a1[106] = 0LL;
  a1[100] = 0LL;
  if ( !v4 )
    return 5LL;
  FDE = _Unwind_Find_FDE();
  if ( FDE )
  {
    v13 = FDE + 4 - *(int *)(FDE + 4);
    *((_QWORD *)s + 201) = a1[103];
    v14 = v13 + 9 + strlen((const char *)(v13 + 9)) + 1;
    if ( *(_BYTE *)(v13 + 9) == 101 && *(_BYTE *)(v13 + 10) == 104 )
    {
      v15 = *(_QWORD *)v14;
      v14 += 8LL;
      *((_QWORD *)s + 207) = v15;
    }
    if ( *(unsigned __int8 *)(v13 + 8) > 3u )
    {
      if ( *(_BYTE *)v14 != 8 || *(_BYTE *)(v14 + 1) )
        return 3LL;
      v14 += 2LL;
    }
    ((void (__fastcall __noreturn *)(size_t, __int64 *))loc_B7E94)(v14, &v16);
  }
  v7 = (_DWORD *)a1[99];
  if ( *v7 != -763358872 || v7[1] != -738197503 )
    return 5LL;
  v8 = a1[98];
  *((_QWORD *)s + 198) = 31LL;
  *((_DWORD *)s + 400) = 1;
  *((_QWORD *)s + 197) = 304LL;
  v9 = 8LL;
  v10 = s;
  do
  {
    *((_DWORD *)v10 + 2) = 1;
    *(_QWORD *)v10 = v9;
    v10 += 16;
    v9 += 8LL;
  }
  while ( v9 != 256 );
  for ( i = (_DWORD *)(v8 + 592); *i; i = (_DWORD *)((char *)i + (unsigned int)i[1]) )
  {
    if ( *i == 1179680769 )
    {
      v12 = s + 1024;
      do
      {
        *((_DWORD *)v12 + 2) = 1;
        *(_QWORD *)v12 = &v12[-1312 - v8 - (_QWORD)s + (_QWORD)i];
        v12 += 16;
      }
      while ( v12 != s + 1536 );
    }
  }
  s[1651] = 1;
  *((_QWORD *)s + 62) = 256LL;
  *((_DWORD *)s + 126) = 1;
  *((_DWORD *)s + 386) = 4;
  *((_QWORD *)s + 192) = *(_QWORD *)(v8 + 568) - (v8 + 304);
  *((_QWORD *)s + 205) = 96LL;
  return 0LL;
}

//----- (00000000000B8D00) ----------------------------------------------------
__int64 __fastcall sub_B8D00(char *a1, unsigned __int64 a2, __int64 a3, __int64 a4)
{
  int v7; // w25
  unsigned int v8; // w26
  char *v9; // x27
  __int64 v10; // x0
  int v11; // w1
  int v12; // w0
  char *v13; // x27
  char *v14; // x0
  char *v15; // x0
  __int64 GR; // x0
  int v17; // w0
  __int64 v18; // x1
  __int64 v19; // x0
  __int64 v20; // x2
  __int64 v21; // x3
  __int64 v22; // x4
  __int64 v23; // x2
  __int64 v24; // x1
  __int64 v25; // x0
  unsigned __int8 v27; // [xsp+68h] [xbp+68h]
  __int64 v28; // [xsp+70h] [xbp+70h] BYREF
  __int64 v29; // [xsp+78h] [xbp+78h] BYREF
  __int64 v30; // [xsp+80h] [xbp+80h] BYREF
  __int64 v31; // [xsp+88h] [xbp+88h] BYREF
  _QWORD v32[64]; // [xsp+90h] [xbp+90h]

  v32[0] = a4;
  v7 = 1;
  while ( (unsigned __int64)a1 < a2 )
  {
    v8 = (unsigned __int8)*a1;
    v9 = a1 + 1;
    if ( v8 > 0x20 )
    {
      if ( v8 > 0x4F )
      {
        if ( v8 == 144 )
          ((void (__fastcall __noreturn *)(char *, __int64 *))loc_B7E94)(a1 + 1, &v28);
        if ( v8 <= 0x90 )
        {
          if ( v8 > 0x6F )
          {
            v9 = sub_B7EBC(a1 + 1, &v30);
            GR = Unwind_GetGR(a3, v8 - 112);
            v10 = GR + v30;
          }
          else
          {
            v10 = Unwind_GetGR(a3, v8 - 80);
          }
          goto LABEL_117;
        }
        if ( v8 == 148 )
          goto LABEL_76;
        if ( v8 <= 0x94 )
        {
          if ( v8 == 146 )
            ((void (__fastcall __noreturn *)(char *, __int64 *))loc_B7E94)(a1 + 1, &v28);
LABEL_116:
          abort();
        }
        if ( v8 != 150 )
        {
          if ( v8 != 241 )
            goto LABEL_116;
          v13 = a1 + 2;
          v27 = a1[1];
          v14 = (char *)sub_B836C(v27);
          v15 = sub_B7EFC(v27, v14, v13, (unsigned __int64 *)&v31);
LABEL_60:
          v9 = v15;
          v10 = v31;
          goto LABEL_117;
        }
      }
      else
      {
        if ( v8 >= 0x30 )
        {
          v10 = v8 - 48;
          goto LABEL_117;
        }
        if ( v8 <= 0x27 )
        {
          if ( v8 != 35 )
            goto LABEL_91;
          goto LABEL_76;
        }
        if ( v8 > 0x2E )
        {
          v9 = &a1[*(__int16 *)(a1 + 1) + 3];
        }
        else
        {
          if ( v8 >= 0x29 )
          {
LABEL_91:
            if ( v7 > 1 )
            {
              v24 = v32[v7 - 2];
              v25 = v32[v7 - 1];
              switch ( *a1 )
              {
                case 26:
                  v10 = v25 & v24;
                  goto LABEL_109;
                case 27:
                  v10 = v24 / v25;
                  goto LABEL_109;
                case 28:
                  v10 = v24 - v25;
                  goto LABEL_109;
                case 29:
                  v10 = v24 % (unsigned __int64)v25;
                  goto LABEL_109;
                case 30:
                  v10 = v25 * v24;
                  goto LABEL_109;
                case 33:
                  v10 = v25 | v24;
                  goto LABEL_109;
                case 34:
                  v10 = v25 + v24;
                  goto LABEL_109;
                case 36:
                  v10 = v24 << v25;
                  goto LABEL_109;
                case 37:
                  v10 = (unsigned __int64)v24 >> v25;
                  goto LABEL_109;
                case 38:
                  v10 = v24 >> v25;
                  goto LABEL_109;
                case 39:
                  v10 = v25 ^ v24;
                  goto LABEL_109;
                case 41:
                  v10 = v24 == v25;
                  goto LABEL_109;
                case 42:
                  v10 = v24 >= v25;
                  goto LABEL_109;
                case 43:
                  v10 = v24 > v25;
                  goto LABEL_109;
                case 44:
                  v10 = v24 <= v25;
                  goto LABEL_109;
                case 45:
                  v10 = v24 < v25;
                  goto LABEL_109;
                case 46:
                  v10 = v24 != v25;
LABEL_109:
                  v7 -= 2;
                  goto LABEL_117;
                default:
                  goto LABEL_116;
              }
            }
            goto LABEL_116;
          }
          if ( !v7 )
            goto LABEL_116;
          --v7;
          v9 = a1 + 3;
          if ( v32[v7] )
            v9 = &a1[*(__int16 *)(a1 + 1) + 3];
        }
      }
    }
    else
    {
      if ( v8 >= 0x1F )
        goto LABEL_76;
      if ( v8 == 16 )
        ((void (__fastcall __noreturn *)(char *, __int64 *))loc_B7E94)(a1 + 1, &v29);
      if ( v8 <= 0x10 )
      {
        if ( v8 == 10 )
        {
          v10 = *(unsigned __int16 *)(a1 + 1);
        }
        else
        {
          if ( v8 <= 0xA )
          {
            if ( v8 != 6 )
            {
              if ( v8 > 6 )
              {
                v9 = a1 + 2;
                if ( v8 == 8 )
                {
                  v10 = (unsigned __int8)a1[1];
                }
                else
                {
                  if ( v8 != 9 )
                    goto LABEL_116;
                  v10 = a1[1];
                }
              }
              else
              {
                if ( v8 != 3 )
                  goto LABEL_116;
                v10 = *(_QWORD *)(a1 + 1);
                v9 = a1 + 9;
              }
              goto LABEL_117;
            }
LABEL_76:
            if ( !v7 )
              goto LABEL_116;
            v23 = v32[--v7];
            if ( v8 == 31 )
            {
              v10 = -v23;
            }
            else if ( v8 > 0x1F )
            {
              if ( v8 == 35 )
                ((void (__fastcall __noreturn *)(char *, __int64 *))loc_B7E94)(a1 + 1, &v29);
              if ( v8 == 148 )
              {
                v9 = a1 + 2;
                switch ( a1[1] )
                {
                  case 1:
                    v10 = *(unsigned __int8 *)v23;
                    goto LABEL_117;
                  case 2:
                    v10 = *(unsigned __int16 *)v23;
                    goto LABEL_117;
                  case 4:
                    v10 = *(unsigned int *)v23;
                    goto LABEL_117;
                  case 8:
                    goto LABEL_88;
                  default:
                    goto LABEL_116;
                }
              }
              v10 = ~v23;
            }
            else if ( v8 == 6 )
            {
LABEL_88:
              v10 = *(_QWORD *)v23;
            }
            else
            {
              v10 = (v23 ^ (v23 >> 63)) + ((unsigned __int64)v23 >> 63);
            }
            goto LABEL_117;
          }
          if ( v8 == 13 )
          {
            v10 = *(int *)(a1 + 1);
            goto LABEL_58;
          }
          if ( v8 > 0xD )
          {
            v9 = a1 + 9;
            v10 = *(_QWORD *)(a1 + 1);
            goto LABEL_117;
          }
          if ( v8 != 11 )
          {
            v10 = *(unsigned int *)(a1 + 1);
LABEL_58:
            v9 = a1 + 5;
            goto LABEL_117;
          }
          v10 = *(__int16 *)(a1 + 1);
        }
        v9 = a1 + 3;
        goto LABEL_117;
      }
      if ( v8 == 21 )
      {
        v18 = (unsigned __int8)a1[1];
        v30 = v18;
        v9 = a1 + 2;
        v19 = v7 - 1;
        if ( v18 >= v19 )
          goto LABEL_116;
        v10 = v32[v19 - v18];
        goto LABEL_117;
      }
      if ( v8 <= 0x15 )
      {
        if ( v8 == 18 )
        {
          if ( !v7 )
            goto LABEL_116;
          v17 = v7 - 1;
        }
        else
        {
          if ( v8 < 0x12 )
          {
            v15 = sub_B7EBC(a1 + 1, &v31);
            goto LABEL_60;
          }
          if ( v8 == 19 )
          {
            if ( !v7 )
              goto LABEL_116;
            --v7;
            goto LABEL_119;
          }
          if ( v7 <= 1 )
            goto LABEL_116;
          v17 = v7 - 2;
        }
        v10 = v32[v17];
LABEL_117:
        if ( (unsigned int)v7 > 0x3F )
          goto LABEL_116;
        v32[v7++] = v10;
        goto LABEL_119;
      }
      if ( v8 == 25 )
        goto LABEL_76;
      if ( v8 > 0x19 )
        goto LABEL_91;
      v11 = v7 - 1;
      v12 = v7 - 2;
      if ( v8 == 22 )
      {
        if ( v7 <= 1 )
          goto LABEL_116;
        v20 = v32[v11];
        v32[v11] = v32[v12];
        v32[v12] = v20;
      }
      else
      {
        if ( v8 != 23 || v7 <= 2 )
          goto LABEL_116;
        v21 = v32[v11];
        v22 = v32[v7 - 3];
        v32[v11] = v32[v12];
        v32[v12] = v22;
        v32[v7 - 3] = v21;
      }
    }
LABEL_119:
    a1 = v9;
  }
  if ( !v7 )
    goto LABEL_116;
  return v32[v7 - 1];
}
// B8DDC: conditional instruction was optimized away because w26.4==C
// B8DF8: conditional instruction was optimized away because w26.4==F
// B8E24: conditional instruction was optimized away because w26.4==14
// B90BC: conditional instruction was optimized away because w26.4==19
// B90E0: conditional instruction was optimized away because w26.4==20

//----- (00000000000B92B4) ----------------------------------------------------
__int64 __fastcall sub_B92B4(__int64 *src, __int64 a2)
{
  int v4; // w0
  __int64 v5; // x26
  char *v6; // x22
  __int64 i; // x20
  unsigned int v8; // w0
  __int64 v9; // x0
  unsigned __int64 v10; // x1
  __int64 result; // x0
  __int64 v12; // [xsp+70h] [xbp+70h] BYREF
  __int64 v13; // [xsp+78h] [xbp+78h] BYREF
  _QWORD v14[110]; // [xsp+80h] [xbp+80h] BYREF
  char v15; // [xsp+3F7h] [xbp+3F7h]

  memcpy(v14, src, 0x3C0uLL);
  if ( ((v14[104] & 0x4000000000000000LL) == 0 || !v15) && !v14[31] )
    sub_B8100((__int64)v14, src[98], &v12);
  if ( (src[104] & 0x4000000000000000LL) != 0 )
    *((_BYTE *)src + 887) = 0;
  v4 = *(_DWORD *)(a2 + 1600);
  src[31] = 0LL;
  if ( v4 != 1 )
  {
    if ( v4 == 2 )
      ((void (__fastcall __noreturn *)(_QWORD, __int64 *))loc_B7E94)(*(_QWORD *)(a2 + 1592), &v13);
    abort();
  }
  src[98] = Unwind_GetGR((__int64)v14, *(_DWORD *)(a2 + 1584)) + *(_QWORD *)(a2 + 1576);
  v5 = a2;
  v6 = (char *)(src + 107);
  for ( i = 0LL; i != 98; ++i )
  {
    v8 = *(_DWORD *)(v5 + 8) - 1;
    if ( v8 <= 4 )
      __asm { BR              X0 }
    v5 += 16LL;
    ++v6;
  }
  v9 = src[104];
  v10 = v9 | 0x8000000000000000LL;
  result = v9 & 0x7FFFFFFFFFFFFFFFLL;
  if ( *(_BYTE *)(a2 + 1651) )
    result = v10;
  src[104] = result;
  return result;
}

//----- (00000000000B94C0) ----------------------------------------------------
__int64 __fastcall sub_B94C0(_QWORD *a1, __int64 a2, __int64 a3)
{
  __int64 v3; // x30
  __int64 result; // x0
  __int64 v8; // [xsp+48h] [xbp+48h] BYREF
  _QWORD v9[200]; // [xsp+50h] [xbp+50h] BYREF
  int v10; // [xsp+690h] [xbp+690h]

  memset(a1, 0, 0x3C0uLL);
  a1[99] = v3;
  a1[104] = 0x4000000000000000LL;
  if ( (unsigned int)sub_B88DC((int)a1, v9) )
    abort();
  if ( (!&pthread_create || pthread_once((pthread_once_t *)&algn_69EA2E1[3], (void (*)(void))sub_B7FEC))
    && !byte_69EA280[0] )
  {
    sub_B7FEC();
  }
  sub_B8100((__int64)a1, a2, &v8);
  v9[197] = 0LL;
  v10 = 1;
  v9[198] = 31LL;
  result = sub_B92B4(a1, (__int64)v9);
  a1[99] = a3;
  return result;
}
// B94F4: variable 'v3' is possibly undefined
// 69EA2E1: using guessed type _BYTE[7];

//----- (00000000000B959C) ----------------------------------------------------
__int64 __fastcall sub_B959C(__int64 *a1, __int64 a2)
{
  __int64 v4; // x1
  __int64 result; // x0

  sub_B92B4(a1, a2);
  v4 = *(_QWORD *)(a2 + 1640);
  result = *(unsigned int *)(a2 + 16 * v4 + 8);
  if ( (_DWORD)result == 6 )
  {
    a1[99] = 0LL;
  }
  else
  {
    result = Unwind_GetGR((__int64)a1, v4);
    a1[99] = result;
  }
  return result;
}

//----- (00000000000B95E8) ----------------------------------------------------
__int64 __fastcall sub_B95E8(_QWORD *a1, __int64 *a2)
{
  int v4; // w24
  int v5; // w22
  __int64 result; // x0
  char v7[1616]; // [xsp+40h] [xbp+40h] BYREF
  __int64 (__fastcall *v8)(__int64, _QWORD, _QWORD, _QWORD *, __int64 *); // [xsp+690h] [xbp+690h]

  while ( 1 )
  {
    v4 = sub_B88DC(a2, v7);
    v5 = _Unwind_GetCFA() - ((unsigned __int64)a2[104] >> 63) == a1[3] ? 4 : 0;
    if ( v4 )
      break;
    if ( v8 )
    {
      result = v8(1LL, v5 | 2u, *a1, a1, a2);
      if ( (_DWORD)result == 7 )
        return result;
      if ( (_DWORD)result != 8 )
        break;
    }
    if ( v5 )
      abort();
    sub_B959C(a2, (__int64)v7);
  }
  return 2LL;
}

//----- (00000000000B96A8) ----------------------------------------------------
__int64 __fastcall sub_B96A8(_QWORD *a1, __int64 *a2)
{
  unsigned int (__fastcall *v2)(__int64, __int64, _QWORD, _QWORD *, __int64 *, __int64); // x23
  __int64 v3; // x24
  unsigned int v6; // w0
  unsigned int v7; // w19
  __int64 v8; // x1
  unsigned int v9; // w0
  char v11[1616]; // [xsp+50h] [xbp+50h] BYREF
  __int64 (__fastcall *v12)(__int64, __int64, _QWORD, _QWORD *, __int64 *); // [xsp+6A0h] [xbp+6A0h]

  v2 = (unsigned int (__fastcall *)(__int64, __int64, _QWORD, _QWORD *, __int64 *, __int64))a1[2];
  v3 = a1[3];
  while ( 1 )
  {
    v6 = sub_B88DC(a2, v11);
    v7 = v6;
    if ( v6 != 5 && v6 )
      return 2LL;
    v8 = v6 == 5 ? 26LL : 10LL;
    if ( v2(1LL, v8, *a1, a1, a2, v3) )
      return 2LL;
    if ( v7 == 5 )
      return v7;
    if ( v12 )
      break;
LABEL_10:
    sub_B959C(a2, (__int64)v11);
  }
  v9 = v12(1LL, 10LL, *a1, a1, a2);
  v7 = v9;
  if ( v9 != 7 )
  {
    if ( v9 != 8 )
      return 2LL;
    goto LABEL_10;
  }
  return v7;
}

//----- (00000000000B9794) ----------------------------------------------------
__int64 __fastcall _frame_state_for(__int64 a1, __int64 a2)
{
  int v4; // w0
  __int64 v5; // x1
  __int64 *v6; // x0
  _BYTE *v7; // x2
  _QWORD *v8; // x1
  int v9; // w3
  _QWORD v11[120]; // [xsp+30h] [xbp+30h] BYREF
  char v12[8]; // [xsp+3F0h] [xbp+3F0h] BYREF
  __int64 v13; // [xsp+3F8h] [xbp+3F8h] BYREF
  __int64 v14; // [xsp+A18h] [xbp+A18h] BYREF
  __int64 v15; // [xsp+A20h] [xbp+A20h]
  int v16; // [xsp+A30h] [xbp+A30h]
  __int64 v17; // [xsp+A58h] [xbp+A58h]
  __int64 v18; // [xsp+A68h] [xbp+A68h]

  memset(v11, 0, sizeof(v11));
  v11[99] = a1 + 1;
  v11[104] = 0x4000000000000000LL;
  v4 = sub_B88DC(v11, v12);
  v5 = 0LL;
  if ( !v4 && v16 != 2 )
  {
    v6 = &v13;
    v7 = (_BYTE *)(a2 + 820);
    v8 = (_QWORD *)(a2 + 32);
    do
    {
      v9 = *(unsigned __int8 *)v6;
      *v7 = v9;
      if ( v9 == 1 || v9 == 2 )
        *v8 = *(v6 - 1);
      else
        *v8 = 0LL;
      v6 += 2;
      ++v7;
      ++v8;
    }
    while ( v6 != &v14 );
    v5 = a2;
    *(_QWORD *)(a2 + 16) = v14;
    *(_WORD *)(a2 + 816) = v15;
    *(_WORD *)(a2 + 818) = v17;
    *(_QWORD *)(a2 + 24) = v11[106];
    *(_QWORD *)(a2 + 8) = v18;
  }
  return v5;
}

//----- (00000000000B988C) ----------------------------------------------------
_QWORD *__fastcall Unwind_RaiseException(
        _QWORD *a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        __int64 a9)
{
  __int64 v9; // x30
  int v11; // w0
  _QWORD v14[120]; // [xsp+D0h] [xbp+D0h] BYREF
  __int64 v15[120]; // [xsp+490h] [xbp+490h] BYREF
  char v16[1616]; // [xsp+850h] [xbp+850h] BYREF
  __int64 (__fastcall *v17)(__int64, __int64, _QWORD, _QWORD *, __int64 *); // [xsp+EA0h] [xbp+EA0h]

  sub_B94C0(v14, (__int64)&a9, v9);
  memcpy(v15, v14, sizeof(v15));
  while ( !(unsigned int)sub_B88DC(v15, v16) )
  {
    if ( v17 )
    {
      v11 = v17(1LL, 1LL, *a1, a1, v15);
      if ( v11 == 6 )
      {
        a1[2] = 0LL;
        a1[3] = _Unwind_GetCFA() - ((unsigned __int64)v15[104] >> 63);
        memcpy(v15, v14, sizeof(v15));
        if ( (unsigned int)sub_B95E8(a1, v15) == 7 )
        {
          sub_B8194((__int64)v14, (__int64)v15);
          nullsub_1();
        }
        return a1;
      }
      if ( v11 != 8 )
        return a1;
    }
    sub_B959C(v15, (__int64)v16);
  }
  return a1;
}
// B98DC: variable 'v9' is possibly undefined

//----- (00000000000B9A04) ----------------------------------------------------
_QWORD *__fastcall Unwind_ForcedUnwind(
        _QWORD *a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        __int64 a9)
{
  __int64 v9; // x30
  _QWORD v15[120]; // [xsp+D0h] [xbp+D0h] BYREF
  __int64 v16[98]; // [xsp+490h] [xbp+490h] BYREF

  sub_B94C0(v15, (__int64)&a9, v9);
  memcpy(v16, v15, 0x3C0uLL);
  a1[2] = a2;
  a1[3] = a3;
  if ( (unsigned int)sub_B96A8(a1, v16) == 7 )
  {
    sub_B8194((__int64)v15, (__int64)v16);
    nullsub_1();
  }
  return a1;
}
// B9A5C: variable 'v9' is possibly undefined

//----- (00000000000B9AF8) ----------------------------------------------------
void __fastcall __noreturn Unwind_Resume(
        _QWORD *a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        __int64 a9)
{
  __int64 v9; // x30
  int v11; // w0
  _QWORD v12[120]; // [xsp+D0h] [xbp+D0h] BYREF
  __int64 v13[98]; // [xsp+490h] [xbp+490h] BYREF

  sub_B94C0(v12, (__int64)&a9, v9);
  memcpy(v13, v12, 0x3C0uLL);
  if ( a1[2] )
    v11 = sub_B96A8(a1, v13);
  else
    v11 = sub_B95E8(a1, v13);
  if ( v11 != 7 )
    abort();
  sub_B8194((__int64)v12, (__int64)v13);
  nullsub_1();
}
// B9B48: variable 'v9' is possibly undefined

//----- (00000000000B9BF4) ----------------------------------------------------
void __fastcall __noreturn Unwind_Resume_or_Rethrow(
        _QWORD *a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        __int64 a9)
{
  __int64 v9; // x30
  _QWORD v11[120]; // [xsp+D0h] [xbp+D0h] BYREF
  __int64 v12[98]; // [xsp+490h] [xbp+490h] BYREF

  if ( a1[2] )
  {
    sub_B94C0(v11, (__int64)&a9, v9);
    memcpy(v12, v11, 0x3C0uLL);
    if ( (unsigned int)sub_B96A8(a1, v12) != 7 )
      abort();
    sub_B8194((__int64)v11, (__int64)v12);
    nullsub_1();
  }
  else
  {
    _Unwind_RaiseException();
  }
}
// B9C58: variable 'v9' is possibly undefined

//----- (00000000000B9CEC) ----------------------------------------------------
__int64 __fastcall Unwind_DeleteException(__int64 result)
{
  __int64 (__fastcall *v1)(__int64, __int64); // x2

  v1 = *(__int64 (__fastcall **)(__int64, __int64))(result + 8);
  if ( v1 )
    return v1(1LL, result);
  return result;
}

//----- (00000000000B9D10) ----------------------------------------------------
__int64 __fastcall Unwind_Backtrace(
        unsigned int (__fastcall *a1)(__int64 *, __int64),
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        __int64 a9)
{
  __int64 v9; // x30
  int v12; // w0
  int v13; // w19
  __int64 v15[120]; // [xsp+A0h] [xbp+A0h] BYREF
  char v16[1664]; // [xsp+460h] [xbp+460h] BYREF

  sub_B94C0(v15, (__int64)&a9, v9);
  while ( 1 )
  {
    v12 = sub_B88DC(v15, v16);
    v13 = v12;
    if ( v12 != 5 && v12 || a1(v15, a2) )
      return 3LL;
    if ( v13 == 5 )
      break;
    sub_B959C(v15, (__int64)v16);
  }
  return 5LL;
}
// B9D5C: variable 'v9' is possibly undefined

//----- (00000000000B9DE0) ----------------------------------------------------
char *__fastcall sub_B9DE0(char *result, _QWORD *a2)
{
  __int64 v2; // x2
  int v3; // w3
  char v4; // t1
  unsigned __int64 v5; // x4

  v2 = 0LL;
  v3 = 0;
  do
  {
    v4 = *result++;
    v5 = (unsigned __int64)(v4 & 0x7F) << v3;
    v3 += 7;
    v2 |= v5;
  }
  while ( v4 < 0 );
  *a2 = v2;
  return result;
}

//----- (00000000000B9E08) ----------------------------------------------------
char *__fastcall sub_B9E08(char *result, _QWORD *a2)
{
  __int64 v2; // x2
  unsigned int v3; // w3
  char v4; // w4
  char v5; // t1
  unsigned __int64 v6; // x5

  v2 = 0LL;
  v3 = 0;
  do
  {
    v5 = *result++;
    v4 = v5;
    v6 = (unsigned __int64)(v5 & 0x7F) << v3;
    v3 += 7;
    v2 |= v6;
  }
  while ( v5 < 0 );
  if ( v3 <= 0x3F && (v4 & 0x40) != 0 )
    v2 |= -1LL << v3;
  *a2 = v2;
  return result;
}

//----- (00000000000B9E48) ----------------------------------------------------
__int64 __fastcall sub_B9E48(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned __int64 v3; // x3
  unsigned __int64 v4; // x1
  __int64 result; // x0

  v3 = *(_QWORD *)(a2 + 8);
  v4 = *(_QWORD *)(a3 + 8);
  if ( v3 >= v4 )
    LODWORD(result) = 0;
  else
    LODWORD(result) = -1;
  if ( v3 > v4 )
    return 1LL;
  else
    return (unsigned int)result;
}

//----- (00000000000B9E64) ----------------------------------------------------
__int64 __fastcall sub_B9E64(
        __int64 result,
        __int64 (__fastcall *a2)(__int64, _QWORD, _QWORD),
        __int64 a3,
        int a4,
        int a5)
{
  __int64 v5; // x24
  int i; // w19
  int v10; // w0
  __int64 v11; // x21
  __int64 v12; // x0
  int v13; // [xsp+58h] [xbp+58h]

  v5 = result;
  for ( i = 2 * a4 + 1; i < a5; i = result + 1 )
  {
    if ( i + 1 < a5 )
    {
      v13 = a4;
      v10 = a2(v5, *(_QWORD *)(a3 + 8LL * i), *(_QWORD *)(a3 + 8LL * i + 8));
      a4 = v13;
      if ( v10 < 0 )
        ++i;
    }
    v11 = 8LL * a4;
    result = a2(v5, *(_QWORD *)(a3 + v11), *(_QWORD *)(a3 + 8LL * i));
    if ( (result & 0x80000000) == 0 )
      break;
    a4 = i;
    v12 = *(_QWORD *)(a3 + v11);
    *(_QWORD *)(a3 + v11) = *(_QWORD *)(a3 + 8LL * i);
    *(_QWORD *)(a3 + 8LL * i) = v12;
    result = (unsigned int)(2 * i);
  }
  return result;
}

//----- (00000000000B9F24) ----------------------------------------------------
__int64 __fastcall sub_B9F24(__int64 result, __int64 (__fastcall *a2)(__int64, _QWORD, _QWORD), __int64 a3)
{
  unsigned __int64 v3; // x19
  __int64 v4; // x24
  __int64 v7; // x22
  unsigned __int64 i; // x20
  __int64 v9; // x20
  int v10; // w19
  __int64 v11; // x23
  int v12; // w4
  __int64 v13; // x0

  v3 = *(_QWORD *)(a3 + 8);
  v4 = result;
  v7 = a3 + 16;
  for ( i = v3 >> 1; ; result = sub_B9E64(v4, a2, v7, i, v3) )
  {
    LODWORD(i) = i - 1;
    if ( (i & 0x80000000) != 0 )
      break;
  }
  v9 = 0LL;
  v10 = v3 - 1;
  v11 = v7 + 8LL * v10;
  while ( v10 > 0 )
  {
    v12 = v10;
    v13 = *(_QWORD *)(a3 + 16);
    *(_QWORD *)(a3 + 16) = *(_QWORD *)(v11 + v9);
    *(_QWORD *)(v11 + v9) = v13;
    --v10;
    v9 -= 8LL;
    result = sub_B9E64(v4, a2, v7, 0, v12);
  }
  return result;
}

//----- (00000000000B9FD8) ----------------------------------------------------
__int64 __fastcall sub_B9FD8(unsigned __int8 a1)
{
  __int64 result; // x0

  if ( a1 == 255 )
    return 0LL;
  switch ( a1 & 7 )
  {
    case 0:
    case 4:
      result = 8LL;
      break;
    case 2:
      result = 2LL;
      break;
    case 3:
      result = 4LL;
      break;
    default:
      abort();
  }
  return result;
}

//----- (00000000000BA038) ----------------------------------------------------
__int64 __fastcall sub_BA038(unsigned __int8 a1, __int64 a2)
{
  unsigned int v2; // w0
  bool v3; // zf

  if ( a1 == 255 )
    return 0LL;
  v2 = a1 & 0x70;
  if ( v2 == 32 )
    return *(_QWORD *)(a2 + 8);
  if ( v2 > 0x20 )
  {
    if ( v2 == 48 )
      return *(_QWORD *)(a2 + 16);
    v3 = v2 == 80;
    goto LABEL_8;
  }
  v3 = v2 == 16;
  if ( v2 )
  {
LABEL_8:
    if ( !v3 )
      abort();
  }
  return 0LL;
}

//----- (00000000000BA098) ----------------------------------------------------
__int64 __fastcall sub_BA098(unsigned __int8 a1, __int64 a2)
{
  unsigned int v2; // w0
  bool v3; // zf

  if ( a1 == 255 )
    return 0LL;
  v2 = a1 & 0x70;
  if ( v2 == 32 )
    return *(_QWORD *)(a2 + 8);
  if ( v2 > 0x20 )
  {
    if ( v2 == 48 )
      return *(_QWORD *)(a2 + 16);
    v3 = v2 == 80;
    goto LABEL_8;
  }
  v3 = v2 == 16;
  if ( v2 )
  {
LABEL_8:
    if ( !v3 )
      abort();
  }
  return 0LL;
}

//----- (00000000000BA0F8) ----------------------------------------------------
char *__fastcall sub_BA0F8(char a1, char *a2, char *a3, unsigned __int64 *a4)
{
  char *v5; // x19
  _QWORD *v8; // x0
  char *result; // x0
  unsigned __int64 v10; // x1
  _QWORD *v11; // t1
  _QWORD *v12; // [xsp+38h] [xbp+38h] BYREF

  v5 = a3;
  if ( a1 == 80 )
  {
    v8 = (_QWORD *)((unsigned __int64)(a3 + 7) & 0xFFFFFFFFFFFFFFF8LL);
    v11 = (_QWORD *)*v8;
    result = (char *)(v8 + 1);
    v10 = (unsigned __int64)v11;
  }
  else
  {
    switch ( a1 & 0xF )
    {
      case 0:
      case 4:
      case 0xC:
        result = a3 + 8;
        v10 = *(_QWORD *)a3;
        break;
      case 1:
        result = sub_B9DE0(a3, &v12);
        goto LABEL_6;
      case 2:
        result = a3 + 2;
        v10 = *(unsigned __int16 *)a3;
        break;
      case 3:
        result = a3 + 4;
        v10 = *(unsigned int *)a3;
        break;
      case 9:
        result = sub_B9E08(a3, &v12);
LABEL_6:
        v10 = (unsigned __int64)v12;
        break;
      case 0xA:
        result = a3 + 2;
        v10 = *(__int16 *)a3;
        break;
      case 0xB:
        result = a3 + 4;
        v10 = *(int *)a3;
        break;
      default:
        abort();
    }
    if ( v10 )
    {
      if ( (a1 & 0x70) != 0x10 )
        v5 = a2;
      v10 += (unsigned __int64)v5;
      if ( a1 < 0 )
        v10 = *(_QWORD *)v10;
    }
  }
  *a4 = v10;
  return result;
}

//----- (00000000000BA1E8) ----------------------------------------------------
__int64 __fastcall sub_BA1E8(__int64 a1, __int64 a2, __int64 a3)
{
  char v5; // w19
  char *v7; // x21
  __int64 result; // x0
  unsigned __int64 v9; // [xsp+40h] [xbp+40h] BYREF
  unsigned __int64 v10; // [xsp+48h] [xbp+48h] BYREF

  v5 = (unsigned __int64)*(unsigned __int16 *)(a1 + 32) >> 3;
  v7 = (char *)sub_BA038(v5, a1);
  sub_BA0F8(v5, v7, (char *)(a2 + 8), &v9);
  sub_BA0F8((unsigned __int64)*(unsigned __int16 *)(a1 + 32) >> 3, v7, (char *)(a3 + 8), &v10);
  if ( v9 >= v10 )
    LODWORD(result) = 0;
  else
    LODWORD(result) = -1;
  if ( v9 > v10 )
    return 1LL;
  else
    return (unsigned int)result;
}

//----- (00000000000BA278) ----------------------------------------------------
__int64 __fastcall sub_BA278(__int64 a1)
{
  __int64 v1; // x20
  size_t v3; // x0
  char *v4; // x1
  int v5; // w2
  __int64 result; // x0
  char *v7; // x0
  char *v8; // x0
  char *v9; // x0
  unsigned __int8 *v10; // x19
  char *v11; // x0
  int v12; // w1
  unsigned __int64 v13; // [xsp+28h] [xbp+28h] BYREF
  __int64 v14; // [xsp+30h] [xbp+30h] BYREF
  __int64 v15; // [xsp+38h] [xbp+38h] BYREF

  v1 = a1 + 9;
  v3 = strlen((const char *)(a1 + 9)) + 1;
  v4 = (char *)(v1 + v3);
  if ( *(unsigned __int8 *)(a1 + 8) > 3u )
  {
    v5 = *(unsigned __int8 *)(v1 + v3);
    result = 255LL;
    if ( v5 != 8 || v4[1] )
      return result;
    v4 += 2;
  }
  if ( *(_BYTE *)(a1 + 9) != 122 )
    return 0LL;
  v7 = sub_B9DE0(v4, &v14);
  v8 = sub_B9E08(v7, &v15);
  if ( *(_BYTE *)(a1 + 8) == 1 )
    v9 = v8 + 1;
  else
    v9 = sub_B9DE0(v8, &v14);
  v10 = (unsigned __int8 *)(a1 + 10);
  v11 = sub_B9DE0(v9, &v14);
  while ( 1 )
  {
    v12 = *v10;
    if ( v12 == 82 )
      break;
    if ( v12 == 80 )
    {
      v11 = sub_BA0F8(*v11 & 0x7F, 0LL, v11 + 1, &v13);
    }
    else
    {
      if ( v12 != 76 )
        return 0LL;
      ++v11;
    }
    ++v10;
  }
  return (unsigned __int8)*v11;
}

//----- (00000000000BA374) ----------------------------------------------------
unsigned int *__fastcall sub_BA374(__int64 a1, unsigned int *a2, __int64 a3)
{
  unsigned __int8 v4; // w0
  int v7; // w21
  char *v8; // x27
  __int64 v9; // x0
  signed int v10; // w1
  __int64 v11; // x20
  unsigned __int64 v12; // x1
  char *v14; // x0
  unsigned int v15; // w0
  __int64 v16; // x1
  unsigned __int64 v17; // [xsp+60h] [xbp+60h] BYREF
  unsigned __int64 v18; // [xsp+68h] [xbp+68h] BYREF

  v4 = (unsigned __int64)*(unsigned __int16 *)(a1 + 32) >> 3;
  v7 = v4;
  v8 = (char *)sub_BA038(v4, a1);
  v9 = 0LL;
  while ( *a2 )
  {
    v10 = a2[1];
    if ( !v10 )
    {
      v11 = v9;
      goto LABEL_16;
    }
    v11 = v9;
    if ( (*(_BYTE *)(a1 + 32) & 4) != 0 )
    {
      v11 = (__int64)a2 - v10 + 4;
      if ( v11 != v9 )
      {
        v7 = sub_BA278((__int64)a2 - v10 + 4);
        v8 = (char *)sub_BA038(v7, a1);
      }
    }
    if ( v7 )
    {
      v14 = sub_BA0F8(v7, v8, (char *)a2 + 8, &v17);
      sub_BA0F8(v7 & 0xF, 0LL, v14, &v18);
      v15 = sub_B9FD8(v7);
      v16 = -1LL;
      if ( v15 <= 7uLL )
        v16 = (1LL << (8 * (unsigned __int8)v15)) - 1;
      if ( (v16 & v17) == 0 )
        goto LABEL_16;
    }
    else
    {
      v12 = *((_QWORD *)a2 + 2);
      v17 = *((_QWORD *)a2 + 1);
      v18 = v12;
      if ( !v17 )
        goto LABEL_16;
    }
    if ( a3 - v17 < v18 )
      return a2;
LABEL_16:
    a2 = (unsigned int *)((char *)a2 + *a2 + 4);
    v9 = v11;
  }
  return 0LL;
}

//----- (00000000000BA4D4) ----------------------------------------------------
__int64 __fastcall sub_BA4D4(__int64 a1)
{
  return sub_BA278(a1 + 4 - *(int *)(a1 + 4));
}

//----- (00000000000BA4E4) ----------------------------------------------------
__int64 __fastcall sub_BA4E4(__int64 *a1, unsigned __int64 a2, __int64 a3)
{
  _BOOL4 v3; // w14
  int *v4; // x6
  __int64 v5; // x7
  __int64 v6; // x5
  __int64 v7; // x9
  __int64 v8; // x4
  _QWORD *v9; // x5
  _QWORD *i; // x1
  int *v11; // x8
  _QWORD *v12; // x1
  __int64 v13; // x13
  unsigned __int64 v14; // x9
  __int64 v15; // x10
  __int64 v16; // x12
  int *v17; // x11
  int v18; // w0
  unsigned __int64 v19; // x1
  _QWORD *v21; // x0
  _BYTE *v22; // x21
  char v23; // w20
  char *v25; // x0
  char *v26; // x0
  int v27; // w20
  char *v28; // x0
  char *v29; // x22
  unsigned __int64 v30; // x1
  unsigned __int64 v31; // x0
  unsigned __int64 v32; // x3
  unsigned __int64 v33; // x4
  __int64 v34; // x20
  __int64 v35; // x23
  unsigned __int8 v36; // w24
  unsigned int v37; // w0
  _BYTE *v38; // x21
  __int64 v39; // x2
  unsigned int *v40; // x0
  char v41; // w20
  char *v42; // x0
  char *v43; // [xsp+48h] [xbp+48h]
  unsigned int *v44; // [xsp+50h] [xbp+50h] BYREF
  unsigned __int64 v45; // [xsp+58h] [xbp+58h] BYREF
  unsigned __int64 v46[4]; // [xsp+60h] [xbp+60h] BYREF
  __int64 v47; // [xsp+80h] [xbp+80h]

  v3 = a2 > 0x2F;
  v4 = (int *)a1[2];
  v5 = *a1;
  if ( a2 > 0x2F && *(_DWORD *)(a3 + 40) )
  {
    v6 = a1[5];
    if ( a1[4] == qword_69EA028 && v6 == qword_69EA2E8 )
    {
      v7 = qword_69EA2F0;
      v8 = 0LL;
      v9 = 0LL;
      for ( i = (_QWORD *)qword_69EA2F0; i; i = (_QWORD *)i[5] )
      {
        if ( *(_QWORD *)a3 >= *i && *(_QWORD *)a3 < i[1] )
        {
          v5 = i[2];
          v11 = (int *)i[3];
          if ( i != (_QWORD *)qword_69EA2F0 )
          {
            v9[5] = i[5];
            i[5] = v7;
            qword_69EA2F0 = (__int64)i;
          }
          goto LABEL_41;
        }
        if ( *(_OWORD *)i == 0LL )
        {
          v8 = (__int64)i;
          break;
        }
        v8 = (__int64)i;
        if ( i[5] )
          v9 = i;
      }
LABEL_21:
      v13 = *((unsigned __int16 *)a1 + 12);
      v14 = 0LL;
      v15 = 0LL;
      v16 = 0LL;
      v17 = 0LL;
      v11 = 0LL;
      while ( --v13 != -1 )
      {
        v18 = *v4;
        if ( *v4 == 1 )
        {
          v19 = v5 + *((_QWORD *)v4 + 2);
          if ( *(_QWORD *)a3 >= v19 && *(_QWORD *)a3 < v19 + *((_QWORD *)v4 + 5) )
          {
            v14 = v19 + *((_QWORD *)v4 + 5);
            v15 = v5 + *((_QWORD *)v4 + 2);
            v16 = 1LL;
          }
        }
        else if ( v18 == 1685382480 )
        {
          v11 = v4;
        }
        else if ( v18 == 2 )
        {
          v17 = v4;
        }
        v4 += 14;
      }
      if ( !v16 )
        return 0LL;
      if ( v3 )
      {
        if ( v9 && v8 )
        {
          v9[5] = *(_QWORD *)(v8 + 40);
          *(_QWORD *)(v8 + 40) = qword_69EA2F0;
          qword_69EA2F0 = v8;
        }
        v21 = (_QWORD *)qword_69EA2F0;
        *(_QWORD *)(qword_69EA2F0 + 16) = v5;
        v21[3] = v11;
        v21[4] = v17;
        *v21 = v15;
        v21[1] = v14;
      }
LABEL_41:
      if ( !v11 )
        return 0LL;
      v22 = (_BYTE *)(v5 + *((_QWORD *)v11 + 2));
      if ( *v22 != 1 )
        return 1LL;
      v23 = v22[1];
      v25 = (char *)sub_BA098(v23, a3);
      v26 = sub_BA0F8(v23, v25, v22 + 4, (unsigned __int64 *)&v44);
      v27 = (unsigned __int8)v22[2];
      if ( v27 != 255 && v22[3] == 59 )
      {
        v43 = v26;
        v28 = (char *)sub_BA098(v27, a3);
        v29 = sub_BA0F8(v27, v28, v43, &v45);
        if ( !v45 )
          return 1LL;
        if ( ((unsigned __int8)v29 & 3) == 0 )
        {
          v30 = *(_QWORD *)a3;
          if ( *(_QWORD *)a3 >= (unsigned __int64)&v22[*(int *)v29] )
          {
            v31 = v45 - 1;
            if ( v30 < (unsigned __int64)&v22[*(int *)&v29[8 * v45 - 8]] )
            {
              v32 = v45 - 1;
              v33 = 0LL;
              do
              {
                while ( 1 )
                {
                  if ( v33 >= v32 )
                    abort();
                  v31 = (v32 + v33) >> 1;
                  if ( v30 >= (unsigned __int64)&v22[*(int *)&v29[8 * v31]] )
                    break;
                  v32 = (v32 + v33) >> 1;
                }
                v33 = v31 + 1;
              }
              while ( v30 >= (unsigned __int64)&v22[*(int *)&v29[8 * v31 + 8]] );
            }
            v34 = 8 * v31;
            v35 = (__int64)&v22[*(int *)&v29[8 * v31 + 4]];
            v36 = sub_BA4D4(v35);
            v37 = sub_B9FD8(v36);
            sub_BA0F8(v36 & 0xF, 0LL, (char *)(v35 + v37 + 8), v46);
            v38 = &v22[*(int *)&v29[v34]];
            if ( *(_QWORD *)a3 < (unsigned __int64)&v38[v46[0]] )
              *(_QWORD *)(a3 + 32) = v35;
            *(_QWORD *)(a3 + 24) = v38;
          }
          return 1LL;
        }
      }
      v46[1] = *(_QWORD *)(a3 + 8);
      v46[2] = *(_QWORD *)(a3 + 16);
      v47 = 0LL;
      v39 = *(_QWORD *)a3;
      LOBYTE(v47) = 4;
      v46[0] = 0LL;
      v46[3] = (unsigned __int64)v44;
      v40 = sub_BA374((__int64)v46, v44, v39);
      *(_QWORD *)(a3 + 32) = v40;
      if ( v40 )
      {
        v41 = sub_BA4D4((__int64)v40);
        v42 = (char *)sub_BA098(v41, a3);
        sub_BA0F8(v41, v42, (char *)(*(_QWORD *)(a3 + 32) + 8LL), &v45);
        *(_QWORD *)(a3 + 24) = v45;
      }
      return 1LL;
    }
    qword_69EA028 = a1[4];
    v12 = &unk_69EA328;
    qword_69EA2E8 = v6;
    do
    {
      *(v12 - 6) = 0LL;
      *(v12 - 5) = 0LL;
      *(v12 - 1) = v12;
      v12 += 6;
    }
    while ( v12 != (_QWORD *)&MEMORY[0x69EA4A8] );
    qword_69EA470 = 0LL;
    qword_69EA2F0 = (__int64)&unk_69EA2F8;
    *(_DWORD *)(a3 + 40) = 0;
LABEL_19:
    v8 = 0LL;
    v9 = 0LL;
    goto LABEL_21;
  }
  if ( a2 > 0x19 )
    goto LABEL_19;
  return 0xFFFFFFFFLL;
}
// 69EA028: using guessed type __int64 qword_69EA028;
// 69EA2E8: using guessed type __int64 qword_69EA2E8;
// 69EA2F0: using guessed type __int64 qword_69EA2F0;
// 69EA470: using guessed type __int64 qword_69EA470;

//----- (00000000000BA900) ----------------------------------------------------
__int64 __fastcall sub_BA900(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v5; // x20
  char v6; // w22
  char *v7; // x0
  char *v8; // x0
  __int64 result; // x0
  unsigned __int64 v10; // [xsp+30h] [xbp+30h] BYREF
  unsigned __int64 v11; // [xsp+38h] [xbp+38h] BYREF

  v5 = a2;
  v6 = sub_BA4D4(a2);
  v7 = (char *)sub_BA038(v6, a1);
  sub_BA0F8(v6, v7, (char *)(v5 + 8), &v10);
  LOBYTE(v5) = sub_BA4D4(a3);
  v8 = (char *)sub_BA038(v5, a1);
  sub_BA0F8(v5, v8, (char *)(a3 + 8), &v11);
  if ( v10 >= v11 )
    LODWORD(result) = 0;
  else
    LODWORD(result) = -1;
  if ( v10 > v11 )
    return 1LL;
  else
    return (unsigned int)result;
}

//----- (00000000000BA99C) ----------------------------------------------------
__int64 __fastcall sub_BA99C(__int64 a1, char *a2)
{
  char *v4; // x26
  int v5; // w25
  __int64 v6; // x22
  __int64 v7; // x0
  signed int v8; // w21
  __int64 v9; // x21
  int v10; // w0
  unsigned __int8 v12; // w27
  unsigned __int64 v13; // x1
  unsigned int v14; // w0
  __int64 v15; // x1
  unsigned __int64 v16; // [xsp+68h] [xbp+68h] BYREF

  v4 = 0LL;
  LOBYTE(v5) = 0;
  v6 = 0LL;
  v7 = 0LL;
  while ( *(_DWORD *)a2 )
  {
    v8 = *((_DWORD *)a2 + 1);
    if ( v8 )
    {
      v9 = (__int64)&a2[-v8 + 4];
      if ( v9 == v7 )
      {
        v9 = v7;
      }
      else
      {
        v10 = sub_BA278(v9);
        v5 = v10;
        if ( v10 == 255 )
          return -1LL;
        v12 = v10;
        v4 = (char *)sub_BA038(v10, a1);
        v13 = *(unsigned __int16 *)(a1 + 32);
        if ( (v13 & 0x7F8) == 0x7F8 )
        {
          *(_WORD *)(a1 + 32) = v13 & 0xF807 | (8 * v12);
        }
        else if ( (unsigned __int8)(v13 >> 3) != v5 )
        {
          *(_BYTE *)(a1 + 32) |= 4u;
        }
      }
      sub_BA0F8(v5, v4, a2 + 8, &v16);
      v14 = sub_B9FD8(v5);
      v15 = -1LL;
      if ( v14 <= 7uLL )
        v15 = (1LL << (8 * (unsigned __int8)v14)) - 1;
      if ( (v15 & v16) != 0 )
      {
        ++v6;
        if ( v16 < *(_QWORD *)a1 )
          *(_QWORD *)a1 = v16;
      }
    }
    else
    {
      v9 = v7;
    }
    a2 += *(unsigned int *)a2 + 4;
    v7 = v9;
  }
  return v6;
}

//----- (00000000000BAAFC) ----------------------------------------------------
__int64 __fastcall sub_BAAFC(__int64 a1, __int64 *a2, unsigned int *a3)
{
  unsigned __int8 v4; // w0
  int v6; // w21
  char *v8; // x26
  __int64 result; // x0
  signed int v10; // w1
  __int64 v11; // x20
  unsigned int v12; // w0
  __int64 v13; // x1
  __int64 v14; // x0
  __int64 v15; // x1
  unsigned __int64 v16; // [xsp+68h] [xbp+68h] BYREF

  v4 = (unsigned __int64)*(unsigned __int16 *)(a1 + 32) >> 3;
  v6 = v4;
  v8 = (char *)sub_BA038(v4, a1);
  result = 0LL;
  while ( *a3 )
  {
    v10 = a3[1];
    v11 = result;
    if ( !v10 )
      goto LABEL_15;
    if ( (*(_BYTE *)(a1 + 32) & 4) != 0 )
    {
      v11 = (__int64)a3 - v10 + 4;
      if ( v11 != result )
      {
        v6 = sub_BA278((__int64)a3 - v10 + 4);
        v8 = (char *)sub_BA038(v6, a1);
      }
    }
    if ( !v6 )
    {
      if ( !*((_QWORD *)a3 + 1) )
        goto LABEL_15;
LABEL_13:
      v14 = *a2;
      if ( *a2 )
      {
        v15 = *(_QWORD *)(v14 + 8);
        *(_QWORD *)(v14 + 8) = v15 + 1;
        *(_QWORD *)(v14 + 8 * (v15 + 2)) = a3;
      }
      goto LABEL_15;
    }
    sub_BA0F8(v6, v8, (char *)a3 + 8, &v16);
    v12 = sub_B9FD8(v6);
    v13 = -1LL;
    if ( v12 <= 7uLL )
      v13 = (1LL << (8 * (unsigned __int8)v12)) - 1;
    if ( (v13 & v16) != 0 )
      goto LABEL_13;
LABEL_15:
    a3 = (unsigned int *)((char *)a3 + *a3 + 4);
    result = v11;
  }
  return result;
}

//----- (00000000000BAC30) ----------------------------------------------------
unsigned int *__fastcall sub_BAC30(__int64 a1, unsigned __int64 a2)
{
  __int64 v4; // x20
  char **i; // x21
  __int64 v6; // x0
  int v7; // w0
  _QWORD *v8; // x0
  _QWORD *v9; // x0
  __int64 v10; // x5
  __int64 v11; // x4
  __int64 v12; // x1
  __int64 k; // x2
  char *v14; // x26
  _QWORD *v15; // x27
  _QWORD *v16; // x21
  __int64 v17; // x20
  __int64 v18; // x24
  __int64 v19; // x26
  _QWORD *v20; // x25
  __int64 v21; // x28
  _QWORD *v22; // x0
  unsigned int *result; // x0
  __int64 v24; // x27
  unsigned __int64 v25; // x24
  unsigned __int64 m; // x23
  unsigned __int64 v27; // x21
  __int64 v28; // x20
  char v29; // w28
  char *v30; // x0
  char *v31; // x0
  unsigned __int64 v32; // x0
  __int64 v33; // x5
  unsigned __int64 v34; // x3
  unsigned __int64 v35; // x2
  unsigned __int64 v36; // x1
  unsigned __int64 v37; // x6
  __int64 v38; // x24
  unsigned __int64 v39; // x23
  char v40; // w25
  char *v41; // x28
  unsigned __int64 v42; // x21
  unsigned __int64 *v43; // x4
  unsigned __int64 v44; // x19
  char *v45; // x0
  unsigned int **n; // x20
  unsigned int **j; // x21
  unsigned int *v48; // x2
  _QWORD *v49; // x24
  __int64 (__fastcall *v50)(__int64, __int64, __int64); // x23
  _QWORD *v51; // x25
  __int64 v52; // x3
  __int64 *v53; // x21
  __int64 *v54; // x28
  __int64 v55; // x27
  __int64 *v56; // x4
  int v57; // w0
  char *v58; // x0
  char *v59; // x0
  __int64 v60; // x0
  __int64 v61; // x4
  __int64 v62; // x1
  __int64 *v63; // [xsp+60h] [xbp+60h]
  unsigned __int64 *v64; // [xsp+68h] [xbp+68h]
  __int64 v65; // [xsp+68h] [xbp+68h]
  unsigned __int64 v66; // [xsp+78h] [xbp+78h] BYREF
  _QWORD *v67; // [xsp+80h] [xbp+80h] BYREF
  void *p; // [xsp+88h] [xbp+88h]

  if ( (*(_BYTE *)(a1 + 32) & 1) != 0 )
    goto LABEL_2;
  v4 = *(_DWORD *)(a1 + 32) >> 11;
  if ( *(_DWORD *)(a1 + 32) >> 11 )
    goto LABEL_16;
  if ( (*(_BYTE *)(a1 + 32) & 2) != 0 )
  {
    for ( i = *(char ***)(a1 + 24); *i; ++i )
    {
      v6 = sub_BA99C(a1, *i);
      if ( v6 == -1 )
        goto LABEL_9;
      v4 += v6;
    }
  }
  else
  {
    v4 = sub_BA99C(a1, *(char **)(a1 + 24));
    if ( v4 == -1 )
    {
LABEL_9:
      *(_QWORD *)(a1 + 32) = 0LL;
      *(_WORD *)(a1 + 32) = 2040;
      *(_QWORD *)(a1 + 24) = &unk_69EA480;
      goto LABEL_32;
    }
  }
  v7 = (v4 & 0x1FFFFF) == v4 ? *(_DWORD *)(a1 + 32) & 0x7FF | ((_DWORD)v4 << 11) : *(_DWORD *)(a1 + 32) & 0x7FF;
  *(_DWORD *)(a1 + 32) = v7;
  if ( v4 )
  {
LABEL_16:
    v8 = malloc(8 * (v4 + 2));
    v67 = v8;
    if ( v8 )
    {
      v8[1] = 0LL;
      v9 = malloc(8 * (v4 + 2));
      p = v9;
      if ( v9 )
        v9[1] = 0LL;
      if ( (*(_BYTE *)(a1 + 32) & 2) != 0 )
      {
        for ( j = *(unsigned int ***)(a1 + 24); ; ++j )
        {
          v48 = *j;
          if ( !*j )
            break;
          sub_BAAFC(a1, (__int64 *)&v67, v48);
        }
      }
      else
      {
        sub_BAAFC(a1, (__int64 *)&v67, *(unsigned int **)(a1 + 24));
      }
      v49 = v67;
      if ( v67 && v67[1] != v4 )
LABEL_69:
        abort();
      if ( (*(_BYTE *)(a1 + 32) & 4) != 0 )
      {
        v50 = sub_BA900;
      }
      else if ( (*(_WORD *)(a1 + 32) & 0x7F8) != 0 )
      {
        v50 = sub_BA1E8;
      }
      else
      {
        v50 = sub_B9E48;
      }
      v51 = p;
      if ( p )
      {
        v14 = (char *)(v67 + 2);
        v52 = v67[1];
        v53 = &qword_69EA478;
        v54 = v67 + 2;
        v55 = 0LL;
        v56 = &qword_69EA478;
        while ( v55 != v52 )
        {
          while ( v53 != v56 )
          {
            v63 = v56;
            v65 = v52;
            v57 = v50(a1, *v54, *v53);
            v52 = v65;
            v56 = v63;
            if ( (v57 & 0x80000000) == 0 )
              break;
            v58 = (char *)v51 + (char *)v53 - v14;
            v53 = (__int64 *)*((_QWORD *)v58 + 2);
            *((_QWORD *)v58 + 2) = 0LL;
          }
          v59 = (char *)&v51[v55++];
          *((_QWORD *)v59 + 2) = v53;
          v53 = v54++;
        }
        v60 = 0LL;
        v12 = 0LL;
        for ( k = 0LL; k != v52; ++k )
        {
          v10 = *(_QWORD *)v14;
          if ( v51[k + 2] )
          {
            v11 = v12 + 2;
            ++v12;
            v49[v11] = v10;
          }
          else
          {
            v61 = v60 + 2;
            ++v60;
            v51[v61] = v10;
          }
          v14 += 8;
        }
        v49[1] = v12;
        v51[1] = v60;
        if ( *((_QWORD *)p + 1) + v67[1] != v4 )
          goto LABEL_69;
        sub_B9F24(a1, v50, (__int64)p);
        v15 = p;
        v16 = v67;
        v17 = *((_QWORD *)p + 1);
        if ( v17 )
        {
          v18 = v67[1];
          v19 = v17;
          do
          {
            --v17;
            v20 = &v16[v18];
            v21 = v15[v19 + 1];
            while ( v18 )
            {
              v62 = v20[1];
              --v20;
              if ( (int)v50(a1, v62, v21) <= 0 )
                break;
              --v18;
              v20[v19 + 2] = v20[2];
            }
            --v19;
            v16[v17 + 2 + v18] = v21;
          }
          while ( v17 );
          v16[1] += v15[1];
        }
        free(p);
      }
      else
      {
        sub_B9F24(a1, v50, (__int64)v67);
      }
      v22 = v67;
      *v67 = *(_QWORD *)(a1 + 24);
      *(_QWORD *)(a1 + 24) = v22;
      *(_BYTE *)(a1 + 32) |= 1u;
    }
  }
LABEL_32:
  if ( a2 < *(_QWORD *)a1 )
    return 0LL;
LABEL_2:
  if ( (*(_BYTE *)(a1 + 32) & 1) != 0 )
  {
    if ( (*(_BYTE *)(a1 + 32) & 4) != 0 )
    {
      v24 = *(_QWORD *)(a1 + 24);
      v25 = 0LL;
      for ( m = *(_QWORD *)(v24 + 8); v25 < m; m = v27 )
      {
        v27 = (m + v25) >> 1;
        v28 = *(_QWORD *)(v24 + 8 * (v27 + 2));
        v29 = sub_BA4D4(v28);
        v30 = (char *)sub_BA038(v29, a1);
        v31 = sub_BA0F8(v29, v30, (char *)(v28 + 8), &v66);
        sub_BA0F8(v29 & 0xF, 0LL, v31, (unsigned __int64 *)&v67);
        if ( a2 >= v66 )
        {
          if ( a2 < (unsigned __int64)v67 + v66 )
            return (unsigned int *)v28;
          v25 = v27 + 1;
          v27 = m;
        }
      }
    }
    else
    {
      v32 = *(unsigned __int16 *)(a1 + 32);
      if ( (v32 & 0x7F8) != 0 )
      {
        v38 = *(_QWORD *)(a1 + 24);
        v39 = 0LL;
        v40 = v32 >> 3;
        v41 = (char *)sub_BA038(v40, a1);
        v42 = *(_QWORD *)(v38 + 8);
        v43 = &v66;
        while ( v39 < v42 )
        {
          v44 = (v42 + v39) >> 1;
          v64 = v43;
          v28 = *(_QWORD *)(v38 + 8 * (v44 + 2));
          v45 = sub_BA0F8(v40, v41, (char *)(v28 + 8), v43);
          sub_BA0F8(v40 & 0xF, 0LL, v45, (unsigned __int64 *)&v67);
          v43 = v64;
          if ( a2 >= v66 )
          {
            if ( a2 < (unsigned __int64)v67 + v66 )
              return (unsigned int *)v28;
            v39 = v44 + 1;
            v44 = v42;
          }
          v42 = v44;
        }
      }
      else
      {
        v33 = *(_QWORD *)(a1 + 24);
        v34 = 0LL;
        v35 = *(_QWORD *)(v33 + 8);
        while ( v34 < v35 )
        {
          v36 = (v35 + v34) >> 1;
          result = *(unsigned int **)(v33 + 8 * (v36 + 2));
          v37 = *((_QWORD *)result + 1);
          if ( a2 < v37 )
          {
            v35 = (v35 + v34) >> 1;
          }
          else
          {
            if ( a2 < v37 + *((_QWORD *)result + 2) )
              return result;
            v34 = v36 + 1;
          }
        }
      }
    }
    return 0LL;
  }
  if ( (*(_BYTE *)(a1 + 32) & 2) != 0 )
  {
    for ( n = *(unsigned int ***)(a1 + 24); *n; ++n )
    {
      result = sub_BA374(a1, *n, a2);
      if ( result )
        return result;
    }
    return 0LL;
  }
  return sub_BA374(a1, *(unsigned int **)(a1 + 24), a2);
}
// 69EA478: using guessed type __int64 qword_69EA478;

//----- (00000000000BB1A0) ----------------------------------------------------
__int64 *__fastcall _register_frame_info_bases(__int64 *result, _QWORD *a2, __int64 a3, __int64 a4)
{
  if ( result && *(_DWORD *)result )
  {
    *a2 = -1LL;
    a2[4] = 0LL;
    a2[3] = result;
    a2[1] = a3;
    a2[2] = a4;
    *((_WORD *)a2 + 16) = 2040;
    if ( &pthread_create )
      pthread_mutex_lock(&stru_69EA488);
    result = &qword_69EA2E8;
    a2[5] = qword_69EA4B0;
    qword_69EA4B0 = (__int64)a2;
    if ( &pthread_create )
      return (__int64 *)pthread_mutex_unlock(&stru_69EA488);
  }
  return result;
}
// 69EA2E8: using guessed type __int64 qword_69EA2E8;
// 69EA488: using guessed type pthread_mutex_t;
// 69EA4B0: using guessed type __int64 qword_69EA4B0;

//----- (00000000000BB23C) ----------------------------------------------------
__int64 _register_frame_info()
{
  return __register_frame_info_bases();
}

//----- (00000000000BB248) ----------------------------------------------------
_DWORD *__fastcall _register_frame(_DWORD *result)
{
  if ( *result )
  {
    malloc(0x30uLL);
    return (_DWORD *)__register_frame_info();
  }
  return result;
}

//----- (00000000000BB288) ----------------------------------------------------
__int64 *__fastcall _register_frame_info_table_bases(__int64 a1, _QWORD *a2, __int64 a3, __int64 a4)
{
  __int16 v4; // w0
  __int64 *result; // x0
  _QWORD *v6; // [xsp+28h] [xbp+28h]

  a2[4] = 0LL;
  a2[3] = a1;
  *((_BYTE *)a2 + 32) = 2;
  a2[1] = a3;
  v4 = *((_WORD *)a2 + 16);
  *a2 = -1LL;
  a2[2] = a4;
  *((_WORD *)a2 + 16) = v4 | 0x7F8;
  if ( &pthread_create )
  {
    v6 = a2;
    pthread_mutex_lock(&stru_69EA488);
    a2 = v6;
  }
  result = &qword_69EA2E8;
  a2[5] = qword_69EA4B0;
  qword_69EA4B0 = (__int64)a2;
  if ( &pthread_create )
    return (__int64 *)pthread_mutex_unlock(&stru_69EA488);
  return result;
}
// 69EA2E8: using guessed type __int64 qword_69EA2E8;
// 69EA488: using guessed type pthread_mutex_t;
// 69EA4B0: using guessed type __int64 qword_69EA4B0;

//----- (00000000000BB31C) ----------------------------------------------------
__int64 _register_frame_info_table()
{
  return __register_frame_info_table_bases();
}

//----- (00000000000BB328) ----------------------------------------------------
__int64 _register_frame_table()
{
  malloc(0x30uLL);
  return __register_frame_info_table();
}

//----- (00000000000BB354) ----------------------------------------------------
__int64 __fastcall _deregister_frame_info_bases(_DWORD *a1)
{
  __int64 *j; // x0
  __int64 i; // x19

  if ( !a1 || !*a1 )
    return 0LL;
  if ( &pthread_create )
    pthread_mutex_lock(&stru_69EA488);
  j = &qword_69EA4B0;
  for ( i = qword_69EA4B0; i; i = *(_QWORD *)(i + 40) )
  {
    if ( *(_DWORD **)(i + 24) == a1 )
    {
LABEL_14:
      *j = *(_QWORD *)(i + 40);
      goto LABEL_21;
    }
    j = (__int64 *)(i + 40);
  }
  for ( j = &qword_69EA4B8; ; j = (__int64 *)(i + 40) )
  {
    i = *j;
    if ( !*j )
    {
      if ( !&pthread_create )
        goto LABEL_20;
      goto LABEL_19;
    }
    if ( (*(_BYTE *)(i + 32) & 1) != 0 )
      break;
    if ( *(_DWORD **)(i + 24) == a1 )
      goto LABEL_14;
LABEL_10:
    ;
  }
  if ( **(_DWORD ***)(i + 24) != a1 )
    goto LABEL_10;
  *j = *(_QWORD *)(i + 40);
  free(*(void **)(i + 24));
LABEL_21:
  if ( &pthread_create )
  {
LABEL_19:
    pthread_mutex_unlock(&stru_69EA488);
    if ( i )
      return i;
LABEL_20:
    abort();
  }
  return i;
}
// 69EA488: using guessed type pthread_mutex_t;
// 69EA4B0: using guessed type __int64 qword_69EA4B0;
// 69EA4B8: using guessed type __int64 qword_69EA4B8;

//----- (00000000000BB458) ----------------------------------------------------
void __fastcall _deregister_frame(_DWORD *a1)
{
  void *v1; // x0

  if ( *a1 )
  {
    v1 = (void *)__deregister_frame_info();
    free(v1);
  }
}

//----- (00000000000BB47C) ----------------------------------------------------
unsigned int *__fastcall Unwind_Find_FDE(unsigned __int64 a1, _QWORD *a2)
{
  __int64 i; // x19
  unsigned int *v5; // x20
  _QWORD *v6; // x1
  __int64 *v7; // x2
  char v8; // w1
  unsigned __int8 v9; // w0
  char v10; // w21
  char *v11; // x0
  unsigned __int64 v12; // x0
  unsigned __int64 v14; // [xsp+50h] [xbp+50h] BYREF
  __int64 v15; // [xsp+58h] [xbp+58h]
  __int64 v16; // [xsp+60h] [xbp+60h]
  unsigned __int64 v17; // [xsp+68h] [xbp+68h]
  unsigned int *v18; // [xsp+70h] [xbp+70h]
  int v19; // [xsp+78h] [xbp+78h]

  if ( &pthread_create )
    pthread_mutex_lock(&stru_69EA488);
  for ( i = qword_69EA4B8; ; i = *(_QWORD *)(i + 40) )
  {
    if ( !i )
      goto LABEL_9;
    if ( a1 >= *(_QWORD *)i )
      break;
  }
  v5 = sub_BAC30(i, a1);
  if ( v5 )
  {
LABEL_25:
    if ( !&pthread_create )
      goto LABEL_18;
  }
  else
  {
LABEL_9:
    while ( 1 )
    {
      i = qword_69EA4B0;
      if ( !qword_69EA4B0 )
        break;
      qword_69EA4B0 = *(_QWORD *)(qword_69EA4B0 + 40);
      v5 = sub_BAC30(i, a1);
      v6 = (_QWORD *)qword_69EA4B8;
      v7 = &qword_69EA4B8;
      while ( v6 && *v6 >= *(_QWORD *)i )
      {
        v7 = v6 + 5;
        v6 = (_QWORD *)v6[5];
      }
      *(_QWORD *)(i + 40) = v6;
      *v7 = i;
      if ( v5 )
        goto LABEL_25;
    }
    v5 = 0LL;
    if ( !&pthread_create )
      goto LABEL_21;
  }
  pthread_mutex_unlock(&stru_69EA488);
  if ( v5 )
  {
LABEL_18:
    *a2 = *(_QWORD *)(i + 8);
    v8 = *(_BYTE *)(i + 32);
    a2[1] = *(_QWORD *)(i + 16);
    v9 = (unsigned __int64)*(unsigned __int16 *)(i + 32) >> 3;
    if ( (v8 & 4) != 0 )
      v9 = sub_BA4D4((__int64)v5);
    v10 = v9;
    v11 = (char *)sub_BA038(v9, i);
    sub_BA0F8(v10, v11, (char *)v5 + 8, &v14);
    v12 = v14;
    goto LABEL_24;
  }
LABEL_21:
  v19 = 1;
  v14 = a1;
  v5 = 0LL;
  v15 = 0LL;
  v16 = 0LL;
  v17 = 0LL;
  v18 = 0LL;
  if ( (dl_iterate_phdr((int (*)(struct dl_phdr_info *, size_t, void *))sub_BA4E4, &v14) & 0x80000000) == 0 )
  {
    v5 = v18;
    if ( v18 )
    {
      *a2 = v15;
      a2[1] = v16;
      v12 = v17;
LABEL_24:
      a2[2] = v12;
    }
  }
  return v5;
}
// 69EA488: using guessed type pthread_mutex_t;
// 69EA4B0: using guessed type __int64 qword_69EA4B0;
// 69EA4B8: using guessed type __int64 qword_69EA4B8;

// nfuncs=470 queued=343 decompiled=343 lumina nreq=0 worse=0 better=0
#error "There were 1 decompilation failure(s) on 343 function(s)"
